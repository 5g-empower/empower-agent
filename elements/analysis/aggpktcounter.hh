// -*- mode: c++; c-basic-offset: 4 -*-
#ifndef CLICK_AGGPKTCOUNTER_HH
#define CLICK_AGGPKTCOUNTER_HH
#include <click/element.hh>
#include <click/task.hh>
#include <click/notifier.hh>
#include <click/ipflowid.hh>
CLICK_DECLS

/*
=c

AggregatePacketCounter(FILENAME [, I<KEYWORDS>])

=s analysis

reads packets from an IP summary dump file

=d

Reads IP packet descriptors from a file produced by ToIPSummaryDump, then
creates packets containing info from the descriptors and pushes them out the
output. Optionally stops the driver when there are no more packets.

The file may be compressed with gzip(1) or bzip2(1); AggregatePacketCounter will
run zcat(1) or bzcat(1) to uncompress it.

AggregatePacketCounter reads from the file named FILENAME unless FILENAME is a
single dash `C<->', in which case it reads from the standard input. It will
not uncompress the standard input, however.

Keyword arguments are:

=over 8

=item STOP

Boolean. If true, then AggregatePacketCounter will ask the router to stop when it
is done reading. Default is false.

=item ACTIVE

Boolean. If false, then AggregatePacketCounter will not emit packets (until the
`C<active>' handler is written). Default is true.

=item ZERO

Boolean. Determines the contents of packet data not set by the dump. If true,
this data is zero. If false (the default), this data is random garbage.

=item CHECKSUM

Boolean. If true, then output packets' IP, TCP, and UDP checksums are set. If
false (the default), the checksum fields contain random garbage.

=item PROTO

Byte (0-255). Sets the IP protocol used for output packets when the dump
doesn't specify a protocol. Default is 6 (TCP).

=item MULTIPACKET

Boolean. If true, then AggregatePacketCounter will emit multiple packets for each
line---specifically, it will emit as many packets as the packet count field
specifies. Default is false.

=item SAMPLE

Unsigned real number between 0 and 1. AggregatePacketCounter will output each
packet with probability SAMPLE. Default is 1. AggregatePacketCounter uses
fixed-point arithmetic, so the actual sampling probability may differ
substantially from the requested sampling probability. Use the
C<sampling_prob> handler to find out the actual probability. If MULTIPACKET is
true, then the sampling probability applies separately to the multiple packets
generated per record.

=item DEFAULT_CONTENTS

String, containing a space-separated list of content names (see
ToIPSummaryDump for the possibilities). Defines the default contents of the
dump.

=item DEFAULT_FLOWID

String, containing a space-separated flow ID (source address, source port,
destination address, destination port, and, optionally, protocol). Defines the
IP addresses and ports used by default.

=back

Only available in user-level processes.

=n

Packets generated by AggregatePacketCounter always have IP version 4 and a correct
IP header length. The rest of the packet data is zero or garbage, unless set
by the dump. Generated packets will usually have short lengths, but the extra
header length annotations are set correctly.

AggregatePacketCounter is a notifier signal, active when the element is active and
the dump contains more packets.

=h sampling_prob read-only

Returns the sampling probability (see the SAMPLE keyword argument).

=h active read/write

Value is a Boolean.

=h encap read-only

Returns `IP'. Useful for ToDump's USE_ENCAP_FROM option.

=h filesize read-only

Returns the length of the AggregatePacketCounter file, in bytes, or "-" if that
length cannot be determined.

=h filepos read-only

Returns AggregatePacketCounter's position in the file, in bytes.

=h stop write-only

When written, sets `active' to false and stops the driver.

=a

ToIPSummaryDump */

class AggregatePacketCounter : public Element { public:

    AggregatePacketCounter();
    ~AggregatePacketCounter();

    const char *class_name() const	{ return "AggregatePacketCounter"; }
    const char *processing() const	{ return AGNOSTIC; }
    const char *flow_code() const	{ return "#/#"; }
    AggregatePacketCounter *clone() const { return new AggregatePacketCounter; }
    void notify_ninputs(int);

    int configure(Vector<String> &, ErrorHandler *);
    int initialize(ErrorHandler *);
    void cleanup(CleanupStage);
    void add_handlers();

    void push(int, Packet *);
    Packet *pull(int);

  private:

#ifdef HAVE_INT64_TYPES
    typedef uint64_t packetctr_t;
#else
    typedef int64_t packetctr_t;
#endif
    
    class Flow { public:

	Flow(uint32_t aggregate, int columns);

	uint32_t aggregate() const	{ return _aggregate; }
	Flow *next() const		{ return _next; }
	void set_next(Flow *next)	{ _next = next; }

	packetctr_t column_count(int column) const;
	void undelivered(Vector<uint32_t> &) const;
	
	void add(uint32_t packetno, int column);
	
      private:

	uint32_t _aggregate;
	Flow *_next;

	Vector<uint32_t> *_counts;
	
    };
    
    enum { FLOWMAP_BITS = 10, NFLOWMAP = 1 << FLOWMAP_BITS };
    Flow *_flowmap[NFLOWMAP];
    
    uint32_t _total_flows;
    packetctr_t _total_packets;

    bool _use_packetno;
    
    Flow *find_flow(uint32_t aggregate);
    void end_flow(Flow *, ErrorHandler *);
    inline void smaction(int, Packet *);

    static String read_handler(Element *, void *);
    static String undelivered_read_handler(Element *, void *);
    static int write_handler(const String &, Element *, void *, ErrorHandler *);
    static int star_write_handler(const String &, Element *, void *, ErrorHandler *);
    
};

CLICK_ENDDECLS
#endif
