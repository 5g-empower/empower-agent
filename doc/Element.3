.\" -*- mode: nroff -*-
.ds E " \-\- 
.if t .ds E \(em
.de Sp
.if n .sp
.if t .sp 0.4
..
.de Es
.Sp
.RS 5
.nf
..
.de Ee
.fi
.RE
.PP
..
.de Rs
.RS
.Sp
..
.de Re
.Sp
.RE
..
.de M
.BR "\\$1" "(\\$2)\\$3"
..
.de RM
.RB "\\$1" "\\$2" "(\\$3)\\$4"
..
.de K
.BR "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6"
..
.de RK
.RB "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6"
..
.TH ELEMENT 3 "19/Oct/1999" "Version \*V"
.SH NAME
Element \- Click superclass for elements
'
.SH DESCRIPTION
'
The C++ class Element is the superclass for all Click elements. This manual
page describes its operations\*Especifically, the operations that an author
of an Element subclass might use.
'
.SH "CREATION"
.PD 0
.TP 5
.BR "Element()"
The default Element constructor. Creates an Element with no inputs or
outputs. Every Element subclass should have a default constructor.
.Sp
.TP
.BR "Element(" "int \fIninputs\fP, int \fInoutputs\fP" )
Creates an Element with \fIninputs\fP input ports and \fInoutputs\fP output
ports.
.Sp
.TP
.BR "virtual Element *clone() const"
Should create and return a new element with the same class as this element.
The new element need not have the same configuration or private data as
this element, however. No default implementation.
.PD
'
.SH "IDENTIFICATION"
.PD 0
.TP 5
.BR "virtual const char *class_name() const"
Should return the element's class name as a C string. No default
implementation.
'
.Sp
.TP
.BR "virtual void *cast(" "const char *\fIname" ")"
If the element implements the \fIname\fP interface, this function will
return the address of that interface. Otherwise, it returns a null pointer.
\fIName\fP is most frequently an element class name, but could be anything.
The default implementation returns
.K this
iff \fIname\fP equals
.BR class_name() .
'
.Sp
.TP
.BR "const String &id() const"
Returns the element's name as set in the configuration file.
'
.Sp
.TP
.BR "String declaration() const"
Returns a string of the form ``\fIELEMENTNAME\fP :: \fICLASSNAME\fR''.
'
.Sp
.TP
.BR "const String &landmark() const"
Returns a string that specifies the source file location of the element's
declaration. At user level, has the form ``\fIFILE\fP:\fILINE\fP''; in the
Linux kernel module, has the form ``line \fILINE\fP''.
.PD
'
.SH "INPUT AND OUTPUT PORTS"
.PD 0
.TP 5
.BR "int ninputs() const"
.TP
.BR "int noutputs() const"
Returns the number of input or output ports.
'
.Sp
.TP
.BR "const Connection &input(" "int \fIport_number" ") const"
.TP
.BR "const Connection &output(" "int \fIport_number" ") const"
Returns a Connection object corresponding to the given input or output
port. These objects are most interesting for push outputs and pull inputs;
for them, the Connection points to the unique element\-port pair that it is
connected to. The Connection has methods for pushing packets to, and
pulling packets from, that other element. See
.M Connection 3 .
'
.Sp
.TP
.BR "void set_ninputs(" "int \fInumber_of_ports" ")"
.TP
.BR "void set_noutputs(" "int \fInumber_of_ports" ")"
Sets the number of input or output ports. Any newly created ports are
unconnected.
'
.Sp
.TP
.BR "void add_input()"
.TP
.BR "void add_output()"
Adds a single input or output port.
'
.Sp
.TP
.BR "virtual void notify_ninputs(" "int \fInumber_of_ports_used" ")"
.TP
.BR "virtual void notify_noutputs(" "int \fInumber_of_ports_used" ")"
Called on every element during Router initialization. The parameters are
the number of that element's input and output ports that are used in the
router configuration. This is one more than the maximum input or output
port number that appears in a connection. Elements often react to these
calls by creating or destroying ports, depending on whether they are needed
in the router configuration. The default implementations do nothing.
'
.PD
'
.SH "ROUTER"
'
.PD 0
.TP 5
.BR "Router *router() const"
Returns a pointer to the Router object that this element is a part of.
.PD
'
.SH "PROCESSING AND FLOW"
'
.PD 0
'
.Sp
.TP 5
.BR "virtual const char *processing() const"
Should return the element's processing code. This is a string that
specifies whether the element's ports should be push, pull, or agnostic.
Most elements use one of the constants
.BR PUSH ", " PULL ", " PUSH_TO_PULL ,
.BR PULL_TO_PUSH ", or " AGNOSTIC ;
the default implementation returns
.BR AGNOSTIC .
.Sp
Elements with complex port arrangements will return a custom string. The
string looks like
.RI ` INPUTS / OUTPUTS ',
where
.IR INPUTS " and " OUTPUTS
are sequences of `h', `l', and `a' characters. `h' means push, `l' means
pull, and `a' means agnostic. The processing values for the input ports are
set by the corresponding characters of 
.IR INPUTS ,
and similarly for output ports and 
.IR OUTPUTS .
If there are more ports than characters, then the last character in the
relevant portion of the string is repeated as often as necessary. If there
are more characters than ports, then extra characters are ignored. Thus,
the string "a/ah" means that all of the element's inputs are agnostic, the
first output is also agnostic, and the second and subsequent outputs are
push.
.Sp
This function is used by the default implementation of
.BR processing_vector() .
.Sp
'
.TP 5
.BR "virtual void processing_vector(" "Subvector<int> &\fIinput_vector\fP,"
.TP 5
.RB "\%            Subvector<int> &\fIoutput_vector\fP,"
.TP 5
.RB "\%            ErrorHandler *\fIerrh\fP" ") const"
Should set elements of \fIinput_vector\fP and \fIoutput_vector\fP to
indicate whether the element's input and output ports are push, pull, or
agnostic. If \fIn\fP is a valid input port (0 <= \fIn\fP <
\fBninputs()\fP), then the value at
.BR input_vector[\fIn\fP]
should be that port's initial processing type, and similarly for output
ports. Possible processing types are
.BR VPUSH ", " VPULL ", and " VAGNOSTIC .
.Sp
There is generally no reason to override this function; override
.BR processing()
instead.
'
.Sp
.TP
.BR "bool output_is_push(" "int \fIport_number" ") const"
.TP
.BR "bool input_is_pull(" "int \fIport_number" ") const"
Returns
.K true
iff the given output port (input port) is push (pull).
'
.Sp
.TP
.BR "virtual Bitvector forward_flow(" "int \fIinput_number" ") const"
Should return the element's internal forward flow pattern. This is a
Bitvector with
.BR noutputs()
bits; its \fIn\fPth bit should be
.K true
iff a packet entering the element on input port \fIinput_number\fP could
eventually be emitted on output port \fIn\fP. (Equivalently, it should be
.K true
iff a packet emitted on output port \fIn\fP could have come from input port
\fIinput_number\fP.) The packet received and the packet transmitted need
not be identical\*Efor example, an encapsulator might create and emit a new
packet. This information is used for flow-based router context. If you
aren't sure about the right flow pattern for a particular element, set up
simple examples that would involve flow-based router context (for example,
a
.M RED n
element before the input port in question and a
.M Queue n
element after the output port) and see how they work. The default
implementation returns an
.RK all- true
Bitvector.
'
.Sp
.TP
.BR "virtual Bitvector backward_flow(" "int \fIoutput_number" ") const"
Should return the element's internal backward flow pattern. This is the
dual of
.BR forward_flow() .
Specifically, it is a 
Bitvector with
.BR ninputs()
bits; the bit
.B backward_flow(\fIpo\fP)[\fIpi\fP]
should be
.K true
iff the bit
.B forward_flow(\fIpi\fP)[\fIpo\fP]
is
.K true .
The default implementation returns an
.RK all- true
Bitvector.
'
.PD
.SH "CONFIGURATION AND INITIALIZATION"
'
.PD 0
.TP 5
.BR "virtual int configure(" "const String &\fIconfig_string\fP,"
.TP
.RB "\%            ErrorHandler *\fIerrh\fP" )
Called on every element during Router initialization. The
\fIconfig_string\fP parameter contains the element's configuration string.
The element should parse this string and change its private state
accordingly, reporting any errors, warnings or messages to the \fIerrh\fP
ErrorHandler. Should return 0 if configuration succeeded, or negative if an
error occurred. The default implementation reports an error unless
\fIconfig_string\fP is empty.
.Sp
Most
.B configure()
functions create or destroy input or output ports and set private instance
variables. The router has not yet been connected when
.B configure()
is called, so it cannot examine flow-based router context or the
personalities of its ports. In general, it should examine and change only
local element state; anything outside the element (devices or files, for
example) should be examined and changed in the
.B initialize()
method. This is so
.B configure()
can run in a user-level tool, or some other context where outside-element
state does not exist.
.PD 0
'
.Sp
.TP
.BR "virtual int initialize(" "ErrorHandler *\fIerrh" )
Called on every element during Router initialization, after
.BR configure() . 
The element can react by initializing itself. It should report any errors,
warnings or messages to the \fIerrh\fP ErrorHandler. Should return 0 if
initialization succeeded, or negative if an error occurred. The default
implementation always succeeds.
.Sp
.B initialize()
is called after the router has been connected, so it can examine flow-based
router context and the processing types of its ports. The
.B initialize()
function can also examine and change state outside the element itself
(devices or files, for example).
'
.Sp
.TP
.BR "virtual void uninitialize()"
Called on every initialized element in a Router when the Router is
decommissioned. This may happen long before the element itself is
destroyed. This function should undo the work of
.BR initialize() :
for example, by closing files or unregistering devices.
.PD
.SH "RUN-TIME RECONFIGURATION"
.PD 0
.TP 5
.BR "virtual bool can_live_reconfigure() const"
Returns
.K true
iff this element supports live reconfiguration. The
.B live_reconfigure()
method will be called only if
.B can_live_reconfigure()
returns
.K true .
The default implementation returns
.K false .
'
.Sp
.TP
.BR "virtual int live_reconfigure(" "const String &\fIconfig_string\fP,"
.TP
.RB "\%            ErrorHandler *\fIerrh\fP" )
Called to reconfigure the element at run time with the configuration string
\fIconfig_string\fP. This string is exactly like a configuration string
that would be passed to
.BR configure() ;
if reconfiguration succeeds, the element's state should be as if it were
given that configuration string from the beginning. For example,
reconfiguring a
.M Queue n
with an empty string does not keep the Queue's current maximum length, but
reconfigures it with the default maximum length of 1000. However,
packet-related state can and should be retained: reconfiguring a Queue
keeps its packet contents, or as many packets as will fit in the new Queue.
.Sp
Any errors should be reported to the \fIerrh\fP ErrorHandler. Should return
0 if the live reconfiguration succeeded, or negative if an error occurred.
If an error occurs, the element should be left in the same state it had
before the live reconfiguration was attempted. The default implementation
just calls
.BR configure( "\fIconfig_string\fP, \fIerrh\fP" )
and returns its value.
.PD
'
.SH "HANDLERS"
.PD 0
.TP 5
.BR "virtual void add_handlers()"
Called after an element has been
.BR initialize() d
so it can register its handlers. Handlers are user access points that
return information about the element or change its behavior. They are
identified by name, and may be read-only, write-only, or read/write; in the
Linux kernel module (see
.M click.o 8 ),
they are implemented as files in a /proc/click/ELEMENT directory. Within
this function, register a handler by calling
.BR add_read_handler() ,
.BR add_write_handler() ,
or both. These methods are described below. The default
.BR add_handlers()
implementation does nothing. (The default "class", "config", "inputs",
"name", and "outputs" handlers, described in
.M click.o 8 ,
are added by the
.BR add_default_handlers()
method.)
'
.Sp
.TP
.BR "void add_read_handler(" "const char *\fIname\fP,"
.TP
.RB "\%            ReadHandler \fIhandler\fP, void *\fIthunk\fP" )
'
Registers a read handler named
.I name
for this element. Read handlers are functions with type
.br
\%   String (*ReadHandler)(Element *\fIe\fP, void *\fIthunk\fP).
.br
The first argument passed to this function is the relevant element; the
second,
.IR thunk ,
is the same as the
.IR thunk
argument to
.BR add_read_handler() .
The handler function should return a string representing the value read.
'
.Sp
.TP
.BR "void add_write_handler(" "const char *\fIname\fP,"
.TP
.RB "\%            WriteHandler \fIhandler\fP, void *\fIthunk\fP" )
'
Registers a write handler named
.I name
for this element. Write handlers are functions with type
.br
\%   int (*WriteHandler)(const String &\fIs\fP, Element *\fIe\fP,
.br
\%              void *\fIthunk\fP, ErrorHandler *\fIerrh\fP).
.br
The string written is passed to this handler function as its first
argument. The second argument is the relevant element; the third,
.IR thunk ,
is the same as the
.IR thunk
argument to
.BR add_write_handler() .
The handler function should report any errors using the fourth argument, an
ErrorHandler. It should return 0 if the write succeeded or a negative
number if there was an error.
'
.Sp
.TP
.BR "static String configuration_read_handler(" "Element *\fIe\fP,"
.TP
.RB "\%            void *\fIthunk\fP" )
This generic read handler is provided as a convenience. It implements the
common case where a read handler returns a single argument in a
multi-argument configuration string. The
.B configuration_read_handler()
function determines the argument number by casting \fIthunk\fP to an
integer; it decomposes the current configuration string and returns the
\fIthunk\fPth argument.
.Sp
Think twice before using this generic handler. For example, it behaves
oddly for optional configuration arguments: if an optional argument was
left off,
.B configuration_read_handler()
will return an empty string for that argument. You probably want to return
the defaulted value instead, which requires that you write your own
handler.
'
.Sp
.TP
.BR "static int reconfigure_write_handler(" "const String &\fIs\fP,"
.TP
.RB "\%            Element *\fIe\fP, void *\fIthunk\fP,"
.TP
.RB "\%            ErrorHandler *\fIerrh\fP" )
This generic write handler is provided as a convenience. It implements the
common case where a write handler changes a single argument in a
multi-argument configuration string. The
.B reconfigure_write_handler()
function determines the argument number by casting \fIthunk\fP to an
integer; it decomposes the current configuration string, replaces the
\fIthunk\fPth argument with \fIs\fP, and calls
.B live_reconfigure()
on the given element with the new configuration string.
.PD
'
.SH "PACKET PASSING"
.PD 0
.TP 5
.BR "virtual void push(" "int \fIport_number\fP, Packet *\fIp" )
Called to push a packet to this element's input port \fIport_number\fP. The
default implementation calls
.BR simple_action() .
'
.Sp
.TP
.BR "virtual Packet *pull(" "int \fIport_number\fP" )
Called to pull a packet from this element's output port \fIport_number\fP.
The default implementation calls
.BR simple_action() .
'
.Sp
.TP
.BR "virtual Packet *simple_action(" "Packet *\fIp" )
A simple agnostic element can implement its action with
.BR simple_action() 
and not have to write
.BR push() " and " pull()
methods.
.BR simple_action()
is called when a packet passes through the element; that packet is its
parameter. The element can modify the packet, return a different packet, or
return 0 for no packet. (If it returns 0 or a different packet, it is
responsible for freeing the input packet with `p->kill()'.) The default
implementation just returns \fIp\fP.
.PD
.SH "SCHEDULING"
.PD 0
.TP 5
.BR "void join_scheduler()"
Adds this element to the schedule. In its 
.B initialize()
routine, an element that wants to be scheduled should either call 
.B SchedulerInfo::join_scheduler(this, errh)
or manually query and set the number of tickets assigned to the
element in the router configuration using 
.B SchedulerInfo::query(this, errh)
and 
.B set_tickets().
Subsequent calls to
.B join_scheduler()
place the element on the schedule.
'
.Sp
.TP 5
.BR "void reschedule()"
Reschedules this element. The element must have joined the scheduler
before.
'
.Sp
.TP
.BR "void unschedule()"
Removes this element from the schedule. Does nothing if the element isn't
scheduled.
'
.Sp
.TP
.BR "virtual void run_scheduled()"
Called by the Router to run an element that was on the schedule.
Within
.BR run_scheduled() ,
an element can schedule itself or other elements with
.BR reschedule() ;
they will be run at some later time. The default
implementation reports an error.
.PD
'
.SH "SEE ALSO"
.M Connection 3 ,
.M click 5 ,
.M click.o 8 ,
.M elements n ,
.M ScheduleInfo n,
.M Queue n ,
.M RED n
'
.SH AUTHOR
.na
Eddie Kohler, eddietwo@lcs.mit.edu
.br
John Jannotti, jj@lcs.mit.edu
.br
Robert Morris, rtm@lcs.mit.edu
.br
http://www.pdos.lcs.mit.edu/click/
'
