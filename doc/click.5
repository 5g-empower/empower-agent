.\" -*- mode: nroff -*-
.ds V 1.0
.ds E " \-\- 
.if t .ds E \(em
.de OP
.BR "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6"
..
.de OA
.IR "\fB\\$1\& \|\fI\\$2" "\\$3" "\\$4" "\\$5" "\\$6"
..
.de QO
.RB ` "\\$1" "'\\$2"
..
.de Sp
.if n .sp
.if t .sp 0.4
..
.de Es
.Sp
.RS 5
.nf
..
.de Ee
.fi
.RE
.PP
..
.de M
.BR "\\$1" "(\\$2)\\$3"
..
.de Rs
.RS
.Sp
..
.de Re
.Sp
.RE
..
.TH CLICK 5 "16/Oct/1999" "Version \*V"
.SH NAME
click \- Click router configuration language
'
.SH DESCRIPTION
The Click language describes the configuration of a Click router. It has
two main directives:
.IR declarations
declare new elements, and
.IR connections
connect those elements together.
Click router configurations are like directed graphs of elements; in this
interpretation, declarations specify the vertices of the graph and
connections specify the edges.
'
.SS "Declarations"
'
A declaration looks like this:
.Rs
.IR "name" " :: " "class" ( "config" );
.Re
(The semicolon, like all semicolons in Click syntax, is optional.)
This declares an element called
.IR name
that has element class
.IR class
and configuration arguments
.IR config .
If the configuration string is empty, the parentheses can be left off.
Also, there can be two or more names in a comma-separated list, which has
the same effect as multiple declarations.
.Rs
.IR "name" " :: " "class" ;
.br
.IR "name1" ", " "name2" ", ..., " "nameN" " ::"
.IR "class" ( "config" );
.Re
'
.SS "Connections"
'
A connection looks like this:
.Rs
.IR "name1" " [" "port1" "] -> [" "port2" "] " "name2" ;
.Re
where the two
.IR name s
are names of previously declared elements, and the two
.IR port s
are nonnegative integers. This says that
.IR name1 "'s output port " port1
should be connected to
.IR name2 "'s input port " port2 .
Two connections can be strung together into a single statement if the
output element of one is the same as the input element of the other:
.Rs
.IR "n1" " [" "p1" "] -> [" "p2" "] " "x" ;
.br
.IR "x" " [" "p3" "] -> [" "p4" "] " "n2" ;
.Re
is the same as
.Rs
.IR "n1" " [" "p1" "] -> [" "p2" "] " "x"
.RI "[" "p3" "] -> [" "p4" "] " "n2" ;
.Re
This can be extended to three or more connections. Furthermore, if an input
or output port is 0, it can be omitted along with the brackets. These two
lines are equivalent:
.Rs
.IR "n1" " [0] -> [0] " "n2" ;
.br
.IR "n1" " -> " "n2" ;
.Re
'
.SS "Declarations inside connections"
'
You can declare elements inside connections:
.Rs
.RI "... -> [" "p1" "] " "name" " ::"
.IR "class" ( "config" ") [" "p2" "] -> ...;"
.Re
is equivalent to
.Rs
.IR "name" " :: " "class" ( "config" );
.br
.RI "... -> [" "p1" "] " "name" " [" "p2" "] -> ...;"
.Re
Every such declaration can declare at most one element.
.PP
You can also declare nameless elements inside connections. An
.I anonymous element
is declared by writing the element class:
.Rs
.RI "... -> [" p1 "] " class ( config )
.RI "[" p2 "] -> ...;"
.Re
is equivalent to
.Rs
.IR generatedname " :: " class ( config );
.br
.RI "... -> [" p1 "] " generatedname " [" p2 "] -> ...;"
.Re
Again, the parentheses can be left off if
.I config
is empty.
.PP
The
.I generatedname
has the form
.RI ` class "@" number ',
where the
.IR number
is chosen to make the name unique. These numbers are predictable: when the
system parses a Click file twice, that file's anonymous elements will get
the same generated names each time. Nothing prevents a user from declaring
an element named like an anonymous element, which can lead to errors if the
system tries to use that name itself. We suggest that users avoid the `@'
character in their element names.
.PP
Not all elements can usefully be anonymous, since an anonymous element can
be part of at most two connections (once as input, once as output).
'
.SH "CONFIGURATION STRINGS"
'
The Click parser passes configuration strings verbatim to the elements.
(The process of extracting a configuration string from a Click language
file is described in the Lexical Issues section below.) The elements are
free in principle to treat configuration strings however they'd like, but
in practice, most treat them as comma-separated lists of arguments. This
section describes how these argument lists are parsed, and the objects that
they consist of, but any particular element class might not follow these
guidelines. See the element documentation for more details.
.PP
The configuration string parser first performs substitutions and separates
the string into arguments. There are two kinds of characters, normal and
special. The entire configuration string starts out normal; special
characters are created by backslash substitutions and are not subject to
further substitution. The parser logically acts as follows:
.TP 4
1.
Performs C-like backslash substitutions. Every resulting
character is special. Specifically:
.RS
.TP 3
\(bu
`\\a' -> ASCII BEL (hex 07)
.TP 3
\(bu
`\\b' -> ASCII BS (hex 08)
.TP 3
\(bu
`\\t' -> ASCII HT (hex 09)
.TP 3
\(bu
`\\n' -> ASCII LF (hex 0A)
.TP 3
\(bu
`\\v' -> ASCII VT (hex 0B)
.TP 3
\(bu
`\\f' -> ASCII FF (hex 0C)
.TP 3
\(bu
`\\r' -> ASCII CR (hex 0D)
.TP 3
\(bu
`\\\\' -> `\\'
.TP 3
\(bu
`\\[1, 2, or 3 octal digits]' -> that ASCII character
.TP 3
\(bu
`\\x[any number of hex digits]' -> the ASCII character defined by the last
2 hex digits
.RE
.TP 4
2.
Replaces `\\< ... hex digits and spaces ... >' sequences with the ASCII
character data represented by the hex digits. Every resulting character is
special. For example, the sequence `\\< 48 45 4c 4C 4f >' is replaced with
`HELLO'.
.TP
3.
Removes backlash-newline sequences (`\\[LF]', `\\[CR]', or `\\[CR][LF]').
.TP
4.
Replaces any remaining `\\[CHAR]' sequence with the special version of
`[CHAR]'.
.TP
5.
Replaces comments (`// ... EOL' and `/* ... */') with single normal space
characters.
.TP
6.
Breaks the string into arguments by splitting it at every normal comma.
The commas are thrown away.
.TP
7.
Removes leading and trailing normal whitespace from the resulting
arguments.
.PD
.PP
Once this is done, the element can process the arguments. The most common
argument types are:
.TP 4
\(bu
.B Strings.
\ 
.TP
\(bu
.B Booleans.
`0', `false', and `no' mean false; `1', `true', and `yes' mean true.
.TP
\(bu
.B Integers
preceded by an optional `+' or `\-' sign. Decimal, octal (first digit `0'),
and hexadecimal (starting with `0x') are allowed. Network byte order is
supported with `0n', which must be followed by 4 or 8 hexadecimal digits;
the resulting number is translated into a network-order short or long.
.TP
\(bu
.B Real numbers
in decimal notation.
.TP
\(bu
.B IP addresses
in the conventional `n.n.n.n' form (for example, `18.26.4.15').
.TP
\(bu
.B Ethernet addresses
in the conventional `x:x:x:x:x:x' form (for example, `0:a0:c9:9c:fd:9c').
.TP
\(bu
.B Element names.
.PD
.PP
Some elements, like
.IR Classifier ,
take arguments that don't fit any of these types. See the element
documentation for details.
'
.SH "COMPOUND ELEMENTS"
'
A
.I compound element
is a scoped collection of elements that acts like a single element from
outside. A compound element can be used anywhere an element class is
expected (that is, in a declaration or connection). Syntactically, a
compound element is a set of Click statements enclosed in braces `{ }'.
Inside the braces, the special names `input' and `output' represent
connections from or to the outside. Before a router is put on line,
compound elements are systematically expanded until none remain; thus, they
have no run-time overhead.
.PP
Here are some examples. This code, with a compound element,
.Rs
a -> { input -> X -> output } -> b;
.Re
expands to
.Rs
a -> X -> b;
.Re
Here is a more complicated example, with multiple ports:
.Rs
compound :: {
.br
  input -> X -> output;
.br
  input [1] -> Y -> [1] output;
.br
};
.br
a -> compound -> b;
.br
c -> [1] compound [1] -> d;
.Re
expands to
.Rs
a -> X -> b;
.br
c -> Y -> d;
.Re
.PP
The `input' and `output' pseudo-elements have no existence in a running
router; they serve as placeholders for connections from outside. (In fact,
they are connection tunnel endpoints. See below for more on connection
tunnels.) If no one from outside connects to one of a compound element's
input or output ports, then all connections involving that port are removed
from the expansion. For example:
.Rs
{ input -> X -> output } -> b;
.Re
expands to
.Rs
X -> b;
.Re
with no connection to X's input.
.PP
The actual expansions will differ from these examples because the elements
will have different names. A prefix is prepended to the components' names,
providing locality relative to other names in the configuration. The new
names have the form
.RI ` "compoundname" / "componentname" ',
where
.I compoundname
is the name of the compound element being expanded, and
.I componentname
is the name of the component element inside that compound. For example,
.Rs
compound :: { input -> x :: X -> output };
.br
a -> compound -> b;
.Re
is really expanded to
.Rs
a -> compound/x :: X -> b;
.Re
For this purpose, anonymous compound elements are given constructed names
like
.RI `@Anon number '.
Nothing prevents a user from declaring an element named like a compound
element component. We suggest that users generally avoid using the `/'
character in their element names.
'
.SS "The `elementclass' statement"
'
The `elementclass' statement lets the user name a frequently-occurring
compound element, and use the name as if it were a primitive element class.
Syntactically, it looks like this:
.Rs
elementclass
.I identifier
.I compoundelement
;
.Re
After this statement, every occurrence of the
.I identifier
will be replaced with the
.IR compoundelement .
For example, this code, with an `elementclass':
.Rs
elementclass MyQueue {
.br
  input -> Queue -> Shaper(1000) -> output;
.br
}
.br
q :: MyQueue;
.br
a -> q -> b;
.Re
is equivalent to this code, without it:
.Rs
q :: { input -> Queue -> Shaper(1000) -> output };
.br
a -> q -> b;
.Re
which roughly expands to:
.Rs
a -> Queue -> Shaper(1000) -> b;
.Re
.PP
The user can declare element classes that have the names of previously
existing element classes:
.Rs
elementclass Queue {
.br
  input -> Queue -> Shaper(1000) -> output;
.br
}
.Re
Element classes are nonrecursive and lexically scoped, so the `Queue'
inside this definition refers to the original `Queue'. Also, elementclass
statements don't affect elements declared earlier:
.Rs
elementclass A {
.br
  input -> B -> output;
.br
}
.br
elementclass B {
.br
  input -> C -> output;
.br
}
.br
\&... -> A -> ...
.Re
expands to `... -> B -> ...', not `... -> C -> ...'.
'
.SH "CONNECTION TUNNELS"
'
A
.I connection tunnel
is a pair of element names that acts as a tunnel for connections.
Consider a tunnel
.RI ` p1 " -> " p2 '.
Then connections to 
.I p1
pass through the tunnel and are transformed, at compile time, into
connections from
.IR p2 .
For example, this code, with a tunnel,
.Rs
connectiontunnel p1 -> p2;
.br
a -> p1; p2 -> b;
.Re
is transformed into this code, without it:
.Rs
a -> b;
.Re
The connections to p1's 
.IR i th
input port have been expanded to jump over the connections from p2's
.IR i th
output port. Thus, a is connected to b in the result because a was
connected to p1's input port 0, and p2's output port 0 was connected to b.
Here is a slightly more complicated example involving several connections
and different port numbers:
.Rs
connectiontunnel p1 -> p2;
.br
a -> p1; b -> p1; p2 -> c;
.br
a [1] -> [1] p1; p2 [1] -> Discard;
.Re
is transformed into
.Rs
a -> c; b -> c;
.br
a [1] -> Discard;
.Re
And one final example:
.Rs
connectiontunnel p1 -> p2;
.br
a -> p1; p2 -> b; p2 -> c;
.Re
becomes
.Rs
a -> b; a -> c;
.Re
.PP
Connection tunnels can be connected to each other. The system will
recursively expand the tunnels until none of them remain. (Circular
connections are silently ignored.) For example:
.Rs
connectiontunnel p1 -> p2, q1 -> q2;
.br
a -> p1; p2 -> q1; q2 -> b;
.Re
becomes
.Rs
a -> b;
.Re
.PP
An identifier that has been used for a connection tunnel cannot be used for
an element, and vice versa. However, an identifier can be used for two
tunnels, once as the input end and once as the output end. For example:
.Rs
connectiontunnel p -> p/input, p/output -> p;
.br
a -> p; // using `p' as input
.br
p/input -> Counter -> p/output; 
.br
p -> b; // using `p' as output
.Re
becomes
.Rs
a -> Counter -> b;
.Re
Compound elements use this mechanism.
'
.SH "REQUIREMENTS"
'
A configuration can say that it depends on optional packages by using the
`require' statement. Its argument is a comma-separated list of package
names:
.Rs
require(fastclassifier, specialcode);
.Re
Installation programs can use the package names to find and upload any
necessary package code. Furthermore, the required package names are checked
against a list of currently active packages when a configuration is
installed. If any required packages are unavailable, an error is reported.
'
.SH "LEXICAL ISSUES"
'
Click identifiers are nonempty sequences of letters, numbers, underscores
`_', at-signs `@', and slashes `/' that does not begin with a slash. The
system uses `@' and `/' for special purposes: `@' in constructed names for
anonymous elements and prefixes, and `/' in names for components of
compound elements. Users are discouraged from using these characters in
their own identifiers.
.PP
Two keywords, `connectiontunnel' and `elementclass', may not be used as
identifiers. The normal identifiers `input' and `output' have special
meaning inside compound element definitions.
.PP
The following characters and two-character sequences are single Click
tokens:
.TS
l l l l l l l l l l l.
	->	::	;	(	)	[	]	{	}
.TE
.PP
Whitespace (using the C definition) and comments separate Click tokens.
Click uses C++-style comments: from `//' to the end of the line, or from
`/*' to the next `*/'. Either form of comment terminates an identifier, so
this Click fragment
.RS
an/identifier/with/slashes//too/many
.RE
has an identifier `an/identifier/with/slashes' and a comment
`//too/many'. No identifier contains two consecutive slashes.
.PP
Configuration strings do not follow Click's usual lexical rules. A
configuration string starts immediately following a left parenthesis `(',
and continues up to the next unbalanced right parenthesis `)'. Backslash
characters `\\' quote parentheses and backslashes so they doesn't affect
balancing, but they are not removed from the string. A configuration string
can also include comments. (The configuration string parser generally
removes the backslashes and comments itself.) Here are several examples; in
each case, the configuration string starts immediately after the first `#'
and continues to right before the second `#'.
.Rs
C1(#simple string#)
.br
C2(#string with (balanced parens)#)
.br
C3(#string with \\(escaped paren#)
.br
C4(#// end-of-line comment)
.br
   still going!#)
.br
C5(#/* slash-star comment) */ and backslash \\\\#)
.Re
'
.SH "ARCHIVES"
The Click programs also accept
.M ar 1
archives as configurations. The archive must contain a member called
`config', which is treated as a Click-language configuration. The archive
may also contain package code required by the configuration. The
.M click-install 1
and
.M click 1
programs will decompose the archive and install any package code before
installing the configuration itself.
'
.SH "BNF GRAMMAR"
'
.IR stmts " ::= " stmts " " stmt " | " empty
.br
.IR stmt " ::= " declaration
.br
.RI "    | " connection
.br
.RI "    | " tunnelstmt
.br
.RI "    | " elementclassstmt
.br
.RI "    | " requirestmt
.br
.RI "    | "";"""
.br
.IR declaration " ::= " elements " ""::"" "
.IR elementclass " " opt-config
.br
.IR connection " ::= " celement " " conntail
.br
.IR conntail " ::= " opt-port " ""->"" " opt-port " " celement " " opt-conntail
.br
.IR opt-conntail " ::= " conntail " | " empty
.br
.IR celement " ::= " element
.br
.RI "    | " element " ""::"" " elementclass " " opt-config
.br
.RI "    | " elementclass " " opt-config
.br
.IR opt-config " ::= " config " | " empty
.br
.IR config " ::= ""("" configstring "")"""
.br
.IR elements " ::= " element " | " elements " "","" " element
.br
.IR element " ::= identifier | ""^"" identifier"
.br
.IR elementclass " ::= identifier"
.br
.RI "    | ""{"" " stmts " ""}"""
.br
.IR opt-port " ::= " port " | " empty
.br
.IR port " ::= ""["" portnumber ""]"""
.br
.IR tunnelstmt " ::= ""connectiontunnel"" " tunneltail
.br
.IR tunneltail " ::= identifier ""->"" identifier"
.br
.RI "    | " tunneltail " "","" identifier ""->"" identifier"
.br
.IR elementclassstmt " ::= ""elementclass"" identifier "
.br
.RI "        ""{"" " stmts " ""}"""
.br
.IR requirestmt " ::= ""require"" ""("" configstring "")"""
.br
.IR empty " ::= "
'
.SH AUTHOR
.na
Eddie Kohler, eddietwo@lcs.mit.edu
.br
http://www.pdos.lcs.mit.edu/click/
'
