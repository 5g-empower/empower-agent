#!/usr/local/bin/perl

my(%text_processing) = ( 'AGNOSTIC' => 'agnostic', 'PUSH' => 'push',
			 'PULL' => 'pull', 'PUSH_TO_PULL' => 'push-to-pull',
			 'PULL_TO_PUSH' => 'pull-to-push' );
my $directory;
my $section = 'n';

# find date
my($today) = '';
if (localtime =~ /\w* (\w*) (\d*) \S* (\d*)/) {
  $today = "$2/$1/$3";
}


sub nroffize ($@) {
  my($t) = shift @_;
  $t =~ s/\\/\\\\/g;
  $t =~ s/^\./\\&./gm;
  $t =~ s/^'/\\&'/gm;
  $t =~ s/^\s*$/.PP\n/gm;
  $t =~ s/<i>(.*?)<\/i>/\\fI$1\\fP/g;
  $t =~ s/<b>(.*?)<\/b>/\\fB$1\\fP/g;
  while ($t =~ /^\.PP\n\.PP\n/m) {
    $t =~ s/^\.PP\n\.PP\n/.PP\n/gm;
  }
  $t =~ s/^= (.*\n)/.nf\n$1.fi\n/mg;
  $t =~ s/^\.fi\n\.nf\n//mg;
  my($i);
  foreach $i (sort { length($b) <=> length($a) } @_) {
    $t =~ s/$i/\\fB$i\\fR/g;
  }
  $t;
}

sub process_comment ($$) {
  my($t, $filename) = @_;
  my(%x, $i);

  while ($t =~ m{^=(\w+)\s*([\0-\377]*?)(?=\n=\w|\Z)}mg) {
    $x{$1} .= "$2\n";
  }
  
  my(@classes);
  while ($x{'c'} =~ /^\s*(\w+)\(/mg) { # configuration arguments section
    push @classes, $1;
  }
  my($classes_plural) = (@classes == 1 ? '' : 's');
  my($classes) = join(', ', @classes);

  # open new output file if necessary
  if ($directory) {
    if (!open(OUT, ">$directory/$classes[0].$section")) {
      print STDERR "$directory/$classes[0].$section: $!\n";
      return;
    }
  }
  
  print OUT <<"EOD;";
.\\" -*- mode: nroff -*-
' Generated by `element2man.pl' from `$filename'
.TH "$classes" $section "$today" "Click"
.SH "NAME"
$classes \- Click element$classes_plural
EOD;
  
  if ($x{'c'}) {
    print OUT ".SH \"SYNOPSIS\"\n";
    while ($x{'c'} =~ /^\s*(\S.*)$/mg) {
      print OUT nroffize($1, @classes), "\n.br\n";
    }
  }

  if (@classes == 1 && $processing{$classes}) {
    print OUT ".SH \"PROCESSING TYPE\"\n";
    print OUT nroffize($text_processing{$processing{$classes}}), "\n";
  }

  if ($x{'io'}) {
    print OUT ".SH \"INPUTS AND OUTPUTS\"\n";
    print OUT nroffize($x{'io'});
  }

  if ($x{'d'}) {
    print OUT ".SH \"DESCRIPTION\"\n";
    print OUT nroffize($x{'d'}, @classes);
  }

  if ($x{'n'}) {
    print OUT ".SH \"NOTES\"\n";
    print OUT nroffize($x{'n'});
  }

  if ($x{'e'}) {
    print OUT ".SH \"EXAMPLES\"\n";
    print OUT nroffize($x{'e'});
  }

  my(@related);
  while ($x{'a'} =~ /(\w+)/g) {
    push @related, $1;
  }
  if (@related) {
    print OUT ".SH \"SEE ALSO\"\n", join("(n), ", sort @related), "(n)\n";
  }

  # close output file & make links if appropriate
  if ($directory) {
    close OUT;
    foreach $i (@classes[1..$#classes]) {
      unlink("$directory/$i.$section");
      if (!link "$directory/$classes[0].$section", "$directory/$i.$section") {
	print STDERR "$directory/$i.$section: $!\n";
      }
    }
  }
}

sub process_file ($) {
  my($filename) = @_;
  $filename =~ s/\.cc$/\.hh/;
  if (!open(IN, $filename)) {
    print STDERR "$filename: $!\n";
    return;
  }
  my $text = <IN>;
  close IN;

  foreach $_ (split(m{^class}m, $text)) {
    my($cxx_class) = (/^\s*(\w*)/);
    if (/class_name.*return\s*\"([^\"]+)\"/) {
      $class_name{$cxx_class} = $1;
      $cxx_class = $1;
    }
    if (/default_processing.*return\s+(\w*)/) {
      $processing{$cxx_class} = $1;
    }
  }

  foreach $_ (split(m{(/\*.*?\*/)}s, $text)) {
    if (/^\/\*/ && /^[\/*\s]+=/) {
      s/^\/\*\s*//g;
      s/\s*\*\/$//g;
      s/^[ \t]*\*[ \t]*//gm;
      process_comment($_, $ff);
    }
  }
}

# main program: parse options
sub read_files_from ($) {
  my($fn) = @_;
  if (open(IN, ($fn eq '-' ? "<&STDIN" : $fn))) {
    my($t) = <IN>;
    close IN;
    map { glob($_) } split(/\s+/, $t);
  } else {
    print STDERR "$fn: $!\n";
    ();
  }
}

undef $/;
my(@files, $fn);
while (@ARGV) {
  $_ = shift @ARGV;
  if (/^-d$/ || /^--directory$/) {
    die "not enough arguments" if !@ARGV;
    $directory = shift @ARGV;
  } elsif (/^--directory=(.*)$/) {
    $directory = $1;
  } elsif (/^-f$/ || /^--files$/) {
    die "not enough arguments" if !@ARGV;
    push @files, read_files_from(shift @ARGV);
  } elsif (/^--files=(.*)$/) {
    push @files, read_files_from($1);
  } elsif (/^-./) {
    die "unknown option `$_'\n";
  } elsif (/^-$/) {
    push @files, "-";
  } else {
    push @files, glob($_);
  }
}
push @files, "-" if !@files;

umask(022);
open(OUT, ">&STDOUT") if !$directory;
foreach $fn (@files) {
  process_file($fn);
}
close OUT if !$directory;
