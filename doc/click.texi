\input texinfo.tex
@setfilename click.info
@settitle Click
@footnotestyle end

@ifinfo
@macro click {arg}
@code{\arg\}
@end macro
@macro leq
<=
@end macro
@end ifinfo
@ifnotinfo
@macro click {arg}
@emph{\arg\}
@end macro
@end ifnotinfo

@macro handler {arg}
`\arg\'
@end macro

@rmacro strcode {arg}
@t{\arg\}
@end rmacro

@syncodeindex vr cp
@syncodeindex fn cp

@titlepage
@title Programming the Click Modular Router
@author Eddie Kohler
@end titlepage

@contents

@node Top, Overview, (dir), (dir)
@top

@ifinfo
This document describes@dots{}
@end ifinfo

@menu
* Overview::                    
* Helper Classes::              
* Packets::                     
* Element Characteristics::     
* Element Initialization::      
* Element Runtime::             
* Configuration Strings::       
* Tasks::                       
* Timers::                      
* Coding Standards::            
* Index::                       Index.

@detailmenu
 --- The Detailed Node Listing ---

Overview

* Packet Transfer::             

Helper Classes

* String::                      
* StringAccum::                 
* Vector::                      
* Bitvector::                   
* HashMap::                     
* BigHashMap::                  
* ErrorHandler::                
* IPAddress::                   
* IP6Address::                  

String

* String Constructors::         
* String Contents::             
* String Characters::           
* Derived Strings::             
* Appending to Strings::        
* String Comparison::           
* String Out-of-Memory::        

StringAccum

* StringAccum Constructors::    
* StringAccum operator<<::      
* StringAccum Manipulation::    
* StringAccum Contents::        
* StringAccum Results::         
* StringAccum Out-of-Memory::   

ErrorHandler

* Reporting Errors::            
* Error Format Strings::        
* Counting Errors::             
* Basic ErrorHandlers::        
* Error Veneers::               
* Writing ErrorHandlers::       

IPAddress

* IPAddress Constructors::      
* IPAddress Data::              
* IPAddress Operations::        
* IPAddress Unparsing::         

Packets

* Packet Structure and Contents::  
* Packet Creation::             
* Packets and sk_buffs::        
* Packet Sharing::              
* Packet Buffer Manipulation::  
* Annotations::                 
* Packet Out-of-Memory::        

Annotations

* Header Annotations::          
* User Annotations::            
* Specific User Annotations::   
* Other Annotations::           
* Annotations In General::      

Other Annotations

* Destination Address Annotation::  
* Timestamp Annotation::        
* Device Annotation::           
* Packet Type Annotation::      
* Performance Counter Annotation::  

Element Characteristics

* Element Class::               
* Element Casting::             
* Element Names::               
* Element Router::              
* Creating Element Ports::      
* Using Element Ports::         
* When to Call Element Methods::  

Element Initialization

* notify_ninputs notify_noutputs::  
* configure_phase::             
* configure::                   
* processing::                  
* flow_code::                   
* initialize::                  
* uninitialize::                
* add_handlers::                
* Initialization Phases::       

Element Runtime

* Moving Packets::              
* Handling Packets::            
* Running Tasks::               
* Handlers::                    
* Live Reconfiguration::        

Moving Packets

* push::                        
* pull::                        
* Transferring Packets::        
* simple_action::               

Handlers

* add_read_handler add_write_handler::  

Live Reconfiguration

* can_live_reconfigure::        

Configuration Strings

* Configuration String Structure::  

Tasks

* Task Initialization::         
* Scheduling a Task::           
* Tickets::                     
* Task Thread Choice::          
* Task Status::                 
* Task Handlers::               
* Destroying a Task::           

Coding Standards

* Upper and lower case names::
* Common name patterns::

@end detailmenu
@end menu

@node Overview, Helper Classes, Top, Top
@chapter Overview

@menu
* Packet Transfer::             
@end menu

@node Packet Transfer,  , Overview, Overview
@section Packet Transfer



@node Helper Classes, Packets, Overview, Top
@chapter Helper Classes

@menu
* String::                      
* StringAccum::                 
* Vector::                      
* Bitvector::                   
* HashMap::                     
* BigHashMap::                  
* ErrorHandler::                
* IPAddress::                   
* IP6Address::                  
@end menu


@node String, StringAccum, Helper Classes, Helper Classes
@section String

The @code{String} class represents a string of characters.
@code{String}s may be constructed from C strings, characters, numbers,
and so forth. They may also be added together. The underlying character
arrays are dynamically allocated; operations on @code{String}s allocate
and free memory as needed. A @code{String} and its substrings will
generally share memory. @code{String}s may be assigned, stored, and
passed to functions at will.

@menu
* String Constructors::         
* String Contents::             
* String Characters::           
* Derived Strings::             
* Appending to Strings::        
* String Comparison::           
* String Out-of-Memory::        
@end menu

@node String Constructors, String Contents, String, String
@subsection Constructors

@deftypeop Constructor String {} String ()
Creates a string with no characters.
@end deftypeop

@deftypeop Constructor String {} String @w{(const char *@var{s})}
Creates a string containing a copy of the C string @var{s}.
@end deftypeop

@deftypeop Constructor String {} String @w{(const char *@var{s}}, @w{int @var{len})}
Creates a string containing the first @var{len} characters of @var{s}.
If @var{len} is negative, then this function treats @var{s} as a C
string, effectively setting @var{len} to @code{strlen(@var{s})}.
@end deftypeop

@deftypeop Constructor String {} String (char @var{c})
@deftypeopx Constructor String {} String (unsigned char @var{c})
Creates a string containing the single character @var{c}.
@end deftypeop

@deftypeop Constructor String {} String (int @var{n})
@deftypeopx Constructor String {} String (unsigned @var{n})
@deftypeopx Constructor String {} String (long @var{n})
@deftypeopx Constructor String {} String (unsigned long @var{n})
@deftypeopx Constructor String {} String (long long @var{n})
@deftypeopx Constructor String {} String (unsigned long long @var{n})
@deftypeopx Constructor String {} String (double @var{n})
Creates a string containing an ASCII decimal representation of the number
@var{n}. For example, if @var{n} is 20, then @code{String(@var{n})}
equals @code{"20"}. The @code{double} constructor is not available in
the kernel.
@end deftypeop

@deftypeop {Static method} String {const String &} null_string ()
Returns a const reference to a string with no characters. Useful in
situations where you wish to avoid unnecessary memory operations by
returning string references instead of @code{String}s.
@end deftypeop

@deftypeop {Static method} String String claim_string @w{(char *@var{s},} @w{int @var{len})}
Creates and returns a string containing the @var{len} bytes of data
starting at @var{s}. If @var{len} is negative, then this function treats
@var{s} as a C string, effectively setting @var{len} to
@code{strlen(@var{s})}. The @var{s} memory is claimed by the
@code{String} implementation. When the last @code{String} referencing
this memory is destroyed, the memory itself will be freed by calling
@code{delete[] @var{s}}. (Thus, @var{s} should have been allocated with
@code{new[]}.)
@end deftypeop

@deftypeop {Static method} String String stable_string @w{(const char *@var{s},} @w{int @var{len})}
Creates and returns a string containing the @var{len} bytes of data
starting at @var{s}. If @var{len} is negative, then this function treats
@var{s} as a C string, effectively setting @var{len} to
@code{strlen(@var{s})}. The caller guarantees that @var{s} is located in
stable, read-only memory and will not be changed while any @code{String}
references to it still exist. For example, @var{s} might be a C string
constant. The @code{String} implementation will not alter or free
@var{s}. Functions such as @code{mutable_data} (see below) will return
copies of @var{s}, not @var{s} itself.
@end deftypeop


@node String Contents, String Characters, String Constructors, String
@subsection Contents

@quotation
@strong{Caution}: Any pointer to a string's data should be treated as
temporary, since once the string is destroyed, that memory will be
freed. Remember, however, that a temporary @code{String} object will not
be destroyed until the end of the statement in which it was created.
Therefore, this use of @code{cc()} is safe:

@example
String a, b; // ...
fprintf(stderr, "%s\n", (a + b).cc());
@end example

This use is not safe:

@example
String a, b; // ...
const char *s = (a + b).cc();
fprintf(stderr, "%s\n", s); // probably an error
@end example
@end quotation

@deftypemethod String {const char *} data () const
Returns a pointer to the string's data. This data is not guaranteed to
be null-terminated. Only the first @code{length()} of its characters are
valid.
@end deftypemethod

@deftypemethod String int length () const
Returns the string's length in characters.
@end deftypemethod

@deftypemethod String {} {operator bool} ()
@deftypemethodx String {} {operator bool} () const
Returns true iff the string has at least one character.
@end deftypemethod

@deftypemethod String {char *} mutable_data ()
Returns a mutable pointer to the string's data. If the data is shared
with any other @code{String} object, or was allocated by
@code{stable_string} (see above), then this method will transparently
modify the @code{String} to use a unique copy of the data, and return
that.
@end deftypemethod

@deftypemethod String {const char *} cc ()
@deftypemethodx String {const char *} c_str ()
@deftypemethodx String {} {operator const char *} ()
Returns a pointer to the string's data as a C string. This may
transparently modify the @code{String} by adding a null character after
the string's data, which may involve making a copy of the data. This
null character will not be counted as part of the string's length.
@end deftypemethod

@deftypemethod String {char *} mutable_c_str ()
Returns a mutable pointer to the string's data as a C string.
@end deftypemethod


@node String Characters, Derived Strings, String Contents, String
@subsection Characters and Indices

@deftypemethod String char {operator[]} (int @var{i}) const
Returns the @var{i}th character of the string. @var{i} should be between
0 and @math{@code{length()} - 1}.
@end deftypemethod

@deftypemethod String char back () const
Returns the last character of the string. The string must not be empty.
@end deftypemethod

@deftypemethod String int find_left (int @var{c}, int @var{start} = 0) const
Returns the position of the first occurrence of the character @var{c} in
the string on or after position @var{start}. If @var{c} does not occur
on or after position @var{start}, returns @math{-1}.
@end deftypemethod

@deftypemethod String int find_right (int @var{c}) const
@deftypemethodx String int find_right (int @var{c}, int @var{start}) const
Returns the position of the last occurrence of the character @var{c} in
the string before position @var{start}. If @var{start} is not supplied,
returns the absolute last occurrence of @var{c} in the string. If
@var{c} does not occur before position @var{start}, returns @math{-1}.
@end deftypemethod

@deftypemethod String int find_left (const String &@var{s}, int @var{start} = 0) const
Returns the position of the first occurrence of the substring @var{s} in
the string on or after position @var{start}. If @var{s} does not occur
on or after position @var{start}, returns @math{-1}.
@end deftypemethod


@node Derived Strings, Appending to Strings, String Characters, String
@subsection Derived Strings

@deftypemethod String String substring (int @var{pos}, int @var{len}) const
Returns a new string containing characters @var{pos} through
@math{@var{pos} + @var{len} - 1} of this string.

If @var{pos} is negative, then start @math{-@var{pos}} characters from
the end of the string. If @var{len} is negative, then drop
@math{-@var{len}} characters from the end of the string. @var{len} may
be too large; only characters actually in the string will be returned.
If @var{pos} is too large or too small, the result is a null string.

These examples demonstrate the use of @var{substring}:

@example
String("abcde").substring(2, 2)   == "cd"
String("abcde").substring(-3, 2)  == "cd"
String("abcde").substring(-3, -1) == "cd"
String("abcde").substring(2, 10)  == "cde"
String("abcde").substring(10, 4)  == ""
String("abcde").substring(-10, 4) == ""
@end example
@end deftypemethod

@deftypemethod String String substring (int @var{pos}) const
Same as @code{substring(@var{pos}, length() - @var{pos})}: return a new
string containing all of this string's characters starting at @var{pos}.
@end deftypemethod

@deftypemethod String String lower () const
Return a string equal to this string, but with all alphabetic characters
translated to lower case.
@end deftypemethod

@deftypemethod String String upper () const
Return a string equal to this string, but with all alphabetic characters
translated to upper case.
@end deftypemethod


@node Appending to Strings, String Comparison, Derived Strings, String
@subsection Appending to Strings

If you are gradually building up a string by successive appends, you
should probably use @code{StringAccum} instead of these @code{String}
operations (@pxref{StringAccum}).

@deftypemethod String void append (const char *@var{s}, int @var{len})
Appends the first @var{len} characters of @var{s} to the end of this
string. If @var{len} is negative, then this function treats @var{s} as a
C string, effectively setting @var{len} to @code{strlen(@var{s})}.
@end deftypemethod

@deftypemethod String void append_fill (int @var{c}, int @var{len})
Adds @var{len} copies of the character @var{c} to the end of this
string.
@end deftypemethod

@deftypemethod String void append_space (int @var{len})
Adds @var{len} arbitrary characters to the end of this string.
@end deftypemethod

@deftypemethod String {String &} {operator+=} (const String &@var{s})
@deftypemethodx String {String &} {operator+=} (const char *@var{s})
@deftypemethodx String {String &} {operator+=} (char @var{c})
Appends the string @var{s} or character @var{c} to this string.
@end deftypemethod

@deftypefun String {operator+} (String @var{s1}, const String &@var{s2})
@deftypefunx String {operator+} (String @var{s1}, const char *@var{s2})
@deftypefunx String {operator+} (const char *@var{s1}, const String &@var{s2})
@deftypefunx String {operator+} (String @var{s1}, char @var{c})
Appends the string @var{s2} or character @var{c} to the string @var{s1},
and returns the resulting string.
@end deftypefun


@node String Comparison, String Out-of-Memory, Appending to Strings, String
@subsection Comparison

@deftypemethod String bool equals (const char *@var{s}, int @var{len}) const
Compares this string to the first @var{len} characters of @var{s}. If
@var{len} is negative, then this function treats @var{s} as a C string,
effectively setting @var{len} to @code{strlen(@var{s})}. Returns true
iff the two strings have the same length and contain the same characters
in the same order.
@end deftypemethod

@deftypefun bool {operator==} (const String &@var{s1}, const String &@var{s2})
@deftypefunx bool {operator==} (const char *@var{s1}, const String &@var{s2})
@deftypefunx bool {operator==} (const String &@var{s1}, const char *@var{s2})
Returns true iff the two strings are equal---that is, returns
@code{@var{s1}.equals(@var{s2}.data(), @var{s2}.length())}.
@end deftypefun

@deftypefun bool {operator!=} (const String &@var{s1}, const String &@var{s2})
@deftypefunx bool {operator!=} (const char *@var{s1}, const String &@var{s2})
@deftypefunx bool {operator!=} (const String &@var{s1}, const char *@var{s2})
Returns true iff the two strings are not equal---that is, returns
@code{!(@var{s1} == @var{s2})}.
@end deftypefun

@deftypemethod String int hashcode () const
Returns a number with the property that, for any two equal strings
@var{s1} and @var{s2}, @code{@var{s1}.hashcode() ==
@var{s2}.hashcode()}. With this method, @code{String}s may be used as
keys for @code{HashMap}s and @code{BigHashMap}s (@pxref{HashMap}).
@end deftypemethod


@node String Out-of-Memory,  , String Comparison, String
@subsection Out-of-Memory Conditions

All @code{String} operations are robust against out-of-memory
conditions. If there is not enough memory to create a particular string,
the @code{String} implementation will return an empty string instead. If
there is not enough memory to append to a particular string, the
@code{String} implementation will erase the existing string, setting it
to an empty string.

The @code{out_of_memory_count} static method can help detect whether a
@code{String} operation has run out of memory.

@deftypeop {Static method} String int out_of_memory_count ()
Returns the number of times that the @code{String} implementation has
encountered an out-of-memory condition. The result is normally zero.
@end deftypeop


@node StringAccum, Vector, String, Helper Classes
@section StringAccum

The @code{StringAccum} class, like @code{String} (@pxref{String}),
represents a string of characters. @code{StringAccum} is optimized for
building a string through @dfn{accumulation}, or successively appending
substrings until the whole string is ready. A @code{StringAccum} has
both a @dfn{length}---the number of characters it currently
contains---and a @dfn{capacity}---the maximum number of characters it
could hold without reallocating memory.

@menu
* StringAccum Constructors::    
* StringAccum operator<<::      
* Special StringAccum operator<<::  
* StringAccum Manipulation::    
* StringAccum Contents::        
* StringAccum Results::         
* StringAccum Out-of-Memory::   
@end menu


@node StringAccum Constructors, StringAccum operator<<, StringAccum, StringAccum
@subsection Constructors

@deftypeop Constructor StringAccum {} StringAccum ()
Creates a @code{StringAccum} with no characters.
@end deftypeop

@deftypeop Constructor StringAccum {} StringAccum (int @var{capacity})
Creates a @code{StringAccum} with no characters, but a capacity of
@var{capacity}. @var{capacity} must be greater than zero.
@end deftypeop

@code{StringAccum}'s copy constructor (@code{StringAccum(const
StringAccum &)}) and assignment operator (@code{operator=(const
StringAccum &)}) are private. Thus, @code{StringAccum}s cannot be
assigned or passed as arguments. Of course, references to
@code{StringAccum}s may be passed as arguments, and this usage is quite
common.


@node StringAccum operator<<, Special StringAccum operator<<, StringAccum Constructors, StringAccum
@subsection Appending with @code{operator<<}

Generally, you append to a @code{StringAccum} using iostreams-like
@code{<<} operators, which this section describes. The next section
describes the low-level interface, the @code{append} and @code{pop_back}
methods.

Here is a conventional use of @code{StringAccum}'s @code{<<} operators:

@example
struct timeval tv; StringAccum sa; int n; // ...
sa << tv << ": There are " << n << " things.\n";
@end example

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, char @var{c})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{unsigned char @var{c}})
Appends the character @var{c} to the @code{StringAccum} @var{sa} and
returns @var{sa}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, const char *@var{s})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, const String &@var{s})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{const StringAccum &@var{sa2}})
Appends the string @var{s}, or the value of the @code{StringAccum}
@var{sa2}, to @var{sa} and returns @var{sa}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, short @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, unsigned short @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, int @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, unsigned @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, long @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, unsigned long @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, long long @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{unsigned long long @var{n}})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, double @var{n})
Appends an ASCII decimal representation of the number @var{n} to
@var{sa} and returns @var{sa}. For example, if @var{n} is 20, then
@code{@var{sa} << @var{n}} has the same effect as @code{@var{sa} <<
"20"}. The @code{double} operator is not available in the kernel.
@end deftypefun

@node Special StringAccum operator<<, StringAccum Manipulation, StringAccum operator<<, StringAccum
@subsection Appending Data Types

@code{StringAccum} comes with @code{operator<<} definitions for the
@code{struct timeval}, @code{IPAddress}, and @code{EtherAddress} types.
Of course, you can write your own @code{operator<<} functions for other
data types, either using existing @code{operator<<}s or the manipulation
functions described in the next section.

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{const struct timeval &@var{tv}})
Appends an ASCII decimal representation of the time value @var{tv} to
@var{sa} and returns @var{sa}. The time value is printed as if by
@code{printf("%ld.%06ld", @var{tv}.tv_sec, @var{tv}.tv_usec)}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{IPAddress &@var{addr}})
Appends the conventional dotted-quad representation of the IP address
@var{addr} to @var{sa} and returns @var{sa}. For example, @samp{sa <<
addr} might have the same effect as @samp{sa << "18.26.4.44"}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{const EtherAddress &@var{addr}})
Appends the conventional colon-separated hexadecimal representation of
the Ethernet address @var{addr} to @var{sa} and returns @var{sa}. For
example, @samp{sa << addr} might have the same effect as @samp{sa <<
"00:02:B3:06:06:36:EE"}.
@end deftypefun


@node StringAccum Manipulation, StringAccum Contents, Special StringAccum operator<<, StringAccum
@subsection Manipulation

This section describes lower-level methods for manipulating
@code{StringAccum} objects. The @code{append} methods append data to the
@code{StringAccum}; the @code{extend}, @code{reserve}, and
@code{forward} methods add space to the end of it; and the @code{clear}
and @code{pop_back} methods remove its characters.

@deftypemethod StringAccum void append (char @var{c})
@deftypemethodx StringAccum void append (unsigned char @var{c})
Appends the character @var{c} to the end of this @code{StringAccum}.
Equivalent to @code{*this << @var{c}}.
@end deftypemethod

@deftypemethod StringAccum void append (const char *@var{s}, int @var{len})
Appends the first @var{len} characters of @var{s} to the end of this
@code{StringAccum}. If @var{len} is negative, then this function treats
@var{s} as a C string, effectively setting @var{len} to
@code{strlen(@var{s})}.
@end deftypemethod

@deftypemethod StringAccum {char *} extend (int @var{len})
Puts @var{len} arbitrary characters at the end of this
@code{StringAccum} and returns a pointer to those characters. The return
value may be a null pointer if there is not enough memory to grow the
character array. This method increases the @code{StringAccum}'s length
by @var{len}, which must be greater than or equal to zero.
@end deftypemethod

@quotation
@strong{Caution}: The pointer returned by @code{extend}, or the
@code{reserve} method described below, should be treated as transient.
It may become invalid after the next call to a method that grows the
@code{StringAccum}, such as @code{append}, @code{extend}, or one of the
@code{operator<<} functions, and will definitely become invalid when the
@code{StringAccum} is destroyed.
@end quotation


The @code{reserve} and @code{forward} methods together provide a
convenient, fast interface for appending strings of unknown, but
bounded, length.

@deftypemethod StringAccum {char *} reserve (int @var{len})
Reserves space for @var{len} characters at the end of this
@code{StringAccum} and returns a pointer to those characters. The return
value may be a null pointer if there is not enough memory to grow the
character array. This method does not change the @code{StringAccum}'s
length, although it may change its capacity. Use @code{forward} to
change the @code{StringAccum}'s length.
@end deftypemethod

@deftypemethod StringAccum void forward (int @var{amt})
Adds @var{amt} to the @code{StringAccum}'s length without changing its
data. This method is only useful in conjunction with @code{reserve},
above. Use @code{reserve} to get space suitable for appending a string
of unknown, but bounded, length. After finding the actual length, use
@code{forward} to inform the @code{StringAccum}. @var{amt} must be
greater than or equal to zero, and less than or equal to the remaining
capacity.
@end deftypemethod

Finally, these methods remove characters from a @code{StringAccum}
rather than add characters to it.

@deftypemethod StringAccum void clear ()
Erases the @code{StringAccum}, making its length zero (an empty string).
@end deftypemethod

@deftypemethod StringAccum void pop_back ()
@deftypemethodx StringAccum void pop_back (int @var{amt})
Remove the last character, or the last @var{amt} characters, of the
string. @var{amt} must be greater than or equal to zero, and less than
or equal to the @code{StringAccum}'s length.
@end deftypemethod


@node StringAccum Contents, StringAccum Results, StringAccum Manipulation, StringAccum
@subsection Contents

@quotation
@strong{Caution}: The pointer returned by @code{data} and @code{c_str}
should be treated as transient. It may become invalid after the next
call to a method that grows the @code{StringAccum}, such as
@code{append}, @code{extend}, or one of the @code{operator<<} functions,
and will definitely become invalid when the @code{StringAccum} is destroyed.
@end quotation

@deftypemethod StringAccum {char *} data () const
Returns a pointer to the character data contained in this
@code{StringAccum}.
@end deftypemethod

@deftypemethod StringAccum int length () const
Returns the number of characters in this @code{StringAccum}.
@end deftypemethod

@deftypemethod String {} {operator bool} ()
@deftypemethodx String {} {operator bool} () const
Returns true iff this @code{StringAccum} has at least one character.
@end deftypemethod

@deftypemethod StringAccum {const char *} c_str ()
@deftypemethodx StringAccum {const char *} cc ()
Returns a pointer to the character data contained in this
@code{StringAccum}. Guarantees that the returned string is
null-terminated: the @code{length()}th character will be @code{'\0'}.
This does not affect the @code{StringAccum}'s contents or length.
@end deftypemethod

@deftypemethod StringAccum char {operator[]} (int @var{i}) const
@deftypemethodx StringAccum {char &} {operator[]} (int @var{i})
Returns the @var{i}th character of this @code{StringAccum}. @var{i} must
be greater than or equal to zero, and less than the @code{StringAccum}'s
length. Note that the non-@code{const} version of this method returns a
mutable character reference, which facilitates code like

@example
StringAccum sa; // ...
sa[5] = 'a';
@end example
@end deftypemethod


@node StringAccum Results, StringAccum Out-of-Memory, StringAccum Contents, StringAccum
@subsection Results

@code{StringAccum}'s @code{take} methods return the string accumulated
by a series of calls to @code{operator<<} or similar methods. Each
@code{take} method makes @code{StringAccum} relinquish responsibility
for its character array memory, passing that responsibility on to its
caller. The caller should free the memory when it is done---either with
@code{delete[]}, for the @code{take} and @code{take_bytes} methods, or
by relying on @code{String} to handle it, for the @code{take_string}
method.

Each @code{take} method additionally restores the @code{StringAccum} to
its original, empty state. Further @code{append}s or similar operations
will begin building a new string from scratch.

@deftypemethod StringAccum void take (unsigned char *&@var{s}, int &@var{len})
Sets the @var{s} variable to this @code{StringAccum}'s character data
and @var{len} to its length. Then clears the @code{StringAccum}'s
internal state. 
@end deftypemethod

@deftypemethod StringAccum {char *} take ()
@deftypemethodx StringAccum {unsigned char *} take_bytes ()
Returns this @code{StringAccum}'s character data, then clears the
@code{StringAccum}'s internal state. The methods differ only in their
return types. Note that @code{StringAccum::length} will always return
zero immediately after a @code{take} or @code{take_bytes}. If you need
to know the string's length, call @code{length} first.
@end deftypemethod

@deftypemethod StringAccum String take_string ()
Returns this @code{StringAccum}'s character data as a @code{String}
object (@pxref{String}), then clears the @code{StringAccum}'s internal
state. This method hands the character data over to the @code{String}
implementation; no data copies are performed.
@end deftypemethod


@node StringAccum Out-of-Memory,  , StringAccum Results, StringAccum
@subsection Out-of-Memory Conditions

@code{StringAccum} operations are robust against out-of-memory
conditions. The @code{operator<<} functions and the @code{append} method
leave a @code{StringAccum} as is if they cannot create the memory needed
to complete an append. The @code{extend} and @code{reserve} methods can
return null pointers on out-of-memory; their callers should always check
that their return values are non-null.

@code{StringAccum} has no equivalent to @code{String}'s
@code{out_of_memory_count} static method.



@node Vector, Bitvector, StringAccum, Helper Classes
@section Vector

@node Bitvector, HashMap, Vector, Helper Classes
@section Bitvector

@node HashMap, BigHashMap, Bitvector, Helper Classes
@section HashMap

@node BigHashMap, ErrorHandler, HashMap, Helper Classes
@section BigHashMap


@node ErrorHandler, IPAddress, BigHashMap, Helper Classes
@section ErrorHandler

All Click error messages are passed to an instance of the
@code{ErrorHandler} class. @code{ErrorHandler} separates the generation
of error messages from the particular way those messages should be
printed. It also makes it easy to automatically decorate errors with
context information.

Most Click users must know how to report errors to an
@code{ErrorHandler}, and how @code{ErrorHandler}s count the messages
they receive. This section also describes how to decorate error messages
with error veneers, and how to write new @code{ErrorHandler}s.

@code{ErrorHandler} and its important subclasses are defined in
@code{<click/error.hh>}.

@menu
* ErrorHandler Initialization::  
* Reporting Errors::            
* Error Format Strings::        
* Counting Errors::             
* Basic ErrorHandlers::        
* Error Veneers::               
* Writing ErrorHandlers::      
@end menu


@node ErrorHandler Initialization, Reporting Errors, ErrorHandler, ErrorHandler
@subsection Initialization

The @code{ErrorHandler} class maintains some global state that must be
initialized by calling @code{static_initialize} at the beginning of the
program, and may be freed by calling @code{static_cleanup} when
execution is complete.

@deftypeop {Static method} ErrorHandler void static_initialize (ErrorHandler *@var{default_errh})
This function should be called exactly once, at the beginning of the
program, before any error messages are reported to any
@code{ErrorHandler}. It is OK to create arbitrary @code{ErrorHandler}
objects before calling this method, however. The @var{default_errh}
argument becomes the default @code{ErrorHandler}; see @ref{Basic
ErrorHandlers}.
@end deftypeop

@deftypeop {Static method} ErrorHandler void static_cleanup ()
This function should be called exactly once, just before the program
exits. Destroys the default and silent @code{ErrorHandler}s and cleans
up other @code{ErrorHandler}-related memory. It is an error to call any
@code{ErrorHandler} method after calling @code{static_cleanup}.
@end deftypeop


@node Reporting Errors, Error Format Strings, ErrorHandler Initialization, ErrorHandler
@subsection Reporting Errors

@code{ErrorHandler}'s basic error reporting methods take a format
string, which may use @code{printf}-like @samp{%} escape sequences, and
additional arguments as required by the format string. @xref{Error
Format Strings}, for more details on the format string. The five methods
differ in the seriousness of the error they report.

@deftypemethod ErrorHandler void debug (const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler void message (const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int warning (const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int error (const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int fatal (const char *@var{format}, @dots{})
Report the error described by @var{format} and any additional arguments.
The methods are listed by increasing seriousness. Use @code{debug} for
debugging messages that should not be printed in a production
environment; @code{message} for explanatory messages that do not
indicate errors; @code{warning} for warnings (this function prepends the
string @samp{warning:@ } to every line of the error message);
@code{error} for errors; and @code{fatal} for errors so serious that
they should halt the execution of the program. The three functions that
indicate errors, @code{warning}, @code{error}, and @code{fatal}, always
return @code{-EINVAL}. In some environments, @code{fatal} will actually
exit the program with exit code 1.
@end deftypemethod

Each of these methods has an analogue that additionally takes a
@dfn{landmark}: a string representing where the error took place. A
typical landmark contains a file name and line number, separated by a
colon---@samp{foo.click:31}, for example.

@deftypemethod ErrorHandler void ldebug (const String &@var{landmark}, const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler void lmessage (const String &@var{landmark}, const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int lwarning (const String &@var{landmark}, const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int lerror (const String &@var{landmark}, const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int lfatal (const String &@var{landmark}, const char *@var{format}, @dots{})
Report the error described by @var{format} and any additional arguments.
The error took place at @var{landmark}. Most @code{ErrorHandler}s will
simply prepend @samp{@var{landmark}:@ } to each line of the error
message.
@end deftypemethod

These methods are all implemented as wrappers around the @code{verror}
function. This function takes a landmark, a format string, a
@code{va_list} packaging up any additional arguments, and a
@dfn{seriousness value}, which encodes how serious the error was. The
@code{Seriousness} enumerated type, which is defined in the
@code{ErrorHandler} class, represents seriousness values. There are five
constants, corresponding to the five error-reporting methods:

@table @code
@item ERR_DEBUG
Corresponds to @code{debug} and @code{ldebug}.

@item ERR_MESSAGE
Corresponds to @code{message} and @code{lmessage}.

@item ERR_WARNING
Corresponds to @code{warning} and @code{lwarning}.

@item ERR_ERROR
Corresponds to @code{error} and @code{lerror}.

@item ERR_FATAL
Corresponds to @code{fatal} and @code{lfatal}.
@end table

@deftypemethod ErrorHandler int verror (Seriousness @var{seriousness}, const String &@var{landmark}, const char *@var{format}, va_list @var{val})
Report the error described by @var{format} and @var{val}. The error took
place at @var{landmark}, if @var{landmark} is nonempty. The
@var{seriousness} value is one of the five constants described above.
Always returns @code{-EINVAL}.
@end deftypemethod


@node Error Format Strings, Counting Errors, Reporting Errors, ErrorHandler
@subsection Format Strings

@code{ErrorHandler}'s format strings closely follow C's standard
@code{printf} format strings. Most characters in the format string are
printed verbatim. The @samp{%} character introduces a @dfn{conversion},
which prints data read from the remaining arguments. The format string
may contain newlines @samp{\n}, but it need not end with a newline;
@code{ErrorHandler} will add a final newline if one does not exist.

Each conversion, or formatting escape, follows this pattern:

@itemize @bullet
@item
First, the @samp{%} character introduces each conversion.

@item
Next comes zero or more @dfn{flag characters};

@item
then an optional @dfn{field width};

@item
then an optional @dfn{precision};

@item
then an optional @dfn{length modifier};

@item
and finally, the mandatory @dfn{conversion specifier}.
@end itemize

@noindent
We discuss each of these is turn.

Any conversion may be modified by zero or more of these flag characters.

@table @asis
@item @samp{#}
The value should be converted to an ``alternate form''. For @samp{o}
conversions, the first character of the output string is made @samp{0},
by prepending a @samp{0} if there was not one already. For @samp{x} and
@samp{X} conversions, nonzero values have @samp{0x} or @samp{0X}
prepended, respectively.

@item @samp{0}
The value should be zero padded. For @samp{d}, @samp{i}, @samp{u},
@samp{o}, @samp{x}, and @samp{X} conversions, the converted value is
padded on the left with @samp{0} characters rather than spaces.

@item @samp{-}
The value should be left-justified within the field width.

@item @samp{@ } (a space)
Leave a blank before a nonnegative number produced by a signed
conversion.

@item @samp{+}
Print a @samp{+} character before a nonnegative number produced by a
signed conversion.

@end table

The optional @dfn{field width}, a decimal digit string, forces the
conversion to use a minimum number of characters. The result of a
conversion is padded on the left with space characters to reach the
minimum field width, unless one of the @samp{0} or @samp{-} flags was
supplied.

The optional @dfn{precision} is a decimal digit string preceded by a
period @samp{.}. For @samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x},
and @samp{X} conversions, the precision specifies the minimum number of
digits that must appear; results with fewer digits are padded on the
left with @samp{0} characters. For the @samp{s} conversion, the
precision specifies the maximum number of characters that can be
printed.

If either the field width or precision is specified as a star @samp{*},
@code{ErrorHandler} reads the next argument as an integer and uses that
instead.

Length modifiers affect the argument type read by the conversion. There
are three modifiers:

@table @asis
@item @samp{h}
The next argument is a @code{short} or @code{unsigned short}. Affects
the @samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x}, and @samp{X}
conversions.

@item @samp{l}
The next argument is a @code{long} or @code{unsigned long}. Affects the
@samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x}, and @samp{X}
conversions.

@item @samp{ll}
The next argument is a @code{long long} or @code{unsigned long long}.
Affects the @samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x}, and
@samp{X} conversions.
@end table

Finally, these are the conversions themselves.

@table @asis
@item @samp{s}
Print the @code{const char *} argument, treated as a C string.

@item @samp{c}
The @code{int} argument is treated as a character constant. Printable
ASCII characters (values between 32 and 126) are printed verbatim.
Characters @samp{\n}, @samp{\t}, @samp{\r}, and @samp{\0} use those C
escape representations. Other characters use the representation
@samp{\%03o}.

@item @samp{e}
The argument is an @code{Element *}. Print that element's declaration.

@item @samp{d}, @samp{i}
The argument is an @code{int}; print its decimal representation.

@item @samp{u}
The argument is an @code{unsigned int}; print its decimal
representation.

@item @samp{o}
The argument is an @code{unsigned int}; print its octal representation.

@item @samp{x}, @samp{X}
The argument is an @code{unsigned int}; print its hexadecimal
representation. The @samp{%x} conversion uses lowercase letters;
@samp{%X} uses uppercase letters.

@item @samp{p}
The @code{void *} argument is cast to @code{unsigned long} and printed
as by @samp{%#lx}.

@item @samp{%}
Print a literal @samp{%} character.

@end table

Note that @code{ErrorHandler} does not support the @samp{e}, @samp{E},
@samp{f}, @samp{F}, @samp{g}, @samp{G}, and @samp{n} conversions.


@node Counting Errors, Basic ErrorHandlers, Error Format Strings, ErrorHandler
@subsection Counting Errors

@code{ErrorHandler} objects count the number of errors and warnings they
have received and make those values available to the user.

@deftypemethod ErrorHandler {virtual int} nwarnings () const
@deftypemethodx ErrorHandler {virtual int} nerrors () const
Returns the number of warnings or errors received by this
@code{ErrorHandler} so far.
@end deftypemethod

@deftypemethod ErrorHandler {virtual void} reset_counts ()
Resets the @code{nwarnings} and @code{nerrors} counters to zero.
@end deftypemethod

These counters are typically used to determine whether an error has
taken place in some complex piece of code. For example:

@example
int before_nerrors = errh->nerrors();
// @r{@dots{} complex code that may report errors to @code{errh} @dots{}}
if (errh->nerrors() != before_nerrors) @{
  // @r{an error has taken place}
@}
@end example


@node Basic ErrorHandlers, Error Veneers, Counting Errors, ErrorHandler
@subsection Basic @code{ErrorHandler}s

Every Click error message eventually reaches some @dfn{basic}
@code{ErrorHandler}, which generally prints the messages it receives.
The user-level driver's basic @code{ErrorHandler} prints error messages
to standard error, while in the Linux kernel module, the basic
@code{ErrorHandler} logs messages to the syslog and stores them for
access via @file{/proc/click/errors}.

@cindex default @code{ErrorHandler}
@cindex @code{ErrorHandler}, default
Two basic @code{ErrorHandlers} are always accessible via static methods:
the @dfn{default @code{ErrorHandler}}, returned by
@code{default_handler} and set by @code{set_default_handler}; and the
@dfn{silent @code{ErrorHandler}}, returned by @code{silent_handler},
which ignores any error messages it receives.

@deftypeop {Static method} ErrorHandler {ErrorHandler *} default_handler ()
Returns the default @code{ErrorHandler}.
@end deftypeop

@deftypeop {Static method} ErrorHandler void set_default_handler (@w{ErrorHandler *errh})
Sets the default @code{ErrorHandler} to @var{errh}. The
@code{static_initialize} method also sets the default
@code{ErrorHandler}; see @ref{ErrorHandler Initialization}.
@end deftypeop

@deftypeop {Static method} ErrorHandler {ErrorHandler *} silent_handler ()
Returns the silent @code{ErrorHandler}. This handler ignores any error
messages it receives. It maintains correct @code{nwarnings} and
@code{nerrors} counts, however.
@end deftypeop

@code{FileErrorHandler}, a kind of basic @code{ErrorHandler}, is
available in any user-level program. It prints every message it receives
to some file, usually standard error. It can also prepend an optional
context string to every line of every error message.

@deftypeop Constructor FileErrorHandler {} FileErrorHandler (FILE *@var{f}, @w{const String &@var{prefix} = ""})
Constructs a @code{FileErrorHandler} that prints error messages to file
@var{f}. If @var{prefix} is nonempty, then every line of every error
message is prepended by @var{prefix}.
@end deftypeop


@node Error Veneers, Writing ErrorHandlers, Basic ErrorHandlers, ErrorHandler
@subsection Error Veneers---Adding Context to Error Messages

@dfn{Error veneers} wrap around basic @code{ErrorHandler} objects and
change how error text is generated. An error veneer generally changes
each error message's text in some way, perhaps by adding a context
message or some indentation. It then passes the altered text to the
basic @code{ErrorHandler} for printing. Error veneers can be easily
nested.

The first argument to each error veneer constructor is a pointer to
another @code{ErrorHandler} object. The veneer will pass altered error
text to this handler, the @dfn{base handler}, for further processing and
printing. It also delegates @code{nwarnings()} and @code{nerrors()}
calls to the base handler.

Click comes with three error veneers: one for adding context, one for
prepending text to every line, and one for supplying missing landmarks.
It is easy to write others; see @ref{Writing ErrorHandlers}, for
details.

@deftypeop Constructor ContextErrorHandler {} ContextErrorHandler (@w{ErrorHandler *@var{base_errh}}, @w{const String &@var{context}}, @w{const String &@var{indent} = "@w{@ @ }"})
Constructs a @code{ContextErrorHandler} with @var{base_errh} as base.

The first time this handler receives an error message, it will precede
the message with the @var{context} string---generally more detailed
information about where the error has occurred. Every line in every
received error message is prepended with @var{indent}, two spaces by
default, to set off the message from its context.
@end deftypeop

@deftypeop Constructor PrefixErrorHandler {} PrefixErrorHandler (@w{ErrorHandler *@var{base_errh}}, @w{const String &@var{prefix}})
Constructs a @code{PrefixErrorHandler} with @var{base_errh} as base.

This handler precedes every line of every error message with
@var{prefix}.
@end deftypeop

@deftypeop Constructor LandmarkErrorHandler {} LandmarkErrorHandler (@w{ErrorHandler *@var{base_errh}}, @w{const String &@var{landmark}})
Constructs a @code{LandmarkErrorHandler} with @var{base_errh} as base.

This handler supplies @var{landmark} in place of any blank landmark
passed to it. This will cause the base handler to include @var{landmark}
in its error message.
@end deftypeop

To demonstrate these veneers in practice, we'll use the following
function, which prints two error messages:

@example
void f(ErrorHandler *errh) @{
  errh->error("First line\nSecond line");
  errh->lwarning("here", "Third line");
@}
@end example

A simple @code{FileErrorHandler} shows the base case.

@example
FileErrorHandler errh1(stderr);
f(&errh1);
    @print{} First line
    @print{} Second line
    @print{} here: warning: Third line
@end example

The simplest error veneer, @code{PrefixErrorHandler}, just prepends text
to every line.

@example
PrefixErrorHandler errh2(&errh1, "prefix - ");
f(&errh2);
    @print{} prefix - First line
    @print{} prefix - Second line
    @print{} prefix - here: warning: Third line
@end example

@code{ContextErrorHandler} supplies a line of context before the first
error message, and indents all messages except the context.

@example
ContextErrorHandler errh3(&errh1, "This was called from ...", "** ");
f(&errh3);
    @print{} This was called from ...
    @print{} ** First line
    @print{} ** Second line
    @print{} here: ** warning: Third line
@end example

@noindent
Note that the indentation @samp{**@ } is printed after the landmark.
This often looks better than the alternative.

Of course, an error veneer can take another error veneer as its ``base
handler'', leading to cumulative effects.

@example
ContextErrorHandler errh4(&errh2, "This was called from ...", "** ");
f(&errh4);
    @print{} prefix - This was called from ...
    @print{} prefix - ** First line
    @print{} prefix - ** Second line
    @print{} prefix - here: ** warning: Third line
@end example


@node Writing ErrorHandlers,  , Error Veneers, ErrorHandler
@subsection Writing @code{ErrorHandler}s

@code{ErrorHandler} constructs an error message using three virtual
functions. The first, @code{make_text}, parses a format string and
argument list into a single @code{String}. This is passed to the second
function, @code{decorate_text}, which may transform the string. The
final function, @code{handle_text}, prints the resulting error message.
This structure makes @code{ErrorHandler} easy to extend. To write a new
basic @code{ErrorHandler}, you will need to override just
@code{handle_text} and the counting functions (@code{nwarnings},
@code{nerrors}, and @code{reset_counts}). The @code{ErrorVeneer} helper
class, described below, lets you override just @code{decorate_text} when
writing an error veneer.

@deftypemethod ErrorHandler {virtual String} make_text @w{(Seriousness @var{s},} @w{const char *@var{format}}, va_list @var{val})
Parses the format string @var{format} with arguments from @var{val},
returning the results as a @var{String} object.

The default implementation processes the formatting escapes described
above (@pxref{Error Format Strings}). It also prepends every line of
the error message with @samp{warning: } if @var{s} equals
@code{ERR_WARNING}.
@end deftypemethod

@deftypemethod ErrorHandler {virtual String} decorate_text (Seriousness @var{s}, const String &@var{prefix}, const String &@var{landmark}, const String &@var{text})
Decorates the error message @var{text} as appropriate and returns the
result. At minimum, every line of the result should be prepended by
@var{prefix} and, if it is nonempty, the landmark string @var{landmark}.

The default implementation creates lines like this:

@example
@var{prefix}@var{landmark}: @var{text}     @r{(if @var{landmark} is nonempty)}
@var{prefix}@var{text}               @r{(if @var{landmark} is empty)}
@end example

@noindent
Any spaces and/or a final colon are stripped from the end of
@var{landmark}. Special landmarks, which begin and end with a backslash
@samp{\}, are ignored.
@end deftypemethod

@deftypemethod ErrorHandler {virtual void} handle_text @w{(Seriousness @var{s}}, @w{const String &@var{text})}
This method is responsible for printing or otherwise informing the user
about the error message @var{text}. If @var{s} equals @code{ERR_FATAL},
the method should exit the program or perform some other drastic action.
It should also maintain the @code{nwarnings()} and @code{nerrors()}
counters. In most cases, it should ensure that the last character in
@var{text} is a newline.

This method has no default implementation.
@end deftypemethod

@tpindex @code{ErrorVeneer}
The @code{ErrorVeneer} class, a subclass of @code{ErrorHandler},
supplies default implementations for these functions that ease the
construction of new error veneers. @code{ErrorVeneer}'s single instance
variable, @code{ErrorHandler *_errh}, is the base handler.
@code{ErrorVeneer} overrides all the relevant virtual
functions---@code{nwarnings}, @code{nerrors}, @code{reset_counts},
@code{make_text}, @code{decorate_text}, and @code{handle_text}. Its
versions simply delegate to the corresponding methods on @code{_errh}.
An error veneer designer will generally subclass @code{ErrorVeneer}
rather than @code{ErrorHandler}; then she will override only the methods
she cares about (usually @code{decorate_text}), relying on
@code{ErrorVeneer}'s default implementations for the rest.

@deftypeop Constructor ErrorVeneer {} ErrorVeneer (ErrorHandler *@var{base_errh})
Constructs an @code{ErrorVeneer} helper class with @var{base_errh} as
its base error handler. This constructor simply sets @code{_errh =
base_errh}.
@end deftypeop


@node IPAddress, IP6Address, ErrorHandler, Helper Classes
@section IPAddress

The @code{IPAddress} type represents an IPv4 address. It supports
bitwise operations like @samp{&} and @samp{|} and provides methods for
unparsing IP addresses into ASCII dotted-quad form.

@menu
* IPAddress Constructors::      
* IPAddress Data::              
* IPAddress Operations::        
* IPAddress Unparsing::         
@end menu

@node IPAddress Constructors, IPAddress Data, IPAddress, IPAddress
@subsection Constructors

@code{IPAddress} objects can be constructed from network-order integers,
from pointers to arrays of bytes, from ASCII strings, and from the
conventional @code{struct in_addr} type.

@deftypemethod IPAddress {} IPAddress ()
Creates an IP address equal to 0.0.0.0.
@end deftypemethod

@deftypemethod IPAddress explicit IPAddress (const unsigned char *@var{value})
Creates an IP address equal to
`@var{value}@math{[0]}.@var{value}@math{[1]}.@var{value}@math{[2]}.@var{value}@math{[3]}'.
@end deftypemethod

@deftypemethod IPAddress {} IPAddress (unsigned int @var{value})
@deftypemethodx IPAddress explicit IPAddress (int @var{value})
@deftypemethodx IPAddress explicit IPAddress (long @var{value})
@deftypemethodx IPAddress explicit IPAddress (unsigned long @var{value})
Creates an IP address equal to @var{value}, which is an IP address in
network byte order.
@end deftypemethod

@deftypemethod IPAddress {} IPAddress (struct in_addr @var{value})
Creates an IP address equal to @var{value}.
@end deftypemethod

@deftypemethod IPAddress explicit IPAddress (const String &@var{text})
Creates an IP address equal to @var{text}, which should be a dotted-quad
string in ASCII. For example, @var{text} might equal
@strcode{"18.26.4.44"}. If @var{text} does not parse into a dotted-quad
string, the resulting @code{IPAddress} equals 0.0.0.0.
@end deftypemethod

@deftypeop {Static method} IPAddress IPAddress make_prefix (int @var{k})
Creates and returns an IP address with the upper @var{k} bits on and all
other bits off. @var{k} must be between 0 and 32, inclusive. For
example, @code{make_prefix(0)} equals 0.0.0.0, @code{make_prefix(8)}
equals 255.0.0.0, and @code{make_prefix(32)} equals 255.255.255.255. The
netmask corresponding to a CIDR address @samp{@var{addr}/@var{k}}
equals @code{IPAddress::make_prefix(@var{k})}.
@end deftypeop


@node IPAddress Data, IPAddress Operations, IPAddress Constructors, IPAddress
@subsection Data

These methods return an @code{IPAddress}'s data in a variety of ways.

@deftypemethod IPAddress {} {operator bool} () const
Returns true if and only if this IP address does not equal 0.0.0.0.
@end deftypemethod

@deftypemethod IPAddress {struct in_addr} in_addr () const
@deftypemethodx IPAddress {} {operator struct in_addr} () const
Returns this IP address as a @code{struct in_addr} object.
@end deftypemethod

@deftypemethod IPAddress u_int32_t addr () const
@deftypemethodx IPAddress {} {operator u_int32_t} () const
Returns this IP address as an unsigned integer in network byte order.
@end deftypemethod
  
@deftypemethod IPAddress {const unsigned char *} data () const
@deftypemethodx IPAddress {unsigned char *} data ()
Returns a pointer to this IP address's data.
@end deftypemethod

@deftypemethod IPAddress int mask_to_prefix_bits () const
Returns the number @var{k} so that this IP address equals
@code{make_prefix(@var{k})}, or @math{-1} if there is no such number.
@end deftypemethod

@deftypemethod IPAddress unsigned hashcode () const
Returns a number with the property that, for any two equal IP addresses
@var{addr1} and @var{addr2}, @code{@var{addr1}.hashcode() ==
@var{addr2}.hashcode()}. With this method, @code{IPAddress}es may be
used as keys for @code{HashMap}s and @code{BigHashMap}s
(@pxref{HashMap}).
@end deftypemethod


@node IPAddress Operations, IPAddress Unparsing, IPAddress Data, IPAddress
@subsection Operations

@deftypefun bool {operator==} (IPAddress @var{addr1}, IPAddress @var{addr2})
Returns true if and only if @var{addr1} equals @var{addr2}. Equivalent
to @code{@var{addr1}.addr() == @var{addr2}.addr()}.
@end deftypefun

@deftypefun bool {operator!=} (IPAddress @var{addr1}, IPAddress @var{addr2})
Returns true if and only if @var{addr1} does not equal @var{addr2}.
@end deftypefun

@deftypefun IPAddress {operator&} (IPAddress @var{addr1}, IPAddress @var{addr2})
Returns a new IP address equal to @var{addr1} masked by @var{addr2}.
Equivalent to @code{IPAddress(@var{addr1}.addr() & @var{addr2}.addr())}.
@end deftypefun

@deftypefun IPAddress {operator|} (IPAddress @var{addr1}, IPAddress @var{addr2})
Returns a new IP address equal to the bitwise or of @var{addr1} and
@var{addr2}. Equivalent to @code{IPAddress(@var{addr1}.addr() |
@var{addr2}.addr())}.
@end deftypefun

@deftypefun IPAddress {operator~} (IPAddress @var{addr})
Returns a new IP address equal to the bitwise complement of @var{addr}.
Equivalent to @code{IPAddress(~@var{addr1}.addr())}.
@end deftypefun

@deftypemethod IPAddress {IPAddress &} {operator&=} (IPAddress @var{addr1})
Masks this IP address by @var{addr1} and returns the result. Equivalent
to @code{*this = (*this & @var{addr1})}.
@end deftypemethod

@deftypemethod IPAddress {IPAddress &} {operator|=} (IPAddress @var{addr1})
Bitwise-ors this IP address with @var{addr1} and returns the result.
Equivalent to @code{*this = (*this | @var{addr1})}.
@end deftypemethod


@node IPAddress Unparsing,  , IPAddress Operations, IPAddress
@subsection Unparsing

These functions unparse IP addresses, IP netmasks, and address/netmask
pairs into conventional ASCII text form.

@deftypemethod IPAddress String unparse () const
@deftypemethodx IPAddress String s () const
@deftypemethodx IPAddress {} {operator String} () const
Unparses this IP address into dotted-quad ASCII form and returns the
result as a @code{String} object. A sample result might be
@strcode{"18.26.4.9"}.
@end deftypemethod

@deftypemethod IPAddress String unparse_mask () const
Unparses this IP address as a netmask. If the IP address equals
@code{make_prefix(@var{k})} for some @var{k}, then the result is the
ASCII decimal representation of @var{k}. Otherwise, it is just the
dotted-quad ASCII form of the IP address. For example,
@code{IPAddress("18.26.4.9").unparse_mask()} equals
@strcode{"18.26.4.9"}, but @code{IPAddress("255.0.0.0").unparse_mask()}
equals @strcode{"8"}.
@end deftypemethod

@deftypemethod IPAddress String unparse_with_mask (IPAddress @var{mask}) const
Unparses this IP address with @var{mask} as its netmask. The result has
the form @strcode{"@var{addrtext}/@var{masktext}"}, where @var{addrtext}
equals @code{this->unparse()} and @var{masktext} equals
@code{@var{mask}.unparse_mask()}.
@end deftypemethod


@node IP6Address,  , IPAddress, Helper Classes
@section IP6Address



@node Packets, Element Characteristics, Helper Classes, Top
@chapter Packets

The @code{Packet} class represents Click packets. The single
@code{Packet} interface has multiple implementations, one per driver.
Inside the Linux kernel driver, a @code{Packet} object is equivalent to
a Linux @code{sk_buff} structure; most @code{Packet} methods are inline
functions that expand to @code{sk_buff} calls. The user-level driver,
however, uses a purpose-built @code{Packet} implementation.

Click packets separate header information from data. The @w{@code{Packet
*}} pointer points to a header structure, which holds pointers to the
actual packet data and a set of @dfn{annotations}. Packet data may be
shared by two or more packet headers. Packet headers, however, should
never be shared.

Packets come in two flavors, @code{Packet} and @code{WritablePacket}. A
@code{Packet} object represents a packet header whose data might be
shared with other packets. Because of this potential sharing,
@code{Packet} data is read-only, and its methods return @code{const}
pointers to data. A @code{WritablePacket} object, in contrast,
represents a packet header whose data is known not to be shared. Its
methods return non-@code{const} pointers. The @code{uniqueify} method
turns a @code{Packet} into a @code{WritablePacket}, possibly by making a
copy of the packet's data. @code{WritablePacket} is a subclass of
@code{Packet}, so you can turn a @code{WritablePacket} into a
@code{Packet} implicitly.

The @code{Packet} and @code{WritablePacket} classes are defined in
@samp{<click/packet.hh>}.

@menu
* Packet Structure and Contents::  
* Packet Creation::             
* Packets and sk_buffs::        
* Packet Sharing::              
* Packet Buffer Manipulation::  
* Annotations::                 
* Packet Out-of-Memory::        
@end menu


@node Packet Structure and Contents, Packet Creation, Packets, Packets
@section Structure and Contents

Packet data is stored in a single flat array of bytes. There is no
support for linked chains @`a la BSD @code{mbuf}. The actual packet data
is embedded inside a buffer that may be much larger, leaving unused
spaces called @dfn{headroom} and @dfn{tailroom} before and after the
data proper. Therefore, tasks like prepending a header need not always
reallocate memory. If the headroom is big enough, prepending space for a
new header just requires bumping a pointer.

This diagram shows how a typical packet is laid out, with the relevant
@code{Packet} methods' names.

@example
                      data
        |<- headroom ->|<----- length ----->|<- tailroom ->|
        |              |                    |              |
        +==============+====================+==============+
        |XXXXXXXXXXXXXX| PACKET CONTENTS... |XXXXXXXXXXXXXX|
        +==============+====================+==============+
        |                                                  |
        |<---------------- buffer_length ----------------->|
   buffer_data
@end example

@sp 1

And here are those methods' descriptions.

@deftypemethod Packet {const unsigned char *} data () const
Returns a pointer to the packet data proper.
@end deftypemethod

@deftypemethod Packet unsigned length () const
Returns the length of the packet data proper.
@end deftypemethod

@deftypemethod Packet {const unsigned char *} buffer_data () const
Returns a pointer to the buffer that contains the packet data.
@end deftypemethod

@deftypemethod Packet unsigned headroom () const
@deftypemethodx Packet unsigned tailroom () const
@deftypemethodx Packet unsigned buffer_length () const
Returns the length of the headroom area, the tailroom area, and the
whole buffer, respectively.
@end deftypemethod

@deftypemethod WritablePacket {unsigned char *} data () const
@deftypemethodx WritablePacket {unsigned char *} buffer_data () const
These @code{WritablePacket} methods are identical to @code{Packet}'s
@code{data} and @code{buffer_data} methods except for their
non-@code{const} return type.
@end deftypemethod

Two invariants relate these methods' values:

@display
@t{buffer_length()} @math{=} @t{headroom()} @math{+} @t{length()} @math{+} @t{tailroom()}
@t{data()} @math{=} @t{buffer_data()} @math{+} @t{headroom()}
@end display


@node Packet Creation, Packets and sk_buffs, Packet Structure and Contents, Packets
@section Creation and Destruction

Packets are created with the @code{Packet::make} static methods, and
destroyed with the @code{Packet::kill} method. (The @code{Packet} and
@code{WritablePacket} classes have private constructors and destructors;
you cannot create or destroy packets with @code{new} or @code{delete}.)

@subsection @code{Packet::make}

The @code{make} methods always take the length of the packet data; some
of them take the packet contents and the headroom and tailroom lengths
as well. (The contents of any headroom and tailroom areas are always
undefined.) Most of them return a @w{@code{WritablePacket *}}, since new
packets are not shared.

The @code{Packet} class defines two constants related to packet
creation, @code{DEFAULT_HEADROOM} and @code{MIN_BUFFER_LENGTH}. Those
@code{make} methods that do not take an explicit headroom parameter use
@code{DEFAULT_HEADROOM} instead. Furthermore, no @code{make} method will
create a packet with buffer length less than @code{MIN_BUFFER_LENGTH}.
If the sum of a packet's headroom and length is less than this, the
packet buffer is given extra tailroom to bump the buffer length up to
@code{MIN_BUFFER_LENGTH}. These constants have the values
@code{DEFAULT_HEADROOM} @math{= 28} and @code{MIN_BUFFER_LENGTH} @math{=
64}.


@deftypeop {Static method} Packet {WritablePacket *} make (unsigned @var{len})
Returns a new packet containing @var{len} bytes of undefined data.
@end deftypeop

@deftypeop {Static method} Packet {WritablePacket *} make @w{(const char *@var{data}, unsigned @var{len})}
@deftypeopx {Static method} Packet {WritablePacket *} make @w{(const unsigned char *@var{data}}, unsigned @var{len})
Returns a new packet whose contents equal the first @var{len} bytes of
@var{data}. @var{data} may be a null pointer, in which case the packet
contains @var{len} bytes of undefined data.
@end deftypeop

@deftypeop {Static method} Packet {WritablePacket *} make (unsigned @var{headroom}, @w{const unsigned char *@var{data}}, unsigned @var{len}, unsigned @var{tailroom})
Returns a new packet containing @var{headroom} bytes of headroom,
@var{len} bytes of contents, and at least @var{tailroom} bytes of
tailroom. The packet contents will equal the first @var{len} bytes of
@var{data} unless @var{data} is a null pointer, in which case the
contents are undefined.
@end deftypeop

The following @code{make} method is only available in the user-level
driver.

@deftypeop {Static method} Packet {WritablePacket *} make (@w{unsigned char *@var{data}}, @w{unsigned @var{len}}, @w{void (*@var{destructor})(unsigned char *, size_t)})
Returns a new packet that uses @var{data} as a buffer. That is, the new
packet will have the following characteristics:

@multitable {@code{buffer_length}} {@code{buffer_length_buffer}}
@item @code{buffer_data}
@tab @var{data}
@item @code{buffer_length}
@tab @var{len}
@item @code{headroom}
@tab 0
@item @code{length}
@tab @var{len}
@item @code{tailroom}
@tab 0
@end multitable

@noindent
When the resulting packet is destroyed, the function @var{destructor}
will be called with @var{data} and @var{len} as arguments.
@var{destructor} may be a null pointer, in which case @code{Packet}
calls @w{@code{delete[] @var{data}}} instead.

This method lets a user-level element manage packet memory itself,
rather than relying on @code{Packet}.
@end deftypeop

@noindent
@xref{Packets and sk_buffs}, for a @code{make} method only available in
the Linux kernel driver.

@subsection @code{Packet::kill}

To destroy a @code{Packet}, simply call its @code{kill} method.

@deftypemethod Packet void kill ()
Frees this packet. If this packet contained the last reference to its
data buffer, then frees the data buffer as well.
@end deftypemethod


@node Packets and sk_buffs, Packet Sharing, Packet Creation, Packets
@section @code{Packet}s and @code{sk_buff}s

In the Linux kernel driver, @code{Packet} objects are equivalent to
@code{struct sk_buff}s. This avoids indirection overhead and makes it
cheap to pass packets back and forth between Linux and Click. The
@code{Packet} operations described in this section are mostly inline
functions that expand to conventional @code{sk_buff} calls like
@code{skb_clone()}.

Click @code{Packet} @code{sk_buff}s should always have @code{skb->users}
equal to 1. That is, the @code{sk_buff} headers should not be shared,
although the data buffers they point to may be shared.

The @code{make}, @code{skb}, and @code{steal_skb} methods described in
this section convert @code{Packet}s to @code{sk_buff}s and vice versa.

@deftypeop {Static method} Packet {Packet *} make (@w{struct sk_buff *@var{skb}})
Returns a new packet equivalent to the @code{sk_buff} @var{skb}. All of
@var{skb}'s data pointers and annotations are left unchanged. This
method generally does nothing, since @code{Packet}s and @code{sk_buff}s
are equivalent in the Linux kernel. However, if @code{@var{skb}->users}
field is bigger than 1, the method will return a clone of @var{skb}.
This method returns a @code{Packet *}, not a @w{@code{WritablePacket
*}}, because the @var{skb} argument might share data with some other
@code{sk_buff}.

Do not use or manipulate @var{skb} after passing it to this method,
since Click and the @code{Packet} implementation now own @var{skb}.
@end deftypeop

@deftypemethod Packet {struct sk_buff *} skb ()
@deftypemethodx Packet {const struct sk_buff *} skb () const
Returns the @code{sk_buff} corresponding to this packet. Use this method
to examine the @code{sk_buff} version of a @code{Packet}.

Do not pass the result to a function that might free it or increment its
@code{users} field; use @code{steal_skb} for that.
@end deftypemethod

@deftypemethod Packet {struct sk_buff *} steal_skb ()
Returns the @code{sk_buff} corresponding to this packet. Use this
method to permanently change a @code{Packet} into an
@code{sk_buff}---for example, to create an @code{sk_buff} you'd like to
send to Linux.

Do not use or manipulate a @code{Packet} after calling its
@code{steal_skb} method, since Linux now owns the resulting
@code{sk_buff}.
@end deftypemethod


@node Packet Sharing, Packet Buffer Manipulation, Packets and sk_buffs, Packets
@section Sharing---@code{clone} and @code{uniqueify}

The @code{clone} method creates a new packet header that shares data
with an existing packet. The @code{uniqueify} method, in contrast,
ensures that a packet's data is not shared by anyone, perhaps by making
a copy of the data.

@deftypemethod Packet {Packet *} clone ()
Creates and returns a new packet header that shares this packet's data.
The new packet's annotations are copied from this packet's annotations.

The result may be a null pointer if there was not enough memory to make a
new packet header.
@end deftypemethod

@deftypemethod Packet {WritablePacket *} uniqueify ()
Ensures that this packet does not share data with any other packet. This
may involve copying the packet data, and perhaps creating a new packet
header, but if this packet is already unshared, no real work is
required. Returns a @w{@code{WritablePacket *}} because the new packet
is unshared.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{uniqueify} method. Manipulate the returned @w{@code{WritablePacket
*}} instead.

The result may be a null pointer if there was not enough memory to make a
required data copy. In this case, the old packet is freed.
@end deftypemethod

@deftypemethod Packet bool shared () const
Returns true if and only if this packet shares data with some other
packet.
@end deftypemethod


@node Packet Buffer Manipulation, Annotations, Packet Sharing, Packets
@section Buffer Manipulation---@code{push}, @code{pull}, @code{put}, and @code{take}

The @code{push}, @code{pull}, @code{put}, and @code{take} methods
manipulate a packet's contents by adding or removing space from its
headroom or tailroom. Given a packet, use @code{push} to add space to
its beginning, @code{pull} to remove space from its beginning,
@code{put} to add space to its end, and @code{take} to remove space from
its end. The methods that add space, @code{push} and @code{put},
uniqueify the relevant packet as a side effect. This ensures that the
packet's data is unshared so you can immediately manipulate the added
space.

@deftypemethod Packet {WritablePacket *} push (unsigned @var{amt})
Adds @var{amt} bytes of space to the beginning of the packet's data and
returns the resulting packet. The new space is uninitialized. The result
will not share data with any other packet; thus, it is a
@w{@code{WritablePacket *}}. If this packet is unshared and its headroom
is bigger than @var{amt}, then this operation is cheap, amounting to a
bit of pointer arithmetic. Otherwise, it requires copying the packet
data and possibly creating a new packet header.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{push} method. Manipulate the returned @w{@code{WritablePacket
*}} instead.

The result may be a null pointer if there was not enough memory to make a
required new packet. In this case, the old packet is freed.
@end deftypemethod

@deftypemethod Packet void pull (unsigned @var{amt})
Removes @var{amt} bytes of space from the beginning of the packet's
data. @var{amt} must be less than or equal to the packet's
@code{length()}. This operation is always cheap, amounting to a bit of
pointer arithmetic.
@end deftypemethod

@deftypemethod Packet {WritablePacket *} put (unsigned @var{amt})
Adds @var{amt} bytes of space to the end of the packet's data and
returns the resulting packet. The new space is uninitialized. The result
will not share data with any other packet; thus, it is a
@w{@code{WritablePacket *}}. If this packet is unshared and its tailroom
is bigger than @var{amt}, then this operation is cheap, amounting to a
bit of pointer arithmetic. Otherwise, it requires copying the packet
data and possibly creating a new packet header.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{put} method. Manipulate the returned @w{@code{WritablePacket *}}
instead.

The result may be a null pointer if there was not enough memory to make a
required new packet. In this case, the old packet is freed.
@end deftypemethod

@deftypemethod Packet void take (unsigned @var{amt})
Removes @var{amt} bytes of space from the end of the packet's data.
@var{amt} must be less than or equal to the packet's @code{length()}.
This operation is always cheap, amounting to a bit of pointer
arithmetic.
@end deftypemethod

The @code{push} and @code{put} methods have ``nonunique'' variants,
@code{nonunique_push} and @code{nonunique_put}, which do not have the
side effect of uniqueifying their resulting packet. These methods are
rarely used.

@deftypemethod Packet {Packet *} nonunique_push (unsigned @var{amt})
Adds @var{amt} bytes of space to the beginning of the packet's data and
returns the resulting packet. The new space is uninitialized. The result
may share data with other packets. If this packet's headroom is bigger
than @var{amt}, then this operation is cheap, amounting to a bit of
pointer arithmetic. Otherwise, it requires copying the packet data and
possibly creating a new packet header.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{nonunique_push} method. Manipulate the returned @w{@code{Packet
*}} instead.

The result may be a null pointer if there was not enough memory to make a
required new packet. In this case, the old packet is freed.
@end deftypemethod

@deftypemethod Packet {Packet *} nonunique_put (unsigned @var{amt})
Adds @var{amt} bytes of space to the end of the packet's data, returning
the resulting packet. The new space is uninitialized. The result may
share data with other packets. If this packet's tailroom is bigger than
@var{amt}, then this operation is cheap, amounting to a bit of pointer
arithmetic. Otherwise, it requires copying the packet data and possibly
creating a new packet header.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{nonunique_put} method. Manipulate the returned @w{@code{Packet *}}
instead.

The result may be a null pointer if there was not enough memory to make a
required new packet. In this case, the old packet is freed.
@end deftypemethod


@node Annotations, Packet Out-of-Memory, Packet Buffer Manipulation, Packets
@section Annotations

Each packet header has space for a number of @dfn{annotations}, extra
information about the packet that is not contained in its data. Click
supports @dfn{header annotations}, which indicate where in the packet a
network header, such as an IP header, is located; @dfn{user
annotations}, whose semantics are left undefined by Click---different
elements can treat them in different ways; and other specialized
annotations, such as the @dfn{timestamp annotation}, the
@dfn{destination IP address annotation}, and so forth.

New packets begin with all annotations cleared: numeric annotations are
zero, pointer annotations are null pointers. @code{clone},
@code{uniqueify}, and their equivalents always copy each of the original
packet's annotations in the appropriate way. (For example, the new
header annotations will point into the new data, if a data copy was
made.)

@menu
* Header Annotations::          
* User Annotations::            
* Specific User Annotations::   
* Other Annotations::           
* Annotations In General::      
@end menu

@node Header Annotations, User Annotations, Annotations, Annotations
@subsection Header Annotations

Many packets contain a network header of some kind, such as an IP
header. This header may be located anywhere in the packet depending on
how the packet was encapsulated. Furthermore, the data encapsulated by
that network header may be located anywhere after the network header,
given the presence of options. With the @dfn{network header annotation}
and the @dfn{transport header annotation}, one element can determine
where a network header is and how long it is, then store this
information for other elements to use. For example, the
@click{CheckIPHeader} element sets the header annotations on packets it
receives. Elements like @click{SetIPDSCP} then require a non-null IP
header annotation on their input packets.

The header annotations on new packets are each set to a null pointer.

@deftypemethod Packet {const unsigned char *} network_header () const
@deftypemethodx WritablePacket {unsigned char *} network_header () const
Returns the network header annotation. The resulting pointer is
read-only on @code{Packet}s and read/write on @code{WritablePacket}s.
@end deftypemethod

@deftypemethod Packet {const unsigned char *} transport_header () const
@deftypemethodx WritablePacket {unsigned char *} transport_header () const
Returns the transport header annotation. The resulting pointer is
read-only on @code{Packet}s and read/write on @code{WritablePacket}s.
@end deftypemethod

@deftypemethod Packet int network_header_offset () const
Returns the offset from @code{data()} to @code{network_header()}. The
result might be negative, since the @code{data} pointer may have been
advanced past the network header annotation with the @code{pull} method.
@end deftypemethod

@deftypemethod Packet int network_header_length () const
Returns the network header's length. This equals
@code{transport_header()} @minus{} @code{network_header()}.
@end deftypemethod

@deftypemethod Packet unsigned transport_header_offset () const
Returns the offset from @code{data()} to @code{transport_header()}. The
result might be negative, since the @code{data} pointer may have been
advanced past the transport header annotation with the @code{pull} method.
@end deftypemethod

Several invariants relate these methods' values whenever the header
annotations are non-null:

@display
@code{buffer_data()} @math{@leq} @code{network_header()} @math{@leq} @code{transport_header()}
             @math{@leq} @code{buffer_data()} @math{+} @code{buffer_length()}
@code{network_header_offset()} @math{=} @code{network_header()} @minus{} @code{data()}
@code{transport_header_offset()} @math{=} @code{transport_header()} @minus{} @code{data()}
@code{network_header_length()} @math{=} @code{transport_header()} @minus{} @code{network_header()}
@end display

@sp 1

Set the network and transport header annotations simultaneously with the
@code{set_network_header} method.

@deftypemethod Packet void set_network_header (@w{const unsigned char *@var{header}}, @w{unsigned @var{len}})
Sets the network header annotation to @var{header}, which must lie
between @code{buffer_data()} and @code{buffer_data()} @math{+}
@code{buffer_length()}. The network header is @var{len} bytes long, so
@code{network_header_length()} will equal @var{len} and
@code{transport_header()} will equal @var{header} @math{+} @var{len}.
@end deftypemethod

@subsubsection Typed Header Annotations

For convenience, @code{Packet} provides methods for accessing and
setting the network header annotation as an IP or IPv6 header. These
methods use the same annotations as the generic @code{network_header}
methods; they are just typed differently.

@deftypemethod Packet {const click_ip *} ip_header () const
@deftypemethodx WritablePacket {click_ip *} ip_header () const
@deftypemethodx Packet {const click_ip6 *} ip6_header () const
@deftypemethodx WritablePacket {click_ip6 *} ip6_header () const
Returns @code{network_header()} as a pointer to an IP or IPv6 header
structure.
@end deftypemethod

@deftypemethod Packet int ip_header_offset () const
@deftypemethodx Packet unsigned ip_header_length () const
@deftypemethodx Packet int ip6_header_offset () const
@deftypemethodx Packet unsigned ip6_header_length () const
Equivalent to @code{network_header_offset()} and
@code{network_header_length()}.
@end deftypemethod

@deftypemethod Packet void set_ip_header (@w{const click_ip *@var{header}}, @w{unsigned @var{len}})
@deftypemethodx Packet void set_ip6_header (@w{const click_ip6 *@var{header}}, @w{unsigned @var{len}})
Equivalent to @code{set_network_header(@var{header}, @var{len})}.
@end deftypemethod

@deftypemethod Packet void set_ip6_header (@w{const click_ip6 *@var{header}})
Equivalent to @code{set_ip6_header(@var{header}, 40)}.
@end deftypemethod


@node User Annotations, Specific User Annotations, Header Annotations, Annotations
@subsection User Annotations

Each packet header has a @dfn{user annotation area}, space reserved for
arbitrary annotations. Different methods access this space as an array
of bytes, integers, or unsigned integers. The @code{Packet} class does
not assign semantics to any particular byte in the user annotation area.
Instead, macros in @w{@samp{<click/packet_anno.hh>}} provide names for
particular bytes. Some of these names have overlapping byte ranges; the
user must take care not to define a configuration whose elements use an
annotation byte on a packet for different purposes. The next section
describes the macros in Click's default
@w{@samp{<click/packet_anno.hh>}}.

These constants define the size of the annotation area.

@table @code
@item Packet::USER_ANNO_SIZE
The size of the annotation area in bytes.
@item Packet::USER_ANNO_U_SIZE
The size of the annotation area in @code{unsigned int}s.
@item Packet::USER_ANNO_I_SIZE
The size of the annotation area in @code{int}s.
@end table

@noindent
Currently, @code{USER_ANNO_SIZE} is 12 and @code{USER_ANNO_U_SIZE} and
@code{USER_ANNO_I_SIZE} are both 3.

The user annotation area may be accessed as an array of bytes, an array
of @code{unsigned int}s, or an array of @code{int}s. The elements of
these arrays are numbered from 0 to @math{@var{k} - 1}, where @var{k} is
the appropriate @code{SIZE} constant.

@deftypemethod Packet unsigned char user_anno_c (@w{int @var{i}}) const
Returns the @var{i}th byte in the user annotation area. @var{i} must be
between 0 and @code{USER_ANNO_SIZE} @minus{} 1.
@end deftypemethod

@deftypemethod Packet unsigned user_anno_u (@w{int @var{i}})
@deftypemethodx Packet int user_anno_i (@w{int @var{i}})
Returns the @var{i}th @code{unsigned int} or @code{int} in the user
annotation area. @var{i} must be between 0 and @code{USER_ANNO_U_SIZE}
@minus{} 1. The @var{i}th @code{unsigned int} or @code{int} annotation
occupies bytes @math{4@var{i}} through @math{4@var{i} + 3} of the user
annotation area.
@end deftypemethod

@deftypemethod Packet void set_user_anno_c (@w{int @var{i}}, @w{unsigned char @var{value}})
@deftypemethodx Packet void set_user_anno_u (@w{int @var{i}}, @w{unsigned @var{value}})
@deftypemethodx Packet void set_user_anno_i (@w{int @var{i}}, @w{int @var{value}})
Sets the @var{i}th byte, @code{unsigned int}, or @code{int} user
annotation to @var{value}.
@end deftypemethod

@deftypemethod Packet {unsigned *} all_user_anno_u ()
Returns a pointer to the user annotation area, treated as an array of
@code{unsigned int}s.
@end deftypemethod


@node Specific User Annotations, Other Annotations, User Annotations, Annotations
@subsection Specific User Annotations

The @w{@samp{<click/packet_anno.hh>}} header file defines macros for
accessing a packet's user annotation area by name. These macros follow
some simple guidelines. Each user annotation is given a name like
@samp{PAINT} or @samp{FIX_IP_SRC}. Then, two macros are written for each
annotation, @code{@var{name}_ANNO} and @code{SET_@var{name}_ANNO}.

@deftypefn {Macro} {} {@var{name}_ANNO} (@w{const Packet *@var{p}})
Returns the value of @var{p}'s @var{name} annotation.
@end deftypefn

@deftypefn {Macro} {} {SET_@var{name}_ANNO} (@w{Packet *@var{p}}, @var{value})
Sets @var{p}'s @var{name} annotation to @var{value}.
@end deftypefn

@noindent
For example, here are the definitions of @code{PAINT_ANNO} and
@code{SET_PAINT_ANNO} from Click's default
@samp{<click/packet_anno.hh>}.

@example
#define PAINT_ANNO(p)          ((p)->user_anno_c(0))
#define SET_PAINT_ANNO(p, v)   ((p)->set_user_anno_c(0, (v)))
@end example

@sp 1

This table lists the annotations declared in Click's default
@samp{<click/packet_anno.hh>}.

@multitable {@code{ICMP_PARAM_PROB}} {@code{unsigned char}} {Bytes} {Blah,blah,blah,blah,blah,blah,blah,blah}
@item Annotation name
@tab Type
@tab Bytes
@tab Some relevant elements
@item @code{PAINT}
@tab @code{unsigned char}
@tab 0
@tab @click{Paint}, @click{CheckPaint}, @click{PaintTee}
@item @code{ICMP_PARAM_PROB}
@tab @code{unsigned char}
@tab 1
@tab @click{IPGWOptions}, @click{ICMPError}
@item @code{FIX_IP_SRC}
@tab @code{unsigned char}
@tab 3
@tab @click{ICMPError}, @click{FixIPSrc}
@item @code{FWD_RATE}
@tab @code{int}
@tab 4--7
@tab @click{IPRateMonitor}
@item @code{REV_RATE}
@tab @code{int}
@tab 8--11
@tab @click{IPRateMonitor}
@end multitable


@node Other Annotations, Annotations In General, Specific User Annotations, Annotations
@subsection Other Annotations

Packet headers have space for four other particular annotations, and
special methods for accessing them. These annotations do not overlap the
user annotation area. There are annotations that hold a destination IP
address, a timestamp, the device on which the packet arrived, a packet
type constant, and, in the Linux kernel module, a performance counter
value.

@menu
* Destination Address Annotation::  
* Timestamp Annotation::        
* Device Annotation::           
* Packet Type Annotation::      
* Performance Counter Annotation::  
@end menu

@node Destination Address Annotation, Timestamp Annotation, Other Annotations, Other Annotations
@subsubsection Destination Address

The destination address annotation stores the IP or IPv6 address of the
next hop towards the packet's destination. Elements check and manipulate
this address, rather than the IP header's destination address, since the
next-hop address often differs from the final destination. The
destination IP address and IPv6 address are different annotations, but
they overlap; you may set only one at a time.

@deftypemethod Packet IPAddress dst_ip_anno () const
Returns this packet's destination IP address annotation.
@end deftypemethod

@deftypemethod Packet {const IP6Address &} dst_ip6_anno () const
Returns a reference to this packet's destination IPv6 address
annotation.
@end deftypemethod

@deftypemethod Packet void set_dst_ip_anno (@w{IPAddress @var{value}})
@deftypemethodx Packet void set_dst_ip6_anno (@w{const IP6Address &@var{value}})
Sets this packet's destination IP or IPv6 address annotation to
@var{value}.
@end deftypemethod

The destination IP address annotation is set by the @click{GetIPAddress}
and @click{SetIPAddress} elements, manipulated by @click{LookupIPRoute}
and its cousins, and used by @click{ARPQuerier}. It defaults to zero.

@node Timestamp Annotation, Device Annotation, Destination Address Annotation, Other Annotations
@subsubsection Timestamp

The timestamp annotation generally indicates when a packet was received.

@deftypemethod Packet {const struct timeval &} timestamp_anno () const
@deftypemethodx Packet {struct timeval &} timestamp_anno ()
Returns a reference to this packet's timestamp annotation.
@end deftypemethod

@deftypemethod Packet void set_timestamp_anno (@w{const struct timeval &@var{value}})
Sets this packet's timestamp annotation to @var{value}.
@end deftypemethod

@deftypemethod Packet void set_timestamp_anno (@w{int @var{sec}}, @w{int @var{usec}})
Sets this packet's timestamp annotation to @var{sec} and @var{usec}.
Equivalent to @code{struct timeval tv; tv.tv_sec = @var{sec}; tv.tv_usec
= @var{usec}; set_timestamp_anno(tv)}.
@end deftypemethod

Linux device drivers set this annotation, so packets emitted by
@click{FromDevice} and @click{PollDevice} in the Linux kernel driver
have the annotation set. Packet sources like @click{InfiniteSource} and
@click{RatedSource} also set the annotation, as does @click{FromDump} in
the user-level driver. Debugging elements like @click{Print} generally
take a keyword argument that makes them print packet timestamps.

The timestamp annotation defaults to zero.

@node Device Annotation, Packet Type Annotation, Timestamp Annotation, Other Annotations
@subsubsection Device

In the Linux kernel, packets received from some device are annotated
with a pointer to the relevant @code{struct net_device} object. (In
versions of the kernel prior to 2.3, this type was called @code{struct
device}.) The @code{Packet} class provides access to this annotation.
The annotation has type @w{@code{net_device *}}; Click defines
@code{net_device} as a synonym for @code{struct device} in kernel
versions 2.2 and prior.

@deftypemethod Packet {net_device *} device_anno () const
Returns this packet's device annotation.
@end deftypemethod

@deftypemethod Packet void set_device_anno (@w{net_device *@var{value}})
Sets this packet's device annotation to @var{value}.
@end deftypemethod

@noindent
In the user-level driver, @code{device_anno} always returns 0, and
@code{set_device_anno} does nothing.

The @click{ARPResponder} element sets this annotation on every generated
response to the value of the annotation on the relevant query. Because
of this, those responses can be safely forwarded to Linux: Linux's
ARP-response code requires a correct device annotation.

The device annotation defaults to a null pointer.

@node Packet Type Annotation, Performance Counter Annotation, Device Annotation, Other Annotations
@subsubsection Packet Type

The packet type annotation specifies how a packet was received. Its
value is one of the following constants, which are defined in the
@code{Packet::PacketType} enumeration.

@table @asis
@item @samp{HOST}
The packet was sent to this host.

@item @samp{BROADCAST}
The packet was sent to a link-level broadcast address.

@item @samp{MULTICAST}
The packet was sent to a link-level multicast address.

@item @samp{OTHERHOST}
The packet was sent to a different host, but received anyway. The
relevant device is probably in promiscuous mode.

@item @samp{OUTGOING}
The packet was generated at this host and is being sent to another host.

@item @samp{LOOPBACK}, @samp{FASTROUTE}
See the Linux kernel documentation. These values correspond to
@samp{PACKET_LOOPBACK} and @samp{PACKET_FASTROUTE}, which are defined in
@samp{<linux/if_packet.h>}.
@end table

@deftypemethod Packet {Packet::PacketType} packet_type_anno () const
Returns this packet's packet type annotation.
@end deftypemethod

@deftypemethod Packet void set_packet_type_anno (@w{Packet::PacketType @var{value}})
Sets this packet's packet type annotation to @var{value}.
@end deftypemethod

In the Linux kernel, device drivers set the packet type annotation for
the packets they receive. Thus, the @click{FromDevice} and
@click{PollDevice} elements generate packets with correct packet type
annotations. The user-level driver's @click{FromDevice} also sets the
packet type annotation. The @click{ICMPError} and @click{DropBroadcasts}
elements use the annotation's value.

The packet type annotation defaults to @code{Packet::HOST}.

@node Performance Counter Annotation,  , Packet Type Annotation, Other Annotations
@subsubsection Performance Counter

This annotation is available only in the Linux kernel driver. Its value
is an @code{unsigned long long} that generally corresponds to some
performance counter value.

@deftypemethod Packet {unsigned long long} perfctr_anno () const
Returns this packet's performance counter annotation.
@end deftypemethod

@deftypemethod Packet void set_perfctr_anno (@w{unsigned long long @var{value}})
Sets this packet's performance counter annotation to @var{value}.
@end deftypemethod

The @click{SetCycleCount}, @click{SetPerfCount},
@click{CycleCountAccum}, and @click{PerfCountAccum} elements manipulate
this annotation. Its default value is zero.


@node Annotations In General,  , Other Annotations, Annotations
@subsection Annotations In General

@code{Packet} provides methods for clearing a packet's annotations, and
for copying all of a packet's annotations from another packet.

@deftypemethod Packet void clear_annotations ()
Clears all of this packet's annotations to their default state, which is
generally zero.
@end deftypemethod

@deftypemethod Packet void copy_annotations (const Packet *@var{p})
Copies all of @var{p}'s annotations into this packet except for its
header annotations. (This packet's current header annotations are left
unchanged.)
@end deftypemethod


@node Packet Out-of-Memory,  , Annotations, Packets
@section Out-of-Memory Conditions

Any method that potentially allocates memory for a @code{Packet} may
fail due to an out-of-memory condition. The complete list of these
methods follows:

@itemize @bullet
@item @code{make} variants
@item @code{clone}
@item @code{uniqueify}
@item @code{push}
@item @code{put}
@item @code{nonunique_push}
@item @code{nonunique_put}
@end itemize

@noindent
These methods always return a null pointer on out-of-memory. Methods
that manipulate existing packets---@code{uniqueify}, @code{push},
@code{put}, @code{nonunique_push}, and
@code{nonunique_put}---additionally free any existing packet before
returning a null pointer. You should always check the results of these
methods to see if you have run out of memory.


@node Element Characteristics, Element Initialization, Packets, Top
@chapter Element Characteristics

@menu
* Element Class::               
* Element Casting::             
* Element Names::               
* Element Router::              
* Creating Element Ports::      
* Using Element Ports::         
* When to Call Element Methods::  
@end menu

@node Element Class, Element Casting, Element Characteristics, Element Characteristics
@section Element Class

Every element belongs to a single element class, and every element class
has a name. The @code{class_name} virtual function returns that name.

@deftypemethod Element {virtual const char *} class_name {() const}
Returns the element's class name as a null-terminated C string. This
method has no default implementation; every element must supply a
definition.

The @code{class_name} method should be declared on a single line in the
element's class definition, and should return a C string constant. This
makes the element's class name easy to automatically extract from the
source code.

Here is a typical @code{class_name} method.

@example
class ARPQuerier : public Element @{ public: // ...
  const char *class_name() const @{ return "ARPQuerier"; @}
@}
@end example
@end deftypemethod

Click creates new element objects by cloning existing element objects.
The system maintains one prototype element for each element class it
understands. When a router configuration declares a new element, the
system finds the appropriate prototype and calls its @code{clone}
method. This method creates and returns a new element with the same
element class as the prototype.

@deftypemethod Element {virtual Element *} clone {() const}
Returns a new element with the same element class as this element. This
method has no default implementation; every element must supply a
definition.

The @code{clone} method should return a completely fresh element object.
In particular, the resulting element should not be configured or
initialized, and should not share this element's configuration state. It
will be configured independently through element initialization methods;
see @ref{Element Initialization}, for more information.

Here is a typical @code{clone} method.

@example
class ARPQuerier : public Element @{ public: // ...
  ARPQuerier *clone() const @{ return new ARPQuerier; @}
@}
@end example

@noindent
Note that @code{clone}'s return type has been changed to
@code{ARPQuerier *} rather than @w{@code{Element *}}. This is considered
good style, since it makes the types more specific, but it is not really
necessary. @code{clone} need not be defined in the class definition,
although many elements do define it this way.
@end deftypemethod


@node Element Casting, Element Names, Element Class, Element Characteristics
@section Casting

Each element conforms to one or more named @dfn{interfaces}. Each
element class is an interface, whose name is just the element class
name, but the user can create additional interfaces at will. Generally,
these interfaces export functionality that elements may be interested
in, but that is not specific to any one element class. For example, the
@click{Storage} interface provides information about how many packets
are stored in an element; elements that implement this interface include
@click{Queue}, @click{FrontDropQueue}, and @click{FromDevice}. Elements
interested in packet storage, such as @click{RED}, then look for
@click{Storage} elements, making them independent of any particular
storage strategy.

A caller can discover whether an element implements a particular
interface by calling its @code{cast} method. This method takes an
interface name and returns a non-null pointer if and only if the
element implements that interface.

@deftypemethod Element {virtual void *} cast {(const char *@var{name})}
The @var{name} argument is an interface name represented a
null-terminated C string. If this element implements the @var{name}
interface, @code{cast} should return a pointer to the corresponding
data. If it does not, @code{cast} should return a null pointer.

The default representation returns @code{this} if @var{name} equals the
element's @code{class_name()}, or a null pointer if it does not.
@end deftypemethod

Some care is required when one element class is a subclass of another.
Say that element class @code{Derived} is a subclass of @code{Base}. Then
@code{Derived}'s @code{cast} method should return a non-null pointer
when passed either @code{"Derived"}, @code{"Base"}, or any additional
interfaces that @code{Derived} or @code{Base} might implement. Here is a
first try at @code{Derived}'s @code{cast} implementation:

@example
void *
Derived::cast(const char *name)
@{
  if (strcmp(name, "Derived") == 0)
    return (Derived *)this;
  else // rely on Base::cast to check for "Base"
    return Base::cast(name);
@}
@end example

@noindent
This code is correct and preferred as long as @code{Base} has its own
@code{cast} implementation. Unfortunately, if @code{Base} took advantage
of @code{cast}'s default implementation, which uses @code{class_name},
the code is broken. Since a @code{Derived} element's @code{class_name}
method returns @code{"Derived"}, the default @code{cast} method will
check only for @code{"Derived"}, not for @code{"Base"} as we wished. The
solution is either to write an explicit @code{cast} method for
@code{Base}, or to write @code{Derived::cast} differently---like so, for
example:

@example
void *
Derived::cast(const char *name)
@{
  if (strcmp(name, "Derived") == 0)
    return (Derived *)this;
  else if (strcmp(name, "Base") == 0)
    return (Base *)this;
  else
    return 0;
@}
@end example

Always explicitly cast @code{this} to the correct type before returning
it. This is important because of multiple inheritance, where the value
of a pointer to a supertype may be different from the value of
@code{this}. (The type system generally determines when pointer
arithmetic is necessary, but the @w{@code{void *}} return type hides
this type information from @code{cast}'s caller.)

We encourage you to write simple @code{cast} methods that compare the
@var{name} argument against a set of fixed strings. Arbitrary
computation inside @var{cast} is discouraged; we may eventually want to
analyze @code{cast} definitions.

Click uses a @code{cast} method rather than C++'s standard
@code{dynamic_cast} mechanism because it's difficult to use
@code{dynamic_cast} in the Linux kernel.


@node Element Names, Element Router, Element Casting, Element Characteristics
@section Names

Each element in a router configuration has a @dfn{name} under which it
was declared and a @dfn{landmark}, a string indicating where it was
declared in the configuration file.

@deftypemethod Element String id () const
Returns the element's name.
@end deftypemethod

@deftypemethod Element String declaration () const
Returns a textual representation of the element's declaration. The
result has the form @w{@samp{@var{id} :: @var{cname}}}, where @var{id}
is the element's @code{id()} and @var{cname} is its @code{class_name()}.
@end deftypemethod

@deftypemethod Element String landmark () const
Returns a string indicating where the element was declared in the
configuration file. The result generally has the form
@samp{@var{filename}:@var{linenumber}}.
@end deftypemethod



@node Element Router, Creating Element Ports, Element Names, Element Characteristics
@section Router Relationship

Elements may be part of some router configuration, which is represented
by a @code{Router} object. Elements in a @code{Router} are numbered
between 0 and that router's @code{nelements()}; @code{eindex} returns
that number.

@deftypemethod Element {Router *} router () const
Returns the element's corresponding @code{Router} object.
@end deftypemethod

@deftypemethod Element int eindex () const
Returns the element's index in its router.
@end deftypemethod

@deftypemethod Element int eindex (Router *@var{r}) const
Returns the element's index in its router, if that router is @var{r}, or
@math{-1}, if that router is not @var{r}. Equivalent to:

@example
return (router() == @var{r} ? eindex() : -1);
@end example
@end deftypemethod


@node Creating Element Ports, Using Element Ports, Element Router, Element Characteristics
@section Creating Ports

These methods return or change how many input and output ports an
element has.

@deftypemethod Element int ninputs () const
@deftypemethodx Element int noutputs () const
Returns the element's number of input or output ports.
@end deftypemethod

The @code{set_} and @code{add_} methods, which add or remove ports, must
be called only by the element itself. For example, the Click
infrastructure never calls @code{set_ninputs} or @code{set_noutputs}.
Click will inform the element how many of its ports were used in a
particular router configuration; see @ref{notify_ninputs
notify_noutputs}.

You may change an element's number of ports only during router
initialization. You may not, for example, call @code{set_ninputs} at run
time, or even during the element's @code{initialize} method
(@pxref{initialize}). @xref{When to Call Element Methods}, for more
information.

@deftypemethod Element void set_ninputs (int @var{n}) const
@deftypemethodx Element void set_noutputs (int @var{n}) const
Sets the element's number of input or output ports to @var{n}, which
must be greater than or equal to zero.
@end deftypemethod

@deftypemethod Element void add_input () const
@deftypemethodx Element void add_output () const
Add an input or output port to the element. Same as
@code{set_ninputs(ninputs() + 1)} or @code{set_noutputs(noutputs() +
1)}.
@end deftypemethod


@node Using Element Ports, When to Call Element Methods, Creating Element Ports, Element Characteristics
@section Using Ports

Each of an element's input and output ports is represented by an
@code{Element::Port} object. The @code{input} and @code{output} methods
return the @code{Port} object corresponding to a given port number.

@deftypemethod Element {const Port &} input (int @var{p}) const
@deftypemethodx Element {const Port &} output (int @var{p}) const
Returns the @code{Element::Port} object corresponding to the
element's @var{p}th input or output port. @var{p} must be a valid port
number: greater than or equal to zero and less than @code{ninputs()} or
@code{noutputs()}, respectively.
@end deftypemethod

The following methods return information about a port.
@code{input_is_pull} and @code{output_is_push} are @code{Element}
methods; the rest are methods on @code{Element::Port}. All of these
methods return meaningful results only after the router has been
partially initialized; see @ref{When to Call Element Methods}.

@deftypemethod Element bool input_is_pull (int @var{p}) const
@deftypemethodx Element bool output_is_push (int @var{p}) const
Returns true if input port @var{p} is pull or output port @var{p} is
push, respectively. @var{p} must be a valid port number.
@end deftypemethod

@deftypemethod {Element::Port} {Element *} element () const
Returns the element this port is connected to, if one exists. Pull input
ports and push output ports are always connected to another element;
push input ports and pull output ports never are. @code{element()}
returns a null pointer when called on a push input port or pull output
port.
@end deftypemethod

@deftypemethod {Element::Port} int port () const
Returns the port number this port is connected to, if one exists. Pull
input ports and push output ports are always connected to another port;
push input ports and pull output ports never are. @code{port()} returns
@math{-1} when called on a push input port or pull output port.
@end deftypemethod

For example, consider this router configuration.

@example
x :: X; y :: Y;
x [0] -> [1] y; // push connection
@end example

@noindent
Because @code{x [0]} is a push output port,
@code{x->output(0).element()} will return @code{y} and
@code{@w{x->}output(0).port()} will return 1. On the other hand,
@code{@w{y->}input(1).element()} will return a null pointer and
@code{@w{y->}input(1).port()} will return @math{-1}.

The @code{element} and @code{port} methods only supply local information
about how elements are connected. Furthermore, they provide no
information about how push input ports and pull output ports are
connected. For these reasons, most elements interested in router
configuration topology call @code{Router}'s @code{upstream_elements} and
@code{downstream_elements} methods instead.


@node When to Call Element Methods,  , Using Element Ports, Element Characteristics
@section When Element Methods May Be Called

This chart shows when it is OK to call particular @code{Element}
methods. Methods not mentioned here are generally not called by the
user; for example, generally only the system calls @code{clone}.

@example
  Method Name                    constr notify config  init   run  
+-------------------------------+------+------+------+------+------+
| class_name, cast              |  OK  |  OK  |  OK  |  OK  |  OK  |
| id, declaration, landmark     |      |  OK  |  OK  |  OK  |  OK  |
| router, eindex                |      |  OK  |  OK  |  OK  |  OK  |
+-------------------------------+------+------+------+------+------+
| ninputs, noutputs             |  OK  |  OK  |  OK  |  OK  |  OK  |
| set_ninputs, set_noutputs     |  OK  |  OK  |  OK  |      |      |
| add_input, add_output         |  OK  |  OK  |  OK  |      |      |
+-------------------------------+------+------+------+------+------+
| input, output                 |      |      |      |  OK  |  OK  |
| input_is_pull, output_is_push |      |      |      |  OK  |  OK  |
| Port::element, Port::port     |      |      |      |  OK  |  OK  |
+-------------------------------+------+------+------+------+------+
  Method Name                    constr notify config  init   run  
@end example

The headings denote:

@table @samp
@item constr
Construction time. This includes the element's constructor and its
destructor.

@item notify
Inside the @code{notify_ninputs} and @code{notify_noutputs} methods.

@item config
Inside the @code{configure} method.

@item init
Inside the @code{initialize}, @code{add_handlers}, and
@code{uninitialize} methods.

@item run
At run time. That is, inside some @code{run_scheduled}, @code{push}, or
@code{pull} method, or some handler, or some function called from one of
these places.
@end table


@node Element Initialization, Element Runtime, Element Characteristics, Top
@chapter Element Initialization

The process of making an element ready for inclusion in an active router
is called @dfn{element initialization}. This includes processing the
element's configuration string, setting up internal state and any input
and output ports, and querying the router about neighboring elements.

Every element in an active router must have successfully initialized. If
there is an error initializing even one element, the router is aborted.
Router initialization happens in sequential phases: every element must
successfully complete one phase before the next phase begins.

@menu
* notify_ninputs notify_noutputs::  
* configure_phase::             
* configure::                   
* processing::                  
* flow_code::                   
* initialize::                  
* uninitialize::                
* add_handlers::                
* Initialization Phases::       
@end menu


@node notify_ninputs notify_noutputs, configure_phase, Element Initialization, Element Initialization
@section @code{notify_ninputs} and @code{notify_noutputs}

The router calls each element's @code{notify_ninputs} and
@code{notify_noutputs} methods to tell it how many of its input and
output ports were used in the configuration. A port is used if it is
used in a connection.

@deftypemethod Element {virtual void} notify_ninputs (int @var{ninputs})
@deftypemethodx Element {virtual void} notify_noutputs (int @var{noutputs})

The @var{ninputs} and @var{noutputs} arguments specify how many input
and output ports were used in the configuration. For example, if
@var{ninputs} is 5, then input ports 0 through 4 were
used.@footnote{Strictly speaking, it is possible that one or more of the
lower-numbered ports were not used---for example, that input port 0 was
not used by the configuration. This is always a configuration error,
however. A later stage will report unused ports as errors and abort
router initialization.}

These methods' default implementations do nothing.
@end deftypemethod

@code{notify_ninputs} and @code{notify_noutputs} are called early in the
initialization process---before @code{configure}, for example, and
before ports are assigned to push or pull. They may create and destroy
input and output ports or set other private element state.

A @code{notify_ninputs} or @code{notify_noutputs} method should
generally be very short and stylized. It should call no Element methods
except for possibly @code{set_ninputs} or @code{set_noutputs}. This
typical @code{notify_noutputs} method sets the element's number of
outputs to one or two, depending on how many outputs were actually used:

@example
void
ARPQuerier::notify_noutputs(int n)
@{
  set_noutputs(n < 2 ? 1 : 2);
@}
@end example


@node configure_phase, configure, notify_ninputs notify_noutputs, Element Initialization
@section @code{configure_phase}---Initialization Order

Some elements depend on being configured and initialized before or after
other elements. For example, the @click{AddressInfo} element must be
configured before all other elements, since its address abbreviations
must be available in their configuration strings. The
@code{configure_phase} method makes this possible.

@deftypemethod Element {virtual int} configure_phase () const
Returns the element's @dfn{configure phase}, an integer that specifies
when it should be configured and initialized relative to other elements.

An element with a low configure phase will be configured before an
element with a high configure phase. Elements with the same configure
phase might be configured in any order relative to one another.

The following basic configure phase constants are defined in
@code{<click/element.hh>}:

@table @code
@item CONFIGURE_PHASE_FIRST
Configure before most other elements. Only used by @click{AddressInfo}
in the Click distribution.
@item CONFIGURE_PHASE_INFO
Configure early. Appropriate for most information elements.
@item CONFIGURE_PHASE_DEFAULT
Default configuration phase. Appropriate for most elements.
@item CONFIGURE_PHASE_LAST
Configure after most other elements. No elements in the Click
distribution use this configure phase.
@end table

@code{configure_phase} may also return a number based on these
constants. For example, all @click{FromLinux} elements should be
initialized before any @click{ToDevice} elements. The @click{FromLinux}
element therefore contains the following definitions:

@example
enum @{ CONFIGURE_PHASE_FROMLINUX = CONFIGURE_PHASE_DEFAULT,
       CONFIGURE_PHASE_TODEVICE = CONFIGURE_PHASE_FROMLINUX + 1 @};
@end example

@noindent
@code{FromLinux::configure_phase} returns
@code{CONFIGURE_PHASE_FROMLINUX}, and @code{ToDevice::configure_phase}
returns @code{FromLinux::CONFIGURE_PHASE_TODEVICE}.

The default implementation returns @code{CONFIGURE_PHASE_DEFAULT}.
@end deftypemethod

Click uses all elements' configure phases to construct a single element
configuration order. It then configures elements in this order and, if
there were no errors, initializes them in the same order. The
@code{configure_phase} method is called once, relatively early---before
@code{configure} and @code{initialize}.

An element's configure phase should depend only on its class. In
particular, the body of a @code{configure_phase} method should consist
of a single @code{return} statement returning some constant.


@node configure, processing, configure_phase, Element Initialization
@section @code{configure}---Parsing Configure Strings

The @code{configure} method is passed the element's configuration
string. This method is expected to parse the configuration string,
report any errors, and initialize the element's internal state.

@deftypemethod Element {virtual int} configure (const Vector<String> &@var{conf}, ErrorHandler *@var{errh})
The @var{conf} argument is the element's configuration string, divided
into configuration arguments by splitting at commas, and with comments
and extraneous whitespace removed. If @var{conf} is empty, the element
was not supplied with a configuration string (or its configuration
string contained only comments and whitespace).

Any errors, warnings, or messages should be reported to @var{errh}.
Messages should not specify the element name or type; this information
will be supplied externally.

This method should return zero if configuration succeeds, or a negative
number if it fails. Returning a negative number prevents the router from
initializing.

The default @code{configure} method succeeds if and only if there are no
configuration arguments.
@end deftypemethod

@code{configure} is called relatively early in the initialization
process. For instance, @code{configure} may create or destroy input and
output ports---the port validity check happens after @code{configure}
completes. @code{configure} cannot determine whether a port is push or
pull; neither can it query the router for information about its
neighbors.

A @code{configure} method should not perform potentially harmful
actions, such as truncating files or attaching to devices. These actions
should be left for the @code{initialize} method, which is called later.
This avoids harm if another element cannot be configured, or if the
router is incorrectly connected, since in these cases @code{initialize}
will never be called.


@node processing, flow_code, configure, Element Initialization
@section @code{processing}---Push and Pull Processing

Elements use the @code{processing} method to specify whether their ports
are push, pull, or agnostic. This method returns a @dfn{processing
code}---an ASCII string that, properly interpreted, specifies the
processing type for each port.

@deftypemethod Element {virtual const char *} processing () const
Returns the element's processing code as a null-terminated C string.
@end deftypemethod

Processing codes look like this:

@display
@samp{@var{inputspec}/@var{outputspec}}
@end display

@noindent
Each of @var{inputspec} and @var{outputspec} is a sequence of @samp{h},
@samp{l}, and @samp{a} characters, containing at least one character.
@samp{h} indicates a push port, @samp{l} a pull port, and @samp{a} an
agnostic port. The first character in each sequence represents the first
port (port 0), and so forth. For example, @strcode{"a/ah"} says that the
element's first input and first output ports are both agnostic, but the
second output port is push.

@var{Inputspec} and @var{outputspec} need not have the correct numbers
of characters. The last character in each specification is duplicated as
many times as necessary, and any extra characters are ignored. Thus, the
processing codes @strcode{"aaaaaaaa/haaaaaaa"} and @strcode{"a/ha"} behave
identically.

The @code{Element} class provides mnemonic names for five common
processing codes:

@table @code
@item AGNOSTIC
@strcode{"a/a"} (agnostic ports).
@item PUSH
@strcode{"h/h"} (push ports).
@item PULL
@strcode{"l/l"} (pull ports).
@item PUSH_TO_PULL
@strcode{"h/l"} (push input ports, pull output ports).
@item PULL_TO_PUSH
@strcode{"l/h"} (pull input ports, push output ports).
@end table

The default implementation for @code{Element::processing} returns
@code{AGNOSTIC}.

The @code{processing} method should be declared on a single line in the
element's class definition. It should return a C string constant or one
of the five mnemonic names above. These guidelines make the element's
processing code easy to automatically extract from the source code. 

Here is a typical @code{processing} method.

@example
class ARPQuerier : public Element @{ public: // ...
  const char *processing() const @{ return PUSH; @}
@}
@end example


@node flow_code, initialize, processing, Element Initialization
@section @code{flow_code}---Packet Flow Within an Element

Connections determine how packets flow between elements in a router
configuration. Packets flow @emph{within} elements as well: packets
arriving on an element's input port will then be emitted on zero or more
output ports, possibly after some modification. The user supplies
connection information explicitly, but information about packet flow
within an element is provided by the element itself, via its
@code{flow_code} method. This method returns a @dfn{flow code}: an ASCII
string that, properly interpreted, defines how packets may travel within
the element.

@deftypemethod Element {virtual const char *} flow_code () const
Returns the element's flow code as a null-terminated C string.
@end deftypemethod

Flow codes look like @samp{@var{inputspec}/@var{outputspec}}, where each
of @var{inputspec} and @var{outputspec} is a sequence of @dfn{port
codes}. The simplest port code is a single letter. Packets can travel
from an input port to an output port if and only if the port codes
match. (Case is significant.) For example, the flow code @strcode{"x/x"}
says that packets can travel from the element's input port to its output
port, while @strcode{"x/y"} says that packets never travel between ports.

A port code may also be a sequence of letters in brackets, such as
@samp{[abz]}. Two port codes match iff they have at least one letter in
common, so @samp{[abz]} matches @samp{a}, but @samp{[abz]} and
@samp{[cde]} do not match. The opening bracket may be followed by a
caret @samp{^}; this makes the port code match letters @emph{not}
mentioned between the brackets. Thus, the port code @samp{[^abc]} is
equivalent to @samp{[ABC...XYZdef...xyz]}.

Finally, the @samp{#} character is also a valid port code, and may be
used within brackets. One @samp{#} matches another @samp{#} only when
they represent the same port number---for example, when one @samp{#}
corresponds to input port 2 and the other to output port 2. @samp{#}
never matches any letter. Thus, the flow code @strcode{"##/##"} behaves
like @strcode{"xy/xy"}.

@var{Inputspec} and @var{outputspec} need not have the correct numbers
of port codes. The last code in each specification is duplicated as many
times as necessary, and any extra codes are ignored. Thus, the flow
codes @strcode{"[x#][x#][x#][x#]/x######"} and @strcode{"[x#]/x#"} behave
identically.

This table describes some simple flow codes.

@table @code
@item "x/x"
Packets may travel from any input port to any output port. Most elements
use this flow code.

@item "xy/x"
Packets arriving on input port 0 may travel to any output port, but
those arriving on other input ports will not be emitted on any output.
@click{ARPQuerier} uses this flow code, for example.

@item "x/y"
Packets never travel between input and output ports. @click{Idle} and
@click{Error} use this flow code. So does @click{KernelTap}, since its
input port and output port are decoupled (packets received on its input
are sent to the kernel; packets received from the kernel are sent to its
output).

@item "#/#"
Packets arriving on input port @var{K} may travel only to output port
@var{K}. @click{Suppressor} uses this flow code.

@item "#/[^#]"
Packets arriving on input port @var{K} may travel to any output port
except @var{K}. @click{EtherSwitch} uses this flow code.
@end table

The @code{Element} class provides a mnemonic name for a common flow
code:

@table @code
@item COMPLETE_FLOW
@strcode{"x/x"} (packets travel from any input to all outputs).
@end table

The default implementation for @code{Element::processing} returns
@code{COMPLETE_FLOW}.

The @code{flow_code} method should be declared on a single line in the
element's class definition. It should return a C string constant or
@code{COMPLETE_FLOW}. These guidelines make the element's flow code easy
to automatically extract from the source code. 

Here is a typical @code{flow_code} method.

@example
class ARPQuerier : public Element @{ public: // ...
  const char *flow_code() const @{ return "xy/x"; @}
@}
@end example

@noindent
Most elements do not declare a @code{flow_code} method, relying on the
default implementation instead.

Click uses flow code information in its agnostic port assignment
algorithm and its algorithms for finding upstream and downstream
elements.

@subsection What Is a Flow Code?

Flow codes conveniently encode a more primitive concept, @dfn{flow
matrices}. An element's flow matrix, @math{M}, is a Boolean matrix with
@code{ninputs} rows and @code{noutputs} columns. The matrix element
@math{m[i,j]} is true if and only if packets can ``travel'' from input
port @math{i} to output port @math{j}. Note that this is independent of
the element's processing code; it holds for push, pull, and agnostic
ports.

But what does it mean for a packet to ``travel'' from one port to
another? This principle will help you pick the right flow code for an
element: Consider how an element's flow matrix would affect a simple
router.

Take an input port, @math{i}, and output port, @math{j}, on some element
@click{M}. To decide whether @math{m[i,j]} should be true, imagine this
simple configuration (or a similar configuration):

@example
... -> RED -> [@math{i}] M [@math{j}] -> Queue -> ...;
@end example

@noindent
Now, should the @click{RED} element include the @click{Queue} element in
its queue length calculation? The @math{m[i,j]} element should be true
if and only if the answer is yes.

For example, consider @click{ARPQuerier}'s second input port, which
receives ARP responses. @click{ARPQuerier} may, on receiving an ARP
response, emit a held-over IP packet on its first output. However, a
@click{RED} element upstream of that second input port would probably
not include the downstream @click{Queue} in its queue length
configuration. After all, the ARP responses are effectively dropped;
packets emitted onto the @click{Queue} originally came from
@click{ARPQuerier}'s first input port. Therefore, @math{m[1,0]} is
false, and @click{ARPQuerier}'s flow code specifies that packets
arriving on the second input port are not emitted on any output port.

The @click{ARPResponder} element provides a contrasting example. It has
one input port, which receives ARP queries, and one output port, which
emits the corresponding ARP responses. A @click{RED} element upstream of
@click{ARPResponder} would probably want to include a downstream
@click{Queue}, since queries received by @click{ARPResponder} are
effectively transmuted into emitted responses. Thus, @math{m[0,0]} is
true, even though the packets @click{ARPResponder} emits are completely
different from the packets it receives.

If you find this confusing, don't fret. It is perfectly fine to be
conservative when assigning flow codes. About 96% of the Click
distribution's elements use @code{COMPLETE_FLOW}.


@node initialize, uninitialize, flow_code, Element Initialization
@section @code{initialize}---Element Initialization

The @code{initialize} method is called just before the router is placed
on line. It performs any final initialization, and provides the last
chance to abort router installation with an error.

@deftypemethod Element {virtual int} initialize (ErrorHandler *@var{errh})
Any errors, warnings, or messages should be reported to @var{errh}.
Messages should not specify the element name; this information will be
supplied externally.

This method should return zero if initialization succeeds, or a negative
number if it fails. Returning a negative number prevents the router from
initializing.

The default @code{initialize} method simply returns zero.
@end deftypemethod

An element's @code{initialize} method may check whether its input or
output ports are push or pull, or query the router for information about
its neighbors. It may not create or destroy input or output ports.

If every element's @code{initialize} method succeeds, then the router is
installed, and will remain installed until another router replaces it.
Any errors that occur later than @code{initialize}---during a
@code{push} or @code{pull} method, perhaps---will not take the router
off line.

Common tasks performed in @code{initialize} methods include:

@itemize @bullet
@item
Initializing @code{Task}s (@pxref{Task Initialization}).

@item
Allocating memory.

@item
Opening files.
@end itemize


@node uninitialize, add_handlers, initialize, Element Initialization
@section @code{uninitialize}---Removing Initialization State

The @code{uninitialize} method should undo any effects of
initialization---for example, it should close any open files, free up
memory, and unhook from network devices. Every element's
@code{uninitialize} method is called when a successfully initialized
router is taken off line. @code{uninitialize} is also called on certain
elements in an aborted router, namely those that did successfully
initialize.

@deftypemethod Element {virtual void} uninitialize ()
This method takes no arguments and returns no results. It should never
report errors to any source.

The default @code{uninitialize} method does nothing.
@end deftypemethod

An element's @code{uninitialize} method will be called by Click if and
only if its @code{initialize} method succeeded (returned zero).
Furthermore, it will be called by Click exactly once. However, it often
makes sense to write @code{uninitialize} so that it may be called from
other places---from the element's destructor, for example, or from
a partially completed @code{initialize}.

@code{uninitialize} serves some of the same functions as an element's
destructor and, in the normal case, it is called immediately before the
element is destroyed. However, @code{uninitialize} may be called long
before destruction. Elements that are part of an erroneous router are
uninitialized, but kept around for debugging purposes until another
router is installed.


@node add_handlers, Initialization Phases, uninitialize, Element Initialization
@section @code{add_handlers}---Adding Handlers

If a router configuration successfully initializes, the driver will call
every element's @code{add_handlers} method. This method should create
any handlers the element provides. @xref{Handlers}, for more information
on handlers.

@deftypemethod Element {virtual void} add_handlers ()
This method takes no arguments and returns no results. It is called
after the router has successfully initialized, and is expected to create
the element's class-specific handlers. Most @code{add_handlers} methods
simply call @code{add_read_handler} and @code{add_write_handler} one or
more times (@pxref{add_read_handler add_write_handler}), and possibly
@code{add_task_handlers} (@pxref{Task Handlers}). The
@code{add_handlers} method should not change the element's state.

The default implementation does nothing.
@end deftypemethod

@anchor{add_default_handlers} The driver will also call every element's
@code{add_default_handlers} method. This nonvirtual method adds the
default handlers that every element shares: @handler{class},
@handler{name}, @handler{config}, @handler{ports}, and
@handler{handlers}.

@deftypemethod Element {void} add_default_handlers (bool @var{config_writable})
Adds the default collection of handlers for the element. Most of these
handlers are read-only. The @handler{config} handler may be read/write,
but only if @var{config_writable} is true and the
@code{can_live_reconfigure} method also returns true
(@pxref{can_live_reconfigure}).
@end deftypemethod

The default handlers are as follows:

@table @handler
@item class
Returns the element's class name, as returned by @code{class_name()},
followed by a newline. Example result: @strcode{"ARPQuerier\n"}.

@item name
Returns the element's name, as returned by @code{id()}, followed by a
newline. Example result: @strcode{"arpq_0\n"}.

@item config
Returns the element's configuration string. If the configuration string
does not end in @samp{\} or newline, the hander appends a newline
itself. Example result: @strcode{"18.26.7.1, 00:00:C0:4F:71:EF\n"}.

If @code{can_live_reconfigure} returns true, @handler{config} is also a
write handler. Writing to it reconfigures the element.
@xref{Live Reconfiguration}.

@item ports
Returns a multi-line string describing the element's ports and what they
are connected to. The string has the form

@example
@var{M} input[s]
@r{@dots{} @var{M} input port descriptions, one per line @dots{}}
@var{N} output[s]
@r{@dots{} @var{N} output port descriptions, one per line @dots{}}
@end example

@noindent
Each port description lists the port's processing type, a dash, and then
a comma-separated list of all the ports to which this port is connected.
The processing type is either @samp{push} or @samp{pull}; formerly
agnostic ports are indicated by a trailing hyphen (@samp{push-} or
@samp{pull-}). Example result:

@example
1 input
push-   -       Strip@@2 [0]
2 outputs
push-   -       [0] GetIPAddress@@4
push    -       [0] Print@@7
@end example

@noindent
If Click was compiled with statistics collection enabled, the dash on
each line is replaced by a packet count.

@item handlers
Returns a string listing the element's handlers, one per line. Each line
contains the handler name, a tab, and then either @samp{r}, @samp{w}, or
@samp{rw}, depending on whether the handler is read-only, write-only, or
read/write. Example result for an @click{InfiniteSource} element, which
has many handlers:

@example
scheduled       r
tickets r
reset   w
count   r
active  rw
burstsize       rw
limit   rw
data    rw
handlers        r
ports   r
config  rw
name    r
class   r
@end example
@end table


@node Initialization Phases,  , add_handlers, Element Initialization
@section Initialization Phases

@enumerate
@item
Determines how many ports are used on each element and calls their
@code{notify_ninputs} and @code{notify_noutputs} methods.

@item
Calls each element's @code{configure_phase} method, and uses the
result to construct a configuration order.

@item
Calls each element's @code{configure} method, passing in the relevant
configuration string. The elements are configured according to the
configuration order.

@item
Checks that each connection connects a valid input port to a valid
output port. This catches errors where a connection uses a port that
does not exist.

@item
Calls each element's @code{processing} method to determine whether its
ports are push, pull, or agnostic.

@item
For each element with agnostic ports, calls the corresponding
@code{flow_code} method to determine constraints linking agnostic input
ports to agnostic output ports.

@item
Runs the constraint-satisfaction algorithm that determines whether each
agnostic port is push or pull. This catches errors where a single
agnostic port is used as both push and pull.

@item
Checks that every connection is between two push ports or two pull
ports.

@item
Checks that push output ports and pull input ports are connected exactly
once.

@item
Checks that no input or output port goes unused.

@item
If there have been no errors up to this point, then calls each element's
@code{initialize} method. The elements are initialized according to the
configuration order. No @code{initialize} methods are called if there
were any errors in any previous phase.

@item
If there were no errors, then router initialization has succeeded.

@enumerate a
@item
Calls every element's @code{add_handlers} method.

@item
Calls every element's @code{add_default_handlers} method. The
@handler{config} handler may be read-write.

@item
Places the router on line.
@end enumerate

@item
If there were errors, then router initialization has failed.

@enumerate a
@item
Calls the @code{uninitialize} method on each element whose
@code{initialize} method returned successfully.

@item
Some drivers, such as the Linux kernel driver, call every element's
@code{add_default_handlers} method to make information about the
erroneous configuration available for debugging. The @handler{config}
handler is always read-only.
@end enumerate
@end enumerate


@node Element Runtime, Configuration Strings, Element Initialization, Top
@chapter Element Runtime

@menu
* Moving Packets::              
* Handling Packets::            
* Running Tasks::               
* Handlers::                    
* Live Reconfiguration::        
@end menu


@node Moving Packets, Handling Packets, Element Runtime, Element Runtime
@section Moving Packets

Two virtual functions on @code{Element}, @code{push} and @code{pull},
provide Click's means are the main methods for packet transfer.

@menu
* push::                        
* pull::                        
* Transferring Packets::        
* simple_action::               
@end menu

@node push, pull, Moving Packets, Moving Packets
@subsection @code{push}

@deftypemethod Element {virtual void} push (int @var{port}, Packet *@var{p})
Called when an upstream element pushes the packet @var{p} onto this
element's input port @var{port}. This element is expected to process the
packet however it likes.
@end deftypemethod

@node pull, Transferring Packets, push, Moving Packets
@subsection @code{pull}

@deftypemethod Element {virtual Packet *} pull (int @var{port})
Called when a downstream element makes a pull request of this element's
output port @var{port}. This element is expected to process the request
however it likes and to return a packet.
@end deftypemethod

@node Transferring Packets, simple_action, pull, Moving Packets
@subsection Transferring Packets

@deftypemethod {Element::Port} void push (Packet *@var{p}) const
@end deftypemethod

@deftypemethod {Element::Port} {Packet *} pull () const
@end deftypemethod

@node simple_action,  , Transferring Packets, Moving Packets
@subsection @code{simple_action}

@deftypemethod Element {Packet *} simple_action (Packet *@var{p})
@end deftypemethod

@node Handling Packets, Running Tasks, Moving Packets, Element Runtime
@section Handling Packets

Every @code{Packet} object should be single-threaded through Click: the
same @code{Packet} pointer should never be in use in two different
places. In particular, an element should not use a @code{Packet} after
passing it downstream to the rest of the configuration (by calling
@code{output().push}, for example).

This, for example, is the wrong way to write a @click{Tee} with two
outputs.

@example
void
BadTee::push(int, Packet *p)
@{
  output(0).push(p);
  output(1).push(p);
@}
@end example

@noindent
The same packet pointer, @code{p}, has been pushed to two different
outputs. This is always illegal; the rest of the configuration may have
modified or even freed the packet before returning control to
@code{BadTee}. The correct definition uses the @code{clone} method:

@example
void
GoodTee::push(int, Packet *p)
@{
  output(0).push(p->clone());
  output(1).push(p);
@}
@end example

Every @code{push} or @code{pull} method must account for every packet it
receives by freeing it, emitting it on some output, or perhaps
explicitly storing it for later. This @code{push} method, for example,
contains a memory leak:

@example
void
Leaky::push(int, Packet *p)
@{
  const click_ip *iph = p->ip_header();
  // @r{@dots{} more processing @dots{}}
  _counter++;
  return;  // XXX @r{Oops!}
  // @r{Must push the packet on, store it, or kill it before returning.}
@}
@end example


@node Running Tasks, Handlers, Handling Packets, Element Runtime
@section Running Tasks


@node Handlers, Live Reconfiguration, Running Tasks, Element Runtime
@section Handlers

Click users interact with a running router through @dfn{handlers}.

@menu
* add_read_handler add_write_handler::  
@end menu


@node add_read_handler add_write_handler,  , Handlers, Handlers
@subsection Adding Handlers

@node Live Reconfiguration,  , Handlers, Element Runtime
@section Live Reconfiguration

@menu
* can_live_reconfigure::        
@end menu

@node can_live_reconfigure,  , Live Reconfiguration, Live Reconfiguration
@subsection can_live_reconfigure


@node Configuration Strings, Tasks, Element Runtime, Top
@chapter Configuration Strings

@menu
* Configuration String Structure::  
@end menu

@node Configuration String Structure,  , Configuration Strings, Configuration Strings
@section Structure

Configuration strings consist of a list of comma-separated
@dfn{arguments}. For example, this configuration string has three
arguments, @samp{a}, @samp{b}, and @samp{c}:

@example
a,    b          , c
@end example

@noindent
Leading and trailing spaces are trimmed from each argument.

Configuration strings can contain two kinds of @dfn{comments} and three
kinds of @dfn{quoted strings}. Comments let you document a configuration
string; they behave like spaces. With quoted strings, you can protect
special characters like spaces, commas, and comment-starting sequences
from interpretation.

@table @asis
@item @samp{//} comments
Begins with two adjacent slashes, @samp{//}, and continues up to and
including the next end-of-line (@samp{\n}, @samp{\r}, or @samp{\r\n}).
Comment starters (@samp{//} and @samp{/*}) and the quote sequences
(@samp{'}, @samp{"}, and @samp{\<}) have no special meaning inside
@samp{//} comments.

@item @samp{/* @dots{} */} comments
Begins with slash-star, @samp{/*}, and continues up to and including the
next star-slash, @samp{*/}. Comment starters (@samp{/*} and @samp{//})
and the quote sequences (@samp{'}, @samp{"}, and @samp{\<}) have no
special meaning inside @samp{/*} comments.
@end table

@table @asis
@item Single-quoted strings @samp{' @dots{} '}
Begins with a single-quote character @samp{'} and continues up to the
next single quote. Comments, double quotes, and backslashes have no
special meaning inside single quotes. There is no way to include a
single quote in a single-quoted string.

@item Double-quoted strings @samp{" @dots{} "}
Begins with a double-quote character @samp{"} and continues up to the
next unescaped double quote. Backslash @samp{\} acts as an escape
character inside double quotes, as in C. Click's escape sequences are
described below. Comments and single quotes have no special meaning
inside double quotes. @samp{\<} retains its usual meaning, however.

@item Hex strings @samp{\< @dots{} >}
The @samp{\<} sequence begins a string of hexadecimal digits terminated
by @samp{>}. Each pair of digits expands to the corresponding character
value. For example, @samp{\<48454c4c4F>} expands to @samp{HELLO}. Spaces
and comments (either @samp{//} or @samp{/*} style) may be arbitrarily
interleaved with the hex digits; any @samp{>} characters inside comments
are ignored. Characters other than spaces, hex digits, comments, and
@samp{>} should not appear inside a hex string.

Hex strings may be placed within double-quoted strings.
@end table

@subsubheading Escape Sequences

Most of Click's escape sequences are borrowed from C, and behave the
same way. The @samp{\< @dots{} >} escape sequence is new, however.

@table @asis
@item @samp{\@key{END-OF-LINE}}
A backslash followed by an end-of-line sequence---@samp{\n}, @samp{\r},
or @samp{\r\n}---is removed from the string. This string

@example
"a\
b"
@end example

@noindent
is equivalent to @strcode{"ab"}.

@item @samp{\a}, @samp{\b}, @samp{\t}, @samp{\n}, @samp{\v}, @samp{\f}, @samp{\r}
These escape sequences produce the characters with decimal ASCII values
7, 8, 9, 10, 11, 12, and 13, respectively.

@item @samp{\\}, @samp{\"}, @samp{\'}, @samp{\$}
These escape sequences expand to a literal backslash, double quote,
single quote, and dollar sign, respectively.

@item @samp{\@key{1 TO 3 OCTAL DIGITS}}
A backslash followed by 1 to 3 octal digits (@samp{0} @dots{} @samp{7})
expands to the character with that octal value. For example, @samp{\046}
expands to @samp{&}.

@item @samp{\x@key{HEX DIGITS}}
@samp{\x} followed by an arbitrary number of hexadecimal digits expands
to the single character whose value equals the lower 8 bits of that
number. Thus, @samp{\x45} and @samp{\x94839E89DB00ACF45} both expand to
@samp{E}.

@item @samp{\< @key{HEX DIGITS} >}
@samp{\<} introduces a hex string, as described above.
@end table

Any other escape sequence @samp{\@key{CHAR}} is an error. Currently,
such sequences expand to @samp{@key{CHAR}}, but their semantics may
eventually change.


@node Quoting
@section Quoting and Unquoting

These functions interpret quote sequences and comments in configuration
strings. @code{cp_unquote} expands quote sequences and removes comments.
@code{cp_quote} protects special characters, such as spaces and commas,
within double quotes. Finally, @code{cp_uncomment} removes comments and
leading and trailing spaces, but does not expand quote sequences.

@deftypefun String cp_unquote (@w{const String &@var{text}})
Processes @var{text} by replacing every quoted string by its expansion
and every comment by a single space, and returns the result.
@end deftypefun

@deftypefun String cp_quote (@w{const String &@var{text}}, @w{bool @var{allow_newlines} = false})
Returns a quoted version of @var{text}. Any spaces, commas, comments,
quote sequences, and non-ASCII characters in @var{text} are protected
within double quotes. If @var{allow_newlines} is true, then the result
may contain newline characters (within double quotes); otherwise, any
newline characters in @var{text} are replaced by @samp{\n} sequences.
The returned result is never empty (unless Click has run out of memory).
If @var{text} is the empty string, @code{cp_quote} will return @samp{""}
(a string containing two double quotes).
@end deftypefun

@deftypefun String cp_uncomment (@w{const String &@var{text}})
Replaces any comments in @var{text} by single spaces, then removes any
leading and trailing space and returns the result.
@end deftypefun

For example:

@display
@t{cp_uncomment(}@samp{  /* blah */ "quote"/*xx*/\<2 c>}@t{)} @result{} @samp{"quote" \<2 c>}
@t{cp_unquote(}@samp{  /* blah */ "quote"/*xx*/\<2 c>}@t{)} @result{} @samp{    quote ,}
@t{cp_quote(}@samp{quote ,}@t{)} @result{} @samp{"quote ,"}
@end display

@node Tasks, Timers, Configuration Strings, Top
@chapter Tasks

Click schedules a router's CPU or CPUs with one or more @dfn{task
queues}. These queues are simply lists of @dfn{tasks}, which represent
functions that would like access to the CPU. Tasks are generally
associated with elements. When scheduled, most tasks call some element's
@code{run_scheduled} method.

Click tasks are represented by @code{Task} objects. An element that
would like special access to a router's CPU should include and
initialize a @code{Task} instance variable.

The @code{Task} class is defined in the @code{<click/task.hh>} header
file.

@menu
* Task Initialization::         
* Scheduling a Task::           
* Tickets::                     
* Task Thread Choice::          
* Task Status::                 
* Task Handlers::               
* Destroying a Task::           
@end menu


@node Task Initialization, Scheduling a Task, Tasks, Tasks
@section Task Initialization

Task initialization is a two-step process. First, when a @code{Task}
object is constructed, you must supply information about the function
that it should call when it is scheduled. Second, when the router is
initialized, you must schedule the task on the router's task queue.

@code{Task} has two constructors. One of them asks the task to call an
element's @code{run_scheduled} method when scheduled; the other asks it
to call an arbitrary function pointer.

@deftypemethod Task {} Task (Element *@var{e})
When this task is scheduled, call @code{@var{e}->run_scheduled()}.
@end deftypemethod

@deftypemethod Task {} Task (TaskHook @var{hook}, void *@var{thunk})
When this task is scheduled, call @code{@var{hook}(this, @var{thunk})}.
The @var{hook} argument is a function pointer with type @code{void
(*)(Task *, void *)}.
@end deftypemethod

Later, when the router is initialized, each task must be attached to the
router via the @code{Task::initialize} method. This places the task on a
router-wide list of @code{Task}s, associates the task with a particular
task queue, and, optionally, schedules it. Typically, an element's
@code{initialize} method calls @code{Task::initialize}
(@pxref{initialize}).

@deftypemethod Task void initialize (Router *@var{r}, bool @var{scheduled})
@deftypemethodx Task void initialize (Element *@var{e}, bool @var{scheduled})
Attaches the task to the router object @var{r} (or
@code{@var{e}->router()}). Additionally schedules the task if
@var{scheduled} is true.
@end deftypemethod

Many elements call @code{ScheduleInfo::join_scheduler} instead of
calling @code{Task::initialize} directly. This method queries any
@click{ScheduleInfo} elements in the configuration to determine the
task's scheduling parameters, then calls @code{Task::initialize} to
schedule the task. The @code{ScheduleInfo::join_scheduler} method is
defined in the @code{"elements/standard/scheduleinfo.hh"} header file.

@deftypeop {Static method} ScheduleInfo void join_scheduler (Element *@var{e}, Task *@var{task}, ErrorHandler *@var{errh})
Sets @var{task}'s scheduling parameters as specified by any
@click{ScheduleInfo} elements in the router configuration. The element
@var{e} is used to find the correct router, and provides the relevant
name for parameter lookup---the user supplies parameters to
@click{ScheduleInfo} by element name. Also schedules @var{task} on
@code{@var{e}->router()}'s task queue. Reports any errors to @var{errh}.
@end deftypeop

The @code{join_scheduler} method is generally called like this:

@example
int
SomeElement::initialize(ErrorHandler *errh)
@{
  ScheduleInfo::join_scheduler(this, &_task, errh);
@}
@end example

@noindent
Here, @code{_task}, a @code{Task} object, is one of @code{SomeElement}'s
instance variables.


@node Scheduling a Task, Tickets, Task Initialization, Tasks
@section Scheduling a Task

The user may take a task off its task queue with the @code{unschedule}
method, and place it back onto its task queue with the @code{reschedule}
method. As tasks move to the head of the task queue, they are
unscheduled and their callbacks are called. Within these callback
functions, the user will typically call @code{fast_reschedule}, which is
like @code{reschedule} without the locking overhead.

@deftypemethod Task void unschedule ()
Unschedules the task by removing it from its task queue. If the task is
already unscheduled, then this method does nothing.
@end deftypemethod

@deftypemethod Task void reschedule ()
Reschedules the task by placing it on its task queue. If the task is
already scheduled, then this method does nothing.
@end deftypemethod

Both @code{unschedule} and @code{reschedule} lock the task queue before
manipulating it. This avoids corruption when there are multiple
processors executing simultaneously. If these functions cannot lock a
task queue---perhaps because it is being used on another
processor---then they register a task request, which will be executed in
the near future. This implies that a task may remain scheduled for some
time after @code{unschedule} has been called, for example.

The @code{fast_reschedule} method avoids locking overhead in the common
case that a task must be rescheduled from within its callback.

@deftypemethod Task void fast_reschedule ()
Reschedules the task by placing it on its preferred task queue. This
method avoids locking overhead, so it is faster than @code{reschedule}.

@quotation
@strong{Caution}: You may call a @code{Task}'s @code{fast_reschedule}
method only from within its callback function. For instance, if an
element has a task, @w{@code{_task}}, that calls the element's
@code{run_scheduled} method when scheduled, and if @code{run_scheduled}
is called only by that task's callback, then that element's
@code{run_scheduled} method should call @code{_task.fast_reschedule()}
instead of @code{_task.reschedule()}.
@end quotation
@end deftypemethod


@node Tickets, Task Thread Choice, Scheduling a Task, Tasks
@section Tickets

Click tasks are scheduled using the flexible, lightweight stride
scheduling algorithm.@footnote{For more information, see MIT Laboratory
for Computer Science Technical Memo MIT/LCS/TM-528, @cite{Stride
scheduling: deterministic proportional-share resource management}, by
Carl A. Waldspurger and William E. Weihl, June 1995.} This algorithm
assigns each task a parameter called its @dfn{tickets}. A task with
twice as many tickets as usual is scheduled twice as frequently.

@code{Task}s have methods for querying, setting, and adjusting their
tickets.

@deftypemethod Task int tickets () const
Returns this task's tickets. This number will be at least 1 and no more
than @code{Task::MAX_TICKETS}, which equals 32768.
@end deftypemethod

@deftypemethod Task void set_tickets (int @var{t})
Sets this task's tickets to @var{t}. The @var{t} parameter should lie
between 1 and @code{Task::MAX_TICKETS}, inclusive; numbers outside this
range are constrained to the nearest valid value.
@end deftypemethod

@deftypemethod Task void adj_tickets (int @var{delta})
Equivalent to @code{set_tickets(tickets() + @var{delta})}.
@end deftypemethod


@node Task Thread Choice, Task Status, Tickets, Tasks
@section Choosing a Thread

Each task belongs to some task queue, which generally corresponds to a
thread of control. Single-threaded Click has one active thread, and
therefore one task queue, but multithreaded Click can have an arbitrary
number of threads. Every task starts out belonging to the first thread,
@w{thread 0}. The @code{change_thread} method moves a task to another
thread.

@deftypemethod Task void change_thread (int @var{thread_id})
Move this task to thread @var{thread_id}, which should be a number
between @math{-1} and the relevant @code{Router}'s @code{nthreads()}.

The task is scheduled on the new task queue if and only if it was
scheduled on the old task queue.
@end deftypemethod

Like @code{unschedule} and @code{reschedule}, @code{change_thread} must
lock the task queue before manipulating it. (Unlike those methods,
@code{change_thread} must lock two task queues, the old and the new.) If
@code{change_thread} cannot lock a task queue, then it registers a task
request that will be executed in the near future. This implies that a
task may remain on the same thread, or become unscheduled, for some time
after @code{change_thread} is called.


@node Task Status, Task Handlers, Task Thread Choice, Tasks
@section Task Status Methods

These methods let a user check various properties of a task---for
instance, whether it is initialized or scheduled.

@deftypemethod Task bool initialized () const
Returns true iff the task has been initialized---that is, if it is
associated with some router.
@end deftypemethod

@deftypemethod Task bool scheduled () const
Returns true iff the task is currently scheduled on some task queue.
@end deftypemethod

@deftypemethod Task {RouterThread *} scheduled_list () const
Returns the task queue with which this task is associated. Even
unscheduled tasks are associated with some task queue; this is the task
queue on which the task will be placed if @code{reschedule} is called.
@end deftypemethod

@deftypemethod Task TaskHook hook () const
Returns the callback function that is called when the task is scheduled.
If the task is associated with some element, this method returns a null
pointer.
@end deftypemethod

@deftypemethod Task {void *} thunk () const
Returns the extra data passed to the callback function when the task is
scheduled.
@end deftypemethod

@deftypemethod Task {Element *} element () const
If the task is associated with some element, this method returns that
element. Otherwise, returns a null pointer.
@end deftypemethod


@node Task Handlers, Destroying a Task, Task Status, Tasks
@section Task Handlers


@node Destroying a Task,  , Task Handlers, Tasks
@section Destroying a Task


@node Timers, Coding Standards, Tasks, Top
@chapter Timers

Timers



@node Coding Standards, Index, Timers, Top
@chapter Coding Standards


@menu
* Upper and lower case names::
* Common name patterns::
@end menu


@node Upper and lower case names, Common name patterns, Coding Standards, Coding Standards
@section Upper and Lower Case in Names

Keep to the following consistent scheme for choosing between upper and
lower case when naming variables, types, and functions.

@table @strong
@item Classes
Use mixed case with an initial capital letter and no underscores:
@code{LookupIPRoute}.

@item Methods
Use all lower case with underscores separating words:
@code{negation_is_simple}.

@item Constants
Use all upper case with underscores separating words:
@code{TYPE_ICMP_TYPE}.

@item Instance variables
Begin with an underscore, then use all lower case with underscores
separating words: @code{_length}.

@item Regular variables
Use all lower case with underscores separating words: @code{i},
@code{the_handler}.

@item Class variables
These variables are declared as @code{static} in the class header. Name
them like regular variables: @code{nelements_allocated}.

@item Functions
Name them like methods: @code{quicksort_hook}.

@item Other types
This includes typedefs and enumerated types. Name them like classes:
@code{CpVaParseCmd}, @code{ConfigurePhase}.
@end table

There are exceptions to these guidelines. In particular:

@itemize @bullet
@item
Instance variables in C structs---that is, classes with few methods
whose instance variables are mostly public---may be named like regular
variables, without a preceding underscore. The same goes for the
components of unions.

@item
Classes that act like simple types, such as @code{u_atomic32_t}, take
names similar to the types they replace (in this case @code{u_int32_t}).
@end itemize


@node Common name patterns,  , Upper and lower case names, Coding Standards
@section Common Name Patterns

@itemize @bullet
@item
Many instance variables have associated @dfn{getter methods} that return
their values, and/or @dfn{setter methods} that change their values. For
an instance variable named @code{_x}, the getter method should be named
@code{x()} and the setter method should be named @code{set_x()}.

@item
A variable or method which counts something is often named
@code{n@var{object}s}---for instance, @code{_nwarnings},
@code{ninputs()}, @code{_npackets}.

@item
Use a bare @samp{0} for a null pointer, except where some ambiguity
might arise (for example, where an incorrect overloading might be
selected).
@end itemize


@node Index,  , Coding Standards, Top
@unnumbered Index

@printindex cp

@bye
