\input texinfo.tex
@setfilename click.info
@settitle Click
@footnotestyle end

@dircategory Click modular router
@direntry
* Click: (click).           The Click modular router programming manual.
@end direntry

@ifnottex
@macro leq
<=
@end macro
@end ifnottex
@ifnotinfo
@macro click {arg}
@emph{\arg\}
@end macro
@end ifnotinfo
@ifinfo
@macro click {arg}
@code{\arg\}
@end macro
@end ifinfo

@macro handler {arg}
`\arg\'
@end macro

@rmacro strcode {arg}
@t{\arg\}
@end rmacro

@macro qsamp {arg}
@r{``}@t{\arg\}@r{''}
@end macro
@tex
% The macro definition above doesn't get space expansion right.
\gdef\qsamp#1{@r{``}@t{#1}@r{''}}
@end tex

@syncodeindex vr cp
@syncodeindex fn cp
@syncodeindex tp cp

@titlepage
@title Programming the Click Modular Router
@author Eddie Kohler
@end titlepage

@contents

@node Top, Overview, (dir), (dir)
@top

@ifinfo
This document describes the Click modular router's programming
interface. Read this if you're interested in writing new elements for
Click. You shouldn't need to read it if you are just building routers
that use existing elements.
@end ifinfo

@menu
* Overview::                    
* Helper Classes::              
* Packets::                     
* Element Characteristics::     
* Element Initialization::      
* Element Runtime::             
* Configuration Strings::       
* Tasks::                       
* Timers::                      
* Notification::                
* Coding Standards::            
* Index::                       Index.

@detailmenu
 --- The Detailed Node Listing ---

Overview

* Packet Transfer::             

Helper Classes

* String::                      
* StringAccum::                 
* Vector::                      
* Bitvector::                   
* HashMap::                     
* BigHashMap::                  
* ErrorHandler::                
* IPAddress::                   
* IP6Address::                  

String

* String Initialization::       
* String Constructors::         
* String Contents::             
* String Characters::           
* Derived Strings::             
* Appending to Strings::        
* String Comparison::           
* String Out-of-Memory::        

StringAccum

* StringAccum Constructors::    
* StringAccum operator<<::      
* Special StringAccum operator<<::  
* StringAccum Manipulation::    
* StringAccum Contents::        
* StringAccum Results::         
* StringAccum Out-of-Memory::   

ErrorHandler

* ErrorHandler Initialization::  
* Reporting Errors::            
* Error Format Strings::        
* Counting Errors::             
* Basic ErrorHandlers::         
* Error Veneers::               
* Writing ErrorHandlers::       

IPAddress

* IPAddress Constructors::      
* IPAddress Data::              
* IPAddress Operations::        
* IPAddress Unparsing::         

Packets

* Packet Structure and Contents::  
* Packet Creation::             
* Packets and sk_buffs::        
* Packet Sharing::              
* Packet Buffer Manipulation::  
* Annotations::                 
* Packet Out-of-Memory::        

Annotations

* Header Annotations::          
* User Annotations::            
* Specific User Annotations::   
* Other Annotations::           
* Annotations In General::      

Other Annotations

* Destination Address Annotation::  
* Timestamp Annotation::        
* Device Annotation::           
* Packet Type Annotation::      
* Performance Counter Annotation::  

Element Characteristics

* Element Class::               
* Element Casting::             
* Element Names::               
* Element Router::              
* Creating Element Ports::      
* Using Element Ports::         
* When to Call Element Methods::  

Element Initialization

* notify_ninputs notify_noutputs::  
* configure_phase::             
* configure::                   
* processing::                  
* flow_code::                   
* add_handlers::                
* initialize::                  
* uninitialize::                
* Initialization Phases::       

Element Runtime

* Moving Packets::              
* Handling Packets::            
* Running Tasks::               
* Handlers::                    
* Live Reconfiguration::        

Moving Packets

* push::                        
* pull::                        
* Transferring Packets::        
* simple_action::               

Handlers

* Read and Write Handler Overview::  
* Adding Handlers::             
* Default Handlers::            
* Accessing Handlers Internally::  
* LLRPC Overview::              

Accessing Handlers Internally

* Handler Objects::             
* Handler Indexes::             
* Locating Handlers::           

Live Reconfiguration

* can_live_reconfigure::        

Configuration Strings

* Config String Structure::     
* Quoting and Unquoting::       
* Config String Splitting::     
* Parsing Functions::           
* cp_va::                       

Parsing Functions

* Parsing Strings::             
* Parsing Booleans::            
* Parsing Integers::            
* Parsing Reals::               
* Parsing IP Addresses::        
* Parsing IPv6 Addresses::      
* Parsing Ethernet Addresses::  
* Parsing Elements::            
* Parsing Handlers::            
* Parsing Miscellaneous::       

Parsing Argument Lists

* cp_va Concepts::              
* cp_va Initialization::        

Tasks

* Task Initialization::         
* Scheduling Tasks::            
* Tickets::                     
* Task Thread Choice::          
* Task Status::                 
* Task Handlers::               
* Task Cleanup::                

Timers

* Timer Initialization::        
* Scheduling Timers::           
* Timer Status Methods::        
* Timer Cleanup::               

Coding Standards

* Upper and lower case names::  
* Common name patterns::        

@end detailmenu
@end menu

@node Overview, Helper Classes, Top, Top
@chapter Overview

@menu
* Packet Transfer::             
@end menu

@node Packet Transfer,  , Overview, Overview
@section Packet Transfer



@node Helper Classes, Packets, Overview, Top
@chapter Helper Classes

@menu
* String::                      
* StringAccum::                 
* Vector::                      
* Bitvector::                   
* HashMap::                     
* BigHashMap::                  
* ErrorHandler::                
* IPAddress::                   
* IP6Address::                  
@end menu


@node String, StringAccum, Helper Classes, Helper Classes
@section String

The @code{String} class represents a string of characters.
@code{String}s may be constructed from C strings, characters, numbers,
and so forth. They may also be added together. The underlying character
arrays are dynamically allocated; operations on @code{String}s allocate
and free memory as needed. A @code{String} and its substrings will
generally share memory. @code{String}s may be assigned, stored, and
passed to functions.

@menu
* String Initialization::       
* String Constructors::         
* String Contents::             
* String Characters::           
* Derived Strings::             
* Appending to Strings::        
* String Comparison::           
* String Out-of-Memory::        
@end menu

@node String Initialization, String Constructors, String, String
@subsection Class Initialization

The @code{String} class maintains some global state that must be
explicitly initialized with the @code{static_initialize} static method.
You can explicitly clean up this state with @code{static_cleanup}, if
you'd like. String also provides a helper class,
@code{String::Initializer}, that initializes @code{String}'s global
state in its constructor.

@deftypeop {Static Method} String {void} static_initialize ()
Call this function exactly once, at the beginning of the program, before
any Strings are created or other String functions called.
@end deftypeop

@deftypeop {Static Method} String {void} static_cleanup ()
Call this function exactly once, just before the program exits, to clean
up String-related memory. It is an error to call any @code{String}
method, except for @code{String} destructors, after calling
@code{static_cleanup}.
@end deftypeop

@deftp {Class} {String::Initializer}
Declare a @code{String::Initializer} object in any source file that
contains a global string object. The constructor for the
@code{String::Initializer} will call @code{String::static_initialize} if
necessary. For example, this source file is in error, since it declares
a global string without a corresponding @code{Initializer}:

@example
#include <click/string.hh>
String foo = "bar";
int main(int, char **) @{ /* ... */ @}
@end example

To fix it, declare a @code{String::Initializer} before the
global string.

@example
#include <click/string.hh>
String::Initializer string_initializer;
String foo = "bar";
int main(int, char **) @{ /* ... */ @}
@end example
@end deftp

@node String Constructors, String Contents, String Initialization, String
@subsection Constructors

@deftypeop Constructor String {} String ()
Creates a string with no characters.
@end deftypeop

@deftypeop Constructor String {} String @w{(const char *@var{s})}
Creates a string containing a copy of the C string @var{s}.
@end deftypeop

@deftypeop Constructor String {} String @w{(const char *@var{s}}, @w{int @var{len})}
Creates a string containing the first @var{len} characters of @var{s}.
If @var{len} is negative, then this function treats @var{s} as a C
string, effectively setting @var{len} to @code{strlen(@var{s})}.
@end deftypeop

@deftypeop Constructor String {} String (char @var{c})
@deftypeopx Constructor String {} String (unsigned char @var{c})
Creates a string containing the single character @var{c}.
@end deftypeop

@deftypeop Constructor String {} String (int @var{n})
@deftypeopx Constructor String {} String (unsigned @var{n})
@deftypeopx Constructor String {} String (long @var{n})
@deftypeopx Constructor String {} String (unsigned long @var{n})
@deftypeopx Constructor String {} String (long long @var{n})
@deftypeopx Constructor String {} String (unsigned long long @var{n})
@deftypeopx Constructor String {} String (double @var{n})
Creates a string containing an ASCII decimal representation of the number
@var{n}. For example, if @var{n} is 20, then @code{String(@var{n})}
equals @code{"20"}. The @code{double} constructor is not available in
the kernel.
@end deftypeop

@deftypeop {Static Method} String {const String &} null_string ()
Returns a const reference to a string with no characters. Useful in
situations where you wish to avoid unnecessary memory operations by
returning string references instead of @code{String}s.
@end deftypeop

@deftypeop {Static Method} String String stable_string @w{(const char *@var{s},} @w{int @var{len})}
Creates and returns a string containing the @var{len} bytes of data
starting at @var{s}. If @var{len} is negative, then this function treats
@var{s} as a C string, effectively setting @var{len} to
@code{strlen(@var{s})}. The caller guarantees that @var{s} is located in
stable, read-only memory and will not be changed while any @code{String}
references to it still exist. For example, @var{s} might be a C string
constant. The @code{String} implementation will not alter or free
@var{s}. Functions such as @code{mutable_data} (see below) will return
copies of @var{s}, not @var{s} itself.
@end deftypeop

@deftypeop {Static Method} String String garbage_string @w{(@w{int @var{len}})}
Creates and returns a string containing @var{len} bytes of garbage data.
@end deftypeop


@node String Contents, String Characters, String Constructors, String
@subsection Contents

@quotation
@strong{Caution}: Any pointer to a string's data should be treated as
temporary, since once the string is destroyed, that memory will be
freed. Remember, however, that a temporary @code{String} object will not
be destroyed until the end of the statement in which it was created.
Therefore, this use of @code{cc()} is safe:

@example
String a, b; // ...
fprintf(stderr, "%s\n", (a + b).cc());
@end example

This use is not safe:

@example
String a, b; // ...
const char *s = (a + b).cc();
fprintf(stderr, "%s\n", s); // probably an error
@end example
@end quotation

@deftypemethod String {const char *} data () const
Returns a pointer to the string's data. This data is not guaranteed to
be null-terminated. Only the first @code{length()} of its characters are
valid.
@end deftypemethod

@deftypemethod String int length () const
Returns the string's length in characters.
@end deftypemethod

@deftypemethod String {} {operator bool} ()
@deftypemethodx String {} {operator bool} () const
Returns true iff the string has at least one character.
@end deftypemethod

@deftypemethod String {char *} mutable_data ()
Returns a mutable pointer to the string's data. If the data is shared
with any other @code{String} object, or was allocated by
@code{stable_string} (see above), then this method will transparently
modify the @code{String} to use a unique copy of the data, and return
that.
@end deftypemethod

@deftypemethod String {const char *} cc ()
@deftypemethodx String {const char *} c_str ()
@deftypemethodx String {} {operator const char *} ()
Returns a pointer to the string's data as a C string. This may
transparently modify the @code{String} by adding a null character after
the string's data, which may involve making a copy of the data. This
null character will not be counted as part of the string's length.
@end deftypemethod

@deftypemethod String {char *} mutable_c_str ()
Returns a mutable pointer to the string's data as a C string.
@end deftypemethod


@node String Characters, Derived Strings, String Contents, String
@subsection Characters and Indices

@deftypemethod String char {operator[]} (int @var{i}) const
Returns the @var{i}th character of the string. @var{i} should be between
0 and @math{@code{length()} - 1}.
@end deftypemethod

@deftypemethod String char back () const
Returns the last character of the string. The string must not be empty.
@end deftypemethod

@deftypemethod String int find_left (int @var{c}, int @var{start} = 0) const
Returns the position of the first occurrence of the character @var{c} in
the string on or after position @var{start}. If @var{c} does not occur
on or after position @var{start}, returns @math{-1}.
@end deftypemethod

@deftypemethod String int find_right (int @var{c}) const
@deftypemethodx String int find_right (int @var{c}, int @var{start}) const
Returns the position of the last occurrence of the character @var{c} in
the string before position @var{start}. If @var{start} is not supplied,
returns the absolute last occurrence of @var{c} in the string. If
@var{c} does not occur before position @var{start}, returns @math{-1}.
@end deftypemethod

@deftypemethod String int find_left (const String &@var{s}, int @var{start} = 0) const
Returns the position of the first occurrence of the substring @var{s} in
the string on or after position @var{start}. If @var{s} does not occur
on or after position @var{start}, returns @math{-1}.
@end deftypemethod


@node Derived Strings, Appending to Strings, String Characters, String
@subsection Derived Strings

@deftypemethod String String substring (int @var{pos}, int @var{len}) const
Returns a new string containing characters @var{pos} through
@math{@var{pos} + @var{len} - 1} of this string.

If @var{pos} is negative, then start @math{-@var{pos}} characters from
the end of the string. If @var{len} is negative, then drop
@math{-@var{len}} characters from the end of the string. @var{len} may
be too large; only characters actually in the string will be returned.
If @var{pos} is too large or too small, the result is a null string.

These examples demonstrate the use of @var{substring}:

@example
String("abcde").substring(2, 2)   == "cd"
String("abcde").substring(-3, 2)  == "cd"
String("abcde").substring(-3, -1) == "cd"
String("abcde").substring(2, 10)  == "cde"
String("abcde").substring(10, 4)  == ""
String("abcde").substring(-10, 4) == ""
@end example
@end deftypemethod

@deftypemethod String String substring (int @var{pos}) const
Same as @code{substring(@var{pos}, length() - @var{pos})}: return a new
string containing all of this string's characters starting at @var{pos}.
@end deftypemethod

@deftypemethod String String lower () const
Return a string equal to this string, but with all alphabetic characters
translated to lower case.
@end deftypemethod

@deftypemethod String String upper () const
Return a string equal to this string, but with all alphabetic characters
translated to upper case.
@end deftypemethod

@deftypemethod String String printable () const
Return a string equal to this string, but with all non-printable
characters replaced by quote sequences. For example, null characters
@samp{@key{NUL}} become @samp{^@@} sequences.
@end deftypemethod


@node Appending to Strings, String Comparison, Derived Strings, String
@subsection Appending to Strings

If you are gradually building up a string by successive appends, you
should probably use @code{StringAccum} instead of these @code{String}
operations (@pxref{StringAccum}).

@deftypemethod String void append (const char *@var{s}, int @var{len})
Appends the first @var{len} characters of @var{s} to the end of this
string. If @var{len} is negative, then this function treats @var{s} as a
C string, effectively setting @var{len} to @code{strlen(@var{s})}.
@end deftypemethod

@deftypemethod String void append_fill (int @var{c}, int @var{len})
Adds @var{len} copies of the character @var{c} to the end of this
string.
@end deftypemethod

@deftypemethod String void append_garbage (int @var{len})
Adds @var{len} arbitrary characters to the end of this string.
@end deftypemethod

@deftypemethod String {String &} {operator+=} (const String &@var{s})
@deftypemethodx String {String &} {operator+=} (const char *@var{s})
@deftypemethodx String {String &} {operator+=} (char @var{c})
Appends the string @var{s} or character @var{c} to this string.
@end deftypemethod

@deftypefun String {operator+} (String @var{s1}, const String &@var{s2})
@deftypefunx String {operator+} (String @var{s1}, const char *@var{s2})
@deftypefunx String {operator+} (const char *@var{s1}, const String &@var{s2})
@deftypefunx String {operator+} (String @var{s1}, char @var{c})
Appends the string @var{s2} or character @var{c} to the string @var{s1},
and returns the resulting string.
@end deftypefun


@node String Comparison, String Out-of-Memory, Appending to Strings, String
@subsection Comparison

@deftypemethod String bool equals (const char *@var{s}, int @var{len}) const
Compares this string to the first @var{len} characters of @var{s}. If
@var{len} is negative, then this function treats @var{s} as a C string,
effectively setting @var{len} to @code{strlen(@var{s})}. Returns true
iff the two strings have the same length and contain the same characters
in the same order.
@end deftypemethod

@deftypefun bool {operator==} (const String &@var{s1}, const String &@var{s2})
@deftypefunx bool {operator==} (const char *@var{s1}, const String &@var{s2})
@deftypefunx bool {operator==} (const String &@var{s1}, const char *@var{s2})
Returns true iff the two strings are equal---that is, returns
@code{@var{s1}.equals(@var{s2}.data(), @var{s2}.length())}.
@end deftypefun

@deftypefun bool {operator!=} (const String &@var{s1}, const String &@var{s2})
@deftypefunx bool {operator!=} (const char *@var{s1}, const String &@var{s2})
@deftypefunx bool {operator!=} (const String &@var{s1}, const char *@var{s2})
Returns true iff the two strings are not equal---that is, returns
@code{!(@var{s1} == @var{s2})}.
@end deftypefun

@deftypefun int hashcode (const String &@var{s})
Returns a number with the property that, for any two equal strings
@var{s1} and @var{s2}, @code{hashcode(@var{s1}) ==
hashcode(@var{s2})}. With this function, @code{String}s may be used as
keys for @code{HashMap}s and @code{BigHashMap}s (@pxref{HashMap}).
@end deftypefun


@node String Out-of-Memory,  , String Comparison, String
@subsection Out-of-Memory Conditions

@code{String} operations are robust against out-of-memory conditions. If
there is not enough memory to create a particular string, the
@code{String} implementation returns a special ``out-of-memory'' string
instead. This is a contagious empty string. Any concatenation operation
(@code{operator+} or @code{append}) involving an out-of-memory string
has an out-of-memory result. Out-of-memory strings compare unequal to
every other string, including themselves.

All out-of-memory strings share the same @code{data}, which is different
from the @code{data} of any other string.

@deftypemethod String bool out_of_memory () const
Returns true iff this string is an out-of-memory string.
@end deftypemethod

@deftypeop {Static Method} String {const String &} out_of_memory_string ()
Returns an out-of-memory string.
@end deftypeop


@node StringAccum, Vector, String, Helper Classes
@section StringAccum

The @code{StringAccum} class, like @code{String} (@pxref{String}),
represents a string of characters. @code{StringAccum} is optimized for
building a string through @dfn{accumulation}, or successively appending
substrings until the whole string is ready. A @code{StringAccum} has
both a @dfn{length}---the number of characters it currently
contains---and a @dfn{capacity}---the maximum number of characters it
could hold without reallocating memory.

@menu
* StringAccum Constructors::    
* StringAccum operator<<::      
* Special StringAccum operator<<::  
* StringAccum Manipulation::    
* StringAccum Contents::        
* StringAccum Results::         
* StringAccum Out-of-Memory::   
@end menu


@node StringAccum Constructors, StringAccum operator<<, StringAccum, StringAccum
@subsection Constructors

@deftypeop Constructor StringAccum {} StringAccum ()
Creates a @code{StringAccum} with no characters.
@end deftypeop

@deftypeop Constructor StringAccum {} StringAccum (int @var{capacity})
Creates a @code{StringAccum} with no characters, but a capacity of
@var{capacity}. @var{capacity} must be greater than zero.
@end deftypeop

@code{StringAccum}'s copy constructor (@code{StringAccum(const
StringAccum &)}) and assignment operator (@code{operator=(const
StringAccum &)}) are private. Thus, @code{StringAccum}s cannot be
assigned or passed as arguments. Of course, references to
@code{StringAccum}s may be passed as arguments, and this usage is quite
common.


@node StringAccum operator<<, Special StringAccum operator<<, StringAccum Constructors, StringAccum
@subsection Appending with @code{operator<<}

Generally, you append to a @code{StringAccum} using iostreams-like
@code{<<} operators, which this section describes. The next section
describes the low-level interface, the @code{append} and @code{pop_back}
methods.

Here is a conventional use of @code{StringAccum}'s @code{<<} operators:

@example
struct timeval tv; StringAccum sa; int n; // ...
sa << tv << ": There are " << n << " things.\n";
@end example

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, char @var{c})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{unsigned char @var{c}})
Appends the character @var{c} to the @code{StringAccum} @var{sa} and
returns @var{sa}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, const char *@var{s})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, const String &@var{s})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{const StringAccum &@var{sa2}})
Appends the string @var{s}, or the value of the @code{StringAccum}
@var{sa2}, to @var{sa} and returns @var{sa}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, short @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, unsigned short @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, int @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, unsigned @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, long @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, unsigned long @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, long long @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{unsigned long long @var{n}})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, double @var{n})
Appends an ASCII decimal representation of the number @var{n} to
@var{sa} and returns @var{sa}. For example, if @var{n} is 20, then
@code{@var{sa} << @var{n}} has the same effect as @code{@var{sa} <<
"20"}. The @code{double} operator is not available in the kernel.
@end deftypefun

@node Special StringAccum operator<<, StringAccum Manipulation, StringAccum operator<<, StringAccum
@subsection Appending Data Types

@code{StringAccum} comes with @code{operator<<} definitions for the
@code{bool}, @code{struct timeval}, @code{IPAddress}, and
@code{EtherAddress} types. Of course, you can write your own
@code{operator<<} functions for other data types, either using existing
@code{operator<<}s or the manipulation functions described in the next
section.

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{bool &@var{val}})
Appends the string @code{true} or @code{false} to @var{sa}, according to
the value of @var{val}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{const struct timeval &@var{tv}})
Appends an ASCII decimal representation of the time value @var{tv} to
@var{sa} and returns @var{sa}. The time value is printed as if by
@code{printf("%ld.%06ld", @var{tv}.tv_sec, @var{tv}.tv_usec)}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{IPAddress &@var{addr}})
Appends the conventional dotted-quad representation of the IP address
@var{addr} to @var{sa} and returns @var{sa}. For example, @samp{sa <<
addr} might have the same effect as @samp{sa << "18.26.4.44"}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{const EtherAddress &@var{addr}})
Appends the conventional colon-separated hexadecimal representation of
the Ethernet address @var{addr} to @var{sa} and returns @var{sa}. For
example, @samp{sa << addr} might have the same effect as @samp{sa <<
"00:02:B3:06:06:36:EE"}.
@end deftypefun


@node StringAccum Manipulation, StringAccum Contents, Special StringAccum operator<<, StringAccum
@subsection Manipulation

This section describes lower-level methods for manipulating
@code{StringAccum} objects. The @code{append} methods append data to the
@code{StringAccum}; the @code{extend}, @code{reserve}, and
@code{forward} methods add space to the end of it; and the @code{clear}
and @code{pop_back} methods remove its characters.

@deftypemethod StringAccum void append (char @var{c})
@deftypemethodx StringAccum void append (unsigned char @var{c})
Appends the character @var{c} to the end of this @code{StringAccum}.
Equivalent to @code{*this << @var{c}}.
@end deftypemethod

@deftypemethod StringAccum void append (const char *@var{s}, int @var{len})
Appends the first @var{len} characters of @var{s} to the end of this
@code{StringAccum}. If @var{len} is negative, then this function treats
@var{s} as a C string, effectively setting @var{len} to
@code{strlen(@var{s})}.
@end deftypemethod

@deftypemethod StringAccum {char *} extend (int @var{len})
Puts @var{len} arbitrary characters at the end of this
@code{StringAccum} and returns a pointer to those characters. The return
value may be a null pointer if there is not enough memory to grow the
character array. This method increases the @code{StringAccum}'s length
by @var{len}, which must be greater than or equal to zero.
@end deftypemethod

@deftypemethod StringAccum {char *} extend (@w{int @var{len}}, @w{int @var{extra}})
Puts @var{len} arbitrary characters at the end of this
@code{StringAccum} and returns a pointer to those characters. Also
ensures space for @var{extra} additional characters following the
@var{len} new characters; however, these characters do not contribute to
the @code{StringAccum}'s length. The return value may be a null pointer
if there is not enough memory to grow the character array. Increases the
@code{StringAccum}'s length by @var{len}, which must be greater than or
equal to zero.

This form of @code{extend} is generally used to compensate for the null
character appended by C string functions like @code{sprintf}. For
example:

@example
if (char *buf = string_accum.extend(4, 1))
    // 4 real characters plus one terminating null
    sprintf(buf, "\\%03o", i);
@end example
@end deftypemethod

@quotation
@strong{Caution}: The pointer returned by @code{extend}, or the
@code{reserve} method described below, should be treated as transient.
It may become invalid after the next call to a method that grows the
@code{StringAccum}, such as @code{append}, @code{extend}, or one of the
@code{operator<<} functions, and will definitely become invalid when the
@code{StringAccum} is destroyed.
@end quotation


The @code{reserve} and @code{forward} methods together provide a
convenient, fast interface for appending strings of unknown, but
bounded, length.

@deftypemethod StringAccum {char *} reserve (int @var{len})
Reserves space for @var{len} characters at the end of this
@code{StringAccum} and returns a pointer to those characters. The return
value may be a null pointer if there is not enough memory to grow the
character array. This method does not change the @code{StringAccum}'s
length, although it may change its capacity. Use @code{forward} to
change the @code{StringAccum}'s length.
@end deftypemethod

@deftypemethod StringAccum void forward (int @var{amt})
Adds @var{amt} to the @code{StringAccum}'s length without changing its
data. This method is used in conjunction with @code{reserve}, above. Use
@code{reserve} to get space suitable for appending a string of unknown,
but bounded, length. After finding the actual length, use @code{forward}
to inform the @code{StringAccum}. @var{amt} must be greater than or
equal to zero, and less than or equal to the remaining capacity.
@end deftypemethod

Finally, these methods remove characters from a @code{StringAccum}
rather than add characters to it.

@deftypemethod StringAccum void clear ()
Erases the @code{StringAccum}, making its length zero (an empty string).
@end deftypemethod

@deftypemethod StringAccum void pop_back ()
@deftypemethodx StringAccum void pop_back (int @var{amt})
Remove the last character, or the last @var{amt} characters, of the
string. @var{amt} must be greater than or equal to zero, and less than
or equal to the @code{StringAccum}'s length.
@end deftypemethod


@node StringAccum Contents, StringAccum Results, StringAccum Manipulation, StringAccum
@subsection Contents

@quotation
@strong{Caution}: The pointer returned by @code{data} and @code{c_str}
should be treated as transient. It may become invalid after the next
call to a method that grows the @code{StringAccum}, such as
@code{append}, @code{extend}, or one of the @code{operator<<} functions,
and will definitely become invalid when the @code{StringAccum} is destroyed.
@end quotation

@deftypemethod StringAccum {char *} data () const
Returns a pointer to the character data contained in this
@code{StringAccum}.
@end deftypemethod

@deftypemethod StringAccum int length () const
Returns the number of characters in this @code{StringAccum}.
@end deftypemethod

@deftypemethod String {} {operator bool} ()
@deftypemethodx String {} {operator bool} () const
Returns true iff this @code{StringAccum} has at least one character.
@end deftypemethod

@deftypemethod StringAccum {const char *} c_str ()
@deftypemethodx StringAccum {const char *} cc ()
Returns a pointer to the character data contained in this
@code{StringAccum}. Guarantees that the returned string is
null-terminated: the @code{length()}th character will be @code{'\0'}.
This does not affect the @code{StringAccum}'s contents or length.
@end deftypemethod

@deftypemethod StringAccum char {operator[]} (int @var{i}) const
@deftypemethodx StringAccum {char &} {operator[]} (int @var{i})
Returns the @var{i}th character of this @code{StringAccum}. @var{i} must
be greater than or equal to zero, and less than the @code{StringAccum}'s
length. Note that the non-@code{const} version of this method returns a
mutable character reference, which facilitates code like

@example
StringAccum sa; // ...
sa[5] = 'a';
@end example
@end deftypemethod


@node StringAccum Results, StringAccum Out-of-Memory, StringAccum Contents, StringAccum
@subsection Results

@code{StringAccum}'s @code{take} methods return the string accumulated
by a series of calls to @code{operator<<} or similar methods. Each
@code{take} method makes @code{StringAccum} relinquish responsibility
for its character array memory, passing that responsibility on to its
caller. The caller should free the memory when it is done---either with
@code{delete[]}, for the @code{take} and @code{take_bytes} methods, or
by relying on @code{String} to handle it, for the @code{take_string}
method.

Each @code{take} method additionally restores the @code{StringAccum} to
its original, empty state. Further @code{append}s or similar operations
will begin building a new string from scratch.

@deftypemethod StringAccum void take (unsigned char *&@var{s}, int &@var{len})
Sets the @var{s} variable to this @code{StringAccum}'s character data
and @var{len} to its length. Then clears the @code{StringAccum}'s
internal state. 
@end deftypemethod

@deftypemethod StringAccum {char *} take ()
@deftypemethodx StringAccum {unsigned char *} take_bytes ()
Returns this @code{StringAccum}'s character data, then clears the
@code{StringAccum}'s internal state. The methods differ only in their
return types. Note that @code{StringAccum::length} will always return
zero immediately after a @code{take} or @code{take_bytes}. If you need
to know the string's length, call @code{length} first.
@end deftypemethod

@deftypemethod StringAccum String take_string ()
Returns this @code{StringAccum}'s character data as a @code{String}
object (@pxref{String}), then clears the @code{StringAccum}'s internal
state. This method hands the character data over to the @code{String}
implementation; no data copies are performed.
@end deftypemethod


@node StringAccum Out-of-Memory,  , StringAccum Results, StringAccum
@subsection Out-of-Memory Conditions

@code{StringAccum} operations are robust against out-of-memory
conditions. If there is not enough memory to complete a particular
operation, the @code{StringAccum} is erased and turned into a special
out-of-memory indicator. This is a contagious empty string. Every
operation on such a buffer (except for @code{clear}) leaves it in the
out-of-memory state.

@deftypemethod StringAccum bool out_of_memory () const
Returns true iff this @code{StringAccum} is an out-of-memory indicator.
@end deftypemethod

The @code{extend} and @code{reserve} methods can return null pointers on
out-of-memory; their callers should always check that their return
values are non-null.



@node Vector, Bitvector, StringAccum, Helper Classes
@section Vector

@node Bitvector, HashMap, Vector, Helper Classes
@section Bitvector

@node HashMap, BigHashMap, Bitvector, Helper Classes
@section HashMap

@node BigHashMap, ErrorHandler, HashMap, Helper Classes
@section BigHashMap


@node ErrorHandler, IPAddress, BigHashMap, Helper Classes
@section ErrorHandler

All Click error messages are passed to an instance of the
@code{ErrorHandler} class. @code{ErrorHandler} separates the generation
of error messages from the particular way those messages should be
printed. It also makes it easy to automatically decorate errors with
context information.

Most Click users must know how to report errors to an
@code{ErrorHandler}, and how @code{ErrorHandler}s count the messages
they receive. This section also describes how to decorate error messages
with error veneers, and how to write new @code{ErrorHandler}s.

@code{ErrorHandler} and its important subclasses are defined in
@code{<click/error.hh>}.

@menu
* ErrorHandler Initialization::  
* Reporting Errors::            
* Error Format Strings::        
* Counting Errors::             
* Basic ErrorHandlers::         
* Error Veneers::               
* Writing ErrorHandlers::       
@end menu


@node ErrorHandler Initialization, Reporting Errors, ErrorHandler, ErrorHandler
@subsection Class Initialization

The @code{ErrorHandler} class maintains some global state that must be
initialized by calling @code{static_initialize} at the beginning of the
program, and may be freed by calling @code{static_cleanup} when
execution is complete.

@deftypeop {Static Method} ErrorHandler void static_initialize (ErrorHandler *@var{default_errh})
Call this function exactly once, at the beginning of the program, before
any error messages are reported to any @code{ErrorHandler}. It is OK to
create arbitrary @code{ErrorHandler} objects before calling this method,
however. The @var{default_errh} argument becomes the default
@code{ErrorHandler}; see @ref{Basic ErrorHandlers}.
@end deftypeop

@deftypeop {Static Method} ErrorHandler void static_cleanup ()
Call this function exactly once, just before the program exits. Destroys
the default and silent @code{ErrorHandler}s and cleans up other
@code{ErrorHandler}-related memory. It is an error to call any
@code{ErrorHandler} method after calling @code{static_cleanup}.
@end deftypeop


@node Reporting Errors, Error Format Strings, ErrorHandler Initialization, ErrorHandler
@subsection Reporting Errors

@code{ErrorHandler}'s basic error reporting methods take a format
string, which may use @code{printf}-like @samp{%} escape sequences, and
additional arguments as required by the format string. @xref{Error
Format Strings}, for more details on the format string. The five methods
differ in the seriousness of the error they report.

@deftypemethod ErrorHandler void debug (const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler void message (const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int warning (const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int error (const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int fatal (const char *@var{format}, @dots{})
Report the error described by @var{format} and any additional arguments.
The methods are listed by increasing seriousness. Use @code{debug} for
debugging messages that should not be printed in a production
environment; @code{message} for explanatory messages that do not
indicate errors; @code{warning} for warnings (this function prepends the
string @samp{warning:@ } to every line of the error message);
@code{error} for errors; and @code{fatal} for errors so serious that
they should halt the execution of the program. The three functions that
indicate errors, @code{warning}, @code{error}, and @code{fatal}, always
return @code{-EINVAL}. In some environments, @code{fatal} will actually
exit the program with exit code 1.
@end deftypemethod

Each of these methods has an analogue that additionally takes a
@dfn{landmark}: a string representing where the error took place. A
typical landmark contains a file name and line number, separated by a
colon---@samp{foo.click:31}, for example.

@deftypemethod ErrorHandler void ldebug (const String &@var{landmark}, const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler void lmessage (const String &@var{landmark}, const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int lwarning (const String &@var{landmark}, const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int lerror (const String &@var{landmark}, const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int lfatal (const String &@var{landmark}, const char *@var{format}, @dots{})
Report the error described by @var{format} and any additional arguments.
The error took place at @var{landmark}. Most @code{ErrorHandler}s will
simply prepend @samp{@var{landmark}:@ } to each line of the error
message.
@end deftypemethod

These methods are all implemented as wrappers around the @code{verror}
function. This function takes a landmark, a format string, a
@code{va_list} packaging up any additional arguments, and a
@dfn{seriousness value}, which encodes how serious the error was. The
@code{Seriousness} enumerated type, which is defined in the
@code{ErrorHandler} class, represents seriousness values. There are five
constants, corresponding to the five error-reporting methods:

@table @code
@item ERR_DEBUG
Corresponds to @code{debug} and @code{ldebug}.

@item ERR_MESSAGE
Corresponds to @code{message} and @code{lmessage}.

@item ERR_WARNING
Corresponds to @code{warning} and @code{lwarning}.

@item ERR_ERROR
Corresponds to @code{error} and @code{lerror}.

@item ERR_FATAL
Corresponds to @code{fatal} and @code{lfatal}.
@end table

@deftypemethod ErrorHandler int verror (Seriousness @var{seriousness}, const String &@var{landmark}, const char *@var{format}, va_list @var{val})
Report the error described by @var{format} and @var{val}. The error took
place at @var{landmark}, if @var{landmark} is nonempty. The
@var{seriousness} value is one of the five constants described above.
Always returns @code{-EINVAL}.
@end deftypemethod


@node Error Format Strings, Counting Errors, Reporting Errors, ErrorHandler
@subsection Format Strings

@code{ErrorHandler}'s format strings closely follow C's standard
@code{printf} format strings. Most characters in the format string are
printed verbatim. The @samp{%} character introduces a @dfn{conversion},
which prints data read from the remaining arguments. The format string
may contain newlines @samp{\n}, but it need not end with a newline;
@code{ErrorHandler} will add a final newline if one does not exist.

Each conversion, or formatting escape, follows this pattern:

@itemize @bullet
@item
First, the @samp{%} character introduces each conversion.

@item
Next comes zero or more @dfn{flag characters};

@item
then an optional @dfn{field width};

@item
then an optional @dfn{precision};

@item
then an optional @dfn{length modifier};

@item
and finally, the mandatory @dfn{conversion specifier}.
@end itemize

@noindent
We discuss each of these is turn.

Any conversion may be modified by zero or more of these flag characters.

@table @asis
@item @samp{#}
The value should be converted to an ``alternate form''. For @samp{o}
conversions, the first character of the output string is made @samp{0},
by prepending a @samp{0} if there was not one already. For @samp{x} and
@samp{X} conversions, nonzero values have @samp{0x} or @samp{0X}
prepended, respectively.

@item @samp{0}
The value should be zero padded. For @samp{d}, @samp{i}, @samp{u},
@samp{o}, @samp{x}, and @samp{X} conversions, the converted value is
padded on the left with @samp{0} characters rather than spaces.

@item @samp{-}
The value should be left-justified within the field width.

@item @samp{@ } (a space)
Leave a blank before a nonnegative number produced by a signed
conversion.

@item @samp{+}
Print a @samp{+} character before a nonnegative number produced by a
signed conversion.

@end table

The optional @dfn{field width}, a decimal digit string, forces the
conversion to use a minimum number of characters. The result of a
conversion is padded on the left with space characters to reach the
minimum field width, unless one of the @samp{0} or @samp{-} flags was
supplied.

The optional @dfn{precision} is a decimal digit string preceded by a
period @samp{.}. For @samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x},
and @samp{X} conversions, the precision specifies the minimum number of
digits that must appear; results with fewer digits are padded on the
left with @samp{0} characters. For the @samp{s} conversion, the
precision specifies the maximum number of characters that can be
printed.

If either the field width or precision is specified as a star @samp{*},
@code{ErrorHandler} reads the next argument as an integer and uses that
instead.

Length modifiers affect the argument type read by the conversion. There
are three modifiers:

@table @asis
@item @samp{h}
The next argument is a @code{short} or @code{unsigned short}. Affects
the @samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x}, and @samp{X}
conversions.

@item @samp{l}
The next argument is a @code{long} or @code{unsigned long}. Affects the
@samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x}, and @samp{X}
conversions.

@item @samp{ll}
The next argument is a @code{long long} or @code{unsigned long long}.
Affects the @samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x}, and
@samp{X} conversions.
@end table

Finally, these are the conversions themselves.

@table @asis
@item @samp{s}
Print the @code{const char *} argument, treated as a C string.

@item @samp{c}
The @code{int} argument is treated as a character constant. Printable
ASCII characters (values between 32 and 126) are printed verbatim.
Characters @samp{\n}, @samp{\t}, @samp{\r}, and @samp{\0} use those C
escape representations. Other characters use the representation
@samp{\%03o}.

@item @samp{e}
The argument is an @code{Element *}. Print that element's declaration.

@item @samp{d}, @samp{i}
The argument is an @code{int}; print its decimal representation.

@item @samp{u}
The argument is an @code{unsigned int}; print its decimal
representation.

@item @samp{o}
The argument is an @code{unsigned int}; print its octal representation.

@item @samp{x}, @samp{X}
The argument is an @code{unsigned int}; print its hexadecimal
representation. The @samp{%x} conversion uses lowercase letters;
@samp{%X} uses uppercase letters.

@item @samp{p}
The @code{void *} argument is cast to @code{unsigned long} and printed
as by @samp{%#lx}.

@item @samp{%}
Print a literal @samp{%} character.

@end table

Note that @code{ErrorHandler} does not support the @samp{e}, @samp{E},
@samp{f}, @samp{F}, @samp{g}, @samp{G}, and @samp{n} conversions.


@node Counting Errors, Basic ErrorHandlers, Error Format Strings, ErrorHandler
@subsection Counting Errors

@code{ErrorHandler} objects count the number of errors and warnings they
have received and make those values available to the user.

@deftypemethod ErrorHandler {virtual int} nwarnings () const
@deftypemethodx ErrorHandler {virtual int} nerrors () const
Returns the number of warnings or errors received by this
@code{ErrorHandler} so far.
@end deftypemethod

@deftypemethod ErrorHandler {virtual void} reset_counts ()
Resets the @code{nwarnings} and @code{nerrors} counters to zero.
@end deftypemethod

These counters are typically used to determine whether an error has
taken place in some complex piece of code. For example:

@example
int before_nerrors = errh->nerrors();
// @r{@dots{} complex code that may report errors to @code{errh} @dots{}}
if (errh->nerrors() != before_nerrors) @{
    // @r{an error has taken place}
@}
@end example


@node Basic ErrorHandlers, Error Veneers, Counting Errors, ErrorHandler
@subsection Basic @code{ErrorHandler}s

Every Click error message eventually reaches some @dfn{basic}
@code{ErrorHandler}, which generally prints the messages it receives.
The user-level driver's basic @code{ErrorHandler} prints error messages
to standard error, while in the Linux kernel module, the basic
@code{ErrorHandler} logs messages to the syslog and stores them for
access via @file{/proc/click/errors}.

@cindex default @code{ErrorHandler}
@cindex @code{ErrorHandler}, default
Two basic @code{ErrorHandlers} are always accessible via static methods:
the @dfn{default @code{ErrorHandler}}, returned by
@code{default_handler} and set by @code{set_default_handler}; and the
@dfn{silent @code{ErrorHandler}}, returned by @code{silent_handler},
which ignores any error messages it receives.

@deftypeop {Static Method} ErrorHandler {ErrorHandler *} default_handler ()
Returns the default @code{ErrorHandler}.
@end deftypeop

@deftypeop {Static Method} ErrorHandler void set_default_handler (@w{ErrorHandler *errh})
Sets the default @code{ErrorHandler} to @var{errh}. The
@code{static_initialize} method also sets the default
@code{ErrorHandler}; see @ref{ErrorHandler Initialization}.
@end deftypeop

@deftypeop {Static Method} ErrorHandler {ErrorHandler *} silent_handler ()
Returns the silent @code{ErrorHandler}. This handler ignores any error
messages it receives. It maintains correct @code{nwarnings} and
@code{nerrors} counts, however.
@end deftypeop

@code{FileErrorHandler}, a kind of basic @code{ErrorHandler}, is
available in any user-level program. It prints every message it receives
to some file, usually standard error. It can also prepend an optional
context string to every line of every error message.

@deftypeop Constructor FileErrorHandler {} FileErrorHandler (FILE *@var{f}, @w{const String &@var{prefix} = ""})
Constructs a @code{FileErrorHandler} that prints error messages to file
@var{f}. If @var{prefix} is nonempty, then every line of every error
message is prepended by @var{prefix}.
@end deftypeop


@node Error Veneers, Writing ErrorHandlers, Basic ErrorHandlers, ErrorHandler
@subsection Error Veneers

@dfn{Error veneers} wrap around basic @code{ErrorHandler} objects and
change how error text is generated. An error veneer generally changes
each error message's text in some way, perhaps by adding a context
message or some indentation. It then passes the altered text to the
basic @code{ErrorHandler} for printing. Error veneers can be easily
nested.

The first argument to each error veneer constructor is a pointer to
another @code{ErrorHandler} object. The veneer will pass altered error
text to this handler, the @dfn{base handler}, for further processing and
printing. It also delegates @code{nwarnings()} and @code{nerrors()}
calls to the base handler.

Click comes with three error veneers: one for adding context, one for
prepending text to every line, and one for supplying missing landmarks.
It is easy to write others; see @ref{Writing ErrorHandlers}, for
details.

@deftypeop Constructor ContextErrorHandler {} ContextErrorHandler (@w{ErrorHandler *@var{base_errh}}, @w{const String &@var{context}}, @w{const String &@var{indent} = "@w{@ @ }"})
Constructs a @code{ContextErrorHandler} with @var{base_errh} as base.

The first time this handler receives an error message, it will precede
the message with the @var{context} string---generally more detailed
information about where the error has occurred. Every line in every
received error message is prepended with @var{indent}, two spaces by
default, to set off the message from its context.
@end deftypeop

@deftypeop Constructor PrefixErrorHandler {} PrefixErrorHandler (@w{ErrorHandler *@var{base_errh}}, @w{const String &@var{prefix}})
Constructs a @code{PrefixErrorHandler} with @var{base_errh} as base.

This handler precedes every line of every error message with
@var{prefix}.
@end deftypeop

@deftypeop Constructor LandmarkErrorHandler {} LandmarkErrorHandler (@w{ErrorHandler *@var{base_errh}}, @w{const String &@var{landmark}})
Constructs a @code{LandmarkErrorHandler} with @var{base_errh} as base.

This handler supplies @var{landmark} in place of any blank landmark
passed to it. This will cause the base handler to include @var{landmark}
in its error message.
@end deftypeop

To demonstrate these veneers in practice, we'll use the following
function, which prints two error messages:

@example
void f(ErrorHandler *errh) @{
    errh->error("First line\nSecond line");
    errh->lwarning("here", "Third line");
@}
@end example

A simple @code{FileErrorHandler} shows the base case.

@example
FileErrorHandler errh1(stderr);
f(&errh1);
    @print{} First line
    @print{} Second line
    @print{} here: warning: Third line
@end example

The simplest error veneer, @code{PrefixErrorHandler}, just prepends text
to every line.

@example
PrefixErrorHandler errh2(&errh1, "prefix - ");
f(&errh2);
    @print{} prefix - First line
    @print{} prefix - Second line
    @print{} prefix - here: warning: Third line
@end example

@code{ContextErrorHandler} supplies a line of context before the first
error message, and indents all messages except the context.

@example
ContextErrorHandler errh3(&errh1, "This was called from ...", "** ");
f(&errh3);
    @print{} This was called from ...
    @print{} ** First line
    @print{} ** Second line
    @print{} here: ** warning: Third line
@end example

@noindent
Note that the indentation @samp{**@ } is printed after the landmark.
This often looks better than the alternative.

Of course, an error veneer can take another error veneer as its ``base
handler'', leading to cumulative effects.

@example
ContextErrorHandler errh4(&errh2, "This was called from ...", "** ");
f(&errh4);
    @print{} prefix - This was called from ...
    @print{} prefix - ** First line
    @print{} prefix - ** Second line
    @print{} prefix - here: ** warning: Third line
@end example


@node Writing ErrorHandlers,  , Error Veneers, ErrorHandler
@subsection Writing @code{ErrorHandler}s

@code{ErrorHandler} constructs an error message using three virtual
functions. The first, @code{make_text}, parses a format string and
argument list into a single @code{String}. This is passed to the second
function, @code{decorate_text}, which may transform the string. The
final function, @code{handle_text}, prints the resulting error message.
This structure makes @code{ErrorHandler} easy to extend. To write a new
basic @code{ErrorHandler}, you will need to override just
@code{handle_text} and the counting functions (@code{nwarnings},
@code{nerrors}, and @code{reset_counts}). The @code{ErrorVeneer} helper
class, described below, lets you override just @code{decorate_text} when
writing an error veneer.

@deftypemethod ErrorHandler {virtual String} make_text @w{(Seriousness @var{s},} @w{const char *@var{format}}, va_list @var{val})
Parses the format string @var{format} with arguments from @var{val},
returning the results as a @var{String} object.

The default implementation processes the formatting escapes described
above (@pxref{Error Format Strings}). It also prepends every line of
the error message with @samp{warning: } if @var{s} equals
@code{ERR_WARNING}.
@end deftypemethod

@deftypemethod ErrorHandler {virtual String} decorate_text (Seriousness @var{s}, const String &@var{prefix}, const String &@var{landmark}, const String &@var{text})
Decorates the error message @var{text} as appropriate and returns the
result. At minimum, every line of the result should be prepended by
@var{prefix} and, if it is nonempty, the landmark string @var{landmark}.

The default implementation creates lines like this:

@example
@var{prefix}@var{landmark}: @var{text}     @r{(if @var{landmark} is nonempty)}
@var{prefix}@var{text}               @r{(if @var{landmark} is empty)}
@end example

@noindent
Any spaces and/or a final colon are stripped from the end of
@var{landmark}. Special landmarks, which begin and end with a backslash
@samp{\}, are ignored.
@end deftypemethod

@deftypemethod ErrorHandler {virtual void} handle_text (@w{Seriousness @var{s}, const String &@var{text}})
This method is responsible for printing or otherwise informing the user
about the error message @var{text}. If @var{s} equals @code{ERR_FATAL},
the method should exit the program or perform some other drastic action.
It should also maintain the @code{nwarnings()} and @code{nerrors()}
counters. In most cases, it should ensure that the last character in
@var{text} is a newline.

This method has no default implementation.
@end deftypemethod

@tpindex @code{ErrorVeneer}
The @code{ErrorVeneer} class, a subclass of @code{ErrorHandler},
supplies default implementations for these functions that ease the
construction of new error veneers. @code{ErrorVeneer}'s single instance
variable, @code{ErrorHandler *_errh}, is the base handler.
@code{ErrorVeneer} overrides all the relevant virtual
functions---@code{nwarnings}, @code{nerrors}, @code{reset_counts},
@code{make_text}, @code{decorate_text}, and @code{handle_text}. Its
versions simply delegate to the corresponding methods on @code{_errh}.
An error veneer designer will generally subclass @code{ErrorVeneer}
rather than @code{ErrorHandler}; then she will override only the methods
she cares about (usually @code{decorate_text}), relying on
@code{ErrorVeneer}'s default implementations for the rest.

@deftypeop Constructor ErrorVeneer {} ErrorVeneer (ErrorHandler *@var{base_errh})
Constructs an @code{ErrorVeneer} helper class with @var{base_errh} as
its base error handler. This constructor simply sets @code{_errh =
base_errh}.
@end deftypeop


@node IPAddress, IP6Address, ErrorHandler, Helper Classes
@section IPAddress

The @code{IPAddress} type represents an IPv4 address. It supports
bitwise operations like @samp{&} and @samp{|} and provides methods for
unparsing IP addresses into ASCII dotted-quad form.

@menu
* IPAddress Constructors::      
* IPAddress Data::              
* IPAddress Operations::        
* IPAddress Unparsing::         
@end menu

@node IPAddress Constructors, IPAddress Data, IPAddress, IPAddress
@subsection Constructors

@code{IPAddress} objects can be constructed from network-order integers,
from pointers to arrays of bytes, from ASCII strings, and from the
conventional @code{struct in_addr} type.

@deftypemethod IPAddress {} IPAddress ()
Creates an IP address equal to 0.0.0.0.
@end deftypemethod

@deftypemethod IPAddress explicit IPAddress (const unsigned char *@var{value})
Creates an IP address equal to
`@var{value}@math{[0]}.@var{value}@math{[1]}.@var{value}@math{[2]}.@var{value}@math{[3]}'.
@end deftypemethod

@deftypemethod IPAddress {} IPAddress (unsigned int @var{value})
@deftypemethodx IPAddress explicit IPAddress (int @var{value})
@deftypemethodx IPAddress explicit IPAddress (long @var{value})
@deftypemethodx IPAddress explicit IPAddress (unsigned long @var{value})
Creates an IP address equal to @var{value}, which is an IP address in
network byte order.
@end deftypemethod

@deftypemethod IPAddress {} IPAddress (struct in_addr @var{value})
Creates an IP address equal to @var{value}.
@end deftypemethod

@deftypemethod IPAddress explicit IPAddress (const String &@var{text})
Creates an IP address equal to @var{text}, which should be a dotted-quad
string in ASCII. For example, @var{text} might equal
@strcode{"18.26.4.44"}. If @var{text} does not parse into a dotted-quad
string, the resulting @code{IPAddress} equals 0.0.0.0.
@end deftypemethod

@deftypeop {Static Method} IPAddress IPAddress make_prefix (int @var{k})
Creates and returns an IP address with the upper @var{k} bits on and all
other bits off. @var{k} must be between 0 and 32, inclusive. For
example, @code{make_prefix(0)} equals 0.0.0.0, @code{make_prefix(8)}
equals 255.0.0.0, and @code{make_prefix(32)} equals 255.255.255.255. The
netmask corresponding to a CIDR address @samp{@var{addr}/@var{k}}
equals @code{IPAddress::make_prefix(@var{k})}.
@end deftypeop


@node IPAddress Data, IPAddress Operations, IPAddress Constructors, IPAddress
@subsection Data

These methods return an @code{IPAddress}'s data in a variety of ways.

@deftypemethod IPAddress {} {operator bool} () const
Returns true if and only if this IP address does not equal 0.0.0.0.
@end deftypemethod

@deftypemethod IPAddress {struct in_addr} in_addr () const
@deftypemethodx IPAddress {} {operator struct in_addr} () const
Returns this IP address as a @code{struct in_addr} object.
@end deftypemethod

@deftypemethod IPAddress uint32_t addr () const
@deftypemethodx IPAddress {} {operator uint32_t} () const
Returns this IP address as an unsigned integer in network byte order.
@end deftypemethod
  
@deftypemethod IPAddress {const unsigned char *} data () const
@deftypemethodx IPAddress {unsigned char *} data ()
Returns a pointer to this IP address's data.
@end deftypemethod

@deftypemethod IPAddress int mask_to_prefix_len () const
Returns the prefix length @var{k} so that this IP address equals
@code{make_prefix(@var{k})}, or @math{-1} if there is no such prefix
length.
@end deftypemethod

@deftypefun unsigned hashcode (IPAddress @var{addr})
Returns a number with the property that, for any two equal IP addresses
@var{addr1} and @var{addr2}, @code{hashcode(@var{addr1}) ==
hashcode(@var{addr2})}. With this function, @code{IPAddress}es may be
used as keys for @code{HashMap}s and @code{BigHashMap}s
(@pxref{HashMap}).
@end deftypefun


@node IPAddress Operations, IPAddress Unparsing, IPAddress Data, IPAddress
@subsection Operations

@deftypefun bool {operator==} (IPAddress @var{addr1}, IPAddress @var{addr2})
Returns true if and only if @var{addr1} equals @var{addr2}. Equivalent
to @code{@var{addr1}.addr() == @var{addr2}.addr()}.
@end deftypefun

@deftypefun bool {operator!=} (IPAddress @var{addr1}, IPAddress @var{addr2})
Returns true if and only if @var{addr1} does not equal @var{addr2}.
@end deftypefun

@deftypemethod IPAddress bool matches_prefix (@w{IPAddress @var{addr1}}, @w{IPAddress @var{mask}}) const
Returns true if and only if this @code{IPAddress} matches the IP prefix
specified by @var{addr1} and the netmask @var{mask}. Equivalent to
@code{(addr() & @var{mask}.addr()) == @var{addr1}.addr()}.
@end deftypemethod

@deftypemethod IPAddress bool submask (@w{IPAddress @var{mask}}) const
Returns true if and only if this @code{IPAddress}, interpreted as a
netmask, is at least as specific as @var{mask}. Equivalent to
@code{(addr() & @var{mask}.addr()) == @var{mask}.addr()}.
@end deftypemethod

@deftypefun IPAddress {operator&} (IPAddress @var{addr1}, IPAddress @var{addr2})
Returns a new IP address equal to @var{addr1} masked by @var{addr2}.
Equivalent to @code{IPAddress(@var{addr1}.addr() & @var{addr2}.addr())}.
@end deftypefun

@deftypefun IPAddress {operator|} (IPAddress @var{addr1}, IPAddress @var{addr2})
Returns a new IP address equal to the bitwise or of @var{addr1} and
@var{addr2}. Equivalent to @code{IPAddress(@var{addr1}.addr() |
@var{addr2}.addr())}.
@end deftypefun

@deftypefun IPAddress {operator~} (IPAddress @var{addr})
Returns a new IP address equal to the bitwise complement of @var{addr}.
Equivalent to @code{IPAddress(~@var{addr1}.addr())}.
@end deftypefun

@deftypemethod IPAddress {IPAddress &} {operator&=} (IPAddress @var{addr1})
Masks this IP address by @var{addr1} and returns the result. Equivalent
to @code{*this = (*this & @var{addr1})}.
@end deftypemethod

@deftypemethod IPAddress {IPAddress &} {operator|=} (IPAddress @var{addr1})
Bitwise-ors this IP address with @var{addr1} and returns the result.
Equivalent to @code{*this = (*this | @var{addr1})}.
@end deftypemethod


@node IPAddress Unparsing,  , IPAddress Operations, IPAddress
@subsection Unparsing

These functions unparse IP addresses, IP netmasks, and address/netmask
pairs into conventional ASCII text form.

@deftypemethod IPAddress String unparse () const
@deftypemethodx IPAddress String s () const
@deftypemethodx IPAddress {} {operator String} () const
Unparses this IP address into dotted-quad ASCII form and returns the
result as a @code{String} object. A sample result might be
@strcode{"18.26.4.9"}.
@end deftypemethod

@deftypemethod IPAddress String unparse_mask () const
Unparses this IP address as a netmask. If the IP address equals
@code{make_prefix(@var{k})} for some @var{k}, then the result is the
ASCII decimal representation of @var{k}. Otherwise, it is just the
dotted-quad ASCII form of the IP address. For example,
@code{IPAddress("18.26.4.9").unparse_mask()} equals
@strcode{"18.26.4.9"}, but @code{IPAddress("255.0.0.0").unparse_mask()}
equals @strcode{"8"}.
@end deftypemethod

@deftypemethod IPAddress String unparse_with_mask (IPAddress @var{mask}) const
Unparses this IP address with @var{mask} as its netmask. The result has
the form @strcode{"@var{addrtext}/@var{masktext}"}, where @var{addrtext}
equals @code{this->unparse()} and @var{masktext} equals
@code{@var{mask}.unparse_mask()}.
@end deftypemethod


@node IP6Address,  , IPAddress, Helper Classes
@section IP6Address



@node Packets, Element Characteristics, Helper Classes, Top
@chapter Packets

The @code{Packet} class represents Click packets. The single
@code{Packet} interface has multiple implementations, one per driver.
Inside the Linux kernel driver, a @code{Packet} object is equivalent to
a Linux @code{sk_buff} structure; most @code{Packet} methods are inline
functions that expand to @code{sk_buff} calls. The user-level driver,
however, uses a purpose-built @code{Packet} implementation.

Click packets separate header information from data. The @w{@code{Packet
*}} pointer points to a header structure, which holds pointers to the
actual packet data and a set of @dfn{annotations}. Packet data may be
shared by two or more packet headers. Packet headers, however, should
never be shared.

Packets come in two flavors, @code{Packet} and @code{WritablePacket}. A
@code{Packet} object represents a packet header whose data might be
shared with other packets. Because of this potential sharing,
@code{Packet} data is read-only, and its methods return @code{const}
pointers to data. A @code{WritablePacket} object, in contrast,
represents a packet header whose data is known not to be shared. Its
methods return non-@code{const} pointers. The @code{uniqueify} method
turns a @code{Packet} into a @code{WritablePacket}, possibly by making a
copy of the packet's data. @code{WritablePacket} is a subclass of
@code{Packet}, so you can turn a @code{WritablePacket} into a
@code{Packet} implicitly.

The @code{Packet} and @code{WritablePacket} classes are defined in
@samp{<click/packet.hh>}.

@menu
* Packet Structure and Contents::  
* Packet Creation::             
* Packets and sk_buffs::        
* Packet Sharing::              
* Packet Buffer Manipulation::  
* Annotations::                 
* Packet Out-of-Memory::        
@end menu


@node Packet Structure and Contents, Packet Creation, Packets, Packets
@section Structure and Contents

Packet data is stored in a single flat array of bytes. There is no
support for linked chains @`a la BSD @code{mbuf}. The actual packet data
is embedded inside a buffer that may be much larger, leaving unused
spaces called @dfn{headroom} and @dfn{tailroom} before and after the
data proper. Therefore, tasks like prepending a header need not always
reallocate memory. If the headroom is big enough, prepending space for a
new header just requires bumping a pointer.

This diagram shows how a typical packet is laid out, with the relevant
@code{Packet} methods' names.

@example
                      data
        |<- headroom ->|<----- length ----->|<- tailroom ->|
        |              |                    |              |
        +==============+====================+==============+
        |XXXXXXXXXXXXXX| PACKET CONTENTS... |XXXXXXXXXXXXXX|
        +==============+====================+==============+
        |                                                  |
        |<---------------- buffer_length ----------------->|
   buffer_data
@end example

@sp 1

And here are those methods' descriptions.

@deftypemethod Packet {const unsigned char *} data () const
Returns a pointer to the packet data proper.
@end deftypemethod

@deftypemethod Packet unsigned length () const
Returns the length of the packet data proper.
@end deftypemethod

@deftypemethod Packet {const unsigned char *} buffer_data () const
Returns a pointer to the buffer that contains the packet data.
@end deftypemethod

@deftypemethod Packet unsigned headroom () const
@deftypemethodx Packet unsigned tailroom () const
@deftypemethodx Packet unsigned buffer_length () const
Returns the length of the headroom area, the tailroom area, and the
whole buffer, respectively.
@end deftypemethod

@deftypemethod WritablePacket {unsigned char *} data () const
@deftypemethodx WritablePacket {unsigned char *} buffer_data () const
These @code{WritablePacket} methods are identical to @code{Packet}'s
@code{data} and @code{buffer_data} methods except for their
non-@code{const} return type.
@end deftypemethod

Two invariants relate these methods' values:

@display
@t{buffer_length()} @math{=} @t{headroom()} @math{+} @t{length()} @math{+} @t{tailroom()}
@t{data()} @math{=} @t{buffer_data()} @math{+} @t{headroom()}
@end display


@node Packet Creation, Packets and sk_buffs, Packet Structure and Contents, Packets
@section Creation and Destruction

Packets are created with the @code{Packet::make} static methods, and
destroyed with the @code{Packet::kill} method. (The @code{Packet} and
@code{WritablePacket} classes have private constructors and destructors;
you cannot create or destroy packets with @code{new} or @code{delete}.)

@subsection @code{Packet::make}

The @code{make} methods always take the length of the packet data; some
of them take the packet contents and the headroom and tailroom lengths
as well. (The contents of any headroom and tailroom areas are always
undefined.) Most of them return a @w{@code{WritablePacket *}}, since new
packets are not shared.

The @code{Packet} class defines two constants related to packet
creation, @code{DEFAULT_HEADROOM} and @code{MIN_BUFFER_LENGTH}. Those
@code{make} methods that do not take an explicit headroom parameter use
@code{DEFAULT_HEADROOM} instead. Furthermore, no @code{make} method will
create a packet with buffer length less than @code{MIN_BUFFER_LENGTH}.
If the sum of a packet's headroom and length is less than this, the
packet buffer is given extra tailroom to bump the buffer length up to
@code{MIN_BUFFER_LENGTH}. These constants have the values
@code{DEFAULT_HEADROOM} @math{= 28} and @code{MIN_BUFFER_LENGTH} @math{=
64}.


@deftypeop {Static Method} Packet {WritablePacket *} make (unsigned @var{len})
Returns a new packet containing @var{len} bytes of undefined data.
@end deftypeop

@deftypeop {Static Method} Packet {WritablePacket *} make @w{(const char *@var{data}, unsigned @var{len})}
@deftypeopx {Static Method} Packet {WritablePacket *} make @w{(const unsigned char *@var{data}}, unsigned @var{len})
Returns a new packet whose contents equal the first @var{len} bytes of
@var{data}. @var{data} may be a null pointer, in which case the packet
contains @var{len} bytes of undefined data.
@end deftypeop

@deftypeop {Static Method} Packet {WritablePacket *} make (unsigned @var{headroom}, @w{const unsigned char *@var{data}}, unsigned @var{len}, unsigned @var{tailroom})
Returns a new packet containing @var{headroom} bytes of headroom,
@var{len} bytes of contents, and at least @var{tailroom} bytes of
tailroom. The packet contents will equal the first @var{len} bytes of
@var{data} unless @var{data} is a null pointer, in which case the
contents are undefined.
@end deftypeop

The following @code{make} method is only available in the user-level
driver.

@deftypeop {Static Method} Packet {WritablePacket *} make (@w{unsigned char *@var{data}}, @w{unsigned @var{len}}, @w{void (*@var{destructor})(unsigned char *, size_t)})
Returns a new packet that uses @var{data} as a buffer. That is, the new
packet will have the following characteristics:

@multitable {@code{buffer_length}} {@code{buffer_length_buffer}}
@item @code{buffer_data}
@tab @var{data}
@item @code{buffer_length}
@tab @var{len}
@item @code{headroom}
@tab 0
@item @code{length}
@tab @var{len}
@item @code{tailroom}
@tab 0
@end multitable

@noindent
When the resulting packet is destroyed, the function @var{destructor}
will be called with @var{data} and @var{len} as arguments.
@var{destructor} may be a null pointer, in which case @code{Packet}
calls @w{@code{delete[] @var{data}}} instead.

This method lets a user-level element manage packet memory itself,
rather than relying on @code{Packet}.
@end deftypeop

@noindent
@xref{Packets and sk_buffs}, for a @code{make} method only available in
the Linux kernel driver.

@subsection @code{Packet::kill}

To destroy a @code{Packet}, simply call its @code{kill} method.

@deftypemethod Packet void kill ()
Frees this packet. If this packet contained the last reference to its
data buffer, then frees the data buffer as well.
@end deftypemethod


@node Packets and sk_buffs, Packet Sharing, Packet Creation, Packets
@section @code{Packet}s and @code{sk_buff}s

In the Linux kernel driver, @code{Packet} objects are equivalent to
@code{struct sk_buff}s. This avoids indirection overhead and makes it
cheap to pass packets back and forth between Linux and Click. The
@code{Packet} operations described in this section are mostly inline
functions that expand to conventional @code{sk_buff} calls like
@code{skb_clone()}.

Click @code{Packet} @code{sk_buff}s should always have @code{skb->users}
equal to 1. That is, the @code{sk_buff} headers should not be shared,
although the data buffers they point to may be shared.

The @code{make}, @code{skb}, and @code{steal_skb} methods described in
this section convert @code{Packet}s to @code{sk_buff}s and vice versa.

@deftypeop {Static Method} Packet {Packet *} make (@w{struct sk_buff *@var{skb}})
Returns a new packet equivalent to the @code{sk_buff} @var{skb}. All of
@var{skb}'s data pointers and annotations are left unchanged. This
method generally does nothing, since @code{Packet}s and @code{sk_buff}s
are equivalent in the Linux kernel. However, if @code{@var{skb}->users}
field is bigger than 1, the method will return a clone of @var{skb}.
This method returns a @code{Packet *}, not a @w{@code{WritablePacket
*}}, because the @var{skb} argument might share data with some other
@code{sk_buff}.

Do not use or manipulate @var{skb} after passing it to this method,
since Click and the @code{Packet} implementation now own @var{skb}.
@end deftypeop

@deftypemethod Packet {struct sk_buff *} skb ()
@deftypemethodx Packet {const struct sk_buff *} skb () const
Returns the @code{sk_buff} corresponding to this packet. Use this method
to examine the @code{sk_buff} version of a @code{Packet}.

Do not pass the result to a function that might free it or increment its
@code{users} field; use @code{steal_skb} for that.
@end deftypemethod

@deftypemethod Packet {struct sk_buff *} steal_skb ()
Returns the @code{sk_buff} corresponding to this packet. Use this
method to permanently change a @code{Packet} into an
@code{sk_buff}---for example, to create an @code{sk_buff} you'd like to
send to Linux.

Do not use or manipulate a @code{Packet} after calling its
@code{steal_skb} method, since Linux now owns the resulting
@code{sk_buff}.
@end deftypemethod


@node Packet Sharing, Packet Buffer Manipulation, Packets and sk_buffs, Packets
@section Sharing---@code{clone} and @code{uniqueify}

The @code{clone} method creates a new packet header that shares data
with an existing packet. The @code{uniqueify} method, in contrast,
ensures that a packet's data is not shared by anyone, perhaps by making
a copy of the data.

@deftypemethod Packet {Packet *} clone ()
Creates and returns a new packet header that shares this packet's data.
The new packet's annotations are copied from this packet's annotations.

The result may be a null pointer if there was not enough memory to make a
new packet header.
@end deftypemethod

@deftypemethod Packet {WritablePacket *} uniqueify ()
Ensures that this packet does not share data with any other packet. This
may involve copying the packet data, and perhaps creating a new packet
header, but if this packet is already unshared, no real work is
required. Returns a @w{@code{WritablePacket *}} because the new packet
is unshared.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{uniqueify} method. Manipulate the returned @w{@code{WritablePacket
*}} instead.

The result may be a null pointer if there was not enough memory to make a
required data copy. In this case, the old packet is freed.
@end deftypemethod

@deftypemethod Packet bool shared () const
Returns true if and only if this packet shares data with some other
packet.
@end deftypemethod


@node Packet Buffer Manipulation, Annotations, Packet Sharing, Packets
@section Buffer Manipulation---@code{push}, @code{pull}, @code{put}, and @code{take}

The @code{push}, @code{pull}, @code{put}, and @code{take} methods
manipulate a packet's contents by adding or removing space from its
headroom or tailroom. Given a packet, use @code{push} to add space to
its beginning, @code{pull} to remove space from its beginning,
@code{put} to add space to its end, and @code{take} to remove space from
its end. The methods that add space, @code{push} and @code{put},
uniqueify the relevant packet as a side effect. This ensures that the
packet's data is unshared so you can immediately manipulate the added
space.

@deftypemethod Packet {WritablePacket *} push (unsigned @var{amt})
Adds @var{amt} bytes of space to the beginning of the packet's data and
returns the resulting packet. The new space is uninitialized. The result
will not share data with any other packet; thus, it is a
@w{@code{WritablePacket *}}. If this packet is unshared and its headroom
is bigger than @var{amt}, then this operation is cheap, amounting to a
bit of pointer arithmetic. Otherwise, it requires copying the packet
data and possibly creating a new packet header.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{push} method. Manipulate the returned @w{@code{WritablePacket
*}} instead.

The result may be a null pointer if there was not enough memory to make a
required new packet. In this case, the old packet is freed.
@end deftypemethod

@deftypemethod Packet void pull (unsigned @var{amt})
Removes @var{amt} bytes of space from the beginning of the packet's
data. @var{amt} must be less than or equal to the packet's
@code{length()}. This operation is always cheap, amounting to a bit of
pointer arithmetic.
@end deftypemethod

@deftypemethod Packet {WritablePacket *} put (unsigned @var{amt})
Adds @var{amt} bytes of space to the end of the packet's data and
returns the resulting packet. The new space is uninitialized. The result
will not share data with any other packet; thus, it is a
@w{@code{WritablePacket *}}. If this packet is unshared and its tailroom
is bigger than @var{amt}, then this operation is cheap, amounting to a
bit of pointer arithmetic. Otherwise, it requires copying the packet
data and possibly creating a new packet header.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{put} method. Manipulate the returned @w{@code{WritablePacket *}}
instead.

The result may be a null pointer if there was not enough memory to make a
required new packet. In this case, the old packet is freed.
@end deftypemethod

@deftypemethod Packet void take (unsigned @var{amt})
Removes @var{amt} bytes of space from the end of the packet's data.
@var{amt} must be less than or equal to the packet's @code{length()}.
This operation is always cheap, amounting to a bit of pointer
arithmetic.
@end deftypemethod

The @code{push} and @code{put} methods have ``nonunique'' variants,
@code{nonunique_push} and @code{nonunique_put}, which do not have the
side effect of uniqueifying their resulting packet. These methods are
rarely used.

@deftypemethod Packet {Packet *} nonunique_push (unsigned @var{amt})
Adds @var{amt} bytes of space to the beginning of the packet's data and
returns the resulting packet. The new space is uninitialized. The result
may share data with other packets. If this packet's headroom is bigger
than @var{amt}, then this operation is cheap, amounting to a bit of
pointer arithmetic. Otherwise, it requires copying the packet data and
possibly creating a new packet header.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{nonunique_push} method. Manipulate the returned @w{@code{Packet
*}} instead.

The result may be a null pointer if there was not enough memory to make a
required new packet. In this case, the old packet is freed.
@end deftypemethod

@deftypemethod Packet {Packet *} nonunique_put (unsigned @var{amt})
Adds @var{amt} bytes of space to the end of the packet's data, returning
the resulting packet. The new space is uninitialized. The result may
share data with other packets. If this packet's tailroom is bigger than
@var{amt}, then this operation is cheap, amounting to a bit of pointer
arithmetic. Otherwise, it requires copying the packet data and possibly
creating a new packet header.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{nonunique_put} method. Manipulate the returned @w{@code{Packet *}}
instead.

The result may be a null pointer if there was not enough memory to make a
required new packet. In this case, the old packet is freed.
@end deftypemethod


@node Annotations, Packet Out-of-Memory, Packet Buffer Manipulation, Packets
@section Annotations

Each packet header has space for a number of @dfn{annotations}, extra
information about the packet that is not contained in its data. Click
supports @dfn{header annotations}, which indicate where in the packet a
network header, such as an IP header, is located; @dfn{user
annotations}, whose semantics are left undefined by Click---different
elements can treat them in different ways; and other specialized
annotations, such as the @dfn{timestamp annotation}, the
@dfn{destination IP address annotation}, and so forth.

New packets begin with all annotations cleared: numeric annotations are
zero, pointer annotations are null pointers. @code{clone},
@code{uniqueify}, and their equivalents always copy each of the original
packet's annotations in the appropriate way. (For example, the new
header annotations will point into the new data, if a data copy was
made.)

@menu
* Header Annotations::          
* User Annotations::            
* Specific User Annotations::   
* Other Annotations::           
* Annotations In General::      
@end menu

@node Header Annotations, User Annotations, Annotations, Annotations
@subsection Header Annotations

Many packets contain a network header of some kind, such as an IP
header. This header may be located anywhere in the packet depending on
how the packet was encapsulated. Furthermore, the data encapsulated by
that network header may be located anywhere after the network header,
given the presence of options. With the @dfn{network header annotation}
and the @dfn{transport header annotation}, one element can determine
where a network header is and how long it is, then store this
information for other elements to use. For example, the
@click{CheckIPHeader} element sets the header annotations on packets it
receives. Elements like @click{SetIPDSCP} then require a non-null IP
header annotation on their input packets.

The header annotations on new packets are each set to a null pointer.

@deftypemethod Packet {const unsigned char *} network_header () const
@deftypemethodx WritablePacket {unsigned char *} network_header () const
Returns the network header annotation. The resulting pointer is
read-only on @code{Packet}s and read/write on @code{WritablePacket}s.
@end deftypemethod

@deftypemethod Packet {const unsigned char *} transport_header () const
@deftypemethodx WritablePacket {unsigned char *} transport_header () const
Returns the transport header annotation. The resulting pointer is
read-only on @code{Packet}s and read/write on @code{WritablePacket}s.
@end deftypemethod

@deftypemethod Packet int network_header_offset () const
Returns the offset from @code{data()} to @code{network_header()}. The
result might be negative, since the @code{data} pointer may have been
advanced past the network header annotation with the @code{pull} method.
@end deftypemethod

@deftypemethod Packet int network_header_length () const
Returns the network header's length. This equals
@code{transport_header()} @minus{} @code{network_header()}.
@end deftypemethod

@deftypemethod Packet unsigned transport_header_offset () const
Returns the offset from @code{data()} to @code{transport_header()}. The
result might be negative, since the @code{data} pointer may have been
advanced past the transport header annotation with the @code{pull} method.
@end deftypemethod

Several invariants relate these methods' values whenever the header
annotations are non-null:

@display
@code{buffer_data()} @math{@leq} @code{network_header()} @math{@leq} @code{transport_header()}
             @math{@leq} @code{buffer_data()} @math{+} @code{buffer_length()}
@code{network_header_offset()} @math{=} @code{network_header()} @minus{} @code{data()}
@code{transport_header_offset()} @math{=} @code{transport_header()} @minus{} @code{data()}
@code{network_header_length()} @math{=} @code{transport_header()} @minus{} @code{network_header()}
@end display

@sp 1

Set the network and transport header annotations simultaneously with the
@code{set_network_header} method.

@deftypemethod Packet void set_network_header (@w{const unsigned char *@var{header}}, @w{unsigned @var{len}})
Sets the network header annotation to @var{header}, which must lie
between @code{buffer_data()} and @code{buffer_data()} @math{+}
@code{buffer_length()}. The network header is @var{len} bytes long, so
@code{network_header_length()} will equal @var{len} and
@code{transport_header()} will equal @var{header} @math{+} @var{len}.
@end deftypemethod

@subsubsection Typed Header Annotations

For convenience, @code{Packet} provides methods for accessing and
setting the network header annotation as an IP or IPv6 header. These
methods use the same annotations as the generic @code{network_header}
methods; they are just typed differently.

@deftypemethod Packet {const click_ip *} ip_header () const
@deftypemethodx WritablePacket {click_ip *} ip_header () const
@deftypemethodx Packet {const click_ip6 *} ip6_header () const
@deftypemethodx WritablePacket {click_ip6 *} ip6_header () const
Returns @code{network_header()} as a pointer to an IP or IPv6 header
structure.
@end deftypemethod

@deftypemethod Packet int ip_header_offset () const
@deftypemethodx Packet unsigned ip_header_length () const
@deftypemethodx Packet int ip6_header_offset () const
@deftypemethodx Packet unsigned ip6_header_length () const
Equivalent to @code{network_header_offset()} and
@code{network_header_length()}.
@end deftypemethod

@deftypemethod Packet void set_ip_header (@w{const click_ip *@var{header}}, @w{unsigned @var{len}})
@deftypemethodx Packet void set_ip6_header (@w{const click_ip6 *@var{header}}, @w{unsigned @var{len}})
Equivalent to @code{set_network_header(@var{header}, @var{len})}.
@end deftypemethod

@deftypemethod Packet void set_ip6_header (@w{const click_ip6 *@var{header}})
Equivalent to @code{set_ip6_header(@var{header}, 40)}.
@end deftypemethod

@deftypemethod Packet {const click_tcp *} tcp_header () const
@deftypemethodx WritablePacket {click_tcp *} tcp_header () const
@deftypemethodx Packet {const click_udp *} udp_header () const
@deftypemethodx WritablePacket {click_udp *} udp_header () const
Returns @code{transport_header()} as a pointer to a TCP or UDP header
structure.
@end deftypemethod


@node User Annotations, Specific User Annotations, Header Annotations, Annotations
@subsection User Annotations

Each packet header has a @dfn{user annotation area}, space reserved for
arbitrary annotations. Different methods access this space as an array
of bytes, integers, or unsigned integers. The @code{Packet} class does
not assign semantics to any particular byte in the user annotation area.
Instead, macros in @w{@samp{<click/packet_anno.hh>}} provide names for
particular bytes. Some of these names have overlapping byte ranges; the
user must take care not to define a configuration whose elements use an
annotation byte on a packet for different purposes. The next section
describes the macros in Click's default
@w{@samp{<click/packet_anno.hh>}}.

These constants define the size of the annotation area.

@table @code
@item Packet::USER_ANNO_SIZE
The size of the annotation area in bytes.
@item Packet::USER_ANNO_U_SIZE
The size of the annotation area in @code{unsigned int}s.
@item Packet::USER_ANNO_I_SIZE
The size of the annotation area in @code{int}s.
@end table

@noindent
Currently, @code{USER_ANNO_SIZE} is 12 and @code{USER_ANNO_U_SIZE} and
@code{USER_ANNO_I_SIZE} are both 3.

The user annotation area may be accessed as an array of bytes, an array
of @code{unsigned int}s, or an array of @code{int}s. The elements of
these arrays are numbered from 0 to @math{@var{k} - 1}, where @var{k} is
the appropriate @code{SIZE} constant.

@deftypemethod Packet {unsigned char} user_anno_c (@w{int @var{i}}) const
Returns the @var{i}th byte in the user annotation area. @var{i} must be
between 0 and @code{USER_ANNO_SIZE} @minus{} 1.
@end deftypemethod

@deftypemethod Packet unsigned user_anno_u (@w{int @var{i}})
@deftypemethodx Packet int user_anno_i (@w{int @var{i}})
Returns the @var{i}th @code{unsigned int} or @code{int} in the user
annotation area. @var{i} must be between 0 and @code{USER_ANNO_U_SIZE}
@minus{} 1. The @var{i}th @code{unsigned int} or @code{int} annotation
occupies bytes @math{4@var{i}} through @math{4@var{i} + 3} of the user
annotation area.
@end deftypemethod

@deftypemethod Packet void set_user_anno_c (@w{int @var{i}}, @w{unsigned char @var{value}})
@deftypemethodx Packet void set_user_anno_u (@w{int @var{i}}, @w{unsigned @var{value}})
@deftypemethodx Packet void set_user_anno_i (@w{int @var{i}}, @w{int @var{value}})
Sets the @var{i}th byte, @code{unsigned int}, or @code{int} user
annotation to @var{value}.
@end deftypemethod

@deftypemethod Packet {unsigned *} all_user_anno_u ()
Returns a pointer to the user annotation area, treated as an array of
@code{unsigned int}s.
@end deftypemethod


@node Specific User Annotations, Other Annotations, User Annotations, Annotations
@subsection Specific User Annotations

The @w{@samp{<click/packet_anno.hh>}} header file defines macros for
accessing a packet's user annotation area by name. These macros follow
some simple guidelines. Each user annotation is given a name like
@samp{PAINT} or @samp{FIX_IP_SRC}. Then, two macros are written for each
annotation, @code{@var{name}_ANNO} and @code{SET_@var{name}_ANNO}.

@deftypefn {Macro} {} {@var{name}_ANNO} (@w{const Packet *@var{p}})
Returns the value of @var{p}'s @var{name} annotation.
@end deftypefn

@deftypefn {Macro} {} {SET_@var{name}_ANNO} (@w{Packet *@var{p}}, @var{value})
Sets @var{p}'s @var{name} annotation to @var{value}.
@end deftypefn

@noindent
For example, here are the definitions of @code{PAINT_ANNO} and
@code{SET_PAINT_ANNO} from Click's default
@samp{<click/packet_anno.hh>}.

@example
#define PAINT_ANNO(p)          ((p)->user_anno_c(0))
#define SET_PAINT_ANNO(p, v)   ((p)->set_user_anno_c(0, (v)))
@end example

@sp 1

This table lists the annotations declared in Click's default
@samp{<click/packet_anno.hh>}.

@multitable {@code{ICMP_PARAM_PROB}} {@code{unsigned char}} {Bytes} {Blah,blah,blah,blah,blah,blah,blah,blah}
@item Annotation name
@tab Type
@tab Bytes
@tab Some relevant elements
@item @code{PAINT}
@tab @code{unsigned char}
@tab 0
@tab @click{Paint}, @click{CheckPaint}, @click{PaintTee}
@item @code{ICMP_PARAM_PROB}
@tab @code{unsigned char}
@tab 1
@tab @click{IPGWOptions}, @click{ICMPError}
@item @code{FIX_IP_SRC}
@tab @code{unsigned char}
@tab 3
@tab @click{ICMPError}, @click{FixIPSrc}
@item @code{FWD_RATE}
@tab @code{int}
@tab 4--7
@tab @click{IPRateMonitor}
@item @code{REV_RATE}
@tab @code{int}
@tab 8--11
@tab @click{IPRateMonitor}
@end multitable


@node Other Annotations, Annotations In General, Specific User Annotations, Annotations
@subsection Other Annotations

Packet headers have space for four other particular annotations, and
special methods for accessing them. These annotations do not overlap the
user annotation area. There are annotations that hold a destination IP
address, a timestamp, the device on which the packet arrived, a packet
type constant, and, in the Linux kernel module, a performance counter
value.

@menu
* Destination Address Annotation::  
* Timestamp Annotation::        
* Device Annotation::           
* Packet Type Annotation::      
* Performance Counter Annotation::  
@end menu

@node Destination Address Annotation, Timestamp Annotation, Other Annotations, Other Annotations
@subsubsection Destination Address

The destination address annotation stores the IP or IPv6 address of the
next hop towards the packet's destination. Elements check and manipulate
this address, rather than the IP header's destination address, since the
next-hop address often differs from the final destination. The
destination IP address and IPv6 address are different annotations, but
they overlap; you may set only one at a time.

@deftypemethod Packet IPAddress dst_ip_anno () const
Returns this packet's destination IP address annotation.
@end deftypemethod

@deftypemethod Packet {const IP6Address &} dst_ip6_anno () const
Returns a reference to this packet's destination IPv6 address
annotation.
@end deftypemethod

@deftypemethod Packet void set_dst_ip_anno (@w{IPAddress @var{value}})
@deftypemethodx Packet void set_dst_ip6_anno (@w{const IP6Address &@var{value}})
Sets this packet's destination IP or IPv6 address annotation to
@var{value}.
@end deftypemethod

The destination IP address annotation is set by the @click{GetIPAddress}
and @click{SetIPAddress} elements, manipulated by @click{LookupIPRoute}
and its cousins, and used by @click{ARPQuerier}. It defaults to zero.

@node Timestamp Annotation, Device Annotation, Destination Address Annotation, Other Annotations
@subsubsection Timestamp

The timestamp annotation generally indicates when a packet was received.

@deftypemethod Packet {const struct timeval &} timestamp_anno () const
@deftypemethodx Packet {struct timeval &} timestamp_anno ()
Returns a reference to this packet's timestamp annotation.
@end deftypemethod

@deftypemethod Packet void set_timestamp_anno (@w{const struct timeval &@var{value}})
Sets this packet's timestamp annotation to @var{value}.
@end deftypemethod

@deftypemethod Packet void set_timestamp_anno (@w{int @var{sec}}, @w{int @var{usec}})
Sets this packet's timestamp annotation to @var{sec} and @var{usec}.
Equivalent to @code{struct timeval tv; tv.tv_sec = @var{sec}; tv.tv_usec
= @var{usec}; set_timestamp_anno(tv)}.
@end deftypemethod

Linux device drivers set this annotation, so packets emitted by
@click{FromDevice} and @click{PollDevice} in the Linux kernel driver
have the annotation set. Packet sources like @click{InfiniteSource} and
@click{RatedSource} also set the annotation, as does @click{FromDump} in
the user-level driver. Debugging elements like @click{Print} generally
take a keyword argument that makes them print packet timestamps.

The timestamp annotation defaults to zero.

@node Device Annotation, Packet Type Annotation, Timestamp Annotation, Other Annotations
@subsubsection Device

In the Linux kernel, packets received from some device are annotated
with a pointer to the relevant @code{struct net_device} object. (In
versions of the kernel prior to 2.3, this type was called @code{struct
device}.) The @code{Packet} class provides access to this annotation.
The annotation has type @w{@code{net_device *}}; Click defines
@code{net_device} as a synonym for @code{struct device} in kernel
versions 2.2 and prior.

@deftypemethod Packet {net_device *} device_anno () const
Returns this packet's device annotation.
@end deftypemethod

@deftypemethod Packet void set_device_anno (@w{net_device *@var{value}})
Sets this packet's device annotation to @var{value}.
@end deftypemethod

@noindent
In the user-level driver, @code{device_anno} always returns 0, and
@code{set_device_anno} does nothing.

The @click{ARPResponder} element sets this annotation on every generated
response to the value of the annotation on the relevant query. Because
of this, those responses can be safely forwarded to Linux: Linux's
ARP-response code requires a correct device annotation.

The device annotation defaults to a null pointer.

@node Packet Type Annotation, Performance Counter Annotation, Device Annotation, Other Annotations
@subsubsection Packet Type

The packet type annotation specifies how a packet was received. Its
value is one of the following constants, which are defined in the
@code{Packet::PacketType} enumeration.

@table @asis
@item @samp{HOST}
The packet was sent to this host.

@item @samp{BROADCAST}
The packet was sent to a link-level broadcast address.

@item @samp{MULTICAST}
The packet was sent to a link-level multicast address.

@item @samp{OTHERHOST}
The packet was sent to a different host, but received anyway. The
relevant device is probably in promiscuous mode.

@item @samp{OUTGOING}
The packet was generated at this host and is being sent to another host.

@item @samp{LOOPBACK}, @samp{FASTROUTE}
See the Linux kernel documentation. These values correspond to
@samp{PACKET_LOOPBACK} and @samp{PACKET_FASTROUTE}, which are defined in
@samp{<linux/if_packet.h>}.
@end table

@deftypemethod Packet {Packet::PacketType} packet_type_anno () const
Returns this packet's packet type annotation.
@end deftypemethod

@deftypemethod Packet void set_packet_type_anno (@w{Packet::PacketType @var{value}})
Sets this packet's packet type annotation to @var{value}.
@end deftypemethod

In the Linux kernel, device drivers set the packet type annotation for
the packets they receive. Thus, the @click{FromDevice} and
@click{PollDevice} elements generate packets with correct packet type
annotations. The user-level driver's @click{FromDevice} also sets the
packet type annotation. The @click{ICMPError} and @click{DropBroadcasts}
elements use the annotation's value.

The packet type annotation defaults to @code{Packet::HOST}.

@node Performance Counter Annotation,  , Packet Type Annotation, Other Annotations
@subsubsection Performance Counter

This annotation is available only in the Linux kernel driver. Its value
is an @code{unsigned long long} that generally corresponds to some
performance counter value.

@deftypemethod Packet {unsigned long long} perfctr_anno () const
Returns this packet's performance counter annotation.
@end deftypemethod

@deftypemethod Packet void set_perfctr_anno (@w{unsigned long long @var{value}})
Sets this packet's performance counter annotation to @var{value}.
@end deftypemethod

The @click{SetCycleCount}, @click{SetPerfCount},
@click{CycleCountAccum}, and @click{PerfCountAccum} elements manipulate
this annotation. Its default value is zero.


@node Annotations In General,  , Other Annotations, Annotations
@subsection Annotations In General

@code{Packet} provides methods for clearing a packet's annotations, and
for copying all of a packet's annotations from another packet.

@deftypemethod Packet void clear_annotations ()
Clears all of this packet's annotations to their default state, which is
generally zero.
@end deftypemethod

@deftypemethod Packet void copy_annotations (const Packet *@var{p})
Copies all of @var{p}'s annotations into this packet except for its
header annotations. (This packet's current header annotations are left
unchanged.)
@end deftypemethod


@node Packet Out-of-Memory,  , Annotations, Packets
@section Out-of-Memory Conditions

Any method that potentially allocates memory for a @code{Packet} may
fail due to an out-of-memory condition. The complete list of these
methods follows:

@itemize @bullet
@item @code{make} variants
@item @code{clone}
@item @code{uniqueify}
@item @code{push}
@item @code{put}
@item @code{nonunique_push}
@item @code{nonunique_put}
@end itemize

@noindent
These methods always return a null pointer on out-of-memory. Methods
that manipulate existing packets---@code{uniqueify}, @code{push},
@code{put}, @code{nonunique_push}, and
@code{nonunique_put}---additionally free any existing packet before
returning a null pointer. You should always check the results of these
methods to see if you have run out of memory.


@node Element Characteristics, Element Initialization, Packets, Top
@chapter Element Characteristics

@menu
* Element Class::               
* Element Casting::             
* Element Names::               
* Element Router::              
* Creating Element Ports::      
* Using Element Ports::         
* When to Call Element Methods::  
@end menu

@node Element Class, Element Casting, Element Characteristics, Element Characteristics
@section Element Class

Every element belongs to a single element class, and every element class
has a name. The @code{class_name} virtual function returns that name.

@deftypemethod Element {virtual const char *} class_name () const
Returns the element's class name as a null-terminated C string. This
method has no default implementation; every element must supply a
definition.

The @code{class_name} method should be declared on a single line in the
element's class definition, and should return a C string constant. This
makes the element's class name easy to automatically extract from the
source code.

Here is a typical @code{class_name} method.

@example
class ARPQuerier : public Element @{ public: // ...
    const char *class_name() const @{ return "ARPQuerier"; @}
@}
@end example
@end deftypemethod

Click creates new element objects by cloning existing element objects.
The system maintains one prototype element for each element class it
understands. When a router configuration declares a new element, the
system finds the appropriate prototype and calls its @code{clone}
method. This method creates and returns a new element with the same
element class as the prototype.

@deftypemethod Element {virtual Element *} clone () const
Returns a new element with the same element class as this element. This
method has no default implementation; every element must supply a
definition.

The @code{clone} method should return a completely fresh element object.
In particular, the resulting element should not be configured or
initialized, and should not share this element's configuration state. It
will be configured independently through element initialization methods;
see @ref{Element Initialization}, for more information.

Here is a typical @code{clone} method.

@example
class ARPQuerier : public Element @{ public: // ...
    ARPQuerier *clone() const @{ return new ARPQuerier; @}
@}
@end example

@noindent
Note that @code{clone}'s return type has been changed to
@code{ARPQuerier *} rather than @w{@code{Element *}}. This is considered
good style, since it makes the types more specific, but it is not really
necessary. @code{clone} need not be defined in the class definition,
although many elements do define it this way.
@end deftypemethod


@node Element Casting, Element Names, Element Class, Element Characteristics
@section Casting

Each element conforms to one or more named @dfn{interfaces}. Each
element class is an interface, whose name is just the element class
name, but the user can create additional interfaces at will. Generally,
these interfaces export functionality that elements may be interested
in, but that is not specific to any one element class. For example, the
@click{Storage} interface provides information about how many packets
are stored in an element; elements that implement this interface include
@click{Queue}, @click{FrontDropQueue}, and @click{FromDevice}. Elements
interested in packet storage, such as @click{RED}, then look for
@click{Storage} elements, making them independent of any particular
storage strategy.

A caller can discover whether an element implements a particular
interface by calling its @code{cast} method. This method takes an
interface name and returns a non-null pointer if and only if the
element implements that interface.

@deftypemethod Element {virtual void *} cast (const char *@var{name})
The @var{name} argument is an interface name, represented as a
null-terminated C string. If this element implements the @var{name}
interface, @code{cast} should return a pointer to the corresponding
data. If it does not, @code{cast} should return a null pointer.

The default representation returns @code{this} if @var{name} equals the
element's @code{class_name()}, or a null pointer if it does not.
@end deftypemethod

Some care is required when one element class is a subclass of another.
Say that element class @code{Derived} is a subclass of @code{Base}. Then
@code{Derived}'s @code{cast} method should return a non-null pointer
when passed either @code{"Derived"}, @code{"Base"}, or any additional
interfaces that @code{Derived} or @code{Base} might implement. Here is a
first try at @code{Derived}'s @code{cast} implementation:

@example
void *
Derived::cast(const char *name)
@{
    if (strcmp(name, "Derived") == 0)
        return (Derived *)this;
    else // rely on Base::cast to check for "Base"
        return Base::cast(name);
@}
@end example

@noindent
This code is correct and preferred as long as @code{Base} has its own
@code{cast} implementation. Unfortunately, if @code{Base} took advantage
of @code{cast}'s default implementation, which uses @code{class_name},
the code is broken. Since a @code{Derived} element's @code{class_name}
method returns @code{"Derived"}, the default @code{cast} method will
check only for @code{"Derived"}, not for @code{"Base"} as we wished. The
solution is either to write an explicit @code{cast} method for
@code{Base}, or to write @code{Derived::cast} differently---like so, for
example:

@example
void *
Derived::cast(const char *name)
@{
    if (strcmp(name, "Derived") == 0)
        return (Derived *)this;
    else if (strcmp(name, "Base") == 0)
        return (Base *)this;
    else
        return 0;
@}
@end example

Always explicitly cast @code{this} to the correct type before returning
it. This is important because of multiple inheritance, where the value
of a pointer to a supertype may be different from the value of
@code{this}. (The type system generally determines when pointer
arithmetic is necessary, but the @w{@code{void *}} return type hides
this type information from @code{cast}'s caller.)

We encourage you to write simple @code{cast} methods that compare the
@var{name} argument against a set of fixed strings. Arbitrary
computation inside @var{cast} is discouraged; we may eventually want to
analyze @code{cast} definitions.

Click uses a @code{cast} method rather than C++'s standard
@code{dynamic_cast} mechanism because it's difficult to use
@code{dynamic_cast} in the Linux kernel.


@node Element Names, Element Router, Element Casting, Element Characteristics
@section Names

Each element in a router configuration has a @dfn{name} under which it
was declared and a @dfn{landmark}, a string indicating where it was
declared in the configuration file.

@deftypemethod Element String id () const
Returns the element's name.
@end deftypemethod

@deftypemethod Element String declaration () const
Returns a textual representation of the element's declaration. The
result has the form @w{@samp{@var{id} :: @var{cname}}}, where @var{id}
is the element's @code{id()} and @var{cname} is its @code{class_name()}.
@end deftypemethod

@deftypemethod Element String landmark () const
Returns a string indicating where the element was declared in the
configuration file. The result generally has the form
@samp{@var{filename}:@var{linenumber}}.
@end deftypemethod



@node Element Router, Creating Element Ports, Element Names, Element Characteristics
@section Router Relationship

Elements may be part of some router configuration, which is represented
by a @code{Router} object. Elements in a @code{Router} are numbered
between 0 and that router's @code{nelements()}; @code{eindex} returns
that number.

@deftypemethod Element {Router *} router () const
Returns the element's corresponding @code{Router} object.
@end deftypemethod

@deftypemethod Element int eindex () const
Returns the element's index in its router.
@end deftypemethod

@deftypemethod Element int eindex (Router *@var{r}) const
Returns the element's index in its router, if that router is @var{r}, or
@math{-1}, if that router is not @var{r}. Equivalent to:

@example
return (router() == @var{r} ? eindex() : -1);
@end example
@end deftypemethod


@node Creating Element Ports, Using Element Ports, Element Router, Element Characteristics
@section Creating Ports

These methods return or change how many input and output ports an
element has.

@deftypemethod Element int ninputs () const
@deftypemethodx Element int noutputs () const
Returns the element's number of input or output ports.
@end deftypemethod

The @code{set_} and @code{add_} methods, which add or remove ports, must
be called only by the element itself. For example, the Click
infrastructure never calls @code{set_ninputs} or @code{set_noutputs}.
Click will inform the element how many of its ports were used in a
particular router configuration; see @ref{notify_ninputs
notify_noutputs}.

You may change an element's number of ports only during router
initialization. You may not, for example, call @code{set_ninputs} at run
time, or even during the element's @code{initialize} method
(@pxref{initialize}). @xref{When to Call Element Methods}, for more
information.

@deftypemethod Element void set_ninputs (int @var{n}) const
@deftypemethodx Element void set_noutputs (int @var{n}) const
Sets the element's number of input or output ports to @var{n}, which
must be greater than or equal to zero.
@end deftypemethod

@deftypemethod Element void add_input () const
@deftypemethodx Element void add_output () const
Add an input or output port to the element. Same as
@code{set_ninputs(ninputs() + 1)} or @code{set_noutputs(noutputs() +
1)}.
@end deftypemethod


@node Using Element Ports, When to Call Element Methods, Creating Element Ports, Element Characteristics
@section Using Ports

Each of an element's input and output ports is represented by an
@code{Element::Port} object. The @code{input} and @code{output} methods
return the @code{Port} object corresponding to a given port number.

@deftypemethod Element {const Port &} input (int @var{p}) const
@deftypemethodx Element {const Port &} output (int @var{p}) const
Returns the @code{Element::Port} object corresponding to the
element's @var{p}th input or output port. @var{p} must be a valid port
number: greater than or equal to zero and less than @code{ninputs()} or
@code{noutputs()}, respectively.
@end deftypemethod

The following methods return information about a port.
@code{input_is_pull} and @code{output_is_push} are @code{Element}
methods; the rest are methods on @code{Element::Port}. All of these
methods return meaningful results only after the router has been
partially initialized; see @ref{When to Call Element Methods}.

@deftypemethod Element bool input_is_pull (int @var{p}) const
@deftypemethodx Element bool output_is_push (int @var{p}) const
Returns true if input port @var{p} is pull or output port @var{p} is
push, respectively. @var{p} must be a valid port number.
@end deftypemethod

@deftypemethod {Element::Port} {Element *} element () const
Returns the element this port is connected to, if one exists. Pull input
ports and push output ports are always connected to another element;
push input ports and pull output ports never are. @code{element()}
returns a null pointer when called on a push input port or pull output
port.
@end deftypemethod

@deftypemethod {Element::Port} int port () const
Returns the port number this port is connected to, if one exists. Pull
input ports and push output ports are always connected to another port;
push input ports and pull output ports never are. @code{port()} returns
@math{-1} when called on a push input port or pull output port.
@end deftypemethod

For example, consider this router configuration.

@example
x :: X; y :: Y;
x [0] -> [1] y; // push connection
@end example

@noindent
Because @code{x [0]} is a push output port,
@code{x->output(0).element()} will return @code{y} and
@code{@w{x->}output(0).port()} will return 1. On the other hand,
@code{@w{y->}input(1).element()} will return a null pointer and
@code{@w{y->}input(1).port()} will return @math{-1}.

The @code{element} and @code{port} methods only supply local information
about how elements are connected. Furthermore, they provide no
information about how push input ports and pull output ports are
connected. For these reasons, most elements interested in router
configuration topology call @code{Router}'s @code{upstream_elements} and
@code{downstream_elements} methods instead.


@node When to Call Element Methods,  , Using Element Ports, Element Characteristics
@section When Element Methods May Be Called

This chart shows when it is OK to call particular @code{Element}
methods. Methods not mentioned here are generally not called by the
user; for example, most users won't need to call @code{clone}.

@example
  Method Name                    constr notify config  init   run  
+-------------------------------+------+------+------+------+------+
| class_name, cast              |  OK  |  OK  |  OK  |  OK  |  OK  |
| id, declaration, landmark     |      |  OK  |  OK  |  OK  |  OK  |
| router, eindex                |      |  OK  |  OK  |  OK  |  OK  |
+-------------------------------+------+------+------+------+------+
| ninputs, noutputs             |  OK  |  OK  |  OK  |  OK  |  OK  |
| set_ninputs, set_noutputs     |  OK  |  OK  |  OK  |      |      |
| add_input, add_output         |  OK  |  OK  |  OK  |      |      |
+-------------------------------+------+------+------+------+------+
| input, output                 |      |      |      |  OK  |  OK  |
| input_is_pull, output_is_push |      |      |      |  OK  |  OK  |
| Port::element, Port::port     |      |      |      |  OK  |  OK  |
+-------------------------------+------+------+------+------+------+
  Method Name                    constr notify config  init   run  
@end example

The headings denote:

@table @samp
@item constr
Construction time. This includes the element's constructor and its
destructor.

@item notify
Inside the @code{notify_ninputs} and @code{notify_noutputs} methods.

@item config
Inside the @code{configure} method.

@item init
Inside the @code{add_handlers}, @code{initialize}, and
@code{uninitialize} methods.

@item run
At run time. That is, inside some @code{push} or @code{pull} method,
or some task or timer callback, or some handler, or some function
called from one of these places.
@end table


@node Element Initialization, Element Runtime, Element Characteristics, Top
@chapter Element Initialization

The process of making an element ready for inclusion in an active router
is called @dfn{element initialization}. This includes processing the
element's configuration string, setting up internal state and any input
and output ports, and querying the router about neighboring elements.

Every element in an active router must have successfully initialized. If
there is an error initializing even one element, the router is aborted.
Router initialization happens in sequential phases: every element must
successfully complete one phase before the next phase begins.

@menu
* notify_ninputs notify_noutputs::  
* configure_phase::             
* configure::                   
* processing::                  
* flow_code::                   
* add_handlers::                
* initialize::                  
* uninitialize::                
* Initialization Phases::       
@end menu


@node notify_ninputs notify_noutputs, configure_phase, Element Initialization, Element Initialization
@section @code{notify_ninputs} and @code{notify_noutputs}

The router calls each element's @code{notify_ninputs} and
@code{notify_noutputs} methods to tell it how many of its input and
output ports were used in the configuration. A port is used if it is
used in a connection.

@deftypemethod Element {virtual void} notify_ninputs (int @var{ninputs})
@deftypemethodx Element {virtual void} notify_noutputs (int @var{noutputs})

The @var{ninputs} and @var{noutputs} arguments specify how many input
and output ports were used in the configuration. For example, if
@var{ninputs} is 5, then input ports 0 through 4 were
used.@footnote{Strictly speaking, it is possible that one or more of the
lower-numbered ports were not used---for example, that input port 0 was
not used by the configuration. This is always a configuration error,
however. A later stage will report unused ports as errors and abort
router initialization.}

These methods' default implementations do nothing.
@end deftypemethod

@code{notify_ninputs} and @code{notify_noutputs} are called early in the
initialization process---before @code{configure}, for example, and
before ports are assigned to push or pull. They may create and destroy
input and output ports or set other private element state.

A @code{notify_ninputs} or @code{notify_noutputs} method should
generally be very short and stylized. It should call no Element methods
except for possibly @code{set_ninputs} or @code{set_noutputs}. This
typical @code{notify_noutputs} method sets the element's number of
outputs to one or two, depending on how many outputs were actually used:

@example
void
ARPQuerier::notify_noutputs(int n)
@{
    set_noutputs(n < 2 ? 1 : 2);
@}
@end example

There is no need to supply a @code{notify_ninputs} or
@code{notify_noutputs} method if your element has a fixed number of
inputs or outputs.


@node configure_phase, configure, notify_ninputs notify_noutputs, Element Initialization
@section @code{configure_phase}---Initialization Order

Some elements depend on being configured and initialized before or after
other elements. For example, the @click{AddressInfo} element must be
configured before all other elements, since its address abbreviations
must be available in their configuration strings. The
@code{configure_phase} method makes this possible.

@deftypemethod Element {virtual int} configure_phase () const
Returns the element's @dfn{configure phase}, an integer that specifies
when it should be configured and initialized relative to other elements.

An element with a low configure phase will be configured before an
element with a high configure phase. Elements with the same configure
phase might be configured in any order relative to one another.

The following basic configure phase constants are defined in
@code{<click/element.hh>}:

@table @code
@item CONFIGURE_PHASE_FIRST
Configure before most other elements. Only used by @click{AddressInfo}
in the Click distribution.
@item CONFIGURE_PHASE_INFO
Configure early. Appropriate for most information elements.
@item CONFIGURE_PHASE_DEFAULT
Default configuration phase. Appropriate for most elements.
@item CONFIGURE_PHASE_LAST
Configure after most other elements. No elements in the Click
distribution use this configure phase.
@end table

@code{configure_phase} may also return a number based on these
constants. For example, all @click{FromLinux} elements should be
initialized before any @click{ToDevice} elements. The @click{FromLinux}
element therefore contains the following definitions:

@example
enum @{ CONFIGURE_PHASE_FROMLINUX = CONFIGURE_PHASE_DEFAULT,
       CONFIGURE_PHASE_TODEVICE = CONFIGURE_PHASE_FROMLINUX + 1 @};
@end example

@noindent
@code{FromLinux::configure_phase} returns
@code{CONFIGURE_PHASE_FROMLINUX}, and @code{ToDevice::configure_phase}
returns @code{FromLinux::CONFIGURE_PHASE_TODEVICE}.

The default implementation returns @code{CONFIGURE_PHASE_DEFAULT}.
@end deftypemethod

Click uses all elements' configure phases to construct a single element
configuration order. It then configures elements in this order and, if
there were no errors, initializes them in the same order. The
@code{configure_phase} method is called once, relatively early---before
@code{configure} and @code{initialize}.

An element's configure phase should depend only on its class. In
particular, the body of a @code{configure_phase} method should consist
of a single @code{return} statement returning some constant.


@node configure, processing, configure_phase, Element Initialization
@section @code{configure}---Parsing Configure Strings

The @code{configure} method is passed the element's configuration
string. This method is expected to parse the configuration string,
report any errors, and initialize the element's internal state.

@deftypemethod Element {virtual int} configure (Vector<String> &@var{conf}, ErrorHandler *@var{errh})
The @var{conf} argument is the element's configuration string, divided
into configuration arguments by splitting at commas, and with comments
and leading and trailing whitespace removed. If @var{conf} is empty, the
element was not supplied with a configuration string (or its
configuration string contained only comments and whitespace).

Any errors, warnings, or messages should be reported to @var{errh}.
Messages should not specify the element name or type; this information
will be supplied externally.

This method should return zero if configuration succeeds, or a negative
number if it fails. Returning a negative number prevents the router from
initializing.

The default @code{configure} method succeeds if and only if there are no
configuration arguments.

The method may modify @var{conf} however it would like.
@end deftypemethod

@code{configure} is called relatively early in the initialization
process. For instance, @code{configure} may create or destroy input and
output ports---the port validity check happens after @code{configure}
completes. @code{configure} cannot determine whether a port is push or
pull; neither can it query the router for information about its
neighbors.

A @code{configure} method should not perform potentially harmful
actions, such as truncating files or attaching to devices. These actions
should be left for the @code{initialize} method, which is called later.
This avoids harm if another element cannot be configured, or if the
router is incorrectly connected, since in these cases @code{initialize}
will never be called.

The @var{conf} argument is created by calling @code{cp_argvec} on the
element's configuration string; see @ref{Config String Splitting}.


@node processing, flow_code, configure, Element Initialization
@section @code{processing}---Push and Pull Processing

Elements use the @code{processing} method to specify whether their ports
are push, pull, or agnostic. This method returns a @dfn{processing
code}---an ASCII string that, properly interpreted, specifies the
processing type for each port.

@deftypemethod Element {virtual const char *} processing () const
Returns the element's processing code as a null-terminated C string.
@end deftypemethod

Processing codes look like this:

@display
@samp{@var{inputspec}/@var{outputspec}}
@end display

@noindent
Each of @var{inputspec} and @var{outputspec} is a sequence of @samp{h},
@samp{l}, and @samp{a} characters, containing at least one character.
@samp{h} indicates a push port, @samp{l} a pull port, and @samp{a} an
agnostic port. The first character in each sequence represents the first
port (port 0), and so forth. For example, @strcode{"a/ah"} says that the
element's first input and first output ports are both agnostic, but the
second output port is push.

@var{Inputspec} and @var{outputspec} need not have the correct numbers
of characters. The last character in each specification is duplicated as
many times as necessary, and any extra characters are ignored. Thus, the
processing codes @strcode{"aaaaaaaa/haaaaaaa"} and @strcode{"a/ha"} behave
identically.

The @code{Element} class provides mnemonic names for five common
processing codes:

@table @code
@item AGNOSTIC
@strcode{"a/a"} (agnostic ports).
@item PUSH
@strcode{"h/h"} (push ports).
@item PULL
@strcode{"l/l"} (pull ports).
@item PUSH_TO_PULL
@strcode{"h/l"} (push input ports, pull output ports).
@item PULL_TO_PUSH
@strcode{"l/h"} (pull input ports, push output ports).
@end table

The default implementation for @code{Element::processing} returns
@code{AGNOSTIC}.

The @code{processing} method should be declared on a single line in the
element's class definition. It should return a C string constant or one
of the five mnemonic names above. These guidelines make the element's
processing code easy to automatically extract from the source code. 

Here is a typical @code{processing} method.

@example
class ARPQuerier : public Element @{ public: // ...
    const char *processing() const @{ return PUSH; @}
@}
@end example


@node flow_code, add_handlers, processing, Element Initialization
@section @code{flow_code}---Packet Flow Within an Element

Connections determine how packets flow between elements in a router
configuration. Packets flow @emph{within} elements as well: packets
arriving on an element's input port will then be emitted on zero or more
output ports, possibly after some modification. The user supplies
connection information explicitly, but information about packet flow
within an element is provided by the element itself, via its
@code{flow_code} method. This method returns a @dfn{flow code}: an ASCII
string that, properly interpreted, defines how packets may travel within
the element.

@deftypemethod Element {virtual const char *} flow_code () const
Returns the element's flow code as a null-terminated C string.
@end deftypemethod

Flow codes look like @samp{@var{inputspec}/@var{outputspec}}, where each
of @var{inputspec} and @var{outputspec} is a sequence of @dfn{port
codes}. The simplest port code is a single letter. Packets can travel
from an input port to an output port if and only if the port codes
match. (Case is significant.) For example, the flow code @strcode{"x/x"}
says that packets can travel from the element's input port to its output
port, while @strcode{"x/y"} says that packets never travel between ports.

A port code may also be a sequence of letters in brackets, such as
@samp{[abz]}. Two port codes match iff they have at least one letter in
common, so @samp{[abz]} matches @samp{a}, but @samp{[abz]} and
@samp{[cde]} do not match. The opening bracket may be followed by a
caret @samp{^}; this makes the port code match letters @emph{not}
mentioned between the brackets. Thus, the port code @samp{[^abc]} is
equivalent to @samp{[ABC...XYZdef...xyz]}.

Finally, the @samp{#} character is also a valid port code, and may be
used within brackets. One @samp{#} matches another @samp{#} only when
they represent the same port number---for example, when one @samp{#}
corresponds to input port 2 and the other to output port 2. @samp{#}
never matches any letter. Thus, for an element with exactly 2 inputs and
2 outputs, the flow code @strcode{"##/##"} behaves like
@strcode{"xy/xy"}.

@var{Inputspec} and @var{outputspec} need not have the correct numbers
of port codes. The last code in each specification is duplicated as many
times as necessary, and any extra codes are ignored. Thus, the flow
codes @strcode{"[x#][x#][x#][x#]/x######"} and @strcode{"[x#]/x#"} behave
identically.

This table describes some simple flow codes.

@table @code
@item "x/x"
Packets may travel from any input port to any output port. Most elements
use this flow code.

@item "xy/x"
Packets arriving on input port 0 may travel to any output port, but
those arriving on other input ports will not be emitted on any output.
@click{ARPQuerier} uses this flow code.

@item "x/y"
Packets never travel between input and output ports. @click{Idle} and
@click{Error} use this flow code. So does @click{KernelTap}, since its
input port and output port are decoupled (packets received on its input
are sent to the kernel; packets received from the kernel are sent to its
output).

@item "#/#"
Packets arriving on input port @var{K} may travel only to output port
@var{K}. @click{Suppressor} uses this flow code.

@item "#/[^#]"
Packets arriving on input port @var{K} may travel to any output port
except @var{K}. @click{EtherSwitch} uses this flow code.
@end table

The @code{Element} class provides a mnemonic name for a common flow
code:

@table @code
@item COMPLETE_FLOW
@strcode{"x/x"} (packets travel from any input to all outputs).
@end table

The default implementation for @code{Element::processing} returns
@code{COMPLETE_FLOW}.

The @code{flow_code} method should be declared on a single line in the
element's class definition. It should return a C string constant or
@code{COMPLETE_FLOW}. These guidelines make the element's flow code easy
to extract from the source code.

Here is a typical @code{flow_code} method.

@example
class ARPQuerier : public Element @{ public: // ...
    const char *flow_code() const @{ return "xy/x"; @}
@}
@end example

@noindent
Most elements do not declare a @code{flow_code} method, relying on the
default implementation instead.

Click uses flow code information in its agnostic port assignment
algorithm and its algorithms for finding upstream and downstream
elements.

@subsection What Is a Flow Code?

Flow codes conveniently encode a more primitive concept, @dfn{flow
matrices}. An element's flow matrix, @math{M}, is a Boolean matrix with
@code{ninputs} rows and @code{noutputs} columns. The matrix element
@math{m[i,j]} is true if and only if packets can ``travel'' from input
port @math{i} to output port @math{j}. Note that this is independent of
the element's processing code; it holds for push, pull, and agnostic
ports.

But what does it mean for a packet to ``travel'' from one port to
another? This principle will help you pick the right flow code for an
element: Consider how an element's flow matrix would affect a simple
router.

Take an input port, @math{i}, and output port, @math{j}, on some element
@click{M}. To decide whether @math{m[i,j]} should be true, imagine this
simple configuration (or a similar configuration):

@example
... -> RED -> [@math{i}] M [@math{j}] -> Queue -> ...;
@end example

@noindent
Now, should the @click{RED} element include the @click{Queue} element in
its queue length calculation? The @math{m[i,j]} element should be true
if and only if the answer is yes.

For example, consider @click{ARPQuerier}'s second input port, which
receives ARP responses. @click{ARPQuerier} may, on receiving an ARP
response, emit a held-over IP packet on its first output. However, a
@click{RED} element upstream of that second input port would probably
not include the downstream @click{Queue} in its queue length
configuration. After all, the ARP responses are effectively dropped;
packets emitted onto the @click{Queue} originally came from
@click{ARPQuerier}'s first input port. Therefore, @math{m[1,0]} is
false, and @click{ARPQuerier}'s flow code specifies that packets
arriving on the second input port are not emitted on any output port.

The @click{ARPResponder} element provides a contrasting example. It has
one input port, which receives ARP queries, and one output port, which
emits the corresponding ARP responses. A @click{RED} element upstream of
@click{ARPResponder} would probably want to include a downstream
@click{Queue}, since queries received by @click{ARPResponder} are
effectively transmuted into emitted responses. Thus, @math{m[0,0]} is
true, even though the packets @click{ARPResponder} emits are completely
different from the packets it receives.

If you find this confusing, don't fret. It is perfectly fine to be
conservative when assigning flow codes. About 96% of the Click
distribution's elements use @code{COMPLETE_FLOW}.


@node add_handlers, initialize, flow_code, Element Initialization
@section @code{add_handlers}---Creating Handlers

After successfully configuring every element and assigning ports to push
or pull, the driver calls every element's @code{add_handlers} method.
This method should create any handlers provided by the element.
@xref{Handlers}, for more information on handlers.

@deftypemethod Element {virtual void} add_handlers ()
This method takes no arguments and returns no results. Its only side
effect should be to create the element's class-specific handlers. Most
@code{add_handlers} methods simply call @code{add_read_handler} and
@code{add_write_handler} one or more times (@pxref{Adding Handlers}),
and possibly @code{add_task_handlers} (@pxref{Task Handlers}).

The default implementation does nothing.
@end deftypemethod

@anchor{add_default_handlers} The driver also calls every element's
@code{add_default_handlers} method. This nonvirtual method adds the
default handlers that every element shares. See @ref{Default Handlers},
for more information.

@deftypemethod Element {void} add_default_handlers (bool @var{config_writable})
Adds the default collection of handlers for the element. Most of these
handlers are read-only. The @handler{config} handler may be read/write,
but only if @var{config_writable} is true and the
@code{can_live_reconfigure} method also returns true
(@pxref{can_live_reconfigure}).
@end deftypemethod


@node initialize, uninitialize, add_handlers, Element Initialization
@section @code{initialize}---Element Initialization

The @code{initialize} method is called just before the router is placed
on line. It performs any final initialization, and provides the last
chance to abort router installation with an error.

@deftypemethod Element {virtual int} initialize (ErrorHandler *@var{errh})
Any errors, warnings, or messages should be reported to @var{errh}.
Messages should not specify the element name; this information will be
supplied externally.

This method should return zero if initialization succeeds, or a negative
number if it fails. Returning a negative number prevents the router from
initializing.

The default @code{initialize} method simply returns zero.
@end deftypemethod

An element's @code{initialize} method may check whether its input or
output ports are push or pull, or query the router for information about
its neighbors. It may not create or destroy input or output ports.

If every element's @code{initialize} method succeeds, then the router is
installed, and will remain installed until another router replaces it.
Any errors that occur later than @code{initialize}---during a
@code{push} or @code{pull} method, perhaps---will not take the router
off line.

Common tasks performed in @code{initialize} methods include:

@itemize @bullet
@item
Initializing @code{Task}s (@pxref{Task Initialization}).

@item
Allocating memory.

@item
Opening files.
@end itemize


@node uninitialize, Initialization Phases, initialize, Element Initialization
@section @code{uninitialize}---Removing Initialization State

The @code{uninitialize} method should undo any effects of
initialization---for example, it should close any open files, free up
memory, and unhook from network devices. Every element's
@code{uninitialize} method is called when a successfully initialized
router is taken off line. @code{uninitialize} is also called on certain
elements in an aborted router, namely those that did successfully
initialize.

@deftypemethod Element {virtual void} uninitialize ()
This method takes no arguments and returns no results. It should never
report errors to any source.

The default @code{uninitialize} method does nothing.
@end deftypemethod

An element's @code{uninitialize} method will be called by Click if and
only if its @code{initialize} method succeeded (returned zero).
Furthermore, it will be called by Click exactly once. However, it often
makes sense to write @code{uninitialize} so that it may be called from
other places---from the element's destructor, for example, or from
a partially completed @code{initialize}.

@code{uninitialize} serves some of the same functions as an element's
destructor and, in the normal case, it is called immediately before the
element is destroyed. However, @code{uninitialize} may be called long
before destruction. Elements that are part of an erroneous router are
uninitialized, but kept around for debugging purposes until another
router is installed.


@node Initialization Phases,  , uninitialize, Element Initialization
@section Initialization Phases

@enumerate
@item
Determines how many ports are used on each element and calls their
@code{notify_ninputs} and @code{notify_noutputs} methods.

@item
Calls each element's @code{configure_phase} method, and uses the
result to construct a configuration order.

@item
Calls each element's @code{configure} method, passing in the relevant
configuration string. The elements are configured according to the
configuration order.

@item
Checks that each connection connects a valid input port to a valid
output port. This catches errors where a connection uses a port that
does not exist.

@item
Calls each element's @code{processing} method to determine whether its
ports are push, pull, or agnostic.

@item
For each element with agnostic ports, calls the corresponding
@code{flow_code} method to determine constraints linking agnostic input
ports to agnostic output ports.

@item
Runs the constraint-satisfaction algorithm that determines whether each
agnostic port is push or pull. This catches errors where a single
agnostic port is used as both push and pull.

@item
Checks that every connection is between two push ports or two pull
ports.

@item
Checks that push output ports and pull input ports are connected exactly
once.

@item
Checks that no input or output port goes unused.

@item
Calls every element's @code{add_handlers} method.

@item
Calls every element's @code{add_default_handlers} method. The
@handler{config} handler may be read-write.

@item
If there have been no errors up to this point, then calls each element's
@code{initialize} method. The elements are initialized according to the
configuration order. No @code{initialize} methods are called if there
were any errors in any previous phase.

@item
If there were no errors, then router initialization has succeeded, and
the router is placed on line.

@item
If there were errors, then router initialization has failed.

@enumerate a
@item
Removes all handlers, then calls every element's
@code{add_default_handlers} again to make information about the
erroneous configuration available for debugging. The @handler{config}
handler is always read-only.

@item
Calls the @code{uninitialize} method on each element whose
@code{initialize} method returned successfully.
@end enumerate
@end enumerate


@node Element Runtime, Configuration Strings, Element Initialization, Top
@chapter Element Runtime

@menu
* Moving Packets::              
* Handling Packets::            
* Running Tasks::               
* Handlers::                    
* Live Reconfiguration::        
@end menu


@node Moving Packets, Handling Packets, Element Runtime, Element Runtime
@section Moving Packets

Two virtual functions on @code{Element}, @code{push} and @code{pull},
provide Click's means are the main methods for packet transfer.

@menu
* push::                        
* pull::                        
* Transferring Packets::        
* simple_action::               
@end menu

@node push, pull, Moving Packets, Moving Packets
@subsection @code{push}

@deftypemethod Element {virtual void} push (int @var{port}, Packet *@var{p})
Called when an upstream element pushes the packet @var{p} onto this
element's input port @var{port}. This element is expected to process the
packet however it likes.
@end deftypemethod

@node pull, Transferring Packets, push, Moving Packets
@subsection @code{pull}

@deftypemethod Element {virtual Packet *} pull (int @var{port})
Called when a downstream element makes a pull request of this element's
output port @var{port}. This element is expected to process the request
however it likes and to return a packet.
@end deftypemethod

@node Transferring Packets, simple_action, pull, Moving Packets
@subsection Transferring Packets

@deftypemethod {Element::Port} void push (Packet *@var{p}) const
@end deftypemethod

@deftypemethod {Element::Port} {Packet *} pull () const
@end deftypemethod

@node simple_action,  , Transferring Packets, Moving Packets
@subsection @code{simple_action}

@deftypemethod Element {Packet *} simple_action (Packet *@var{p})
@end deftypemethod

@node Handling Packets, Running Tasks, Moving Packets, Element Runtime
@section Handling Packets

Every @code{Packet} object should be single-threaded through Click: the
same @code{Packet} pointer should never be in use in two different
places. In particular, an element should not use a @code{Packet} after
passing it downstream to the rest of the configuration (by calling
@code{output().push}, for example).

This, for example, is the wrong way to write a @click{Tee} with two
outputs.

@example
void
BadTee::push(int, Packet *p)
@{
    output(0).push(p);
    output(1).push(p);
@}
@end example

@noindent
The same packet pointer, @code{p}, has been pushed to two different
outputs. This is always illegal; the rest of the configuration may have
modified or even freed the packet before returning control to
@code{BadTee}. The correct definition uses the @code{clone} method:

@example
void
GoodTee::push(int, Packet *p)
@{
    output(0).push(p->clone());
    output(1).push(p);
@}
@end example

Every @code{push} or @code{pull} method must account for every packet it
receives by freeing it, emitting it on some output, or perhaps
explicitly storing it for later. This @code{push} method, for example,
contains a memory leak:

@example
void
Leaky::push(int, Packet *p)
@{
    const click_ip *iph = p->ip_header();
    // @r{@dots{} more processing @dots{}}
    _counter++;
    return;  // XXX @r{Oops!}
    // @r{Must push the packet on, store it, or kill it before returning.}
@}
@end example


@node Running Tasks, Handlers, Handling Packets, Element Runtime
@section Running Tasks


@node Handlers, Live Reconfiguration, Running Tasks, Element Runtime
@section Handlers

@dfn{Handlers} are access points through which users can interact with
elements in a running Click router, or with the router as a whole.
@dfn{Read} and @dfn{write handlers} behave like files in a file system,
while @dfn{LLRPCs} provide a remote procedure call interface.

@menu
* Read and Write Handler Overview::  
* Adding Handlers::             
* Default Handlers::            
* Accessing Handlers Internally::  
* LLRPC Overview::              
@end menu


@node Read and Write Handler Overview, Adding Handlers, Handlers, Handlers
@subsection Read and Write Handler Overview

Read and write handlers appear to the user like files in a file system,
or alternatively, like a limited RPC mechanism that uses ASCII strings
for data transfer. To the element programmer, a read handler is simply a
function that takes an element and returns a String; a write handler is
a function that takes an element and a String and returns an error code.

@deftypefn {Function Type} String {(*ReadHandler)} (@w{Element *@var{element}}, @w{void *@var{thunk}})
Read handler functions have this type. When the user accesses a read
handler on an element, Click calls some @code{ReadHandler} function and
passes the element as an argument. The @var{thunk} argument contains
callback data specified when the handler was added (@pxref{Adding
Handlers}). The function's String return value is passed back to the
user.
@end deftypefn

@deftypefn {Function Type} int {(*WriteHandler)} (@w{const String &@var{data}}, @w{Element *@var{element}}, @w{void *@var{thunk}}, @w{ErrorHandler *@var{errh}})
Write handler functions have this type. When the user accesses some
element write handler by passing in a string, Click calls some
@code{WriteHandler} function and passes the data and the relevant
element as arguments. The @var{thunk} argument contains callback data
specified when the handler was added (@pxref{Adding Handlers}). The
return value is an error code: zero when there are no errors, and the
negative of some @code{errno} value when there is an error. More
detailed information about any errors should be reported to the
@var{errh} argument.
@end deftypefn

Each handler has an ASCII @dfn{name}. Handler names must be unique
within each element; for example, there can be at most one @samp{x} read
handler in a given element. A given name can be shared by a read handler
and a write handler, however. Such a handler pair is colloquially called
a ``read/write handler'', although its two components need not have
anything to do with one another.

There is currently no way to pass data to a read handler or return data
from a write handler. Use LLRPCs if you need a more RPC-like read-write
interface.

Note that read and write handler functions are regular functions, not
virtual functions. Often, therefore, handler functions are defined as
private static member functions in the relevant element class.

Read and write handlers need not use ASCII-formatted data. Most existing
handlers do format their data in ASCII, however, and use
@code{cp_uncomment} to ignore leading and trailing whitespace and
comments (@pxref{Quoting and Unquoting}). You may want to do the same
for consistency's sake.

Be careful when writing handlers that modify element state, or read
state that packet processing can modify. On an SMP machine, a handler
may be called on one processor while packets are passing through the
router on another processor. Furthermore, multiple read handlers and
safe LLRPCs (@pxref{LLRPC Overview}) may be active simultaneously on
different processors. Write handlers are serialized with respect to
other handlers and LLRPCs (but not packet processing). That is, no other
handler or LLRPC will proceed while a write handler is active.


@node Adding Handlers, Default Handlers, Read and Write Handler Overview, Handlers
@subsection Adding Handlers

Use @code{Element}'s @code{add_read_handler} and
@code{add_write_handler} methods to add handlers for an element. You
will generally call these methods only from within your element's
@code{add_handlers} method (@pxref{add_handlers}), although nothing
prevents you from adding handlers at any time.

@deftypemethod Element void add_read_handler (@w{const String &@var{name}}, @w{ReadHandler @var{func}}, @w{void *@var{thunk}})
Adds a read handler named @var{name} for this element. When the handler
is accessed, @var{func} will be called with @code{this} and @var{thunk}
as parameters.
@end deftypemethod

@deftypemethod Element void add_write_handler (@w{const String &@var{name}}, @w{WriteHandler @var{func}}, @w{void *@var{thunk}})
Adds a write handler named @var{name} for this element. When the handler
is accessed, @var{func} will be called with the relevant data,
@code{this}, @var{thunk}, and an @code{ErrorHandler} as parameters.
@end deftypemethod

To create a read/write handler, call @code{add_read_handler} and
@code{add_write_handler} and supply the same handler name.

Similar static methods on the @code{Router} class add global read and
write handlers to the system.

@deftypeop {Static Method} Router void add_global_read_handler (@w{const String &@var{name}}, @w{ReadHandler @var{func}}, @w{void *@var{thunk}})
@deftypeopx {Static Method} Router void add_global_write_handler (@w{const String &@var{name}}, @w{WriteHandler @var{func}}, @w{void *@var{thunk}})
Adds a global read or write handler to the system. When the handler is
accessed, @var{func} will be called with a null pointer for
@var{element}. All its other arguments will be the same as in the
element handler case.
@end deftypeop

The @code{change_handler_flags} method lets you change a handler's flags
word (@pxref{Handler Objects}).

@anchor{Changing Handler Flags}
@deftypeop {Static Method} Router void change_handler_flags (@w{Element *@var{element}}, @w{const String &@var{name}}, @w{uint32_t @var{clear_flags}}, @w{uint32_t @var{set_flags}})
Changes the flags for @var{element}'s @var{name} handler, or the global
@var{name} handler if @var{element} is null. The flags are changed by
first clearing the bits set in @var{clear_flags}, then setting the bits
set in @var{set_flags}. This method fails and returns @math{-1} when the
specified handler does not exist; otherwise, it returns 0.
@end deftypeop


@node Default Handlers, Accessing Handlers Internally, Adding Handlers, Handlers
@subsection Default Read and Write Handlers

Every element automatically provides five handlers, @handler{class},
@handler{name}, @handler{config}, @handler{ports}, and
@handler{handlers}. There is no need to add these handlers yourself. The
default handlers behave as follows:

@table @asis
@item @handler{class}
Returns the element's class name, as returned by @code{class_name()},
followed by a newline. Example result: @strcode{"ARPQuerier\n"}.

@item @handler{name}
Returns the element's name, as returned by @code{id()}, followed by a
newline. Example result: @strcode{"arpq_0\n"}.

@item @handler{config}
Returns the element's configuration string. If the configuration string
does not end in newline, the hander appends a newline itself. Example
result: @strcode{"18.26.7.1, 00:00:C0:4F:71:EF\n"}.

If @code{can_live_reconfigure} returns true, @handler{config} is also a
write handler, and writing to it reconfigures the element. @xref{Live
Reconfiguration}.

@item @handler{ports}
Returns a multi-line string describing the element's ports and what they
are connected to. The string has the form

@example
@var{M} input[s]
@r{@dots{} @var{M} input port descriptions, one per line @dots{}}
@var{N} output[s]
@r{@dots{} @var{N} output port descriptions, one per line @dots{}}
@end example

@noindent
Each port description lists the port's processing type, a dash, and then
a comma-separated list of all the ports to which this port is connected.
The processing type is either @samp{push} or @samp{pull}; formerly
agnostic ports are indicated by a trailing tilde (@samp{push~} or
@samp{pull~}). Example result:

@example
1 input
push~   -       Strip@@2 [0]
2 outputs
push~   -       [0] GetIPAddress@@4
push    -       [0] Print@@7
@end example

@noindent
If Click was compiled with statistics collection enabled, the dash on
each line is replaced by a packet count.

@item @handler{handlers}
Returns a string listing the element's visible handlers, one per line.
Each line contains the handler name, a tab, and then either @samp{r},
@samp{w}, or @samp{rw}, depending on whether the handler is read-only,
write-only, or read/write. Example result for an @click{InfiniteSource}
element, which has many handlers:

@example
scheduled       r
tickets r
reset   w
count   r
active  rw
burstsize       rw
limit   rw
data    rw
handlers        r
ports   r
config  rw
name    r
class   r
@end example
@end table


@node Accessing Handlers Internally, LLRPC Overview, Default Handlers, Handlers
@subsection Accessing Handlers Internally

Element handlers are stored in the relevant @code{Router} as objects
with type @code{Router::Handler}. (This design allows handler objects to
be shared between elements when possible.) Handlers are often referred
to by index; indexes between 0 and @code{Router::FIRST_GLOBAL_HANDLER
@minus{} 1} refer to element handlers, while indexes above
@code{Router::FIRST_GLOBAL_HANDLER} refer to global handlers. Indexes
less than 0 are used for error returns, such as nonexistent handlers.
@code{Router} methods translate between handler indexes and
@code{Router::Handler} objects, and find handler indexes given handler
names.

@menu
* Handler Objects::             
* Handler Indexes::             
* Locating Handlers::           
@end menu

@node Handler Objects, Handler Indexes, Accessing Handlers Internally, Accessing Handlers Internally
@subsubsection The Router::Handler Type

The @code{Router::Handler} type allows you to check a handler's
properties and call the handler. All of its methods are @code{const};
you must go through @code{Router} to change a handler's properties.
@code{Router::Handler} objects do not contain element references, since
they are shared among elements. That means you can't easily find the
element (if any) to which a particular @code{Router::Handler} is
attached.

@deftypemethod Router::Handler {const String &} name () const
Returns the handler's name.
@end deftypemethod

@deftypemethod Router::Handler uint32_t flags () const
Returns the handler's flags as an integer. The lower bits of the flags
word are reserved for the system, and four bits are reserved for
drivers, but the upper bits (at least 16) are left uninterpreted, and
may be used by elements. The first user flag bit is called
@code{Router::Handler::USER_FLAG_0}; its position in the word equals
@code{Router::Handler::USER_FLAG_SHIFT}. To change a handler's flags,
use the @code{Router::change_handler_flags} method (@pxref{Changing
Handler Flags}).
@end deftypemethod

@deftypemethod Router::Handler bool readable () const
Returns true iff this handler is readable.
@end deftypemethod

@deftypemethod Router::Handler bool read_visible () const
Returns true iff this handler is readable, and that read handler should
be externally visible. Drivers and the ControlSocket element use
@code{read_visible} rather than @code{readable} when deciding whether to
tell the user that a read handler exists. Inter-element communication
within the router, however, may use @code{readable} rather than
@code{read_visible}.
@end deftypemethod

@deftypemethod Router::Handler bool writable () const
@deftypemethodx Router::Handler bool write_visible () const
The analogous methods for write handlers.
@end deftypemethod

@deftypemethod Router::Handler bool visible () const
Equivalent to @code{read_visible() || write_visible()}.
@end deftypemethod

@deftypemethod Router::Handler String unparse_name (@w{Element *@var{element}}) const
Returns the handler's name, including its attached element's name if
@var{element} is non-null. For example, calling @code{unparse_name} on
element @samp{e}'s @samp{foo} handler would return @samp{e.foo}, while
calling it on a global @samp{bar} handler would return @samp{bar}.
@end deftypemethod

@deftypemethod Router::Handler String call_read (@w{Element *@var{element}}) const
Calls this read handler on @var{element} and returns the result. Do not
use this method unless you know the handler is @code{readable()}.
@end deftypemethod

@deftypemethod Router::Handler int call_write (@w{const String &@var{data}}, @w{Element *@var{element}}, @w{ErrorHandler *@var{errh}}) const
Calls this write handler on @var{element}, passing it @var{data} and
@var{errh}, and returns the result. Do not use this method unless you
know the handler is @code{writable()}.
@end deftypemethod


@node Handler Indexes, Locating Handlers, Handler Objects, Accessing Handlers Internally
@subsubsection Handler Indexes

These @code{Router} methods check handler indexes for validity, and
translate handler indexes into @code{Router::Handler} objects. Each
method comes in a pair: one static method that takes a possibly-null
@w{@code{Router *}} argument, and one non-static method that does the
same thing.

@deftypeop {Static Method} Router bool handler_ok (@w{const Router *@var{router}}, @w{int @var{handler_index}})
Returns true if @var{handler_index} is a valid global handler index, or
if @var{router} is non-null and @var{handler_index} is a valid element
handler index for @var{router}.
@end deftypeop

@deftypemethod Router bool handler_ok (@w{int @var{handler_index}}) const
Same as @code{handler_ok(this, @var{handler_index})}.
@end deftypemethod

@deftypeop {Static Method} Router {const Router::Handler &} handler (@w{const Router *@var{router}}, @w{int @var{handler_index}})
Returns the handler with index @var{handler_index}. Do not call this
method unless @code{handler_ok(@var{router}, @var{handler_index})} would
return true.
@end deftypeop

@deftypemethod Router {const Router::Handler &} handler (@w{int @var{handler_index}}) const
Same as @code{handler(this, @var{handler_index})}.
@end deftypemethod

@deftypeop {Static Method} Router {const Router::Handler *} handlerp (@w{const Router *@var{router}}, @w{int @var{handler_index}})
Returns a pointer to the handler with index @var{handler_index}, using
@var{router} if @var{handler_index} refers to an element handler.
Returns a null pointer if @var{handler_index} is not a valid handler
index (for instance, if it is an element handler index and @var{router}
is null). The pointer returned by @code{handlerp} should be treated as
transient, since it may become invalid as new handlers are added.
@end deftypeop

@deftypemethod Router {const Router::Handler *} handler (@w{int @var{handler_index}}) const
Same as @code{handlerp(this, @var{handler_index})}.
@end deftypemethod


@node Locating Handlers,  , Handler Indexes, Accessing Handlers Internally
@subsubsection Locating Handlers

These methods find the handler index corresponding to a given handler
name, or list all handlers for a given element. They are static methods
so that you don't need a @code{Router} object to investigate global
handlers.

@deftypeop {Static Method} Router int find_handler (@w{Element *@var{element}}, @w{const String &@var{name}})
Returns the handler index for @var{element}'s @var{name} handler, or the
global @var{name} handler if @var{element} is null, or @math{-1} if
there is no such handler.
@end deftypeop

@deftypeop {Static Method} Router void element_handlers (@w{const Router *@var{router}}, @w{int @var{eindex}}, @w{Vector<int> &@var{results}})
Adds to @var{results} a list of all the handler indexes for handlers
supported by @var{router}'s element number @var{eindex}, or all global
handlers if @math{@var{eindex} < 0}.
@end deftypeop


@node LLRPC Overview,  , Accessing Handlers Internally, Handlers
@subsection LLRPC Overview

@node Live Reconfiguration,  , Handlers, Element Runtime
@section Live Reconfiguration

@menu
* can_live_reconfigure::        
@end menu

@node can_live_reconfigure,  , Live Reconfiguration, Live Reconfiguration
@subsection can_live_reconfigure


@node Configuration Strings, Tasks, Element Runtime, Top
@chapter Configuration Strings

@menu
* Config String Structure::     
* Quoting and Unquoting::       
* Config String Splitting::     
* Parsing Functions::           
* cp_va::                       
@end menu

@node Config String Structure, Quoting and Unquoting, Configuration Strings, Configuration Strings
@section Structure

Configuration strings consist of a list of comma-separated
@dfn{arguments}. For example, this configuration string has three
arguments, @samp{a}, @samp{b}, and @samp{c}:

@example
a,    b          , c
@end example

@noindent
Leading and trailing whitespace is trimmed from each argument.

Configuration strings can contain two kinds of @dfn{comments} and three
kinds of @dfn{quoted strings}. Comments let you document a configuration
string; they behave like spaces. With quoted strings, you can protect
special characters like whitespace, commas, and comment-starting
sequences from interpretation.

@table @asis
@item @samp{//} comments
Begins with two adjacent slashes, @samp{//}, and continues up to and
including the next end-of-line (@samp{\n}, @samp{\r}, or @samp{\r\n}).
Comment starters (@samp{//} and @samp{/*}) and the quote sequences
(@samp{'}, @samp{"}, and @samp{\<}) have no special meaning inside
@samp{//} comments.

@item @samp{/* @dots{} */} comments
Begins with slash-star, @samp{/*}, and continues up to and including the
next star-slash, @samp{*/}. Comment starters (@samp{/*} and @samp{//})
and the quote sequences (@samp{'}, @samp{"}, and @samp{\<}) have no
special meaning inside @samp{/*} comments.
@end table

@table @asis
@item Single-quoted strings @samp{' @dots{} '}
Begins with a single-quote character @samp{'} and continues up to the
next single quote. Comments, double quotes, and backslashes have no
special meaning inside single quotes. There is no way to include a
single quote in a single-quoted string.

@item Double-quoted strings @samp{" @dots{} "}
Begins with a double-quote character @samp{"} and continues up to the
next unescaped double quote. Backslash @samp{\} acts as an escape
character inside double quotes, as in C@. Click's escape sequences are
described below. Comments and single quotes have no special meaning
inside double quotes. @samp{\<} retains its usual meaning, however.

@item Hex strings @samp{\< @dots{} >}
The @samp{\<} sequence begins a string of hexadecimal digits terminated
by @samp{>}. Each pair of digits expands to the corresponding character
value. For example, @samp{\<48454c4c4F>} expands to @samp{HELLO}.
Whitespace and comments (either @samp{//} or @samp{/*} style) may be
arbitrarily interleaved with the hex digits; any @samp{>} characters
inside comments are ignored. Characters other than whitespace, hex
digits, comments, and @samp{>} should not appear inside a hex string.

Hex strings may be placed within double-quoted strings.
@end table

@subsubheading Escape Sequences

Most of Click's escape sequences are borrowed from C, and behave the
same way. The @samp{\< @dots{} >} escape sequence is new, however.

@table @asis
@item @samp{\@key{END-OF-LINE}}
A backslash followed by an end-of-line sequence---@samp{\n}, @samp{\r},
or @samp{\r\n}---is removed from the string. This string

@example
"a\
b"
@end example

@noindent
is equivalent to @strcode{"ab"}.

@item @samp{\a}, @samp{\b}, @samp{\t}, @samp{\n}, @samp{\v}, @samp{\f}, @samp{\r}
These escape sequences produce the characters with decimal ASCII values
7, 8, 9, 10, 11, 12, and 13, respectively.

@item @samp{\\}, @samp{\"}, @samp{\'}, @samp{\$}
These escape sequences expand to a literal backslash, double quote,
single quote, and dollar sign, respectively.

@item @samp{\@key{1 TO 3 OCTAL DIGITS}}
A backslash followed by 1 to 3 octal digits (@samp{0} @dots{} @samp{7})
expands to the character with that octal value. For example, @samp{\046}
expands to @samp{&}.

@item @samp{\x@key{HEX DIGITS}}
@samp{\x} followed by an arbitrary number of hexadecimal digits expands
to the single character whose value equals the lower 8 bits of that
number. Thus, @samp{\x45} and @samp{\x94839E89DB00ACF45} both expand to
@samp{E}.

@item @samp{\< @key{HEX DIGITS} >}
@samp{\<} introduces a hex string, as described above.
@end table

Any other escape sequence @samp{\@key{CHAR}} is an error. Currently,
such sequences expand to @samp{@key{CHAR}}, but their semantics may
eventually change.


@node Quoting and Unquoting, Config String Splitting, Config String Structure, Configuration Strings
@section Quoting and Unquoting

These functions interpret quote sequences and comments in configuration
strings. @code{cp_uncomment} removes comments and leading and trailing
whitespace, but does not expand quote sequences. @code{cp_unquote} both
removes comments and expands quote sequences. Finally, @code{cp_quote}
protects special characters, such as whitespace and commas, within
double quotes.

@deftypefun String cp_uncomment (@w{const String &@var{str}})
Replaces any comments in @var{str} by single spaces, then removes any
leading and trailing whitespace and returns the result.
@end deftypefun

@deftypefun String cp_unquote (@w{const String &@var{str}})
Replaces any comments in @var{str} by single spaces, then removes any
leading and trailing whitespace. Finally, replaces every quoted string
by its expansion and returns the result.
@end deftypefun

@deftypefun String cp_quote (@w{const String &@var{str}}, @w{bool @var{allow_newlines} = false})
Returns a quoted version of @var{str}. Any whitespace, commas, comments,
quote sequences, and non-ASCII characters in @var{str} are protected
within double quotes. If @var{allow_newlines} is true, then the result
may contain newline characters (within double quotes); otherwise, any
newline characters in @var{str} are replaced by @samp{\n} sequences. The
returned result is never empty (unless Click has run out of memory). If
@var{str} is the empty string, @code{cp_quote} will return @samp{""} (a
string containing two double quotes).
@end deftypefun

For example:

@example
cp_uncomment(@qsamp{  /* blah */ "quote"/*xx*/\<2 c>}) @result{} @qsamp{"quote" \<2 c>}
cp_unquote(@qsamp{  /* blah */ "quote"/*xx*/\<2 c>}) @result{} @qsamp{quote ,}
cp_quote(@qsamp{quote ,}) @result{} @qsamp{"quote ,"}
@end example

@node Config String Splitting, Parsing Functions, Quoting and Unquoting, Configuration Strings
@section Splitting and Combining

@deftypefun void cp_argvec (@w{const String &@var{str}}, @w{Vector<String> &@var{conf}})
Splits @var{str} into arguments by breaking it at every comma not part
of a quote or comment. Comments and leading and trailing whitespace are
removed from each argument, as by @code{cp_uncomment}, and the results
are pushed, in order, onto the vector @var{conf}. If @var{str} contains
only whitespace and comments, nothing is pushed onto @var{conf}.
@end deftypefun

@deftypefun void cp_spacevec (@w{const String &@var{str}}, @w{Vector<String> &@var{conf}})
Splits @var{str} into arguments by breaking it at every sequence of
whitespace characters and/or comments. Leading and trailing whitespace
is removed from each argument, as by @code{cp_uncomment}, and the
results are pushed, in order, onto the vector @var{conf}. If @var{str}
contains only whitespace and comments, nothing is pushed onto
@var{conf}.
@end deftypefun

For example:

@display
@t{cp_argvec(}@qsamp{  x/* ,,, */ab" c",  \<de>  , ','}@t{, @var{vec})}
       @result{} 3 arguments:   @qsamp{x ab" c"}   @qsamp{\<de>}   @qsamp{','}
@t{cp_argvec(}@qsamp{  /* blah, blah, blah, blah */  }@t{, @var{vec})}
       @result{} 0 arguments
@t{cp_argvec(}@qsamp{  /* blah, blah, blah, blah */,  }@t{, @var{vec})}
       @result{} 2 empty arguments:   @qsamp{}   @qsamp{}
@t{cp_spacevec(}@qsamp{  x/* ,,, */yz" w"  \<d e>  ""}@t{, @var{vec})}
       @result{} 4 arguments:   @qsamp{x}   @qsamp{yz" w"}   @qsamp{\<d e>}   @qsamp{""}
@t{cp_spacevec(}@qsamp{  /* blah, blah, blah, blah */  }@t{, @var{vec})}
       @result{} 0 arguments
@t{cp_spacevec(}@qsamp{  /* blah, blah, blah, blah */,  }@t{, @var{vec})}
       @result{} 1 argument:   @qsamp{,}
@end display

Since the @code{const Vector<String> &@var{conf}} arguments passed to
elements' @code{configure} methods (@pxref{configure}) have been
processed by @code{cp_argvec}, there is no need to process them with
@code{cp_uncomment}.

The @code{cp_unargvec} and @code{cp_unspacevec} functions take a vector
of arguments and combine them into a single string. These functions do
not protect their arguments by quoting; use @code{cp_quote} explicitly
when necessary (@pxref{Quoting and Unquoting}). If the arguments are
properly quoted, then calling @code{cp_argvec(cp_unargvec(@var{conf}),
@var{conf2})} or @code{cp_spacevec(cp_unspacevec(@var{conf}),
@var{conf2})} will produce a new vector of arguments equal to the
original.

@deftypefun String cp_unargvec (@w{const Vector<String> &@var{conf}})
Returns a string consisting of the elements of @var{conf} separated by
@w{@samp{,@ }}.
@end deftypefun

@deftypefun String cp_unspacevec (@w{const Vector<String> &@var{conf}})
Returns a string consisting of the elements of @var{conf} separated by
@w{@samp{@ }}.
@end deftypefun

For example:

@display
@t{cp_unargvec(}[@qsamp{x ab" c"}, @qsamp{\<de>}, @qsamp{','}]@t{)}
       @result{} @qsamp{x ab" c", \<de>, ','}
@t{cp_unargvec(}[@qsamp{whatever}]@t{)}
       @result{} @qsamp{whatever}
@t{cp_unargvec(}[ ]@t{)}
       @result{} @qsamp{}
@t{cp_unargvec(}[@qsamp{,}, @qsamp{,}]@t{)}
       (Probably a mistake: caller should have quoted the arguments!)
       @result{} @qsamp{,, ,}
@t{cp_unspacevec(}[@qsamp{xy" z"}, @qsamp{\<de>}, @qsamp{','}]@t{)}
       @result{} @qsamp{xy" z" \<de> ','}
@end display


@node Parsing Functions, cp_va, Config String Splitting, Configuration Strings
@section Parsing Functions

Click's @dfn{parsing functions} parse strings into various kinds of
data, such as integers, fixed-point real numbers, and IP addresses.
Parsing functions follow some consistent conventions:

@itemize @bullet
@item
Their first argument, @code{const String &@var{str}}, contains the
string to be parsed.

@item
At least one additional argument points to a location where any parsed
result should be stored. These @var{result} arguments have pointer type.

@item
Their return type is @code{bool}.

@item
They return true if and only if parsing succeeds.

@item
The values pointed to by the @var{result} arguments are modified only if
parsing succeeds.

@item
Most parsing functions expect to parse the entire supplied string. Any
extraneous characters, such as trailing whitespace, cause parsing to
fail.

@item
Parsing functions never report errors to any source; they simply return
false when parsing fails.
@end itemize

@menu
* Parsing Strings::             
* Parsing Booleans::            
* Parsing Integers::            
* Parsing Reals::               
* Parsing IP Addresses::        
* Parsing IPv6 Addresses::      
* Parsing Ethernet Addresses::  
* Parsing Elements::            
* Parsing Handlers::            
* Parsing Miscellaneous::       
@end menu

@node Parsing Strings, Parsing Booleans, Parsing Functions, Parsing Functions
@subsection Strings and Words

These functions parse strings from their input strings. The resulting
strings may be arbitrary (@code{cp_string}) or constrained
(@code{cp_word}, @code{cp_keyword}). As noted above (@pxref{Parsing
Functions}), the functions have @code{bool} return type; they return
true if parsing was successful.

@deftypefn {Parsing Function} bool cp_string (@w{const String &@var{str}}, @w{String *@var{result}}, @w{String *@var{rest} = 0})
Parses a string from the beginning of @var{str} and stores the result in
@code{*@var{result}}. The parsed string may contain single and double
quotes and hex strings (@qsamp{\< @dots{} >}), which are processed as by
@code{cp_unquote} (@pxref{Quoting and Unquoting}).

If the @var{rest} argument is null and @var{str} contains any unquoted
whitespace, then parsing will fail. If @var{rest} is not null, then
parsing stops at the first unquoted whitespace character, and any
leftover portion of @var{str} is stored in @code{*@var{rest}}.

For example:

@display
@t{cp_string(}@qsamp{"a b c d"}@t{, @var{result})} @result{} true
       @t{*@var{result}} = @qsamp{a b c d}
@t{cp_string(}@qsamp{}@t{, @var{result})} @result{} false
@t{cp_string(}@qsamp{""}@t{, @var{result})} @result{} true
       @t{*@var{result}} = @qsamp{}
@t{cp_string(}@qsamp{ "a b c d"}@t{, @var{result})} @result{} false
       (@var{str} began with an unquoted space)
@t{cp_string(}@qsamp{"a b c d" e}@t{, @var{result})} @result{} false
       (@var{str} contained an unquoted space)
@t{cp_string(}@qsamp{"a b c d" e}@t{, @var{result}, @var{rest})} @result{} true
       @t{*@var{result}} = @qsamp{a b c d}, @t{*@var{rest}} = @qsamp{ e}
@end display
@end deftypefn

@deftypefn {Parsing Function} bool cp_word (@w{const String &@var{str}}, @w{String *@var{result}}, @w{String *@var{rest} = 0})
Parses a word from the beginning of @var{str} and stores the result in
@code{*@var{result}}. A @dfn{word} is a string that does not contain
whitespace, control characters, non-ASCII characters (with values 127 or
higher), or special characters (@samp{'}, @samp{"}, @samp{\}, or
@samp{,}). @var{str} may contain single and double quotes and hex
strings (@qsamp{\< @dots{} >}), which are processed as by
@code{cp_unquote} (@pxref{Quoting and Unquoting}). The unquoted result
must not contain quote marks, whitespace, or other special characters,
however. Returns true if and only if @var{str} contained a valid word.

If the @var{rest} argument is null and @var{str} contains any unquoted
whitespace, then parsing will fail. If @var{rest} is not null, then
parsing stops at the first unquoted whitespace character, and any
leftover portion of @var{str} is stored in @code{*@var{rest}}.

For example:

@display
@t{cp_word(}@qsamp{word}@t{, @var{result})} @result{} true
       @t{*@var{result}} = @qsamp{word}
@t{cp_word(}@qsamp{"wor"\<64>}@t{, @var{result})} @result{} true
       @t{*@var{result}} = @qsamp{word}
@t{cp_word(}@qsamp{"wor d"}@t{, @var{result})} @result{} false
       (processed string contained a space)
@end display
@end deftypefn

@deftypefn {Parsing Function} bool cp_keyword (@w{const String &@var{str}}, @w{String *@var{result}}, @w{String *@var{rest} = 0})
Parses a keyword from the beginning of @var{str} and stores the result
in @code{*@var{result}}. A @dfn{keyword} is a string consisting of one
or more letters, numbers, underscores (@samp{_}), periods (@samp{.}),
and colons (@samp{:}). Keywords may not contain quoted
substrings---@samp{'}, @samp{"}, and @samp{\<} are not allowed. Returns
true if and only if @var{str} contained a valid keyword.

If the @var{rest} argument is null and @var{str} contains any unquoted
whitespace, then parsing will fail. If @var{rest} is not null, then
parsing stops at the first unquoted whitespace character, and any
leftover portion of @var{str} is stored in @code{*@var{rest}}.

For example:

@display
@t{cp_keyword(}@qsamp{word}@t{, @var{result})} @result{} true
       @t{*@var{result}} = @qsamp{word}
@t{cp_keyword(}@qsamp{"wor"\<64>}@t{, @var{result})} @result{} false
       (quotes not allowed in keywords)
@end display
@end deftypefn

To summarize:

@itemize @bullet
@item
@code{cp_string} and @code{cp_word} allow quoted substrings;
@code{cp_keyword} does not.

@item
@code{cp_string} results may contain arbitrary characters;
@code{cp_word} and @code{cp_keyword} restrict the characters allowed in
their results.

@item
If @code{cp_keyword(@var{str}, @var{result})} is true, then
@code{cp_word(@var{str}, @var{result})} is true.

@item
If @code{cp_word(@var{str}, @var{result})} is true, then
@code{cp_string(@var{str}, @var{result})} is true.
@end itemize


@node Parsing Booleans, Parsing Integers, Parsing Strings, Parsing Functions
@subsection Booleans

The @code{cp_bool} function parses a string into a Boolean value.

@deftypefn {Parsing Function} bool cp_bool (@w{const String &@var{str}}, @w{bool *@var{result}})
Parses @var{str} into a Boolean value and stores the result in
@code{*@var{result}}. Allowable Boolean strings are as follows:

@table @asis
@item @samp{0}, @samp{false}, @samp{no}
@code{*@var{result}} becomes false.

@item @samp{1}, @samp{true}, @samp{yes}
@code{*@var{result}} becomes true.
@end table

@noindent
The words must be all lower case.
@end deftypefn


@node Parsing Integers, Parsing Reals, Parsing Booleans, Parsing Functions
@subsection Integers

@code{cp_integer} and @code{cp_unsigned} parse strings into @code{int}
and @code{unsigned int} values, respectively. 

Each function comes in two variants, one with a @var{base} parameter and
one without. If @var{base} is 0 or unspecified, then the function
examines the string to determine the relevant base. Strings beginning
with @samp{0x} or @samp{0X} (after the optional sign) use base 16; other
strings beginning with @samp{0} use base 8; and all other strings use
base 10. Nonzero @var{base}s must be at least 2 and no more than 36.

The functions accept the same strings as C's @code{strtol} function,
except that @code{strtol} will accept leading whitespace and trailing
characters that are not part of the parsed integer. The string should
contain, in order:

@itemize @bullet
@item
An optional @samp{+} or @samp{-} sign. (The @code{cp_unsigned} functions
do not accept a minus sign.)

@item
An optional @samp{0x} or @samp{0X}, if the @var{base} argument is 0 or
16.

@item
One or more alphanumeric digits. The maximum allowed digit is specified
by @var{base}.
@end itemize

If a string contains a valid number too large (or small) to represent,
the parsing function sets @code{cp_errno} to @code{CPE_OVERFLOW}, stores
the largest (or smallest) allowable number in @var{result}, and returns
true. If a function succeeds without overflow, @code{cp_errno} is set to
@code{CPE_OK}.

@deftypefn {Parsing Function} bool cp_integer (@w{const String &@var{str}}, @w{int *@var{result}})
@deftypefnx {Parsing Function} bool cp_integer (@w{const String &@var{str}}, @w{int @var{base}}, @w{int *@var{result}})
Parses @var{str} into a signed integer in base @var{base} and stores the
result in @code{*@var{result}}. Detects overflow on numbers greater than
2147483647 or less than @math{-2147483648}.
@end deftypefn

@deftypefn {Parsing Function} bool cp_unsigned (@w{const String &@var{str}}, @w{unsigned *@var{result}})
@deftypefnx {Parsing Function} bool cp_unsigned (@w{const String &@var{str}}, @w{int @var{base}}, @w{unsigned *@var{result}})
Parses @var{str} into an unsigned integer in base @var{base} and stores
the result in @code{*@var{result}}. Detects overflow on numbers greater
than 4294967295.
@end deftypefn

For example:

@display
@t{cp_integer(}@samp{-0x8000}@t{, @var{result})} @result{} true
       @t{*@var{result}} = @math{-32768}, @t{cp_errno} = @t{CPE_OK}
@t{cp_integer(}@samp{-0x8000 }@t{, @var{result})} @result{} false
       (trailing whitespace not allowed)
@t{cp_unsigned(}@samp{3333333333333333}@t{, 4, @var{result})} @result{} true
       @t{*@var{result}} = @math{4294967295}, @t{cp_errno} = @t{CPE_OK}
@t{cp_unsigned(}@samp{33333333333333333}@t{, 4, @var{result})} @result{} true
       @t{*@var{result}} = @math{4294967295}, @t{cp_errno} = @t{CPE_OVERFLOW}
@end display


@node Parsing Reals, Parsing IP Addresses, Parsing Integers, Parsing Functions
@subsection Real Numbers

Several functions parse real numbers into fixed-point integers. (Some
drivers, such as the Linux kernel driver, can't use floating point
arithmetic, so @code{double}s are not allowed.)

Each function takes an integer argument that determines how many digits
of fraction the result should have. Since the result is a single
fixed-point number, the more digits of fraction in the result, the fewer
digits are available for the integer part. 

You may request binary or decimal digits of fraction. The @code{real10}
function variants use decimal digits, while the @code{real2} variants
use binary digits: bits. For example, @t{cp_real10(}@samp{1}@t{, 2,
@var{result})}, which parses the string @samp{1} with 2 decimal digits
of fraction, yields the number 100 (@math{10^2}). The similar call to a
binary-digit function, @t{cp_real2(}@samp{1}@t{, 2, @var{result})},
yields 4 (@math{2^2}). Parsing @samp{0.5} with the same functions yields
50 and 2, respectively.

A real number string should contain, in order:

@itemize @bullet
@item
An optional @samp{+} or @samp{-} sign. (The @code{unsigned} variants do
not accept minus signs.)

@item
An optional sequence of decimal digits representing the integer part.

@item
An optional fraction point @samp{.}.

@item
An optional sequence of decimal digits representing the fraction part.

@item
An optional @dfn{exponent}---an @samp{E} or @samp{e} character followed
by a signed decimal integer.
@end itemize

@noindent
The string must contain at least one digit in either the integer part or
the fraction part.

All the parsing functions round to the nearest relevant number. For
example, @t{cp_real10(}@samp{0.59}@t{, 1, @var{result})} stores 6 in
@var{result}, since 0.59 rounded to one digit of fraction is 0.6.

If a string contains a real number too large in magnitude for the
specified format, the parsing function will set @code{cp_errno} to
@code{CPE_OVERFLOW}, store the largest representable number in
@var{result}, and return true. For example, the largest number
representable as an unsigned integer with 16 bits of fraction is
@math{65535.99998}, which has the bit pattern @t{0xFFFFFFFF}. Therefore,
@t{cp_unsigned_real2(}@samp{65536}@t{, 16, @var{result})} stores
@t{0xFFFFFFFF} in @var{result} and sets @code{cp_errno} to
@code{CPE_OVERFLOW}. If there was no overflow or other error,
@code{cp_errno} is set to @code{CPE_OK}.

@deftypefn {Parsing Function} bool cp_unsigned_real10 (@w{const String &@var{str}}, @w{int @var{frac_digits}}, @w{unsigned *@var{result}})
Parses @var{str} into an unsigned real number, and stores the result in
@var{result} as an unsigned integer with @var{frac_digits} decimal
digits of fraction.
@end deftypefn

@deftypefn {Parsing Function} bool cp_real10 (@w{const String &@var{str}}, @w{int @var{frac_digits}}, @w{int *@var{result}})
Parses @var{str} into a unsigned real number, and stores the result in
@var{result} as an integer with @var{frac_digits} decimal digits of
fraction.
@end deftypefn

@deftypefn {Parsing Function} bool cp_unsigned_real2 (@w{const String &@var{str}}, @w{int @var{frac_bits}}, @w{unsigned *@var{result}})
Parses @var{str} into an unsigned real number, and stores the result in
@var{result} as an unsigned integer with @var{frac_bits} bits of
fraction.
@end deftypefn

@deftypefn {Parsing Function} bool cp_real2 (@w{const String &@var{str}}, @w{int @var{frac_bits}}, @w{int *@var{result}})
Parses @var{str} into a real number, and stores the result in
@var{result} as an integer with @var{frac_bits} bits of fraction.
@end deftypefn

The fixed-point real parsing functions are built on a lower-level
variant that returns the integer and fraction parts in two different
@code{unsigned int}s.

@deftypefn {Parsing Function} bool cp_unsigned_real10 (@w{const String &@var{str}}, @w{int @var{frac_digits}}, @w{unsigned *@var{int_result}}, @w{unsigned *@var{frac_result}})
Parses @var{str} into an unsigned real number and stores the result in
@var{int_result} and @var{frac_result}. @var{int_result} holds the
integral part of the resulting real, while @var{frac_result} holds its
fractional part as a fixed-point number with @var{frac_digits} decimal
digits of fraction. @var{frac_result} is always less than
@math{10^@var{frac_digits}}.
@end deftypefn

For example:

@display
@t{cp_unsigned_real10(}@samp{10.952}@t{, 3, @var{int_result}, @var{frac_result})} @result{} true
       @t{*@var{int_result}} = @math{10}, @t{*@var{frac_result}} = @math{952}
@t{cp_unsigned_real10(}@samp{10.9526}@t{, 3, @var{int_result}, @var{frac_result})} @result{} true
       @t{*@var{int_result}} = @math{10}, @t{*@var{frac_result}} = @math{953}
       (note rounding)
@t{cp_unsigned_real10(}@samp{10.9996}@t{, 3, @var{int_result}, @var{frac_result})} @result{} true
       @t{*@var{int_result}} = @math{11}, @t{*@var{frac_result}} = @math{0}
@end display


@node Parsing IP Addresses, Parsing IPv6 Addresses, Parsing Reals, Parsing Functions
@subsection IP Addresses

The @code{cp_ip_address} functions parse strings into IP addresses.
Related @code{cp_ip_prefix} and @code{cp_ip_address_set} functions parse
strings into IP address/netmask pairs and sets of IP addresses,
respectively.

Parsable IP addresses are simply dotted quads like @samp{18.26.4.44}. IP
prefixes may be specified using CIDR notation, such as
@samp{18.26.4.44/16}; as explicit address/netmask pairs, such as
@samp{18.26.4.44/255.255.0.0}; or, optionally, as bare IP addresses,
such as @samp{18.26.4.44} (which means
@samp{18.26.4.44/255.255.255.255}).

Besides these conventional forms, the @code{cp_ip} functions understand
user-defined shorthand names for IP addresses and prefixes. Shorthand
names are router-specific; users define them with @click{AddressInfo}
elements. Furthermore, a name's meaning is dependent on its context: an
@click{AddressInfo} inside a compound element defines shorthand names
local to that compound element. The @code{cp_ip} functions, then, take
optional @w{@code{Element *@var{context}}} arguments to specify any
router and compound-element context. If a @code{cp_ip} function's
@var{context} argument is null, it will parse only the conventional IP
address forms described above.

@deftypefn {Parsing Function} bool cp_ip_address (@w{const String &@var{str}}, @w{unsigned char *@var{result}}, @w{Element *@var{context} = 0})
@deftypefnx {Parsing Function} bool cp_ip_address (@w{const String &@var{str}}, @w{IPAddress *@var{result}}, @w{Element *@var{context} = 0})
Parses @var{str} into an IP address and stores the result in
@code{*@var{result}}. @var{context} supplies any element context.
@end deftypefn

@deftypefn {Parsing Function} bool cp_ip_prefix (@w{const String &@var{str}}, @w{unsigned char *@var{result_addr}}, @w{unsigned char *@var{result_mask}}, @w{Element *@var{context} = 0})
@deftypefnx {Parsing Function} bool cp_ip_prefix (@w{const String &@var{str}}, @w{IPAddress *@var{result_addr}}, @w{IPAddress *@var{result_mask}}, @w{Element *@var{context} = 0})
Parses @var{str} into an IP address/netmask pair and stores the
resulting address in @code{*@var{result_addr}}, and the resulting
netmask in @code{*@var{result_mask}}. The resulting address is not
pre-masked by the resulting mask. For example,
@t{cp_ip_prefix(}@samp{18.26.4.44/16}@t{, @var{result_addr},
@var{result_mask})} stores 18.26.4.44 in @var{result_addr}, not
18.26.0.0. Bare addresses, such as @samp{18.26.4.44}, are never allowed.
@end deftypefn

@deftypefn {Parsing Function} bool cp_ip_prefix (@w{const String &@var{str}}, @w{unsigned char *@var{result_addr}}, @w{unsigned char *@var{result_mask}}, @w{bool @var{allow_bare_addr}}, @w{Element *@var{context} = 0})
@deftypefnx {Parsing Function} bool cp_ip_prefix (@w{const String &@var{str}}, @w{IPAddress *@var{result_addr}}, @w{IPAddress *@var{result_mask}}, @w{bool @var{allow_bare_addr}}, @w{Element *@var{context} = 0})
Parses @var{str} into an IP address/netmask pair and stores the
resulting address in @code{*@var{result_addr}} and netmask in
@code{*@var{result_mask}}. Bare addresses, such as @samp{18.26.4.44},
are allowed if and only if @var{allow_bare_addr} is true. The netmask
corresponding to a bare address is 255.255.255.255.
@end deftypefn

Finally, the @code{cp_ip_address_set} function parses a
whitespace-separated list of IP addresses into to an @code{IPAddressSet}
object.

@deftypefn {Parsing Function} bool cp_ip_address_set (@w{const String &@var{str}}, @w{IPAddressSet *@var{result}}, @w{Element *@var{context} = 0})
Parses @var{str} into a set of IP addresses and stores the result in
@code{*@var{result}}. @var{str} must be a whitespace-separated list of
IP addresses, which can take any of the forms accepted by
@code{cp_ip_address}.
@end deftypefn


@node Parsing IPv6 Addresses, Parsing Ethernet Addresses, Parsing IP Addresses, Parsing Functions
@subsection IPv6 Addresses

The @code{cp_ip6_address} functions parse strings into IPv6 addresses.
Related @code{cp_ip6_prefix} functions parse strings into IPv6
address/netmask pairs.

Parsable IPv6 addresses and prefixes take any of the forms described in
@uref{ftp://ftp.ietf.org/rfc/rfc2373.txt,,RFC 2373}, @i{IP Version 6
Addressing Architecture}. A nonabbreviated address consists of eight
colon-separated 16-bit hexadecimal numbers, as in
@samp{1080:0:0:0:8:800:200C:417A}. Strings of zero bits may be
abbreviated with two colons, as in @samp{1080::8:800:200C:417A}, and an
address may end in an embedded IPv4 address, as in @samp{::13.1.68.3}
and @samp{::FFFF:129.144.52.38}. IPv6 prefixes are written in
@samp{@var{address}/@var{prefixlen}} form, like
@samp{12AB:0:0:CD30::/60}. Click also supports
@samp{@var{address}/@var{netmask}} syntax, where @var{netmask} is an
IPv6 address. @var{netmask} must correspond to some contiguous prefix,
however: @samp{12AB:0:0:CD30::/60} and
@samp{12AB:0:0:CD30::/FFFF:FFFF:FFFF:FFF0::} are equivalent, but
@samp{12AB:0:0:CD30::/FFFF::1} is illegal.

Analogously to the @code{cp_ip} functions (@pxref{Parsing IP
Addresses}), the @code{cp_ip6} functions understand
@click{AddressInfo}'s shorthand names for IPv6 addresses, and take
optional @w{@code{Element *@var{context}}} arguments to specify any
router and compound-element context.

@deftypefn {Parsing Function} bool cp_ip6_address (@w{const String &@var{str}}, @w{unsigned char *@var{result}}, @w{Element *@var{context} = 0})
@deftypefnx {Parsing Function} bool cp_ip6_address (@w{const String &@var{str}}, @w{IP6Address *@var{result}}, @w{Element *@var{context} = 0})
Parses @var{str} into an IPv6 address and stores the result in
@code{*@var{result}}. @var{context} supplies any element context.
@end deftypefn

@deftypefn {Parsing Function} bool cp_ip6_prefix (@w{const String &@var{str}}, @w{unsigned char *@var{result_addr}}, @w{int *@var{result_prefix_len}}, @w{bool @var{allow_bare_addr}}, @w{Element *@var{context} = 0})
@deftypefnx {Parsing Function} bool cp_ip6_prefix (@w{const String &@var{str}}, @w{IP6Address *@var{result_addr}}, @w{int *@var{result_prefix_len}}, @w{bool @var{allow_bare_addr}}, @w{Element *@var{context} = 0})
Parse @var{str} into an IPv6 address/prefix length pair and stores the
resulting address in @code{*@var{result_addr}}, and the resulting prefix
length in @code{*@var{result_prefix_len}}. Bare addresses, such as
@samp{1080::8:800:200C:417A}, are allowed if and only if
@var{allow_bare_addr} is true. The prefix length corresponding to a bare
address is 128.
@end deftypefn

@deftypefn {Parsing Function} bool cp_ip6_prefix (@w{const String &@var{str}}, @w{unsigned char *@var{result_addr}}, @w{unsigned char *@var{result_mask}}, @w{bool @var{allow_bare_addr}}, @w{Element *@var{context} = 0})
@deftypefnx {Parsing Function} bool cp_ip6_prefix (@w{const String &@var{str}}, @w{IP6Address *@var{result_addr}}, @w{IP6Address *@var{result_mask}}, @w{bool @var{allow_bare_addr}}, @w{Element *@var{context} = 0})
Parse @var{str} into an IPv6 address/prefix length pair and stores the
resulting address in @code{*@var{result_addr}}, and the netmask
corresponding to the resulting prefix length in
@code{*@var{result_mask}}. Bare addresses are allowed if and only if
@var{allow_bare_addr} is true.
@end deftypefn


@node Parsing Ethernet Addresses, Parsing Elements, Parsing IPv6 Addresses, Parsing Functions
@subsection Ethernet Addresses

The @code{cp_ethernet_address} functions parse strings into Ethernet
addresses. A parsable Ethernet address consists of six colon-separated
8-bit hexadecimal numbers, as in @samp{0:2:B3:06:36:EE}.

Analogously to the @code{cp_ip} functions (@pxref{Parsing IP
Addresses}), the @code{cp_ethernet_address} functions understand
@click{AddressInfo}'s shorthand names for Ethernet addresses, and take
optional @w{@code{Element *@var{context}}} arguments to specify any
router and compound-element context.

@deftypefn {Parsing Function} bool cp_ethernet_address (@w{const String &@var{str}}, @w{unsigned char *@var{result}}, @w{Element *@var{context} = 0})
@deftypefnx {Parsing Function} bool cp_ethernet_address (@w{const String &@var{str}}, @w{EtherAddress *@var{result}}, @w{Element *@var{context} = 0})
Parses @var{str} into an Ethernet address and stores the result in
@code{*@var{result}}. @var{context} supplies any element context.
@end deftypefn


@node Parsing Elements, Parsing Handlers, Parsing Ethernet Addresses, Parsing Functions
@subsection Elements

@code{cp_element} parses an element name into a pointer to an element in
some router configuration. It differs from other parsing functions in two
important ways. First, it returns its result, or a null pointer on
error; parsing functions store their results in some pointer. Second, it
reports errors to the supplied @code{ErrorHandler}.

The @code{cp_element} function follows lexical scoping rules when called
from a compound element: it will check for components of that compound
element first. For instance, say you've called @code{cp_element} on the
string @samp{e}. Normally, this would check the router for an element
named, simply, @samp{e}. However, if called within a compound element
@samp{x}, @code{cp_element} will first check for an element named
@samp{x/e} before looking for the global @samp{e} element. The function
uses its @var{context} argument, an element pointer, to determine both
the relevant router object and any compound element context.

More explicitly, the @code{cp_element} function uses the following
procedure to search for an element named @var{str}:

@enumerate
@item
Set @var{prefix} to @code{@var{context}->id()}.

@item
Remove the final component of @var{prefix}.

@item
Search for an element named @samp{@var{prefix}@var{str}} in
@code{@var{context}->router()}. If one is found, return it.

@item
Otherwise, no element was found. If @var{prefix} is already empty,
parsing fails; report an error to @var{errh} and return a null pointer.
Otherwise, return to step 2.
@end enumerate

@deftypefn {Function} {Element *} cp_element (@w{const String &@var{str}}, @w{Element *@var{context}}, @w{ErrorHandler *@var{errh}})
Returns a element named @var{str} in @var{context}'s router
configuration. @var{str} is first processed as by @code{cp_unquote}.
@var{context} determines both the relevant router configuration and any
compound element context. Returns a null pointer if no element is found;
if @var{errh} is nonnull and no element is found, additionally reports
an error to @var{errh}.
@end deftypefn

A variant function does not perform a lexically scoped search, so its
@var{str} argument must contain a fully-qualified element name.

@deftypefn {Function} {Element *} cp_element (@w{const String &@var{str}}, @w{Router *@var{router}}, @w{ErrorHandler *@var{errh}})
Returns a element named @var{str} in @var{router}. @var{str} is first
processed as by @code{cp_unquote}. Returns a null pointer if no element
is found; if @var{errh} is nonnull and no element is found, additionally
reports an error to @var{errh}.
@end deftypefn


@node Parsing Handlers, Parsing Miscellaneous, Parsing Elements, Parsing Functions
@subsection Handlers

The @code{cp_handler} functions parse a handler specification, such as
@samp{e.config}, into the relevant pair of element and handler ID.
Unlike most other parsing functions, it can report errors to an
@code{ErrorHandler}, if one is supplied.

Most handler specifications consists of an element name and a handler
name separated by a period: @samp{@var{element}.@var{handler}}. The
simplest @code{cp_handler} function parses such a specification into an
element pointer, corresponding to @var{element}, and the handler name,
@var{handler}. Like @code{cp_element} (@pxref{Parsing Elements}),
@code{cp_handler} uses a lexically-scoped search to find the element
corresponding to a given name.

Click also supports a few global handlers, such as @samp{config}.
@code{cp_handler} will also parse global handler names, returning null
for the element pointer.

@deftypefn {Parsing Function} {bool} cp_handler (@w{const String &@var{str}}, @w{Element *@var{context}}, @w{Element **@var{result_element}}, @w{String *@var{result_hname}}, @w{ErrorHandler *@var{errh}})
Parses @var{str} into a handler specification, storing the resulting
element (if any) in @code{*@var{result_element}} and handler name in
@code{*@var{result_hname}}. @var{str} is first processed as by
@code{cp_unquote}. @var{context} determines both the relevant router
configuration and any compound element context. Returns true if and only
if @var{str} contained a valid handler specification whose element part
named an actual element. Note that this function will not check whether
@code{*@var{result_element}} actually has a handler named
@code{*@var{result_hname}}---or, for global handlers, whether the global
handler @code{*@var{result_hname}} actually exists.
@end deftypefn

The other @code{cp_handler} variants ensure that the input string names
an actual handler. These variants are useless until handlers are added
to the router configuration. Therefore, they should be called in
elements' @code{initialize} methods, not their @code{configure} methods,
since handlers are not added until @code{initialize} time
(@pxref{Initialization Phases}).

@deftypefn {Parsing Function} {bool} cp_handler (@w{const String &@var{str}}, @w{Element *@var{context}}, @w{Element **@var{result_element}}, @w{int *@var{result_hid}}, @w{ErrorHandler *@var{errh}})
Parses @var{str} into a handler specification, storing the resulting
element in @code{*@var{result_element}} and handler ID in
@code{*@var{result_hid}}. This function just calls the simpler
@code{cp_handler}, above, then checks that the resulting element has the
named handler.
@end deftypefn

@deftypefn {Parsing Function} {bool} cp_handler (@w{const String &@var{str}}, @w{Element *@var{context}}, @w{bool @var{need_read}}, @w{bool @var{need_write}}, @w{Element **@var{result_element}}, @w{int *@var{result_hid}}, @w{ErrorHandler *@var{errh}})
Similar, but additionally checks for read and/or write handlers. If
@var{need_read} is true, then @var{str} must name a valid read handler;
if @var{need_write} is true, then @var{str} must name a valid write
handler. Returns false if these checks aren't met.
@end deftypefn


@node Parsing Miscellaneous,  , Parsing Handlers, Parsing Functions
@subsection Miscellaneous

The @code{cp_seconds_as} and @code{cp_timeval} functions parse strings
into time.

@deftypefn {Parsing Function} bool cp_seconds_as (@w{int @var{p}}, @w{const String &@var{str}}, @w{int *@var{result}})
Parses @var{str} as a possibly fractional length of time in seconds. The
returned @var{result} is measured in
@tex
$(@r{seconds} * 10^{-p})$;
@end tex
@ifnottex
@math{(@r{seconds} * 10^-@var{p})};
@end ifnottex
for example, if @var{p} is 3, then @var{result} is measured in
milliseconds, and @code{cp_seconds_as(3, "8", @var{result})} stores 8000
in @code{*@var{result}}. 

@var{Str} may contain an optional time unit suffix. Valid units are
@samp{h} or @samp{hr} for hours, @samp{m}/@samp{min} for minutes,
@samp{s}/@samp{sec} for seconds, @samp{ms}/@samp{msec} for milliseconds,
@samp{us}/@samp{usec} for microseconds, and @samp{ns}/@samp{nsec} for
nanoseconds. For example, @code{cp_seconds_as(0, "1h", @var{result})}
stores 3600 in @code{*@var{result}}.

Negative values are not allowed.
@end deftypefn

@deftypefn {Parsing Function} bool cp_seconds_as_milli (@w{const String &@var{str}}, @w{int *@var{result}})
@deftypefnx {Parsing Function} bool cp_seconds_as_micro (@w{const String &@var{str}}, @w{int *@var{result}})
Same as @code{cp_seconds_as(3, @var{s}, @var{result})} and
@code{cp_seconds_as(6, @var{s}, @var{result})}, respectively.
@end deftypefn

@deftypefn {Parsing Function} bool cp_timeval (@w{const String &@var{str}}, @w{struct timeval *@var{result}})
Parses @var{str} as a @code{struct timeval} representing some number of
seconds and microseconds. Textually, this looks like a nonnegative real
number with 6 decimal digits of fraction. Stores the integer part of the
result in @code{@var{result}->tv_sec} and the fraction part in
@code{@var{result}->tv_usec}. Basically equivalent to
@code{cp_unsigned_real10(@var{str}, 6, 0, &@var{result}->tv_sec,
&@var{result}->tv_usec)}.
@end deftypefn


@node cp_va,  , Parsing Functions, Configuration Strings
@section Parsing Argument Lists

@cindex cp_va

@menu
* cp_va Concepts::              
* cp_va Initialization::        
@end menu

@node cp_va Concepts, cp_va Initialization, cp_va, cp_va
@subsection Concepts

@node cp_va Initialization,  , cp_va Concepts, cp_va
@subsection Global Initialization

The @code{cp_va} functions maintain some private global state---for
example, a list of the data types they understand. You must explicitly
initialize this state with @code{cp_va_static_initialize} before calling
any other @code{cp_va} function. You can free this state, if you'd like,
with @code{cp_va_static_cleanup}.

@deftypefun void cp_va_static_initialize ()
Call this function exactly once, at the beginning of the program, before
calling any other @code{cp_va} functions.
@end deftypefun

@deftypefun void cp_va_static_cleanup ()
Call this function exactly once, at the end of the program. It is an
error to call any @code{cp_va} function after calling
@code{cp_va_static_cleanup}.
@end deftypefun

@multitable @columnfractions .3 .7
@item @strong{Constant}
@tab @strong{Storage Arguments}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpArgument}
@tab @code{String *@var{result}}
@item @code{cpString}
@tab @code{String *@var{result}}
@item @code{cpWord}
@tab @code{String *@var{result}}
@item @code{cpKeyword}
@tab @code{String *@var{result}}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpByte}
@tab @code{unsigned char *@var{result}}
@item @code{cpShort}
@tab @code{short *@var{result}}
@item @code{cpUnsignedShort}
@tab @code{unsigned short *@var{result}}
@item @code{cpInteger}
@tab @code{int *@var{result}}
@item @code{cpUnsigned}
@tab @code{unsigned *@var{result}}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpReal2}
@tab @code{@w{int @var{frac_bits}}, @w{int *@var{result}}}
@item @code{cpUnsignedReal2}
@tab @code{@w{int @var{frac_bits}}, @w{unsigned *@var{result}}}
@item @code{cpReal10}
@tab @code{@w{int @var{frac_digits}}, @w{int *@var{result}}}
@item @code{cpUnsignedReal10}
@tab @code{@w{int @var{frac_digits}}, @w{unsigned *@var{result}}}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpIPAddress}
@tab @code{IPAddress *@var{result}}
@item @code{cpIPPrefix}
@tab @code{@w{IPAddress *@var{result_address}}, @w{IPAddress *@var{result_mask}}}
@item @code{cpIPAddressOrPrefix}
@tab @code{@w{IPAddress *@var{result_address}}, @w{IPAddress *@var{result_mask}}}
@item @code{cpIPAddressSet}
@tab @code{@w{IPAddressSet *@var{result}}}
@item @code{cpEtherAddress}
@tab @code{@w{EtherAddress *@var{result}}}
@item @code{cpIP6Address}
@tab @code{IP6Address *@var{result}}
@item @code{cpIP6Prefix}
@tab @code{@w{IP6Address *@var{result_address}}, @w{IP6Address *@var{result_mask}}}
@item @code{cpIP6AddressOrPrefix}
@tab @code{@w{IP6Address *@var{result_address}}, @w{IP6Address *@var{result_mask}}}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpElement}
@tab @code{@w{Element **@var{result}}}
@item @code{cpHandlerName}
@tab @code{@w{Element **@var{result_element}},} @code{@w{String
*@var{result_hname}}}
@item @code{cpHandler}
@tab @code{@w{Element **@var{result_element}}, @w{int *@var{result_hid}}}
@item @code{cpReadHandler}
@tab @code{@w{Element **@var{result_element}}, @w{int *@var{result_hid}}}
@item @code{cpWriteHandler}
@tab @code{@w{Element **@var{result_element}}, @w{int *@var{result_hid}}}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpBool}
@tab @code{@w{bool *@var{result}}}
@item @code{cpSeconds}
@tab @code{@w{int *@var{result}}}
@item @code{cpSecondsAsMilli}
@tab @code{@w{int *@var{result}}}
@item @code{cpSecondsAsMicro}
@tab @code{@w{int *@var{result}}}
@item @code{cpTimeval}
@tab @code{@w{struct timeval *@var{result}}}
@end multitable



@multitable @columnfractions .3 .7
@item @strong{Constant}
@tab @strong{Corresponding Parsing Function}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpArgument}
@tab @code{*@var{result} = arg}
@item @code{cpString}
@tab @code{cp_string(arg, @var{result})}
@item @code{cpWord}
@tab @code{cp_string(arg, @var{result})}
@item @code{cpKeyword}
@tab @code{cp_keyword(arg, @var{result})}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpByte}
@tab @code{cp_unsigned(arg, &tmp)}, check range, store in
@var{result}
@item @code{cpShort}
@tab @code{cp_integer(arg, &tmp)}, check range, store in
@var{result}
@item @code{cpUnsignedShort}
@tab @code{cp_unsigned(arg, &tmp)}, check range, store in
@var{result}
@item @code{cpInteger}
@tab @code{cp_integer(arg, @var{result})}
@item @code{cpUnsigned}
@tab @code{cp_unsigned(arg, @var{result})}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpReal2}
@tab @code{cp_real2(arg, @var{frac_bits}, @var{result})}
@item @code{cpUnsignedReal2}
@tab @code{cp_unsigned_real2(arg, @var{frac_bits}, @var{result})}
@item @code{cpReal10}
@tab @code{cp_real10(arg, @var{frac_digits}, @var{result})}
@item @code{cpUnsignedReal10}
@tab @code{cp_unsigned_real10(arg, @var{frac_digits}, @var{result})}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpIPAddress}
@tab @code{cp_ip_address(arg, @var{result}, context)}
@item @code{cpIPPrefix}
@tab @code{cp_ip_prefix(arg, @var{result_address},
@var{result_mask}, false, context)}
@item @code{cpIPAddressOrPrefix}
@tab @code{cp_ip_prefix(arg, @var{result_address},
@var{result_mask}, true, context)}
@item @code{cpIPAddressSet}
@tab @code{cp_ip_address_set(arg, @var{result}, context)}
@item @code{cpEtherAddress}
@tab @code{cp_ether_address(arg, @var{result}, context)}
@item @code{cpIP6Address}
@tab @code{cp_ip6_address(arg, @var{result}, context)}
@item @code{cpIP6Prefix}
@tab @code{cp_ip6_prefix(arg, @var{result_address},
@var{result_mask}, false, context)}
@item @code{cpIP6AddressOrPrefix}
@tab @code{cp_ip6_prefix(arg, @var{result_address},
@var{result_mask}, false, context)}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpElement}
@tab @code{cp_element(arg, context, @var{result})}
@item @code{cpHandlerName}
@tab @code{cp_handler(arg, context, @var{result_element},
@var{result_hname})}
@item @code{cpHandler}
@tab @code{cp_handler(arg, context, @var{result_element},
@var{result_hid})}
@item @code{cpReadHandler}
@tab @code{cp_handler(arg, context, true, false, @var{result_element},
@var{result_hid})}
@item @code{cpWriteHandler}
@tab @code{cp_handler(arg, context, false, true, @var{result_element},
@var{result_hid})}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpBool}
@tab @code{cp_bool(arg, @var{result})}
@item @code{cpSeconds}
@tab @code{cp_seconds_as(0, arg, @var{result})}
@item @code{cpSecondsAsMilli}
@tab @code{cp_seconds_as(3, arg, @var{result})}
@item @code{cpSecondsAsMicro}
@tab @code{cp_seconds_as(6, arg, @var{result})}
@item @code{cpTimeval}
@tab @code{cp_timeval(arg, @var{result})}
@end multitable


@node Tasks, Timers, Configuration Strings, Top
@chapter Tasks

Click schedules a router's CPU or CPUs with one or more @dfn{task
queues}. These queues are simply lists of @dfn{tasks}, which represent
functions that would like access to the CPU. Tasks are generally
associated with elements. When scheduled, most tasks call some element's
@code{run_task} method.

Click tasks are represented by @code{Task} objects. An element that
would like special access to a router's CPU should include and
initialize a @code{Task} instance variable.

Tasks are generally called very frequently, up to tens of thousands of
times per second. For infrequent events, it is far more efficient to use
timers than to use tasks; see @ref{Timers}.

Executing a task should not take a long time. The Click driver loop is
not currently adaptive, so very long tasks can inappropriately delay
timers and other periodic events. We may address this problem in a
future release, but for now, keep tasks short.

The @code{Task} class is defined in the @code{<click/task.hh>} header
file.

@menu
* Task Initialization::         
* Scheduling Tasks::            
* Tickets::                     
* Task Thread Choice::          
* Task Status::                 
* Task Handlers::               
* Task Cleanup::                
@end menu


@node Task Initialization, Scheduling Tasks, Tasks, Tasks
@section Task Initialization

Task initialization is a two-step process. First, when a @code{Task}
object is constructed, you must supply information about the function
that it should call when it is scheduled. Second, when the router is
initialized, you must initialize the task by supplying it with the
relevant router. (You must initialize the task even if it will not be
scheduled right away.)

@code{Task} has two constructors. One of them asks the task to call an
element's @code{run_task} method when scheduled; the other asks it
to call an arbitrary function pointer.

@deftypeop Constructor Task {} Task (Element *@var{e})
When this task is scheduled, call @code{@var{e}->run_task()}.
@end deftypeop

@deftypeop Constructor Task {} Task (TaskHook @var{hook}, void *@var{thunk})
When this task is scheduled, call @code{@var{hook}(this, @var{thunk})}.
The @var{hook} argument is a function pointer with type @code{void
(*)(Task *, void *)}.
@end deftypeop

The @code{Task::initialize} method places the task on a router-wide list
of @code{Task}s, associates the task with a particular task queue, and,
optionally, schedules it. Typically, an element's @code{initialize}
method calls @code{Task::initialize} (@pxref{initialize}).

@deftypemethod Task void initialize (Router *@var{r}, bool @var{scheduled})
@deftypemethodx Task void initialize (Element *@var{e}, bool @var{scheduled})
Attaches the task to the router object @var{r} (or
@code{@var{e}->router()}). Additionally sets the task's tickets to a
default value, and schedules the task if @var{scheduled} is true.
@end deftypemethod

Many elements call @code{ScheduleInfo::initialize_task} instead of
calling @code{Task::initialize} directly. This method queries any
@click{ScheduleInfo} elements in the configuration to determine the
task's scheduling parameters, sets those parameters, and calls
@code{Task::initialize} to schedule the task. The
@code{ScheduleInfo::initialize_task} method is defined in the
@code{<click/standard/scheduleinfo.hh>} header file.

@deftypeop {Static Method} ScheduleInfo void initialize_task (Element *@var{e}, @w{Task *@var{task}}, @w{bool @var{schedule}}, @w{ErrorHandler *@var{errh}})
Sets @var{task}'s scheduling parameters as specified by any
@click{ScheduleInfo} elements in the router configuration. The element
@var{e} is used to find the correct router, and provides the relevant
name for parameter lookup---the user supplies parameters to
@click{ScheduleInfo} by element name. If @var{schedule} is true, also
schedules @var{task} on @code{@var{e}->router()}'s task queue. Reports
any errors to @var{errh}.
@end deftypeop

@deftypeop {Static Method} ScheduleInfo void initialize_task (Element *@var{e}, @w{Task *@var{task}}, @w{ErrorHandler *@var{errh}})
A synonym for @code{initialize_task(@var{e}, @var{task}, true,
@var{errh})}.
@end deftypeop

@deftypeop {Static Method} ScheduleInfo void join_scheduler (Element *@var{e}, @w{Task *@var{task}}, @w{ErrorHandler *@var{errh}})
A synonym for @code{initialize_task(@var{e}, @var{task}, true,
@var{errh})}.
@end deftypeop

The @code{initialize_task} method is generally called like this:

@example
int
SomeElement::initialize(ErrorHandler *errh)
@{
    ScheduleInfo::initialize_task(this, &_task, errh);
@}
@end example

@noindent
Here, @code{_task}, a @code{Task} object, is one of @code{SomeElement}'s
instance variables.


@node Scheduling Tasks, Tickets, Task Initialization, Tasks
@section Scheduling Tasks

The user may take a task off its task queue with the @code{unschedule}
method, and place it back onto its task queue with the @code{reschedule}
method. As tasks move to the head of the task queue, they are
unscheduled and their callbacks are called. Within these callback
functions, the user will typically call @code{fast_reschedule}, which is
like @code{reschedule} without the locking overhead.

@deftypemethod Task void unschedule ()
Unschedules the task by removing it from its task queue. Does nothing if
if the task is currently unscheduled, or if it was never initialized.
When this function returns, the task will not be scheduled.
@end deftypemethod

@deftypemethod Task void unschedule_soon ()
Unschedules the task by removing it from its task queue. Does nothing if
if the task is currently unscheduled, or if it was never initialized.
This function may schedule a task request if it cannot immediately
unschedule the task.
@end deftypemethod

@deftypemethod Task void reschedule ()
Reschedules the task by placing it on its task queue. If the task is
already scheduled, then this method does nothing.
@end deftypemethod

All three functions lock the task queue before manipulating it. This
avoids corruption when there are multiple processors executing
simultaneously. If @code{unschedule_soon} or @code{reschedule} cannot
immediately lock a task queue---perhaps because it is being used on
another processor---then they register a task request, which will be
executed in the near future. In contrast, the @code{unschedule} function
will wait until it can lock the task queue.

The @code{fast_reschedule} method avoids locking overhead in the common
case that a task must be rescheduled from within its callback.

@deftypemethod Task void fast_reschedule ()
Reschedules the task by placing it on its preferred task queue. This
method avoids locking overhead, so it is faster than @code{reschedule}.

@quotation
@strong{Caution}: You may call a @code{Task}'s @code{fast_reschedule}
method only from within its callback function. For instance, if an
element has a task, @w{@code{_task}}, that calls the element's
@code{run_task} method when scheduled, and if @code{run_task}
is called only by that task's callback, then that element's
@code{run_task} method should call @code{_task.fast_reschedule()}
instead of @code{_task.reschedule()}.
@end quotation
@end deftypemethod

The @code{fast_unschedule} method is to @code{unschedule} as
@code{fast_reschedule} is to @code{reschedule}. It is rarely used,
however, since tasks are automatically unscheduled before they are run.

@deftypemethod Task void fast_unschedule ()
Unschedules the task by removing it from its task queue. Does nothing if
if the task is currently unscheduled, or if it was never initialized.
This method avoids locking overhead, so it is faster than
@code{unschedule}.

@quotation
@strong{Caution}: You may call a @code{Task}'s @code{fast_unschedule}
method only from within its callback function.
@end quotation
@end deftypemethod


@node Tickets, Task Thread Choice, Scheduling Tasks, Tasks
@section Tickets

Click tasks are scheduled using the flexible, lightweight stride
scheduling algorithm.@footnote{For more information, see MIT Laboratory
for Computer Science Technical Memo MIT/LCS/TM-528, @cite{Stride
scheduling: deterministic proportional-share resource management}, by
Carl A. Waldspurger and William E. Weihl, June 1995.} This algorithm
assigns each task a parameter called its @dfn{tickets}. A task with
twice as many tickets as usual is scheduled twice as frequently.

@code{Task}s have methods for querying, setting, and adjusting their
tickets.

@deftypemethod Task int tickets () const
Returns this task's tickets. This number will be at least 1 and no more
than @code{Task::MAX_TICKETS}, which equals 32768.
@end deftypemethod

@deftypemethod Task void set_tickets (int @var{t})
Sets this task's tickets to @var{t}. The @var{t} parameter should lie
between 1 and @code{Task::MAX_TICKETS}, inclusive; numbers outside this
range are constrained to the nearest valid value.
@end deftypemethod

@deftypemethod Task void adj_tickets (int @var{delta})
Equivalent to @code{set_tickets(tickets() + @var{delta})}.
@end deftypemethod


@node Task Thread Choice, Task Status, Tickets, Tasks
@section Choosing a Thread

Each task belongs to some task queue, which generally corresponds to a
thread of control. Single-threaded Click has one active thread, and
therefore one task queue, but multithreaded Click can have an arbitrary
number of threads. Every task starts out belonging to the first thread,
@w{thread 0}. The @code{change_thread} method moves a task to another
thread.

@deftypemethod Task void change_thread (int @var{thread_id})
Move this task to thread @var{thread_id}, which should be a number
between @math{-1} and the relevant @code{Router}'s @code{nthreads()}.

The task is scheduled on the new task queue if and only if it was
scheduled on the old task queue.
@end deftypemethod

Like @code{unschedule_soon} and @code{reschedule}, @code{change_thread}
must lock the task queue before manipulating it. (Unlike those methods,
@code{change_thread} must lock two task queues, the old and the new.) If
@code{change_thread} cannot lock a task queue, then it registers a task
request that will be executed in the near future. This implies that a
task may remain on the same thread, or become unscheduled, for some time
after @code{change_thread} is called.


@node Task Status, Task Handlers, Task Thread Choice, Tasks
@section Task Status Methods

These methods let a user check various properties of a task---for
instance, whether it is initialized or scheduled.

@deftypemethod Task bool initialized () const
Returns true iff the task has been initialized---that is, if it is
associated with some router.
@end deftypemethod

@deftypemethod Task bool scheduled () const
Returns true iff the task is currently scheduled on some task queue.
@end deftypemethod

@deftypemethod Task {RouterThread *} scheduled_list () const
Returns the task queue with which this task is associated. Even
unscheduled tasks are associated with some task queue; this is the task
queue on which the task will be placed if @code{reschedule} is called.
@end deftypemethod

@deftypemethod Task TaskHook hook () const
Returns the callback function that is called when the task is scheduled.
If the task is associated with some element, this method returns a null
pointer.
@end deftypemethod

@deftypemethod Task {void *} thunk () const
Returns the extra data passed to the callback function when the task is
scheduled.
@end deftypemethod

@deftypemethod Task {Element *} element () const
If the task is associated with some element, this method returns that
element. Otherwise, returns a null pointer.
@end deftypemethod


@node Task Handlers, Task Cleanup, Task Status, Tasks
@section Task Handlers

By convention, elements with tasks should provide handlers that access
task properties. The @code{Element::add_task_handlers} method
automatically adds these handlers for a given @code{Task} object.

@deftypemethod Element void add_task_handlers (@w{Task *@var{task}}, @w{const String &@var{prefix} = String()})
Adds task handlers for @var{task} to this element. The string
@var{prefix} is prepended to every handler name.
@end deftypemethod

This method adds at least the following handlers:

@table @asis
@item @handler{scheduled}
Returns a Boolean value saying whether the task is currently scheduled
on some task queue. Example result: @strcode{"true\n"}.

@item @handler{tickets}
Returns the task's currently allocated tickets. This handler is only
available if Click was compiled to support stride scheduling. Example
result: @strcode{"1024\n"}.

@item @handler{thread_preference}
Returns the task's thread preference. This handler is only available on
multithreaded Click. Example result: @strcode{"2\n"}.
@end table


@node Task Cleanup,  , Task Handlers, Tasks
@section Task Cleanup

You generally don't need to worry about destroying @code{Task} objects:
they are automatically unscheduled and removed when the @code{Router} is
destroyed. This only works if the @code{Task} objects have the same
lifetime as the @code{Router}, however. This includes the normal case,
when @code{Task}s are element instance variables. If you create and
destroy @code{Task} objects as the router runs, however, you will need
to call the following method before deleting the @code{Task}.

@deftypemethod Task void cleanup ()
Cleans up the @code{Task} object.
@end deftypemethod


@node Timers, Notification, Tasks, Top
@chapter Timers

Click @dfn{timers}, like Click tasks, represent callback functions that
the driver calls when appropriate. Unlike tasks, however, you schedule
timers to go off at a specified time. Timers are intended for more
infrequent and/or slower tasks.

As with @code{Task}, most @code{Timer} objects are declared as instance
variables of elements and scheduled when needed.

Timers may be scheduled with microsecond precision, but on current
hardware, only millisecond precision is likely to be achievable.

The @code{Timer} class is defined in the @code{<click/timer.hh>} header
file.

@menu
* Timer Initialization::        
* Scheduling Timers::           
* Timer Status Methods::        
* Timer Cleanup::               
@end menu


@node Timer Initialization, Scheduling Timers, Timers, Timers
@section Timer Initialization

Timer initialization resembles task initialization. When the timer is
constructed, you must supply it with information about its callback
function. Later, after the router is initialized, you must initialize
and, optionally, schedule it.

@deftypeop Constructor Timer {} Timer (@w{Element *@var{e}})
When this timer goes off, call @code{@var{e}->run_timer()}.
@end deftypeop

@deftypeop Constructor Timer {} Timer (@w{Task *@var{t}})
When this timer goes off, call @code{@var{t}->reschedule()}.
@end deftypeop

@deftypeop Constructor Timer {} Timer (@w{TimerHook @var{hook}}, @w{void *@var{thunk}})
When this timer goes off, call @code{@var{hook}(this, @var{thunk})}. The
@var{hook} argument is a function pointer with type @code{void (*)(Timer
*, void *)}.
@end deftypeop

@deftypemethod Timer void initialize (@w{Router *@var{r}})
@deftypemethodx Timer void initialize (@w{Element *@var{e}})
Attaches the timer to the router object @var{r} (or
@code{@var{e}->router()}).
@end deftypemethod

Typically, an element's @code{initialize} method (@pxref{initialize})
calls @code{Timer::initialize}, and possibly one of the @code{schedule}
functions described below.


@node Scheduling Timers, Timer Status Methods, Timer Initialization, Timers
@section Scheduling Timers

A variety of methods schedule timers to go off at specified times. The
basic method is @code{schedule_at}, which schedules the timer for a
specified time. Subsidiary methods schedule the timer relative to the
current time (the @code{schedule_after} methods), or relative to the
last time the timer was scheduled to run (the @code{reschedule_after}
methods). Finally, @code{unschedule} unschedules the timer.

All @code{schedule} and @code{reschedule} functions first unschedule the
timer if it was already scheduled.

The @code{reschedule} methods are particularly useful for timers that
should occur periodically. For example, this callback function will
cause its timer to go off at 20-second intervals:

@example
void timer_callback(Timer *t, void *) @{
    t->reschedule_after_s(20);
@}
@end example


@deftypemethod Timer void schedule_at (@w{const struct timeval &@var{when}})
Schedule the timer to go off at @var{when}. You must have initialized
the timer earlier.
@end deftypemethod

@deftypemethod Timer void schedule_now ()
Schedule the timer to go off as soon as possible.
@end deftypemethod

@deftypemethod Timer void schedule_after_s (@w{uint32_t @var{delay}})
Schedule the timer to go off @var{delay} seconds after the current time.
@end deftypemethod

@deftypemethod Timer void schedule_after_ms (@w{uint32_t @var{delay}})
Schedule the timer to go off @var{delay} milliseconds after the current
time.
@end deftypemethod

@deftypemethod Timer void reschedule_after_s (@w{uint32_t @var{delay}})
Schedule the timer to go off @var{delay} seconds after it was last
scheduled to go off. If the timer was never previously scheduled to go
off, this method will schedule the timer for some arbitrary time.
@end deftypemethod

@deftypemethod Timer void reschedule_after_ms (@w{uint32_t @var{delay}})
Schedule the timer to go off @var{delay} milliseconds after it was last
scheduled to go off.
@end deftypemethod

@deftypemethod Timer void unschedule ()
Unschedules the timer, if it was scheduled.
@end deftypemethod


@node Timer Status Methods, Timer Cleanup, Scheduling Timers, Timers
@section Timer Status Methods

These methods return information about a timer, including when it is
scheduled to expire.

@deftypemethod Timer bool initialized () const
Returns true iff the timer has been initialized with a call to
@code{initialize()}. Uninitialized timers must not be scheduled.
@end deftypemethod

@deftypemethod Timer bool scheduled () const
Returns true iff the timer is scheduled to expire some time in the
future.
@end deftypemethod

@deftypemethod Timer {const struct timeval &} when () const
Returns the time that the timer is set to expire. If the timer has never
been scheduled, the value is garbage. If the timer was scheduled but is
not scheduled currently, the value is most recently set expiry time.
@end deftypemethod
 

@node Timer Cleanup,  , Timer Status Methods, Timers
@section Timer Cleanup

You don't need to worry about cleaning up @code{Timer} objects. They are
automatically unscheduled and removed when the @code{Router} is
destroyed, and deleting a @code{Timer} automatically removes it from any
relevant lists. The following function is nevertheless provided for
consistency with @code{Task}s, which do need to be cleaned up in certain
circumstances (@pxref{Task Cleanup}).

@deftypemethod Timer void cleanup ()
Cleans up the @code{Timer} object.
@end deftypemethod


@node Notification, Coding Standards, Timers, Top
@chapter Notification


@node Coding Standards, Index, Notification, Top
@chapter Coding Standards


@menu
* Upper and lower case names::  
* Common name patterns::        
@end menu


@node Upper and lower case names, Common name patterns, Coding Standards, Coding Standards
@section Upper and Lower Case in Names

Keep to the following consistent scheme for choosing between upper and
lower case when naming variables, types, and functions.

@table @strong
@item Classes
Use mixed case with an initial capital letter and no underscores:
@code{LookupIPRoute}.

@item Methods
Use all lower case with underscores separating words:
@code{negation_is_simple}.

@item Constants
Use all upper case with underscores separating words:
@code{TYPE_ICMP_TYPE}.

@item Instance variables
Begin with an underscore, then use all lower case with underscores
separating words: @code{_length}.

@item Regular variables
Use all lower case with underscores separating words: @code{i},
@code{the_handler}.

@item Class variables
These variables are declared as @code{static} in the class header. Name
them like regular variables: @code{nelements_allocated}.

@item Functions
Name them like methods: @code{quicksort_hook}.

@item Other types
This includes typedefs and enumerated types. Name them like classes:
@code{CpVaParseCmd}, @code{ConfigurePhase}.
@end table

There are exceptions to these guidelines. In particular:

@itemize @bullet
@item
Instance variables in C structs---that is, classes with few methods
whose instance variables are mostly public---may be named like regular
variables, without a preceding underscore. The same goes for the
components of unions.

@item
Classes that act like simple types, such as @code{uatomic32_t}, take
names similar to the types they replace (in this case @code{uint32_t}).
@end itemize


@node Common name patterns,  , Upper and lower case names, Coding Standards
@section Common Name Patterns

@itemize @bullet
@item
Many instance variables have associated @dfn{getter methods} that return
their values, and/or @dfn{setter methods} that change their values. For
an instance variable named @code{_x}, the getter method should be named
@code{x()} and the setter method should be named @code{set_x()}.

@item
A variable or method which counts something is often named
@code{n@var{object}s}---for instance, @code{_nwarnings},
@code{ninputs()}, @code{_npackets}.

@item
Use a bare @samp{0} for a null pointer, except where some ambiguity
might arise (for example, where an incorrect overloading might be
selected).
@end itemize


@node Index,  , Coding Standards, Top
@unnumbered Index

@printindex cp

@bye
