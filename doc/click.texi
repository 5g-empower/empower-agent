\input texinfo.tex
@setfilename click.info
@settitle Click
@footnotestyle end

@iftex
@frenchspacing
@end iftex

@ifinfo
@macro click {arg}
@code{\arg\}
@end macro
@end ifinfo
@ifnotinfo
@macro click {arg}
@emph{\arg\}
@end macro
@end ifnotinfo

@macro strcode {arg}
@t{\arg\}
@end macro

@syncodeindex vr cp
@syncodeindex fn cp

@titlepage
@title The Click Modular Router Programming Manual
@author Eddie Kohler
@end titlepage

@contents

@node Top, Coding Standards, (dir), (dir)
@top

@ifinfo
This document describes@dots{}
@end ifinfo

@menu
* Coding Standards::            
* Basics::                      
* Element Initialization::      
* Tasks::                       
* Timers::                      
* Index::                       

@detailmenu
 --- The Detailed Node Listing ---

Coding Standards

* Upper and lower case names::
* Common name patterns::

Basics

* String::                      
* StringAccum::                 
* Vector::                      
* Bitvector::                   
* HashMap::                     
* BigHashMap::                  
* ErrorHandler::                

String

* String Constructors::         
* String Contents::             
* String Characters::           
* Derived Strings::             
* Appending to Strings::        
* String Comparison::           

ErrorHandler

* Reporting Errors::            
* Error Format Strings::        
* Counting Errors::             
* Basic Error Handlers::        
* Error Veneers::               
* Writing Error Handlers::       

Element Initialization

* notify_ninputs notify_noutputs::  
* configure::                   
* processing::                  
* flow_code::                   
* initialize::                  
* configure_phase::             
* uninitialize::                
* Initialization Phases::       

Tasks

* Task Initialization::         
* Scheduling a Task::           
* Tickets::                     
* Multiple Task Queues::        
* Task Status::                 
* Destroying a Task::           

@end detailmenu
@end menu

@node Coding Standards, Basics, Top, Top
@chapter Coding Standards


@menu
* Upper and lower case names::
* Common name patterns::
@end menu


@node Upper and lower case names, Common name patterns, Coding Standards, Coding Standards
@section Upper and Lower Case in Names

Keep to the following consistent scheme for choosing between upper and
lower case when naming variables, types, and functions.

@table @strong
@item Classes
Use mixed case with an initial capital letter and no underscores:
@code{LookupIPRoute}.

@item Methods
Use all lower case with underscores separating words:
@code{negation_is_simple}.

@item Constants
Use all upper case with underscores separating words:
@code{TYPE_ICMP_TYPE}.

@item Instance variables
Begin with an underscore, then use all lower case with underscores
separating words: @code{_length}.

@item Regular variables
Use all lower case with underscores separating words: @code{i},
@code{the_handler}.

@item Class variables
These variables are declared as @code{static} in the class header. Name
them like regular variables: @code{nelements_allocated}.

@item Functions
Name them like methods: @code{quicksort_hook}.

@item Other types
This includes typedefs and enumerated types. Name them like classes:
@code{CpVaParseCmd}, @code{ConfigurePhase}.
@end table

There are exceptions to these guidelines. In particular:

@itemize @bullet
@item
Instance variables in C structs---that is, classes with few methods
whose instance variables are mostly public---may be named like regular
variables, without a preceding underscore. The same goes for the
components of unions.

@item
Classes that act like simple types, such as @code{u_atomic32_t}, take
names similar to the types they replace (in this case @code{u_int32_t}).
@end itemize


@node Common name patterns,  , Upper and lower case names, Coding Standards
@section Common Name Patterns

@itemize @bullet
@item
Many instance variables have associated @dfn{getter methods} that return
their values, and/or @dfn{setter methods} that change their values. For
an instance variable named @code{_x}, the getter method should be named
@code{x()} and the setter method should be named @code{set_x()}.

@item
A variable or method which counts something is often named
@code{n@var{object}s}---for instance, @code{_nwarnings},
@code{ninputs()}, @code{_npackets}.
@end itemize


@node Basics, Element Initialization, Coding Standards, Top
@chapter Basics

@menu
* String::                      
* StringAccum::                 
* Vector::                      
* Bitvector::                   
* HashMap::                     
* BigHashMap::                  
* ErrorHandler::                
@end menu

@node String, StringAccum, Basics, Basics
@section String

The @code{String} class represents a dynamically-allocated string of
characters. Strings may be constructed from C strings, characters,
numbers, and so forth. They may also be added together. A @code{String}
and its substrings will generally share memory. @code{String}s may be
passed and stored at will; they allocate and free memory as appropriate.

@menu
* String Constructors::         
* String Contents::             
* String Characters::           
* Derived Strings::             
* Appending to Strings::        
* String Comparison::           
@end menu

@node String Constructors, String Contents, String, String
@subsection Constructors

@deftypeop Constructor String {} String ()
Creates a string with no characters.
@end deftypeop

@deftypeop Constructor String {} String (const char *@var{s})
Creates a string containing a copy of the C string @var{s}.
@end deftypeop

@deftypeop Constructor String {} String (const char *@var{s}, int @var{len})
Creates a string containing the first @var{len} characters of @var{s}.
If @var{len} is negative, then this function treats @var{s} as a C
string, effectively setting @var{len} to @code{strlen(@var{s})}.
@end deftypeop

@deftypeop Constructor String {} String (char @var{c})
@deftypeopx Constructor String {} String (unsigned char @var{c})
Creates a string containing the single character @var{c}.
@end deftypeop

@deftypeop Constructor String {} String (int @var{n})
@deftypeopx Constructor String {} String (unsigned @var{n})
@deftypeopx Constructor String {} String (long @var{n})
@deftypeopx Constructor String {} String (unsigned long @var{n})
@deftypeopx Constructor String {} String (unsigned long long @var{n})
@deftypeopx Constructor String {} String (double @var{n})
Creates a string containing an ASCII representation of the number
@var{n}. For example, if @var{n} is 20, then @code{String(@var{n})}
equals @code{"20"}. The @code{double} constructor is not available in
the kernel.
@end deftypeop

@deftypeop {Static method} String {const String &} null_string ()
Returns a const reference to a string with no characters. Useful in
situations where you wish to avoid unnecessary memory operations by
returning string references instead of @code{String}s.
@end deftypeop

@deftypeop {Static method} String String claim_string (char *@var{s}, int @var{len})
Creates and returns a string containing the @var{len} bytes of data
starting at @var{s}. If @var{len} is negative, then this function treats
@var{s} as a C string, effectively setting @var{len} to
@code{strlen(@var{s})}. The @var{s} memory is claimed by the
@code{String} implementation. When the last @code{String} referencing
this memory is destroyed, the memory itself will be freed by calling
@code{delete[] @var{s}}. (Thus, @var{s} should have been allocated with
@code{new[]}.)
@end deftypeop

@deftypeop {Static method} String String stable_string (const char *@var{s}, int @var{len})
Creates and returns a string containing the @var{len} bytes of data
starting at @var{s}. If @var{len} is negative, then this function treats
@var{s} as a C string, effectively setting @var{len} to
@code{strlen(@var{s})}. The caller guarantees that @var{s} is located in
stable, read-only memory and will not be changed while any @code{String}
references to it still exist. For example, @var{s} might be a C string
constant. The @code{String} implementation will not alter or free
@var{s}. Functions such as @code{mutable_data} (see below) will return
copies of @var{s}, not @var{s} itself.
@end deftypeop


@node String Contents, String Characters, String Constructors, String
@subsection Contents

@quotation
@strong{Caution}: Any pointer to a string's data should be treated as
temporary, since once the string is destroyed, that memory will be
freed. Remember, however, that a temporary @code{String} object will not
be destroyed until the end of the statement in which it was created.
Therefore, this use of @code{cc()} is safe:

@example
String a, b; // ...
fprintf(stderr, "%s\n", (a + b).cc());
@end example

This use is not safe:

@example
String a, b; // ...
const char *s = (a + b).cc();
fprintf(stderr, "%s\n", s); // probably an error
@end example
@end quotation

@deftypemethod String {const char *} data () const
Returns a pointer to the string's data. This data is not guaranteed to
be null-terminated. Only the first @code{length()} of its characters are
valid.
@end deftypemethod

@deftypemethod String int length () const
Returns the string's length in characters.
@end deftypemethod

@deftypemethod String {} {operator bool} () const
Returns true iff the string has at least one character.
@end deftypemethod

@deftypemethod String {char *} mutable_data ()
Returns a mutable pointer to the string's data. If the data is shared
with any other @code{String} object, or was allocated by
@code{stable_string} (see above), then this method will transparently
modify the @code{String} to use a unique copy of the data, and return
that.
@end deftypemethod

@deftypemethod String {const char *} cc ()
@deftypemethodx String {const char *} c_str ()
@deftypemethodx String {} {operator const char *} ()
Returns a pointer to the string's data as a C string. This may
transparently modify the @code{String} by adding a null character after
the string's data, which may involve making a copy of the data. This
null character will not be counted as part of the string's length.
@end deftypemethod

@deftypemethod String {char *} mutable_c_str ()
Returns a mutable pointer to the string's data as a C string.
@end deftypemethod


@node String Characters, Derived Strings, String Contents, String
@subsection Characters and Indices

@deftypemethod String char {operator []} (int @var{i}) const
Returns the @var{i}th character of the string. @var{i} should be between
0 and @math{@code{length()} - 1}.
@end deftypemethod

@deftypemethod String char back () const
Returns the last character of the string. The string must not be empty.
@end deftypemethod

@deftypemethod String int find_left (int @var{c}, int @var{start} = 0) const
Returns the position of the first occurrence of the character @var{c} in
the string on or after position @var{start}. If @var{c} does not occur
on or after position @var{start}, returns @math{-1}.
@end deftypemethod

@deftypemethod String int find_right (int @var{c}) const
@deftypemethodx String int find_right (int @var{c}, int @var{start}) const
Returns the position of the last occurrence of the character @var{c} in
the string before position @var{start}. If @var{start} is not supplied,
returns the absolute last occurrence of @var{c} in the string. If
@var{c} does not occur before position @var{start}, returns @math{-1}.
@end deftypemethod

@deftypemethod String int find_left (const String &@var{s}, int @var{start} = 0) const
Returns the position of the first occurrence of the substring @var{s} in
the string on or after position @var{start}. If @var{s} does not occur
on or after position @var{start}, returns @math{-1}.
@end deftypemethod


@node Derived Strings, Appending to Strings, String Characters, String
@subsection Derived Strings

@deftypemethod String String substring (int @var{pos}, int @var{len}) const
Returns a new string containing characters @var{pos} through
@math{@var{pos} + @var{len} - 1} of this string.

If @var{pos} is negative, then start @math{-@var{pos}} characters from
the end of the string. If @var{len} is negative, then drop
@math{-@var{len}} characters from the end of the string. @var{len} may
be too large; only characters actually in the string will be returned.
If @var{pos} is too large or too small, the result is a null string.

These examples demonstrate the use of @var{substring}:

@example
String("abcde").substring(2, 2)   == "cd"
String("abcde").substring(-3, 2)  == "cd"
String("abcde").substring(-3, -1) == "cd"
String("abcde").substring(2, 10)  == "cde"
String("abcde").substring(10, 4)  == ""
String("abcde").substring(-10, 4) == ""
@end example
@end deftypemethod

@deftypemethod String String substring (int @var{pos}) const
Same as @code{substring(@var{pos}, length() - @var{pos})}: return a new
string containing all of this string's characters starting at @var{pos}.
@end deftypemethod

@deftypemethod String String lower () const
Return a string equal to this string, but with all alphabetic characters
translated to lower case.
@end deftypemethod

@deftypemethod String String upper () const
Return a string equal to this string, but with all alphabetic characters
translated to upper case.
@end deftypemethod


@node Appending to Strings, String Comparison, Derived Strings, String
@subsection Appending to Strings

If you are gradually building up a string by successive appends, you
should probably use @code{StringAccum} instead of these @code{String}
operations (@pxref{StringAccum}).

@deftypemethod String void append (const char *@var{s}, int @var{len})
Appends the first @var{len} characters of @var{s} to the end of this
string. If @var{len} is negative, then this function treats @var{s} as a
C string, effectively setting @var{len} to @code{strlen(@var{s})}.
@end deftypemethod

@deftypemethod String void append_fill (int @var{c}, int @var{len})
Adds @var{len} copies of the character @var{c} to the end of this
string.
@end deftypemethod

@deftypemethod String void append_space (int @var{len})
Adds @var{len} arbitrary characters to the end of this string.
@end deftypemethod

@deftypemethod String {String &} {operator+=} (const String &@var{s})
@deftypemethodx String {String &} {operator+=} (const char *@var{s})
@deftypemethodx String {String &} {operator+=} (char @var{c})
Appends the string @var{s} or character @var{c} to this string.
@end deftypemethod

@deftypefun String {operator+} (String @var{s1}, const String &@var{s2})
@deftypefunx String {operator+} (String @var{s1}, const char *@var{s2})
@deftypefunx String {operator+} (const char *@var{s1}, const String &@var{s2})
@deftypefunx String {operator+} (String @var{s1}, char @var{c})
Appends the string @var{s2} or character @var{c} to the string @var{s1},
and returns the resulting string.
@end deftypefun


@node String Comparison,  , Appending to Strings, String
@subsection Comparison

@deftypemethod String bool equals (const char *@var{s}, int @var{len}) const
Compares this string to the first @var{len} characters of @var{s}. If
@var{len} is negative, then this function treats @var{s} as a C string,
effectively setting @var{len} to @code{strlen(@var{s})}. Returns true
iff the two strings have the same length and contain the same characters
in the same order.
@end deftypemethod

@deftypefun bool {operator==} (const String &@var{s1}, const String &@var{s2})
@deftypefunx bool {operator==} (const char *@var{s1}, const String &@var{s2})
@deftypefunx bool {operator==} (const String &@var{s1}, const char *@var{s2})
Returns true iff the two strings are equal---that is, returns
@code{@var{s1}.equals(@var{s2}.data(), @var{s2}.length())}.
@end deftypefun

@deftypefun bool {operator!=} (const String &@var{s1}, const String &@var{s2})
@deftypefunx bool {operator!=} (const char *@var{s1}, const String &@var{s2})
@deftypefunx bool {operator!=} (const String &@var{s1}, const char *@var{s2})
Returns true iff the two strings are not equal---that is, returns
@code{!(@var{s1} == @var{s2})}.
@end deftypefun

@deftypemethod String int hashcode () const
Returns a number with the property that, for any two equal strings
@var{s1} and @var{s2}, @code{@var{s1}.hashcode() ==
@var{s2}.hashcode()}. With this method, @code{String}s may be used as
keys for @code{HashMap}s and @code{BigHashMap}s (@pxref{HashMap}).
@end deftypemethod


@node StringAccum, Vector, String, Basics
@section StringAccum


@node Vector, Bitvector, StringAccum, Basics
@section Vector

@node Bitvector, HashMap, Vector, Basics
@section Bitvector

@node HashMap, BigHashMap, Bitvector, Basics
@section HashMap

@node BigHashMap, ErrorHandler, HashMap, Basics
@section BigHashMap


@node ErrorHandler,  , BigHashMap, Basics
@section ErrorHandler

All Click error messages are passed to an instance of the
@code{ErrorHandler} class. @code{ErrorHandler} separates the generation
of error messages from the particular way those messages should be
printed. It also makes it easy to automatically decorate errors with
context information.

Most Click users must know how to report errors to an
@code{ErrorHandler}, and how @code{ErrorHandler}s count the messages
they receive. This section also describes how to decorate error messages
with error veneers, and how to write new @code{ErrorHandler}s.

@code{ErrorHandler} and its important subclasses are defined in
@code{<click/error.hh>}.

@menu
* Reporting Errors::            
* Error Format Strings::        
* Counting Errors::             
* Basic Error Handlers::        
* Error Veneers::               
* Writing Error Handlers::       
@end menu


@node Reporting Errors, Error Format Strings, ErrorHandler, ErrorHandler
@subsection Reporting Errors

@code{ErrorHandler}'s basic error reporting methods take a format
string, which may use @code{printf}-like @samp{%} escape sequences, and
additional arguments as required by the format string. @xref{Error
Format Strings}, for more details on the format string. The five methods
differ in the seriousness of the error they report.

@deftypemethod ErrorHandler void debug (const char *@var{format}, @dots)
@deftypemethodx ErrorHandler void message (const char *@var{format}, @dots)
@deftypemethodx ErrorHandler int warning (const char *@var{format}, @dots)
@deftypemethodx ErrorHandler int error (const char *@var{format}, @dots)
@deftypemethodx ErrorHandler int fatal (const char *@var{format}, @dots)
Report the error described by @var{format} and any additional arguments.
The methods are listed by increasing seriousness. Use @code{debug} for
debugging messages that should not be printed in a production
environment; @code{message} for explanatory messages that do not
indicate errors; @code{warning} for warnings (this function prepends the
string @samp{warning:@ } to every line of the error message);
@code{error} for errors; and @code{fatal} for errors so serious that
they should halt the execution of the program. The three functions that
indicate errors, @code{warning}, @code{error}, and @code{fatal}, always
return @code{-EINVAL}. In some environments, @code{fatal} will actually
exit the program with exit code 1.
@end deftypemethod

Each of these methods has an analogue that additionally takes a
@dfn{landmark}: a string representing where the error took place. A
typical landmark contains a file name and line number, separated by a
colon---@samp{foo.click:31}, for example.

@deftypemethod ErrorHandler void ldebug (const String &@var{landmark}, const char *@var{format}, @dots)
@deftypemethodx ErrorHandler void lmessage (const String &@var{landmark}, const char *@var{format}, @dots)
@deftypemethodx ErrorHandler int lwarning (const String &@var{landmark}, const char *@var{format}, @dots)
@deftypemethodx ErrorHandler int lerror (const String &@var{landmark}, const char *@var{format}, @dots)
@deftypemethodx ErrorHandler int lfatal (const String &@var{landmark}, const char *@var{format}, @dots)
Report the error described by @var{format} and any additional arguments.
The error took place at @var{landmark}. Most @code{ErrorHandler}s will
simply prepend @samp{@var{landmark}:@ } to each line of the error
message.
@end deftypemethod

These methods are all implemented as wrappers around the @code{verror}
function. This function takes a landmark, a format string, a
@code{va_list} packaging up any additional arguments, and a
@dfn{seriousness value}, which encodes how serious the error was. The
@code{Seriousness} enumerated type, which is defined in the
@code{ErrorHandler} class, represents seriousness values. There are five
constants, corresponding to the five error-reporting methods:

@table @code
@item ERR_DEBUG
Corresponds to @code{debug} and @code{ldebug}.

@item ERR_MESSAGE
Corresponds to @code{message} and @code{lmessage}.

@item ERR_WARNING
Corresponds to @code{warning} and @code{lwarning}.

@item ERR_ERROR
Corresponds to @code{error} and @code{lerror}.

@item ERR_FATAL
Corresponds to @code{fatal} and @code{lfatal}.
@end table

@deftypemethod ErrorHandler int verror (Seriousness @var{seriousness}, const String &@var{landmark}, const char *@var{format}, va_list @var{val})
Report the error described by @var{format} and @var{val}. The error took
place at @var{landmark}, if @var{landmark} is nonempty. The
@var{seriousness} value is one of the five constants described above.
Always returns @code{-EINVAL}.
@end deftypemethod


@node Error Format Strings, Counting Errors, Reporting Errors, ErrorHandler
@subsection Format Strings

@code{ErrorHandler}'s format strings closely follow C's standard
@code{printf} format strings. Most characters in the format string are
printed verbatim. The @samp{%} character introduces a @dfn{conversion},
which prints data read from the remaining arguments. The format string
may contain newlines @samp{\n}, but it need not end with a newline;
@code{ErrorHandler} will add a final newline if one does not exist.

Each conversion, or formatting escape, follows this pattern:

@itemize @bullet
@item
First, the @samp{%} character introduces each conversion.

@item
Next comes zero or more @dfn{flag characters};

@item
then an optional @dfn{field width};

@item
then an optional @dfn{precision};

@item
then an optional @dfn{length modifier};

@item
and finally, the mandatory @dfn{conversion specifier}.
@end itemize

@noindent
We discuss each of these is turn.

Any conversion may be modified by zero or more of these flag characters.

@table @asis
@item @samp{#}
The value should be converted to an ``alternate form''. For @samp{o}
conversions, the first character of the output string is made @samp{0},
by prepending a @samp{0} if there was not one already. For @samp{x} and
@samp{X} conversions, nonzero values have @samp{0x} or @samp{0X}
prepended, respectively.

@item @samp{0}
The value should be zero padded. For @samp{d}, @samp{i}, @samp{u},
@samp{o}, @samp{x}, and @samp{X} conversions, the converted value is
padded on the left with @samp{0} characters rather than spaces.

@item @samp{-}
The value should be left-justified within the field width.

@item @samp{@ } (a space)
Leave a blank before a nonnegative number produced by a signed
conversion.

@item @samp{+}
Print a @samp{+} character before a nonnegative number produced by a
signed conversion.

@end table

The optional @dfn{field width}, a decimal digit string, forces the
conversion to use a minimum number of characters. The result of a
conversion is padded on the left with space characters to reach the
minimum field width, unless one of the @samp{0} or @samp{-} flags was
supplied.

The optional @dfn{precision} is a decimal digit string preceded by a
period @samp{.}. For @samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x},
and @samp{X} conversions, the precision specifies the minimum number of
digits that must appear; results with fewer digits are padded on the
left with @samp{0} characters. For the @samp{s} conversion, the
precision specifies the maximum number of characters that can be
printed.

If either the field width or precision is specified as a star @samp{*},
@code{ErrorHandler} reads the next argument as an integer and uses that
instead.

Length modifiers affect the argument type read by the conversion. There
are three modifiers:

@table @asis
@item @samp{h}
The next argument is a @code{short} or @code{unsigned short}. Affects
the @samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x}, and @samp{X}
conversions.

@item @samp{l}
The next argument is a @code{long} or @code{unsigned long}. Affects the
@samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x}, and @samp{X}
conversions.

@item @samp{ll}
The next argument is a @code{long long} or @code{unsigned long long}.
Affects the @samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x}, and
@samp{X} conversions.
@end table

Finally, these are the conversions themselves.

@table @asis
@item @samp{s}
Print the @code{const char *} argument, treated as a C string.

@item @samp{c}
The @code{int} argument is treated as a character constant. Printable
ASCII characters (values between 32 and 126) are printed verbatim.
Characters @samp{\n}, @samp{\t}, @samp{\r}, and @samp{\0} use those C
escape representations. Other characters use the representation
@samp{\%03o}.

@item @samp{e}
The argument is an @code{Element *}. Print that element's declaration.

@item @samp{d}, @samp{i}
The argument is an @code{int}; print its decimal representation.

@item @samp{u}
The argument is an @code{unsigned int}; print its decimal
representation.

@item @samp{o}
The argument is an @code{unsigned int}; print its octal representation.

@item @samp{x}, @samp{X}
The argument is an @code{unsigned int}; print its hexadecimal
representation. The @samp{%x} conversion uses lowercase letters;
@samp{%X} uses uppercase letters.

@item @samp{p}
The @code{void *} argument is cast to @code{unsigned long} and printed
as by @samp{%#lx}.

@item @samp{%}
Print a literal @samp{%} character.

@end table

Note that @code{ErrorHandler} does not support the @samp{e}, @samp{E},
@samp{f}, @samp{F}, @samp{g}, @samp{G}, and @samp{n} conversions.


@node Counting Errors, Basic Error Handlers, Error Format Strings, ErrorHandler
@subsection Counting Errors

@code{ErrorHandler} objects count the number of errors and warnings they
have received and make those values available to the user.

@deftypemethod ErrorHandler {virtual int} nwarnings () const
@deftypemethodx ErrorHandler {virtual int} nerrors () const
Returns the number of warnings or errors received by this
@code{ErrorHandler} so far.
@end deftypemethod

@deftypemethod ErrorHandler {virtual void} reset_counts ()
Resets the @code{nwarnings} and @code{nerrors} counters to zero.
@end deftypemethod

These counters are typically used to determine whether an error has
taken place in some complex piece of code. For example:

@example
int before_nerrors = errh->nerrors();
// @r{@dots{} complex code that may report errors to @code{errh} @dots{}}
if (errh->nerrors() != before_nerrors) @{
  // @r{an error has taken place}
@}
@end example


@node Basic Error Handlers, Error Veneers, Counting Errors, ErrorHandler
@subsection Basic Error Handlers

Basic @code{ErrorHandler}s print the error messages they receive. Every
Click error message eventually reaches some basic @code{ErrorHandler}.
The particular @code{ErrorHandler} depends on where Click is running; in
the user-level driver, the basic @code{ErrorHandler} prints error
messages to standard error, while in the Linux kernel module, it logs
messages to the syslog and stores them for access via
@file{/proc/click/errors}.

@cindex default @code{ErrorHandler}
@cindex @code{ErrorHandler}, default
The @code{ErrorHandler} class maintains a @dfn{default
@code{ErrorHandler}} accessible via the @code{default_handler} static
method. The user defines this default handler by supplying it to the
@code{static_initialize} method. Another static method,
@code{silent_handler}, returns an @code{ErrorHandler} that ignores the
error messages it receives.

@deftypeop {Static method} ErrorHandler {ErrorHandler *} default_handler ()
Returns the default @code{ErrorHandler}.
@end deftypeop

@deftypeop {Static method} ErrorHandler {ErrorHandler *} silent_handler ()
Returns the silent @code{ErrorHandler}. This handler ignores any error
messages it receives. It maintains correct @code{nwarnings} and
@code{nerrors} counts, however.
@end deftypeop

@deftypeop {Static method} ErrorHandler void static_initialize (ErrorHandler *@var{default_errh})
Sets the default @code{ErrorHandler} to @var{default_errh}. This
function should be called exactly once, at the beginning of the program,
before any error messages are reported to any @code{ErrorHandler}. It is
OK to create arbitrary @code{ErrorHandler} objects before calling this
method, however.
@end deftypeop

@deftypeop {Static method} ErrorHandler void static_cleanup ()
Destroys the default and silent @code{ErrorHandler}s and cleans up other
@code{ErrorHandler}-related memory. This function should be called
exactly once, just before the program exits. It is an error to call
generate an error message after calling @code{static_cleanup}.
@end deftypeop

Finally, the @code{FileErrorHandler} class is available in any
user-level program. This @code{ErrorHandler} prints every message it
receives to some file, usually standard error. It can also prepend an
optional context string to every line of every error message.

@deftypeop Constructor FileErrorHandler {} FileErrorHandler (FILE *@var{f}, const String &@var{prefix} = "")
Constructs a @code{FileErrorHandler} that prints error messages to file
@var{f}. If @var{prefix} is nonempty, then every line of every error
message is prepended by @var{prefix}.
@end deftypeop


@node Error Veneers, Writing Error Handlers, Basic Error Handlers, ErrorHandler
@subsection Error Veneers---Adding Context to Error Messages

@dfn{Error veneers} wrap around basic @code{ErrorHandler} objects and
change how error text is generated. An error veneer generally changes
each error message's text in some way, perhaps by adding a context
message or some indentation. It then passes the altered text to the
basic @code{ErrorHandler} for printing. Error veneers can be easily
nested.

The first argument to each error veneer constructor is a pointer to
another @code{ErrorHandler} object. The veneer will pass altered error
text to this handler, the @dfn{base handler}, for further processing and
printing. It also delegates @code{nwarnings()} and @code{nerrors()}
calls to the base handler.

Click comes with three error veneers: one for adding context, one for
prepending text to every line, and one for supplying missing landmarks.
It is easy to write others; see @ref{Writing Error Handlers}, for
details.

@deftypeop Constructor ContextErrorHandler {} ContextErrorHandler (ErrorHandler *@var{base_errh}, const String &@var{context}, const String &@var{indent} = "@w{@ @ }")
Constructs a @code{ContextErrorHandler} with @var{base_errh} as base.

The first time this handler receives an error message, it will precede
the message with the @var{context} string---generally more detailed
information about where the error has occurred. Every line in every
received error message is prepended with @var{indent}, two spaces by
default, to set off the message from its context.
@end deftypeop

@deftypeop Constructor PrefixErrorHandler {} PrefixErrorHandler (ErrorHandler *@var{base_errh}, const String &@var{prefix})
Constructs a @code{PrefixErrorHandler} with @var{base_errh} as base.

This handler precedes every line of every error message with
@var{prefix}.
@end deftypeop

@deftypeop Constructor LandmarkErrorHandler {} LandmarkErrorHandler (ErrorHandler *@var{base_errh}, const String &@var{landmark})
Constructs a @code{LandmarkErrorHandler} with @var{base_errh} as base.

This handler supplies @var{landmark} in place of any blank landmark
passed to it. This will cause the base handler to include @var{landmark}
in its error message.
@end deftypeop

To demonstrate these veneers in practice, we'll use the following
function, which prints two error messages:

@example
void f(ErrorHandler *errh) @{
  errh->error("First line\nSecond line");
  errh->lwarning("here", "Third line");
@}
@end example

A simple @code{FileErrorHandler} shows the base case.

@example
FileErrorHandler errh1(stderr);
f(&errh1);
    @print{} First line
    @print{} Second line
    @print{} here: warning: Third line
@end example

The simplest error veneer, @code{PrefixErrorHandler}, just prepends text
to every line.

@example
PrefixErrorHandler errh2(&errh1, "prefix - ");
f(&errh2);
    @print{} prefix - First line
    @print{} prefix - Second line
    @print{} prefix - here: warning: Third line
@end example

@code{ContextErrorHandler} supplies a line of context before the first
error message, and indents all messages except the context.

@example
ContextErrorHandler errh3(&errh1, "This was called from ...", "** ");
f(&errh3);
    @print{} This was called from ...
    @print{} ** First line
    @print{} ** Second line
    @print{} here: ** warning: Third line
@end example

@noindent
Note that the indentation @samp{**@ } is printed after the landmark.
This often looks better than the alternative.

Of course, an error veneer can take another error veneer as its ``base
handler'', leading to cumulative effects.

@example
ContextErrorHandler errh4(&errh2, "This was called from ...", "** ");
f(&errh4);
    @print{} prefix - This was called from ...
    @print{} prefix - ** First line
    @print{} prefix - ** Second line
    @print{} prefix - here: ** warning: Third line
@end example


@node Writing Error Handlers,  , Error Veneers, ErrorHandler
@subsection Writing Error Handlers

@code{ErrorHandler} constructs an error message using three virtual
functions. The first, @code{make_text}, parses a format string and
argument list into a single @code{String}. This is passed to the second
function, @code{decorate_text}, which may transform the string. The
final function, @code{handle_text}, prints the resulting error message.
This structure makes @code{ErrorHandler} easy to extend. To write a new
basic @code{ErrorHandler}, you will need to override just
@code{handle_text} and the counting functions (@code{nwarnings},
@code{nerrors}, and @code{reset_counts}). The @code{ErrorVeneer} helper
class, described below, lets you override just @code{decorate_text} when
writing an error veneer.

@deftypemethod ErrorHandler {virtual String} make_text (Seriousness @var{s}, const char *@var{format}, va_list @var{val})
Parses the format string @var{format} with arguments from @var{val},
returning the results as a @var{String} object.

The default implementation processes the formatting escapes described
above (@pxref{Error Formatting Escapes}). It also prepends every line of
the error message with @samp{warning: } if @var{s} equals
@code{ERR_WARNING}.
@end deftypemethod

@deftypemethod ErrorHandler {virtual String} decorate_text (Seriousness @var{s}, const String &@var{prefix}, const String &@var{landmark}, const String &@var{text})
Decorates the error message @var{text} as appropriate and returns the
result. At minimum, every line of the result should be prepended by
@var{prefix} and, if it is nonempty, the landmark string @var{landmark}.

The default implementation prepends every line of @var{text} with
@samp{@var{landmark}:@w{@ }}, if @var{landmark} is nonempty. Any spaces
and/or a final colon are stripped from the end of @var{landmark}.
Special landmarks, which begin and end with a backslash @samp{\}, are
ignored. @var{landmark} is added between @var{prefix} and @var{text}.
@end deftypemethod

@deftypemethod ErrorHandler {virtual void} handle_text (Seriousness @var{s}, const String &@var{text})
This method is responsible for printing or otherwise informing the user
about the error message @var{text}. If @var{s} equals @code{ERR_FATAL},
the method should exit the program or perform some other drastic action.
It should also maintain the @code{nwarnings()} and @code{nerrors()}
counters. In most cases, it should ensure that the last character in
@var{text} is a newline.

This method has no default implementation.
@end deftypemethod

@tpindex @code{ErrorVeneer}
The @code{ErrorVeneer} class, a subclass of @code{ErrorHandler},
supplies default implementations for these functions that ease the
construction of new error veneers. @code{ErrorVeneer}'s single instance
variable, @code{ErrorHandler *_errh}, is the base handler.
@code{ErrorVeneer} overrides all the relevant virtual
functions---@code{nwarnings}, @code{nerrors}, @code{reset_counts},
@code{make_text}, @code{decorate_text}, and @code{handle_text}. Its
versions simply delegate to the corresponding methods on @code{_errh}.
An error veneer designer will generally subclass @code{ErrorVeneer}
rather than @code{ErrorHandler}; then she will override only the methods
she cares about (usually @code{decorate_text}), relying on
@code{ErrorVeneer}'s default implementations for the rest.

@deftypeop Constructor ErrorVeneer {} ErrorVeneer (ErrorHandler *@var{base_errh})
Constructs an @code{ErrorVeneer} helper class with @var{base_errh} as
its base error handler. This constructor simply sets @code{_errh =
base_errh}.
@end deftypeop


@node Element Initialization, Tasks, Basics, Top
@chapter Element Initialization

The process of making an element ready for inclusion in an active router
is called @dfn{element initialization}. This includes processing the
element's configuration string, setting up internal state and any input
and output ports, and querying the router about neighboring elements.

Every element in an active router must have successfully initialized. If
there is an error initializing even one element, the router is aborted.
Router initialization happens in sequential phases: every element must
successfully complete one phase before the next phase begins.

@menu
* notify_ninputs notify_noutputs::  
* configure::                   
* processing::                  
* flow_code::                   
* initialize::                  
* configure_phase::             
* uninitialize::                
* Initialization Phases::       
@end menu


@node notify_ninputs notify_noutputs, configure, Element Initialization, Element Initialization
@section @code{notify_ninputs} and @code{notify_noutputs}

The router calls each element's @code{notify_ninputs} and
@code{notify_noutputs} methods to tell it how many of its input and
output ports were used in the configuration. A port is used if it is
used in a connection.

@deftypemethod Element {virtual void} notify_ninputs (int @var{ninputs})
@deftypemethodx Element {virtual void} notify_noutputs (int @var{noutputs})

The @var{ninputs} and @var{noutputs} arguments specify how many input
and output ports were used in the configuration, respectively. For
example, if @var{ninputs} is 5, then input ports 0 through 4 were
used.@footnote{Strictly speaking, it is possible that one or more of the
lower-numbered ports were not used---for example, that input port 0 was
not used by the configuration. This is always a configuration error,
however. A later stage will report unused ports as errors and abort
router initialization.}

These methods' default implementations do nothing.
@end deftypemethod

@code{notify_ninputs} and @code{notify_noutputs} are called early in the
initialization process---before @code{configure}, for example, and
before ports are assigned to push or pull. They may create and destroy
input and output ports or set other private element state.

A @code{notify_ninputs} or @code{notify_noutputs} method should
generally be very short and stylized. It should call no Element methods
except for possibly @code{set_ninputs} or @code{set_noutputs}. The
following typical @code{notify_noutputs} method sets the element's
number of outputs to one or two, depending on how many outputs were
actually used:

@example
void
CheckIPHeader::notify_noutputs(int n)
@{
  set_noutputs(n < 2 ? 1 : 2);
@}
@end example


@node configure, processing, notify_ninputs notify_noutputs, Element Initialization
@section @code{configure}---Parsing Configure Strings

The @code{configure} method is passed the element's configuration
string. This method is expected to parse the configuration string,
report any errors, and initialize the element's internal state.

@deftypemethod Element {virtual int} configure (const Vector<String> &@var{conf}, ErrorHandler *@var{errh})
The @var{conf} argument is the element's configuration string, divided
into configuration arguments by splitting at commas, and with comments
and extraneous whitespace removed. If @var{conf} is empty, the element
was not supplied with a configuration string (or its configuration
string contained only comments and whitespace).

Any errors, warnings, or messages should be reported to @var{errh}.
Messages should not specify the element name or type; this information
will be supplied externally.

This method should return zero if configuration succeeds, or a negative
number if it fails. Returning a negative number prevents the router from
initializing.

The default @code{configure} method succeeds if and only if there are no
configuration arguments.
@end deftypemethod

@code{configure} is called relatively early in the initialization
process. For instance, @code{configure} may create or destroy input and
output ports---the port validity check happens after @code{configure}
completes. @code{configure} cannot determine whether a port is push or
pull; neither can it query the router for information about its
neighbors.

A @code{configure} method should not perform potentially harmful
actions, such as truncating files or attaching to devices. These actions
should be left for the @code{initialize} method, which is called later.
This avoids harm if another element cannot be configured, or if the
router is incorrectly connected, since in these cases @code{initialize}
will never be called.


@node processing, flow_code, configure, Element Initialization
@section @code{processing}---Push and Pull Processing

Elements use the @code{processing} method to specify whether their ports
are push, pull, or agnostic. This method returns a @dfn{processing
code}---an ASCII string that, properly interpreted, specifies the
processing type for each port.

@deftypemethod Element {virtual const char *} processing () const
Returns the element's processing code as a null-terminated C string.
@end deftypemethod

Processing codes look like this:

@display
@samp{@var{inputspec}/@var{outputspec}}
@end display

@noindent
Each of @var{inputspec} and @var{outputspec} is a sequence of @samp{h},
@samp{l}, and @samp{a} characters, containing at least one character.
@samp{h} indicates a push port, @samp{l} a pull port, and @samp{a} an
agnostic port. The first character in each sequence represents the first
port (port 0), and so forth. For example, @strcode{"a/ah"} says that the
element's first input and first output ports are both agnostic, but the
second output port is push.

@var{Inputspec} and @var{outputspec} need not have the correct numbers
of characters. The last character in each specification is duplicated as
many times as necessary, and any extra characters are ignored. Thus, the
processing codes @strcode{"aaaaaaaa/haaaaaaa"} and @strcode{"a/ha"} behave
identically.

The @code{Element} class provides mnemonic names for five common
processing codes:

@table @code
@item AGNOSTIC
@strcode{"a/a"} (agnostic ports).
@item PUSH
@strcode{"h/h"} (push ports).
@item PULL
@strcode{"l/l"} (pull ports).
@item PUSH_TO_PULL
@strcode{"h/l"} (push input ports, pull output ports).
@item PULL_TO_PUSH
@strcode{"l/h"} (pull input ports, push output ports).
@end table

The default implementation for @code{Element::processing} returns
@code{AGNOSTIC}.

The @code{processing} method should be declared as an inline function in
the element's C class definition. It should return a C string constant
or one of the five mnemonic names above. This makes the element's
processing code easy to automatically extract from the source code.


@node flow_code, initialize, processing, Element Initialization
@section @code{flow_code}---Packet Flow Within an Element

In most cases, a packet arriving on an element's input port might then
be emitted on any of that element's output ports. A packet arriving at a
@click{Tee} element will be emitted on each of @click{Tee}'s output
ports; a packet arriving at a @click{CheckIPHeader} element may be
emitted on either of its two output ports, although it is impossible to
say which port a priori. However, it is sometimes possible to rule out
certain port combinations. The @click{Idle} element, for example, drops
every packet it receives, so packets will never travel between its input
ports and its output ports. Packets arriving on one of
@click{Suppressor}'s input ports can exit only on the corresponding
output port. Click needs to know this precise flow information, since it
affects the agnostic port assignment algorithm and the algorithms for
finding upstream and downstream elements.

The @code{flow_code} method specifies how packets travel within an
element. @code{flow_code} returns a @dfn{flow code}---an ASCII string
that, properly interpreted, defines how packets may travel within the
element.

@deftypemethod Element {virtual const char *} flow_code () const
Returns the element's flow code as a null-terminated C string.
@end deftypemethod

Flow codes look like @samp{@var{inputspec}/@var{outputspec}}, where each
of @var{inputspec} and @var{outputspec} is a sequence of @dfn{port
codes}. The simplest port code is a single letter. Packets can travel
from an input port to an output port if and only if the port codes
match. (Case is significant.) For example, the flow code @strcode{"x/x"}
says that packets can travel from the element's input port to its output
port, while @strcode{"x/y"} says that packets never travel between ports.

A port code may also be a sequence of letters in brackets, such as
@samp{[abz]}. Two port codes match iff they have at least one letter in
common, so @samp{[abz]} matches @samp{a}, but @samp{[abz]} and
@samp{[cde]} do not match. The opening bracket may be followed by a
caret @samp{^}; this makes the port code match letters @emph{not}
mentioned between the brackets. Thus, the port code @samp{[^abc]} is
equivalent to @samp{[ABC...XYZdef...xyz]}.

Finally, the @samp{#} character is also a valid port code, and may be
used within brackets. One @samp{#} matches another @samp{#} only when
they represent the same port number---for example, when one @samp{#}
corresponds to input port 2 and the other to output port 2. @samp{#}
never matches any letter. Thus, the flow code @strcode{"##/##"} behaves
like @strcode{"xy/xy"}.

@var{Inputspec} and @var{outputspec} need not have the correct numbers
of port codes. The last code in each specification is duplicated as many
times as necessary, and any extra codes are ignored. Thus, the flow
codes @strcode{"[x#][x#][x#][x#]/x######"} and @strcode{"[x#]/x#"} behave
identically.

This table describes some simple flow codes.

@table @code
@item "x/x"
Packets may travel from any input port to any output port.

@item "xy/x"
Packets arriving on input port 0 may travel to output port 0, but those
arriving on input port 1 will not be emitted on any output.

@item "x/y"
Packets never travel between input and output ports.

@item "#/#"
Packets arriving on input port @var{K} may travel only to output port
@var{K}.

@item "#/[^#]"
Packets arriving on input port @var{K} may travel to any output port
except @var{K}.
@end table

The @code{Element} class provides a mnemonic name for a common flow
code:

@table @code
@item COMPLETE_FLOW
@strcode{"x/x"} (packets travel from any input to all outputs).
@end table

The default implementation for @code{Element::processing} returns
@code{COMPLETE_FLOW}.

The @code{flow_code} method should be declared as an inline function in
the element's C class definition. It should return a C string constant
or @code{COMPLETE_FLOW}. This makes the element's flow code easy to
automatically extract from the source code.


@node initialize, configure_phase, flow_code, Element Initialization
@section @code{initialize}---Element Initialization

The @code{initialize} method is called just before the router is placed
on line. It performs any final initialization, and provides the last
chance to abort router installation with an error.

@deftypemethod Element {virtual int} initialize (ErrorHandler *@var{errh})
Any errors, warnings, or messages should be reported to @var{errh}.
Messages should not specify the element name; this information will be
supplied externally.

This method should return zero if initialization succeeds, or a negative
number if it fails. Returning a negative number prevents the router from
initializing.

The default @code{initialize} method simply returns zero.
@end deftypemethod

An element's @code{initialize} method may check whether its input or
output ports are push or pull, or query the router for information about
its neighbors. It may not create or destroy input or output ports.

If every element's @code{initialize} method succeeds, then the router is
installed, and will remain installed until another router replaces it.
Any errors that occur later than @code{initialize}---during a
@code{push} or @code{pull} method, perhaps---will not take the router
off line.

Common tasks performed in @code{initialize} methods include:

@itemize @bullet
@item
Initializing @code{Task}s (@pxref{Task Initialization}).

@item
Allocating memory.

@item
Opening files.
@end itemize


@node configure_phase, uninitialize, initialize, Element Initialization
@section @code{configure_phase}---Initialization Order

Some elements depend on being configured and initialized before or after
other elements. For example, the @click{AddressInfo} element must be
configured before all other elements, since its address abbreviations
must be available in their configuration strings. The
@code{configure_phase} method makes this possible.

@deftypemethod Element {virtual int} configure_phase () const
Returns the element's @dfn{configure phase}, an integer that specifies
when it should be configured and initialized relative to other elements.

An element with a low configure phase will be configured before an
element with a high configure phase. Elements with the same configure
phase might be configured in any order relative to one another.

The following basic configure phase constants are defined in
@code{<click/element.hh>}:

@table @code
@item CONFIGURE_PHASE_FIRST
Configure first.
@item CONFIGURE_PHASE_INFO
Configure early. Appropriate for most information elements.
@item CONFIGURE_PHASE_DEFAULT
Default configuration phase. Appropriate for most elements.
@item CONFIGURE_PHASE_LAST
Configure last.
@end table

@code{configure_phase} may also return a number based on these
constants. For example, all @click{FromLinux} elements should be
initialized before any @click{ToDevice} elements. The @click{FromLinux}
element therefore contains the following definitions:

@example
enum @{ CONFIGURE_PHASE_FROMLINUX = CONFIGURE_PHASE_DEFAULT,
       CONFIGURE_PHASE_TODEVICE = CONFIGURE_PHASE_FROMLINUX + 1 @};
@end example

@noindent
@code{FromLinux::configure_phase} returns
@code{CONFIGURE_PHASE_FROMLINUX}, and @code{ToDevice::configure_phase}
returns @code{FromLinux::CONFIGURE_PHASE_TODEVICE}.

The default implementation returns @code{CONFIGURE_PHASE_DEFAULT}.
@end deftypemethod

Click uses all elements' configure phases to construct a single element
configuration order. It then configures elements in this order and, if
there were no errors, initializes them in the same order. The
@code{configure_phase} method is called once, relatively early---before
@code{configure} and @code{initialize}.

An element's configure phase should depend only on its class. In
particular, the body of a @code{configure_phase} method should consist
of a single @code{return} statement returning some constant.


@node uninitialize, Initialization Phases, configure_phase, Element Initialization
@section @code{uninitialize}---Removing Initialization State

The @code{uninitialize} method should undo any effects of
initialization---for example, it should close any open files, free up
memory, and unhook from network devices. Every element's
@code{uninitialize} method is called when a successfully initialized
router is taken off line. @code{uninitialize} is also called on certain
elements in an aborted router, namely those that did successfully
initialize.

@deftypemethod Element {virtual void} uninitialize ()
This method takes no arguments and returns no results. It should never
report errors to any source.

The default @code{uninitialize} method does nothing.
@end deftypemethod

An element's @code{uninitialize} method will be called by Click if and
only if its @code{initialize} method succeeded (returned zero).
Furthermore, it will be called by Click exactly once. However, it often
makes sense to write @code{uninitialize} so that it may be called from
other places---from the element's destructor, for example, or from
a partially completed @code{initialize}.

@code{uninitialize} serves some of the same functions as an element's
destructor and, in the normal case, it is called immediately before the
element is destroyed. However, @code{uninitialize} may be called long
before destruction. Elements that are part of an erroneous router are
uninitialized, but kept around for debugging purposes until another
router is installed.


@node Initialization Phases,  , uninitialize, Element Initialization
@section Initialization Phases

@enumerate
@item
Determines how many ports are used on each element and calls their
@code{notify_ninputs} and @code{notify_noutputs} methods.

@item
Calls each element's @code{configure_phase} method, and uses the
result to construct a configuration order.

@item
Calls each element's @code{configure} method, passing in the relevant
configuration string. The elements are configured according to the
configuration order.

@item
Checks that each connection connects a valid input port to a valid
output port. This catches errors where a connection uses a port that
does not exist.

@item
Calls each element's @code{processing} method to determine whether its
ports are push, pull, or agnostic.

@item
For each element with agnostic ports, calls the corresponding
@code{flow_code} method to determine constraints linking agnostic input
ports to agnostic output ports.

@item
Runs the constraint-satisfaction algorithm that determines whether each
agnostic port is push or pull. This catches errors where a single
agnostic port is used as both push and pull.

@item
Checks that every connection is between two push ports or two pull
ports.

@item
Checks that push output ports and pull input ports are connected exactly
once.

@item
Checks that no input or output port goes unused.

@item
If there have been no errors up to this point, then calls each element's
@code{initialize} method. The elements are initialized according to the
configuration order. No @code{initialize} methods are called if there
were any errors in any previous phase.

@item
If there were no errors, then router initialization has succeeded: the
router can be placed on line.

@item
If there were errors, then Click calls the @code{uninitialize} method on
each element whose @code{initialize} method returned successfully.
Router initialization has failed.
@end enumerate


@node Tasks, Timers, Element Initialization, Top
@chapter Tasks

Click schedules a router's CPU or CPUs with one or more @dfn{task
queues}. These queues are simply lists of @dfn{tasks}, which represent
functions that would like access to the CPU. Tasks are generally
associated with elements. When scheduled, most tasks call some element's
@code{run_scheduled} method.

Click tasks are represented by @code{Task} objects. An element that
would like special access to a router's CPU should include and
initialize a @code{Task} instance variable.

The @code{Task} class is defined in the @code{<click/task.hh>} header
file.

@menu
* Task Initialization::         
* Scheduling a Task::           
* Tickets::                     
* Multiple Task Queues::        
* Task Status::                 
* Destroying a Task::           
@end menu


@node Task Initialization, Scheduling a Task, Tasks, Tasks
@section Task Initialization

Task initialization is a two-step process. First, when a @code{Task}
object is constructed, you must supply information about the function
that it should call when it is scheduled. Second, when the router is
initialized, you must schedule the task on the router's task queue.

@code{Task} has two constructors. One of them asks the task to call an
element's @code{run_scheduled} method when scheduled; the other asks it
to call an arbitrary function pointer.

@deftypemethod Task {} Task (Element *@var{e})
When this task is scheduled, call @code{@var{e}->run_scheduled()}.
@end deftypemethod

@deftypemethod Task {} Task (TaskHook @var{hook}, void *@var{thunk})
When this task is scheduled, call @code{@var{hook}(this, @var{thunk})}.
The @var{hook} argument is a function pointer with type @code{void
(*)(Task *, void *)}.
@end deftypemethod

Later, when the router is initialized, each task must be attached to the
router via the @code{Task::initialize} method. This places the task on a
router-wide list of @code{Task}s, associates the task with a particular
task queue, and, optionally, schedules it. Typically, an element's
@code{initialize} method calls @code{Task::initialize}
(@pxref{initialize}).

@deftypemethod Task void initialize (Router *@var{r}, bool @var{scheduled})
@deftypemethodx Task void initialize (Element *@var{e}, bool @var{scheduled})
Attaches the task to the router object @var{r} (or
@code{@var{e}->router()}). Additionally schedules the task if
@var{scheduled} is true.
@end deftypemethod

Many elements call @code{ScheduleInfo::join_scheduler} instead of
calling @code{Task::initialize} directly. The @code{join_scheduler}
method queries any @click{ScheduleInfo} elements in the configuration to
determine the task's scheduling parameters, then calls
@code{Task::initialize} to schedule the task. The
@code{ScheduleInfo::join_scheduler} method is defined in the
@code{"elements/standard/scheduleinfo.hh"} header file.

@deftypeop {Static method} ScheduleInfo void join_scheduler (Element *@var{e}, Task *@var{task}, ErrorHandler *@var{errh})
Sets @var{task}'s scheduling parameters as specified by any
@click{ScheduleInfo} elements in the router configuration. The element
@var{e} is used to find the correct router, and to look up
parameters---the user supplies parameters to @click{ScheduleInfo} based
on element name. Also schedules @var{task} on @code{@var{e}->router()}'s
task queue. Reports any errors to @var{errh}.
@end deftypeop

The @code{join_scheduler} method is generally called like this:

@example
int
SomeElement::initialize(ErrorHandler *errh)
@{
  ScheduleInfo::join_scheduler(this, &_task, errh);
@}
@end example

@noindent
Here, @code{_task}, a @code{Task} object, is one of @code{SomeElement}'s
instance variables.


@node Scheduling a Task, Tickets, Task Initialization, Tasks
@section Scheduling a Task

The user may take a task off its task queue with the @code{unschedule}
method, and place it back onto its task queue with the @code{reschedule}
method. As tasks move to the head of the task queue, they are
unscheduled and their callbacks are called. Within these callback
functions, the user will typically call @code{fast_reschedule}, which is
like @code{reschedule} without the locking overhead.

@deftypemethod Task void unschedule ()
Unschedules the task by removing it from its task queue. If the task is
already unscheduled, then this method does nothing.
@end deftypemethod

@deftypemethod Task void reschedule ()
Reschedules the task by placing it on its task queue. If the task is
already scheduled, then this method does nothing.
@end deftypemethod

Both @code{unschedule} and @code{reschedule} lock the task queue before
manipulating it. This avoids corruption when there are multiple
processors executing simultaneously. If these functions cannot lock a
task queue---perhaps because it is being used on another
processor---then they register a task request, which will be executed in
the near future. This implies that a task may remain scheduled for some
time after @code{unschedule} has been called, for example.

The @code{fast_reschedule} method avoids locking overhead in the common
case that a task must be rescheduled from within its callback.

@deftypemethod Task void fast_reschedule ()
Reschedules the task by placing it on its preferred task queue. This
method avoids locking overhead, so it is faster than @code{reschedule}.

@quotation
@strong{Caution}: You may call a @code{Task}'s @code{fast_reschedule}
method only from within its callback function. For instance, if an
element has a task, @code{_task}, that calls the element's
@code{run_scheduled} method when scheduled, and if @code{run_scheduled}
is called only by that task's callback, then that element's
@code{run_scheduled} method should call @code{_task.fast_reschedule()}
instead of @code{_task.reschedule()}.
@end quotation
@end deftypemethod


@node Tickets, Multiple Task Queues, Scheduling a Task, Tasks
@section Tickets

Click tasks are scheduled using the flexible, lightweight stride
scheduling algorithm.@footnote{For more information, see MIT Laboratory
for Computer Science Technical Memo MIT/LCS/TM-528, @cite{Stride
scheduling: deterministic proportional-share resource management}, by
Carl A. Waldspurger and William E. Weihl, June 1995.} This algorithm
assigns each task a parameter called its @dfn{tickets}. A task with
twice as many tickets as usual is scheduled twice as frequently.

@code{Task}s have methods for querying, setting, and adjusting their
tickets.

@deftypemethod Task int tickets () const
Returns this task's tickets. This number will be at least 1 and no more
than @code{Task::MAX_TICKETS}, which equals 32768.
@end deftypemethod

@deftypemethod Task void set_tickets (int @var{t})
Sets this task's tickets to @var{t}. The @var{t} parameter should lie
between 1 and @code{Task::MAX_TICKETS}; numbers outside this range are
constrained to the nearest valid value.
@end deftypemethod

@deftypemethod Task void adj_tickets (int @var{delta})
Equivalent to @code{set_tickets(tickets() + @var{delta})}.
@end deftypemethod


@node Multiple Task Queues, Task Status, Tickets, Tasks
@section Multiple Task Queues


@node Task Status, Destroying a Task, Multiple Task Queues, Tasks
@section Task Status Methods

These methods let a user check various properties of a task---for
instance, whether it is initialized or scheduled.

@deftypemethod Task bool initialized () const
Returns true iff the task has been initialized---that is, if it is
associated with some router.
@end deftypemethod

@deftypemethod Task bool scheduled () const
Returns true iff the task is currently scheduled on some task queue.
@end deftypemethod

@deftypemethod Task {RouterThread *} scheduled_list () const
Returns the task queue with which this task is associated. Even
unscheduled tasks are associated with some task queue; this is the task
queue on which the task will be placed if @code{reschedule} is called.
@end deftypemethod

@deftypemethod Task TaskHook hook () const
Returns the callback function that is called when the task is scheduled.
If the task is associated with some element, this method returns a null
pointer.
@end deftypemethod

@deftypemethod Task {void *} thunk () const
Returns the extra data passed to the callback function when the task is
scheduled.
@end deftypemethod

@deftypemethod Task {Element *} element () const
If the task is associated with some element, this method returns that
element. Otherwise, returns a null pointer.
@end deftypemethod


@node Destroying a Task,  , Task Status, Tasks
@section Destroying a Task


@node Timers, Index, Tasks, Top
@chapter Timers

Timers


@node Index,  , Timers, Top
@unnumbered Index

@printindex cp

@bye
