\input texinfo.tex
@setfilename click.info
@settitle Click
@footnotestyle end

@dircategory Click modular router
@direntry
* Click: (click).           The Click modular router programming manual.
@end direntry

@ifnottex
@macro leq
<=
@end macro
@end ifnottex
@ifnotinfo
@macro click {arg}
@emph{\arg\}
@end macro
@end ifnotinfo
@ifinfo
@macro click {arg}
@code{\arg\}
@end macro
@end ifinfo

@macro handler {arg}
`\arg\'
@end macro

@rmacro strcode {arg}
@t{\arg\}
@end rmacro

@macro qsamp {arg}
@r{``}@t{\arg\}@r{''}
@end macro
@tex
% The macro definition above doesn't get space expansion right.
\gdef\qsamp#1{@r{``}@t{#1}@r{''}}
@end tex

@syncodeindex vr cp
@syncodeindex fn cp
@syncodeindex tp cp

@titlepage
@title Programming the Click Modular Router
@author Eddie Kohler
@end titlepage

@contents

@node Top, Overview, (dir), (dir)
@top

@ifinfo
This document describes the Click modular router's programming
interface. Read this if you're interested in writing new elements for
Click. You shouldn't need to read it if you are just building routers
that use existing elements.
@end ifinfo

@menu
* Overview::                    
* Helper Classes::              
* Packets::                     
* Element Characteristics::     
* Element Initialization::      
* Element Runtime::             
* Configuration Strings::       
* Tasks::                       
* Timers::                      
* Notification::                
* Coding Standards::            
* Index::                       Index.

@detailmenu
 --- The Detailed Node Listing ---

Overview

* Packet Transfer::             

Helper Classes

* String::                      
* StringAccum::                 
* Vector::                      
* Bitvector::                   
* HashMap::                     
* BigHashMap::                  
* ErrorHandler::                
* IPAddress::                   
* IP6Address::                  

StringAccum

* StringAccum Constructors::    
* StringAccum operator<<::      
* Special StringAccum operator<<::  
* StringAccum Manipulation::    
* StringAccum Contents::        
* StringAccum Results::         
* StringAccum Out-of-Memory::   

ErrorHandler

* ErrorHandler Initialization::  
* Reporting Errors::            
* Error Format Strings::        
* Counting Errors::             
* Basic ErrorHandlers::         
* Error Veneers::               
* Writing ErrorHandlers::       

Packets

* Packet Structure and Contents::  
* Packet Creation::             
* Packets and sk_buffs::        
* Packet Sharing::              
* Packet Buffer Manipulation::  
* Annotations::                 
* Packet Out-of-Memory::        

Annotations

* Header Annotations::          
* User Annotations::            
* Specific User Annotations::   
* Other Annotations::           
* Annotations In General::      

Other Annotations

* Destination Address Annotation::  
* Timestamp Annotation::        
* Device Annotation::           
* Packet Type Annotation::      
* Performance Counter Annotation::  

Element Runtime

* Handling Packets::            
* Handlers::                    

Handlers

* Read and Write Handler Overview::  
* Adding Handlers::             
* Default Handlers::            
* Accessing Handlers Internally::  
* LLRPC Overview::              

Accessing Handlers Internally

* Handler Objects::             
* Handlers By Name or Index::   

Configuration Strings

* Parsing Functions::           
* cp_va::                       

Parsing Functions

* Parsing IPv6 Addresses::      
* Parsing Ethernet Addresses::  
* Parsing Elements::            
* Parsing Handlers::            
* Parsing Miscellaneous::       

Parsing Argument Lists

* cp_va Concepts::              
* cp_va Initialization::        

Tasks

* Task Initialization::         
* Scheduling Tasks::            
* Tickets::                     
* Task Thread Choice::          
* Task Status::                 
* Task Handlers::               
* Task Cleanup::                

Timers

* Timer Initialization::        
* Scheduling Timers::           
* Timer Status Methods::        
* Timer Cleanup::               

Coding Standards

* Upper and lower case names::  
* Common name patterns::        

@end detailmenu
@end menu

@node Overview, Helper Classes, Top, Top
@chapter Overview

@menu
* Packet Transfer::             
@end menu

@node Packet Transfer,  , Overview, Overview
@section Packet Transfer



@node Helper Classes, Packets, Overview, Top
@chapter Helper Classes

@menu
* String::                      
* StringAccum::                 
* Vector::                      
* Bitvector::                   
* HashMap::                     
* BigHashMap::                  
* ErrorHandler::                
* IPAddress::                   
* IP6Address::                  
@end menu


@node String, StringAccum, Helper Classes, Helper Classes
@section String

The @code{String} class represents a string of characters.
@code{String}s may be constructed from C strings, characters, numbers,
and so forth. They may also be added together. The underlying character
arrays are dynamically allocated; operations on @code{String}s allocate
and free memory as needed. A @code{String} and its substrings will
generally share memory. @code{String}s may be assigned, stored, and
passed to functions.

See the Doxygen documentation on class @code{String} for information.

@node StringAccum, Vector, String, Helper Classes
@section StringAccum

The @code{StringAccum} class, like @code{String} (@pxref{String}),
represents a string of characters. @code{StringAccum} is optimized for
building a string through @dfn{accumulation}, or successively appending
substrings until the whole string is ready. A @code{StringAccum} has
both a @dfn{length}---the number of characters it currently
contains---and a @dfn{capacity}---the maximum number of characters it
could hold without reallocating memory.

@menu
* StringAccum Constructors::    
* StringAccum operator<<::      
* Special StringAccum operator<<::  
* StringAccum Manipulation::    
* StringAccum Contents::        
* StringAccum Results::         
* StringAccum Out-of-Memory::   
@end menu


@node StringAccum Constructors, StringAccum operator<<, StringAccum, StringAccum
@subsection Constructors

@deftypeop Constructor StringAccum {} StringAccum ()
Creates a @code{StringAccum} with no characters.
@end deftypeop

@deftypeop Constructor StringAccum {} StringAccum (int @var{capacity})
Creates a @code{StringAccum} with no characters, but a capacity of
@var{capacity}. @var{capacity} must be greater than zero.
@end deftypeop

@code{StringAccum}'s copy constructor (@code{StringAccum(const
StringAccum &)}) and assignment operator (@code{operator=(const
StringAccum &)}) are private. Thus, @code{StringAccum}s cannot be
assigned or passed as arguments. Of course, references to
@code{StringAccum}s may be passed as arguments, and this usage is quite
common.


@node StringAccum operator<<, Special StringAccum operator<<, StringAccum Constructors, StringAccum
@subsection Appending with @code{operator<<}

Generally, you append to a @code{StringAccum} using iostreams-like
@code{<<} operators, which this section describes. The next section
describes the low-level interface, the @code{append} and @code{pop_back}
methods.

Here is a conventional use of @code{StringAccum}'s @code{<<} operators:

@example
struct timeval tv; StringAccum sa; int n; // ...
sa << tv << ": There are " << n << " things.\n";
@end example

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, char @var{c})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{unsigned char @var{c}})
Appends the character @var{c} to the @code{StringAccum} @var{sa} and
returns @var{sa}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, const char *@var{s})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, const String &@var{s})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{const StringAccum &@var{sa2}})
Appends the string @var{s}, or the value of the @code{StringAccum}
@var{sa2}, to @var{sa} and returns @var{sa}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, short @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, unsigned short @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, int @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, unsigned @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, long @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, unsigned long @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, long long @var{n})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{unsigned long long @var{n}})
@deftypefunx {StringAccum &} {operator<<} (StringAccum &@var{sa}, double @var{n})
Appends an ASCII decimal representation of the number @var{n} to
@var{sa} and returns @var{sa}. For example, if @var{n} is 20, then
@code{@var{sa} << @var{n}} has the same effect as @code{@var{sa} <<
"20"}. The @code{double} operator is not available in the kernel.
@end deftypefun

@node Special StringAccum operator<<, StringAccum Manipulation, StringAccum operator<<, StringAccum
@subsection Appending Data Types

@code{StringAccum} comes with @code{operator<<} definitions for the
@code{bool}, @code{struct timeval}, @code{IPAddress}, and
@code{EtherAddress} types. Of course, you can write your own
@code{operator<<} functions for other data types, either using existing
@code{operator<<}s or the manipulation functions described in the next
section.

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{bool &@var{val}})
Appends the string @code{true} or @code{false} to @var{sa}, according to
the value of @var{val}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{const struct timeval &@var{tv}})
Appends an ASCII decimal representation of the time value @var{tv} to
@var{sa} and returns @var{sa}. The time value is printed as if by
@code{printf("%ld.%06ld", @var{tv}.tv_sec, @var{tv}.tv_usec)}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{IPAddress &@var{addr}})
Appends the conventional dotted-quad representation of the IP address
@var{addr} to @var{sa} and returns @var{sa}. For example, @samp{sa <<
addr} might have the same effect as @samp{sa << "18.26.4.44"}.
@end deftypefun

@deftypefun {StringAccum &} {operator<<} (StringAccum &@var{sa}, @w{const EtherAddress &@var{addr}})
Appends the conventional colon-separated hexadecimal representation of
the Ethernet address @var{addr} to @var{sa} and returns @var{sa}. For
example, @samp{sa << addr} might have the same effect as @samp{sa <<
"00:02:B3:06:06:36:EE"}.
@end deftypefun


@node StringAccum Manipulation, StringAccum Contents, Special StringAccum operator<<, StringAccum
@subsection Manipulation

This section describes lower-level methods for manipulating
@code{StringAccum} objects. The @code{append} methods append data to the
@code{StringAccum}; the @code{extend}, @code{reserve}, and
@code{forward} methods add space to the end of it; and the @code{clear}
and @code{pop_back} methods remove its characters.

@deftypemethod StringAccum void append (char @var{c})
@deftypemethodx StringAccum void append (unsigned char @var{c})
Appends the character @var{c} to the end of this @code{StringAccum}.
Equivalent to @code{*this << @var{c}}.
@end deftypemethod

@deftypemethod StringAccum void append (const char *@var{s}, int @var{len})
Appends the first @var{len} characters of @var{s} to the end of this
@code{StringAccum}. If @var{len} is negative, then this function treats
@var{s} as a C string, effectively setting @var{len} to
@code{strlen(@var{s})}.
@end deftypemethod

@deftypemethod StringAccum {char *} extend (int @var{len})
Puts @var{len} arbitrary characters at the end of this
@code{StringAccum} and returns a pointer to those characters. The return
value may be a null pointer if there is not enough memory to grow the
character array. This method increases the @code{StringAccum}'s length
by @var{len}, which must be greater than or equal to zero.
@end deftypemethod

@deftypemethod StringAccum {char *} extend (@w{int @var{len}}, @w{int @var{extra}})
Puts @var{len} arbitrary characters at the end of this
@code{StringAccum} and returns a pointer to those characters. Also
ensures space for @var{extra} additional characters following the
@var{len} new characters; however, these characters do not contribute to
the @code{StringAccum}'s length. The return value may be a null pointer
if there is not enough memory to grow the character array. Increases the
@code{StringAccum}'s length by @var{len}, which must be greater than or
equal to zero.

This form of @code{extend} is generally used to compensate for the null
character appended by C string functions like @code{sprintf}. For
example:

@example
if (char *buf = string_accum.extend(4, 1))
    // 4 real characters plus one terminating null
    sprintf(buf, "\\%03o", i);
@end example
@end deftypemethod

@quotation
@strong{Caution}: The pointer returned by @code{extend}, or the
@code{reserve} method described below, should be treated as transient.
It may become invalid after the next call to a method that grows the
@code{StringAccum}, such as @code{append}, @code{extend}, or one of the
@code{operator<<} functions, and will definitely become invalid when the
@code{StringAccum} is destroyed.
@end quotation


The @code{reserve} and @code{forward} methods together provide a
convenient, fast interface for appending strings of unknown, but
bounded, length.

@deftypemethod StringAccum {char *} reserve (int @var{len})
Reserves space for @var{len} characters at the end of this
@code{StringAccum} and returns a pointer to those characters. The return
value may be a null pointer if there is not enough memory to grow the
character array. This method does not change the @code{StringAccum}'s
length, although it may change its capacity. Use @code{forward} to
change the @code{StringAccum}'s length.
@end deftypemethod

@deftypemethod StringAccum void forward (int @var{amt})
Adds @var{amt} to the @code{StringAccum}'s length without changing its
data. This method is used in conjunction with @code{reserve}, above. Use
@code{reserve} to get space suitable for appending a string of unknown,
but bounded, length. After finding the actual length, use @code{forward}
to inform the @code{StringAccum}. @var{amt} must be greater than or
equal to zero, and less than or equal to the remaining capacity.
@end deftypemethod

Finally, these methods remove characters from a @code{StringAccum}
rather than add characters to it.

@deftypemethod StringAccum void clear ()
Erases the @code{StringAccum}, making its length zero (an empty string).
@end deftypemethod

@deftypemethod StringAccum void pop_back ()
@deftypemethodx StringAccum void pop_back (int @var{amt})
Remove the last character, or the last @var{amt} characters, of the
string. @var{amt} must be greater than or equal to zero, and less than
or equal to the @code{StringAccum}'s length.
@end deftypemethod


@node StringAccum Contents, StringAccum Results, StringAccum Manipulation, StringAccum
@subsection Contents

@quotation
@strong{Caution}: The pointer returned by @code{data} and @code{c_str}
should be treated as transient. It may become invalid after the next
call to a method that grows the @code{StringAccum}, such as
@code{append}, @code{extend}, or one of the @code{operator<<} functions,
and will definitely become invalid when the @code{StringAccum} is destroyed.
@end quotation

@deftypemethod StringAccum {const char *} data () const
@deftypemethodx StringAccum {char *} data ()
Returns a pointer to the character data contained in this
@code{StringAccum}.
@end deftypemethod

@deftypemethod StringAccum int length () const
Returns the number of characters in this @code{StringAccum}.
@end deftypemethod

@deftypemethod String {} {operator bool} ()
@deftypemethodx String {} {operator bool} () const
Returns true iff this @code{StringAccum} has at least one character.
@end deftypemethod

@deftypemethod StringAccum {const char *} c_str ()
@deftypemethodx StringAccum {const char *} cc ()
Returns a pointer to the character data contained in this
@code{StringAccum}. Guarantees that the returned string is
null-terminated: the @code{length()}th character will be @code{'\0'}.
This does not affect the @code{StringAccum}'s contents or length.
@end deftypemethod

@deftypemethod StringAccum char {operator[]} (int @var{i}) const
@deftypemethodx StringAccum {char &} {operator[]} (int @var{i})
Returns the @var{i}th character of this @code{StringAccum}. @var{i} must
be greater than or equal to zero, and less than the @code{StringAccum}'s
length. Note that the non-@code{const} version of this method returns a
mutable character reference, which facilitates code like

@example
StringAccum sa; // ...
sa[5] = 'a';
@end example
@end deftypemethod


@node StringAccum Results, StringAccum Out-of-Memory, StringAccum Contents, StringAccum
@subsection Results

@code{StringAccum}'s @code{take} methods return the string accumulated
by a series of calls to @code{operator<<} or similar methods. Each
@code{take} method makes @code{StringAccum} relinquish responsibility
for its character array memory, passing that responsibility on to its
caller. The caller should free the memory when it is done---either with
@code{delete[]}, for the @code{take} and @code{take_bytes} methods, or
by relying on @code{String} to handle it, for the @code{take_string}
method.

Each @code{take} method additionally restores the @code{StringAccum} to
its original, empty state. Further @code{append}s or similar operations
will begin building a new string from scratch.

@deftypemethod StringAccum void take (unsigned char *&@var{s}, int &@var{len})
Sets the @var{s} variable to this @code{StringAccum}'s character data
and @var{len} to its length. Then clears the @code{StringAccum}'s
internal state. 
@end deftypemethod

@deftypemethod StringAccum {char *} take ()
@deftypemethodx StringAccum {unsigned char *} take_bytes ()
Returns this @code{StringAccum}'s character data, then clears the
@code{StringAccum}'s internal state. The methods differ only in their
return types. Note that @code{StringAccum::length} will always return
zero immediately after a @code{take} or @code{take_bytes}. If you need
to know the string's length, call @code{length} first.
@end deftypemethod

@deftypemethod StringAccum String take_string ()
Returns this @code{StringAccum}'s character data as a @code{String}
object (@pxref{String}), then clears the @code{StringAccum}'s internal
state. This method hands the character data over to the @code{String}
implementation; no data copies are performed.
@end deftypemethod


@node StringAccum Out-of-Memory,  , StringAccum Results, StringAccum
@subsection Out-of-Memory Conditions

@code{StringAccum} operations are robust against out-of-memory
conditions. If there is not enough memory to complete a particular
operation, the @code{StringAccum} is erased and turned into a special
out-of-memory indicator. This is a contagious empty string. Every
operation on such a buffer (except for @code{clear}) leaves it in the
out-of-memory state.

@deftypemethod StringAccum bool out_of_memory () const
Returns true iff this @code{StringAccum} is an out-of-memory indicator.
@end deftypemethod

The @code{extend} and @code{reserve} methods can return null pointers on
out-of-memory; their callers should always check that their return
values are non-null.



@node Vector, Bitvector, StringAccum, Helper Classes
@section Vector

@node Bitvector, HashMap, Vector, Helper Classes
@section Bitvector

@node HashMap, BigHashMap, Bitvector, Helper Classes
@section HashMap

@node BigHashMap, ErrorHandler, HashMap, Helper Classes
@section BigHashMap


@node ErrorHandler, IPAddress, BigHashMap, Helper Classes
@section ErrorHandler

All Click error messages are passed to an instance of the
@code{ErrorHandler} class. @code{ErrorHandler} separates the generation
of error messages from the particular way those messages should be
printed. It also makes it easy to automatically decorate errors with
context information.

Most Click users must know how to report errors to an
@code{ErrorHandler}, and how @code{ErrorHandler}s count the messages
they receive. This section also describes how to decorate error messages
with error veneers, and how to write new @code{ErrorHandler}s.

@code{ErrorHandler} and its important subclasses are defined in
@code{<click/error.hh>}.

@menu
* ErrorHandler Initialization::  
* Reporting Errors::            
* Error Format Strings::        
* Counting Errors::             
* Basic ErrorHandlers::         
* Error Veneers::               
* Writing ErrorHandlers::       
@end menu


@node ErrorHandler Initialization, Reporting Errors, ErrorHandler, ErrorHandler
@subsection Class Initialization

The @code{ErrorHandler} class maintains some global state that must be
initialized by calling @code{static_initialize} at the beginning of the
program, and may be freed by calling @code{static_cleanup} when
execution is complete.

@deftypeop {Static Method} ErrorHandler void static_initialize (ErrorHandler *@var{default_errh})
Call this function exactly once, at the beginning of the program, before
any error messages are reported to any @code{ErrorHandler}. It is OK to
create arbitrary @code{ErrorHandler} objects before calling this method,
however. The @var{default_errh} argument becomes the default
@code{ErrorHandler}; see @ref{Basic ErrorHandlers}.
@end deftypeop

@deftypeop {Static Method} ErrorHandler void static_cleanup ()
Call this function exactly once, just before the program exits. Destroys
the default and silent @code{ErrorHandler}s and cleans up other
@code{ErrorHandler}-related memory. It is an error to call any
@code{ErrorHandler} method after calling @code{static_cleanup}.
@end deftypeop


@node Reporting Errors, Error Format Strings, ErrorHandler Initialization, ErrorHandler
@subsection Reporting Errors

@code{ErrorHandler}'s basic error reporting methods take a format
string, which may use @code{printf}-like @samp{%} escape sequences, and
additional arguments as required by the format string. @xref{Error
Format Strings}, for more details on the format string. The five methods
differ in the seriousness of the error they report.

@deftypemethod ErrorHandler void debug (const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler void message (const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int warning (const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int error (const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int fatal (const char *@var{format}, @dots{})
Report the error described by @var{format} and any additional arguments.
The methods are listed by increasing seriousness. Use @code{debug} for
debugging messages that should not be printed in a production
environment; @code{message} for explanatory messages that do not
indicate errors; @code{warning} for warnings (this function prepends the
string @samp{warning:@ } to every line of the error message);
@code{error} for errors; and @code{fatal} for errors so serious that
they should halt the execution of the program. The three functions that
indicate errors, @code{warning}, @code{error}, and @code{fatal}, always
return @code{-EINVAL}. In some environments, @code{fatal} will actually
exit the program with exit code 1.
@end deftypemethod

Each of these methods has an analogue that additionally takes a
@dfn{landmark}: a string representing where the error took place. A
typical landmark contains a file name and line number, separated by a
colon---@samp{foo.click:31}, for example.

@deftypemethod ErrorHandler void ldebug (const String &@var{landmark}, const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler void lmessage (const String &@var{landmark}, const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int lwarning (const String &@var{landmark}, const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int lerror (const String &@var{landmark}, const char *@var{format}, @dots{})
@deftypemethodx ErrorHandler int lfatal (const String &@var{landmark}, const char *@var{format}, @dots{})
Report the error described by @var{format} and any additional arguments.
The error took place at @var{landmark}. Most @code{ErrorHandler}s will
simply prepend @samp{@var{landmark}:@ } to each line of the error
message.
@end deftypemethod

These methods are all implemented as wrappers around the @code{verror}
function. This function takes a landmark, a format string, a
@code{va_list} packaging up any additional arguments, and a
@dfn{seriousness value}, which encodes how serious the error was. The
@code{Seriousness} enumerated type, which is defined in the
@code{ErrorHandler} class, represents seriousness values. There are five
constants, corresponding to the five error-reporting methods:

@table @code
@item ERR_DEBUG
Corresponds to @code{debug} and @code{ldebug}.

@item ERR_MESSAGE
Corresponds to @code{message} and @code{lmessage}.

@item ERR_WARNING
Corresponds to @code{warning} and @code{lwarning}.

@item ERR_ERROR
Corresponds to @code{error} and @code{lerror}.

@item ERR_FATAL
Corresponds to @code{fatal} and @code{lfatal}.
@end table

@deftypemethod ErrorHandler int verror (Seriousness @var{seriousness}, const String &@var{landmark}, const char *@var{format}, va_list @var{val})
Report the error described by @var{format} and @var{val}. The error took
place at @var{landmark}, if @var{landmark} is nonempty. The
@var{seriousness} value is one of the five constants described above.
Always returns @code{-EINVAL}.
@end deftypemethod


@node Error Format Strings, Counting Errors, Reporting Errors, ErrorHandler
@subsection Format Strings

@code{ErrorHandler}'s format strings closely follow C's standard
@code{printf} format strings. Most characters in the format string are
printed verbatim. The @samp{%} character introduces a @dfn{conversion},
which prints data read from the remaining arguments. The format string
may contain newlines @samp{\n}, but it need not end with a newline;
@code{ErrorHandler} will add a final newline if one does not exist.

Each conversion, or formatting escape, follows this pattern:

@itemize @bullet
@item
First, the @samp{%} character introduces each conversion.

@item
Next comes zero or more @dfn{flag characters};

@item
then an optional @dfn{field width};

@item
then an optional @dfn{precision};

@item
then an optional @dfn{length modifier};

@item
and finally, the mandatory @dfn{conversion specifier}, which is
usually a single character, but may be a name enclosed in braces.
@end itemize

@noindent
We discuss each of these is turn.

Any conversion may be modified by zero or more of these flag characters.

@table @asis
@item @samp{#}
The value should be converted to an ``alternate form''. For @samp{o}
conversions, the first character of the output string is made @samp{0},
by prepending a @samp{0} if there was not one already. For @samp{x} and
@samp{X} conversions, nonzero values have @samp{0x} or @samp{0X}
prepended, respectively.

@item @samp{0}
The value should be zero padded. For @samp{d}, @samp{i}, @samp{u},
@samp{o}, @samp{x}, and @samp{X} conversions, the converted value is
padded on the left with @samp{0} characters rather than spaces.

@item @samp{-}
The value should be left-justified within the field width.

@item @samp{@ } (a space)
Leave a blank before a nonnegative number produced by a signed
conversion.

@item @samp{+}
Print a @samp{+} character before a nonnegative number produced by a
signed conversion.

@end table

The optional @dfn{field width}, a decimal digit string, forces the
conversion to use a minimum number of characters. The result of a
conversion is padded on the left with space characters to reach the
minimum field width, unless one of the @samp{0} or @samp{-} flags was
supplied.

The optional @dfn{precision} is a decimal digit string preceded by a
period @samp{.}. For @samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x},
and @samp{X} conversions, the precision specifies the minimum number
of digits that must appear; results with fewer digits are padded on
the left with @samp{0} characters. For the @samp{s} conversion, the
precision specifies the maximum number of characters that can be
printed. For @samp{e}, @samp{f}, @samp{E}, and @samp{F} conversions,
it specifies the number of digits to appear after the radix character;
for @samp{g} and @samp{G} conversions, the number of significant
digits.

If either the field width or precision is specified as a star @samp{*},
@code{ErrorHandler} reads the next argument as an integer and uses that
instead.

Length modifiers affect the argument type read by the conversion. There
are three modifiers:

@table @asis
@item @samp{h}
The next argument is a @code{short} or @code{unsigned short}. Affects
the @samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x}, and @samp{X}
conversions.

@item @samp{l}
The next argument is a @code{long} or @code{unsigned long}. Affects the
@samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x}, and @samp{X}
conversions.

@item @samp{ll}
The next argument is a @code{long long} or @code{unsigned long long}.
Affects the @samp{d}, @samp{i}, @samp{u}, @samp{o}, @samp{x}, and
@samp{X} conversions.
@end table

Finally, these are the conversions themselves.

@table @asis
@item @samp{s}
Print the @code{const char *} argument, treated as a C string.

@item @samp{c}
The @code{int} argument is treated as a character constant. Printable
ASCII characters (values between 32 and 126) are printed verbatim.
Characters @samp{\n}, @samp{\t}, @samp{\r}, and @samp{\0} use those C
escape representations. Other characters use the representation
@samp{\%03o}.

@item @samp{d}, @samp{i}
The argument is an @code{int}; print its decimal representation.

@item @samp{u}
The argument is an @code{unsigned int}; print its decimal
representation.

@item @samp{o}
The argument is an @code{unsigned int}; print its octal representation.

@item @samp{x}, @samp{X}
The argument is an @code{unsigned int}; print its hexadecimal
representation. The @samp{%x} conversion uses lowercase letters;
@samp{%X} uses uppercase letters.

@item @samp{e}, @samp{f}, @samp{g}, @samp{E}, @samp{F}, @samp{G}
The argument is a @code{double}; print its representation as if by
@code{printf} (user-level drivers only).

@item @samp{p}
The @code{void *} argument is cast to @code{unsigned long} and printed
as by @samp{%#lx}.

@item @samp{%}
Print a literal @samp{%} character.

@item @samp{@{element@}}
The argument is an @code{Element *}. Print that element's declaration.

@end table

Note that @code{ErrorHandler} does not support the @samp{n} conversion.


@node Counting Errors, Basic ErrorHandlers, Error Format Strings, ErrorHandler
@subsection Counting Errors

@code{ErrorHandler} objects count the number of errors and warnings they
have received and make those values available to the user.

@deftypemethod ErrorHandler {virtual int} nwarnings () const
@deftypemethodx ErrorHandler {virtual int} nerrors () const
Returns the number of warnings or errors received by this
@code{ErrorHandler} so far.
@end deftypemethod

@deftypemethod ErrorHandler {virtual void} reset_counts ()
Resets the @code{nwarnings} and @code{nerrors} counters to zero.
@end deftypemethod

These counters are typically used to determine whether an error has
taken place in some complex piece of code. For example:

@example
int before_nerrors = errh->nerrors();
// @r{@dots{} complex code that may report errors to @code{errh} @dots{}}
if (errh->nerrors() != before_nerrors) @{
    // @r{an error has taken place}
@}
@end example


@node Basic ErrorHandlers, Error Veneers, Counting Errors, ErrorHandler
@subsection Basic @code{ErrorHandler}s

Every Click error message eventually reaches some @dfn{basic}
@code{ErrorHandler}, which generally prints the messages it receives.
The user-level driver's basic @code{ErrorHandler} prints error messages
to standard error, while in the Linux kernel module, the basic
@code{ErrorHandler} logs messages to the syslog and stores them for
access via @file{/click/errors}.

@cindex default @code{ErrorHandler}
@cindex @code{ErrorHandler}, default
Two basic @code{ErrorHandlers} are always accessible via static methods:
the @dfn{default @code{ErrorHandler}}, returned by
@code{default_handler} and set by @code{set_default_handler}; and the
@dfn{silent @code{ErrorHandler}}, returned by @code{silent_handler},
which ignores any error messages it receives.

@deftypeop {Static Method} ErrorHandler {ErrorHandler *} default_handler ()
Returns the default @code{ErrorHandler}.
@end deftypeop

@deftypeop {Static Method} ErrorHandler void set_default_handler (@w{ErrorHandler *errh})
Sets the default @code{ErrorHandler} to @var{errh}. The
@code{static_initialize} method also sets the default
@code{ErrorHandler}; see @ref{ErrorHandler Initialization}.
@end deftypeop

@deftypeop {Static Method} ErrorHandler {ErrorHandler *} silent_handler ()
Returns the silent @code{ErrorHandler}. This handler ignores any error
messages it receives. It maintains correct @code{nwarnings} and
@code{nerrors} counts, however.
@end deftypeop

@code{FileErrorHandler}, a kind of basic @code{ErrorHandler}, is
available in any user-level program. It prints every message it receives
to some file, usually standard error. It can also prepend an optional
context string to every line of every error message.

@deftypeop Constructor FileErrorHandler {} FileErrorHandler (FILE *@var{f}, @w{const String &@var{prefix} = ""})
Constructs a @code{FileErrorHandler} that prints error messages to file
@var{f}. If @var{prefix} is nonempty, then every line of every error
message is prepended by @var{prefix}.
@end deftypeop


@node Error Veneers, Writing ErrorHandlers, Basic ErrorHandlers, ErrorHandler
@subsection Error Veneers

@dfn{Error veneers} wrap around basic @code{ErrorHandler} objects and
change how error text is generated. An error veneer generally changes
each error message's text in some way, perhaps by adding a context
message or some indentation. It then passes the altered text to the
basic @code{ErrorHandler} for printing. Error veneers can be easily
nested.

The first argument to each error veneer constructor is a pointer to
another @code{ErrorHandler} object. The veneer will pass altered error
text to this handler, the @dfn{base handler}, for further processing and
printing. It also delegates @code{nwarnings()} and @code{nerrors()}
calls to the base handler.

Click comes with three error veneers: one for adding context, one for
prepending text to every line, and one for supplying missing landmarks.
It is easy to write others; see @ref{Writing ErrorHandlers}, for
details.

@deftypeop Constructor ContextErrorHandler {} ContextErrorHandler (@w{ErrorHandler *@var{base_errh}}, @w{const String &@var{context}}, @w{const String &@var{indent} = "@w{@ @ }"})
Constructs a @code{ContextErrorHandler} with @var{base_errh} as base.

The first time this handler receives an error message, it will precede
the message with the @var{context} string---generally more detailed
information about where the error has occurred. Every line in every
received error message is prepended with @var{indent}, two spaces by
default, to set off the message from its context.
@end deftypeop

@deftypeop Constructor PrefixErrorHandler {} PrefixErrorHandler (@w{ErrorHandler *@var{base_errh}}, @w{const String &@var{prefix}})
Constructs a @code{PrefixErrorHandler} with @var{base_errh} as base.

This handler precedes every line of every error message with
@var{prefix}.
@end deftypeop

@deftypeop Constructor LandmarkErrorHandler {} LandmarkErrorHandler (@w{ErrorHandler *@var{base_errh}}, @w{const String &@var{landmark}})
Constructs a @code{LandmarkErrorHandler} with @var{base_errh} as base.

This handler supplies @var{landmark} in place of any blank landmark
passed to it. This will cause the base handler to include @var{landmark}
in its error message.
@end deftypeop

To demonstrate these veneers in practice, we'll use the following
function, which prints two error messages:

@example
void f(ErrorHandler *errh) @{
    errh->error("First line\nSecond line");
    errh->lwarning("here", "Third line");
@}
@end example

A simple @code{FileErrorHandler} shows the base case.

@example
FileErrorHandler errh1(stderr);
f(&errh1);
    @print{} First line
    @print{} Second line
    @print{} here: warning: Third line
@end example

The simplest error veneer, @code{PrefixErrorHandler}, just prepends text
to every line.

@example
PrefixErrorHandler errh2(&errh1, "prefix - ");
f(&errh2);
    @print{} prefix - First line
    @print{} prefix - Second line
    @print{} prefix - here: warning: Third line
@end example

@code{ContextErrorHandler} supplies a line of context before the first
error message, and indents all messages except the context.

@example
ContextErrorHandler errh3(&errh1, "This was called from ...", "** ");
f(&errh3);
    @print{} This was called from ...
    @print{} ** First line
    @print{} ** Second line
    @print{} here: ** warning: Third line
@end example

@noindent
Note that the indentation @samp{**@ } is printed after the landmark.
This often looks better than the alternative.

Of course, an error veneer can take another error veneer as its ``base
handler'', leading to cumulative effects.

@example
ContextErrorHandler errh4(&errh2, "This was called from ...", "** ");
f(&errh4);
    @print{} prefix - This was called from ...
    @print{} prefix - ** First line
    @print{} prefix - ** Second line
    @print{} prefix - here: ** warning: Third line
@end example


@node Writing ErrorHandlers,  , Error Veneers, ErrorHandler
@subsection Writing @code{ErrorHandler}s

@code{ErrorHandler} constructs an error message using three virtual
functions. The first, @code{make_text}, parses a format string and
argument list into a single @code{String}. This is passed to the second
function, @code{decorate_text}, which may transform the string. The
final function, @code{handle_text}, prints the resulting error message.
This structure makes @code{ErrorHandler} easy to extend. To write a new
basic @code{ErrorHandler}, you will need to override just
@code{handle_text} and the counting functions (@code{nwarnings},
@code{nerrors}, and @code{reset_counts}). The @code{ErrorVeneer} helper
class, described below, lets you override just @code{decorate_text} when
writing an error veneer.

@deftypemethod ErrorHandler {virtual String} make_text @w{(Seriousness @var{s},} @w{const char *@var{format}}, va_list @var{val})
Parses the format string @var{format} with arguments from @var{val},
returning the results as a @var{String} object.

The default implementation processes the formatting escapes described
above (@pxref{Error Format Strings}). It also prepends every line of
the error message with @samp{warning: } if @var{s} equals
@code{ERR_WARNING}.
@end deftypemethod

@deftypemethod ErrorHandler {virtual String} decorate_text (Seriousness @var{s}, const String &@var{prefix}, const String &@var{landmark}, const String &@var{text})
Decorates the error message @var{text} as appropriate and returns the
result. At minimum, every line of the result should be prepended by
@var{prefix} and, if it is nonempty, the landmark string @var{landmark}.

The default implementation creates lines like this:

@example
@var{prefix}@var{landmark}: @var{text}     @r{(if @var{landmark} is nonempty)}
@var{prefix}@var{text}               @r{(if @var{landmark} is empty)}
@end example

@noindent
Any spaces and/or a final colon are stripped from the end of
@var{landmark}. Special landmarks, which begin and end with a backslash
@samp{\}, are ignored.
@end deftypemethod

@deftypemethod ErrorHandler {virtual void} handle_text (@w{Seriousness @var{s}, const String &@var{text}})
This method is responsible for printing or otherwise informing the user
about the error message @var{text}. If @var{s} equals @code{ERR_FATAL},
the method should exit the program or perform some other drastic action.
It should also maintain the @code{nwarnings()} and @code{nerrors()}
counters. In most cases, it should ensure that the last character in
@var{text} is a newline.

This method has no default implementation.
@end deftypemethod

@tpindex @code{ErrorVeneer}
The @code{ErrorVeneer} class, a subclass of @code{ErrorHandler},
supplies default implementations for these functions that ease the
construction of new error veneers. @code{ErrorVeneer}'s single instance
variable, @code{ErrorHandler *_errh}, is the base handler.
@code{ErrorVeneer} overrides all the relevant virtual
functions---@code{nwarnings}, @code{nerrors}, @code{reset_counts},
@code{make_text}, @code{decorate_text}, and @code{handle_text}. Its
versions simply delegate to the corresponding methods on @code{_errh}.
An error veneer designer will generally subclass @code{ErrorVeneer}
rather than @code{ErrorHandler}; then she will override only the methods
she cares about (usually @code{decorate_text}), relying on
@code{ErrorVeneer}'s default implementations for the rest.

@deftypeop Constructor ErrorVeneer {} ErrorVeneer (ErrorHandler *@var{base_errh})
Constructs an @code{ErrorVeneer} helper class with @var{base_errh} as
its base error handler. This constructor simply sets @code{_errh =
base_errh}.
@end deftypeop


@node IPAddress, IP6Address, ErrorHandler, Helper Classes
@section IPAddress

The @code{IPAddress} type represents an IPv4 address. It supports
bitwise operations like @samp{&} and @samp{|} and provides methods for
unparsing IP addresses into ASCII dotted-quad form.

See the Doxygen documentation on class @code{IPAddress} for information.


@node IP6Address,  , IPAddress, Helper Classes
@section IP6Address



@node Packets, Element Characteristics, Helper Classes, Top
@chapter Packets

The @code{Packet} class represents Click packets. The single
@code{Packet} interface has multiple implementations, one per driver.
Inside the Linux kernel driver, a @code{Packet} object is equivalent to
a Linux @code{sk_buff} structure; most @code{Packet} methods are inline
functions that expand to @code{sk_buff} calls. The user-level driver,
however, uses a purpose-built @code{Packet} implementation.

Click packets separate header information from data. The @w{@code{Packet
*}} pointer points to a header structure, which holds pointers to the
actual packet data and a set of @dfn{annotations}. Packet data may be
shared by two or more packet headers. Packet headers, however, should
never be shared.

Packets come in two flavors, @code{Packet} and @code{WritablePacket}. A
@code{Packet} object represents a packet header whose data might be
shared with other packets. Because of this potential sharing,
@code{Packet} data is read-only, and its methods return @code{const}
pointers to data. A @code{WritablePacket} object, in contrast,
represents a packet header whose data is known not to be shared. Its
methods return non-@code{const} pointers. The @code{uniqueify} method
turns a @code{Packet} into a @code{WritablePacket}, possibly by making a
copy of the packet's data. @code{WritablePacket} is a subclass of
@code{Packet}, so you can turn a @code{WritablePacket} into a
@code{Packet} implicitly.

The @code{Packet} and @code{WritablePacket} classes are defined in
@samp{<click/packet.hh>}.

@menu
* Packet Structure and Contents::  
* Packet Creation::             
* Packets and sk_buffs::        
* Packet Sharing::              
* Packet Buffer Manipulation::  
* Annotations::                 
* Packet Out-of-Memory::        
@end menu


@node Packet Structure and Contents, Packet Creation, Packets, Packets
@section Structure and Contents

Packet data is stored in a single flat array of bytes. There is no
support for linked chains @`a la BSD @code{mbuf}. The actual packet data
is embedded inside a buffer that may be much larger, leaving unused
spaces called @dfn{headroom} and @dfn{tailroom} before and after the
data proper. Therefore, tasks like prepending a header need not always
reallocate memory. If the headroom is big enough, prepending space for a
new header just requires bumping a pointer.

This diagram shows how a typical packet is laid out, with the relevant
@code{Packet} methods' names.

@example
                      data
        |<- headroom ->|<----- length ----->|<- tailroom ->|
        |              |                    |              |
        +==============+====================+==============+
        |XXXXXXXXXXXXXX| PACKET CONTENTS... |XXXXXXXXXXXXXX|
        +==============+====================+==============+
        |                                                  |
        |<---------------- buffer_length ----------------->|
   buffer_data
@end example

@sp 1

And here are those methods' descriptions.

@deftypemethod Packet {const unsigned char *} data () const
Returns a pointer to the packet data proper.
@end deftypemethod

@deftypemethod Packet unsigned length () const
Returns the length of the packet data proper.
@end deftypemethod

@deftypemethod Packet {const unsigned char *} buffer_data () const
Returns a pointer to the buffer that contains the packet data.
@end deftypemethod

@deftypemethod Packet unsigned headroom () const
@deftypemethodx Packet unsigned tailroom () const
@deftypemethodx Packet unsigned buffer_length () const
Returns the length of the headroom area, the tailroom area, and the
whole buffer, respectively.
@end deftypemethod

@deftypemethod WritablePacket {unsigned char *} data () const
@deftypemethodx WritablePacket {unsigned char *} buffer_data () const
These @code{WritablePacket} methods are identical to @code{Packet}'s
@code{data} and @code{buffer_data} methods except for their
non-@code{const} return type.
@end deftypemethod

Two invariants relate these methods' values:

@display
@t{buffer_length()} @math{=} @t{headroom()} @math{+} @t{length()} @math{+} @t{tailroom()}
@t{data()} @math{=} @t{buffer_data()} @math{+} @t{headroom()}
@end display


@node Packet Creation, Packets and sk_buffs, Packet Structure and Contents, Packets
@section Creation and Destruction

Packets are created with the @code{Packet::make} static methods, and
destroyed with the @code{Packet::kill} method. (The @code{Packet} and
@code{WritablePacket} classes have private constructors and destructors;
you cannot create or destroy packets with @code{new} or @code{delete}.)

@subsection @code{Packet::make}

The @code{make} methods always take the length of the packet data; some
of them take the packet contents and the headroom and tailroom lengths
as well. (The contents of any headroom and tailroom areas are always
undefined.) Most of them return a @w{@code{WritablePacket *}}, since new
packets are not shared.

The @code{Packet} class defines two constants related to packet
creation, @code{DEFAULT_HEADROOM} and @code{MIN_BUFFER_LENGTH}. Those
@code{make} methods that do not take an explicit headroom parameter use
@code{DEFAULT_HEADROOM} instead. Furthermore, no @code{make} method will
create a packet with buffer length less than @code{MIN_BUFFER_LENGTH}.
If the sum of a packet's headroom and length is less than this, the
packet buffer is given extra tailroom to bump the buffer length up to
@code{MIN_BUFFER_LENGTH}. These constants have the values
@code{DEFAULT_HEADROOM} @math{= 28} and @code{MIN_BUFFER_LENGTH} @math{=
64}.


@deftypeop {Static Method} Packet {WritablePacket *} make (unsigned @var{len})
Returns a new packet containing @var{len} bytes of undefined data.
@end deftypeop

@deftypeop {Static Method} Packet {WritablePacket *} make @w{(const char *@var{data}, unsigned @var{len})}
@deftypeopx {Static Method} Packet {WritablePacket *} make @w{(const unsigned char *@var{data}}, unsigned @var{len})
Returns a new packet whose contents equal the first @var{len} bytes of
@var{data}. @var{data} may be a null pointer, in which case the packet
contains @var{len} bytes of undefined data.
@end deftypeop

@deftypeop {Static Method} Packet {WritablePacket *} make (unsigned @var{headroom}, @w{const unsigned char *@var{data}}, unsigned @var{len}, unsigned @var{tailroom})
Returns a new packet containing @var{headroom} bytes of headroom,
@var{len} bytes of contents, and at least @var{tailroom} bytes of
tailroom. The packet contents will equal the first @var{len} bytes of
@var{data} unless @var{data} is a null pointer, in which case the
contents are undefined.
@end deftypeop

The following @code{make} method is only available in the user-level
driver.

@deftypeop {Static Method} Packet {WritablePacket *} make (@w{unsigned char *@var{data}}, @w{unsigned @var{len}}, @w{void (*@var{destructor})(unsigned char *, size_t)})
Returns a new packet that uses @var{data} as a buffer. That is, the new
packet will have the following characteristics:

@multitable {@code{buffer_length}} {@code{buffer_length_buffer}}
@item @code{buffer_data}
@tab @var{data}
@item @code{buffer_length}
@tab @var{len}
@item @code{headroom}
@tab 0
@item @code{length}
@tab @var{len}
@item @code{tailroom}
@tab 0
@end multitable

@noindent
When the resulting packet is destroyed, the function @var{destructor}
will be called with @var{data} and @var{len} as arguments.
@var{destructor} may be a null pointer, in which case @code{Packet}
calls @w{@code{delete[] @var{data}}} instead.

This method lets a user-level element manage packet memory itself,
rather than relying on @code{Packet}.
@end deftypeop

@noindent
@xref{Packets and sk_buffs}, for a @code{make} method only available in
the Linux kernel driver.

@subsection @code{Packet::kill}

To destroy a @code{Packet}, simply call its @code{kill} method.

@deftypemethod Packet void kill ()
Frees this packet. If this packet contained the last reference to its
data buffer, then frees the data buffer as well.
@end deftypemethod


@node Packets and sk_buffs, Packet Sharing, Packet Creation, Packets
@section @code{Packet}s and @code{sk_buff}s

In the Linux kernel driver, @code{Packet} objects are equivalent to
@code{struct sk_buff}s. This avoids indirection overhead and makes it
cheap to pass packets back and forth between Linux and Click. The
@code{Packet} operations described in this section are mostly inline
functions that expand to conventional @code{sk_buff} calls like
@code{skb_clone()}.

Click @code{Packet} @code{sk_buff}s should always have @code{skb->users}
equal to 1. That is, the @code{sk_buff} headers should not be shared,
although the data buffers they point to may be shared.

The @code{make}, @code{skb}, and @code{steal_skb} methods described in
this section convert @code{Packet}s to @code{sk_buff}s and vice versa.

@deftypeop {Static Method} Packet {Packet *} make (@w{struct sk_buff *@var{skb}})
Returns a new packet equivalent to the @code{sk_buff} @var{skb}. All of
@var{skb}'s data pointers and annotations are left unchanged. This
method generally does nothing, since @code{Packet}s and @code{sk_buff}s
are equivalent in the Linux kernel. However, if @code{@var{skb}->users}
field is bigger than 1, the method will return a clone of @var{skb}.
This method returns a @code{Packet *}, not a @w{@code{WritablePacket
*}}, because the @var{skb} argument might share data with some other
@code{sk_buff}.

Do not use or manipulate @var{skb} after passing it to this method,
since Click and the @code{Packet} implementation now own @var{skb}.
@end deftypeop

@deftypemethod Packet {struct sk_buff *} skb ()
@deftypemethodx Packet {const struct sk_buff *} skb () const
Returns the @code{sk_buff} corresponding to this packet. Use this method
to examine the @code{sk_buff} version of a @code{Packet}.

Do not pass the result to a function that might free it or increment its
@code{users} field; use @code{steal_skb} for that.
@end deftypemethod

@deftypemethod Packet {struct sk_buff *} steal_skb ()
Returns the @code{sk_buff} corresponding to this packet. Use this
method to permanently change a @code{Packet} into an
@code{sk_buff}---for example, to create an @code{sk_buff} you'd like to
send to Linux.

Do not use or manipulate a @code{Packet} after calling its
@code{steal_skb} method, since Linux now owns the resulting
@code{sk_buff}.
@end deftypemethod


@node Packet Sharing, Packet Buffer Manipulation, Packets and sk_buffs, Packets
@section Sharing---@code{clone} and @code{uniqueify}

The @code{clone} method creates a new packet header that shares data
with an existing packet. The @code{uniqueify} method, in contrast,
ensures that a packet's data is not shared by anyone, perhaps by making
a copy of the data.

@deftypemethod Packet {Packet *} clone ()
Creates and returns a new packet header that shares this packet's data.
The new packet's annotations are copied from this packet's annotations.

The result may be a null pointer if there was not enough memory to make a
new packet header.
@end deftypemethod

@deftypemethod Packet {WritablePacket *} uniqueify ()
Ensures that this packet does not share data with any other packet. This
may involve copying the packet data, and perhaps creating a new packet
header, but if this packet is already unshared, no real work is
required. Returns a @w{@code{WritablePacket *}} because the new packet
is unshared.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{uniqueify} method. Manipulate the returned @w{@code{WritablePacket
*}} instead.

The result may be a null pointer if there was not enough memory to make a
required data copy. In this case, the old packet is freed.
@end deftypemethod

@deftypemethod Packet bool shared () const
Returns true if and only if this packet shares data with some other
packet.
@end deftypemethod


@node Packet Buffer Manipulation, Annotations, Packet Sharing, Packets
@section Buffer Manipulation---@code{push}, @code{pull}, @code{put}, and @code{take}

The @code{push}, @code{pull}, @code{put}, and @code{take} methods
manipulate a packet's contents by adding or removing space from its
headroom or tailroom. Given a packet, use @code{push} to add space to
its beginning, @code{pull} to remove space from its beginning,
@code{put} to add space to its end, and @code{take} to remove space from
its end. The methods that add space, @code{push} and @code{put},
uniqueify the relevant packet as a side effect. This ensures that the
packet's data is unshared so you can immediately manipulate the added
space.

@deftypemethod Packet {WritablePacket *} push (unsigned @var{amt})
Adds @var{amt} bytes of space to the beginning of the packet's data and
returns the resulting packet. The new space is uninitialized. The result
will not share data with any other packet; thus, it is a
@w{@code{WritablePacket *}}. If this packet is unshared and its headroom
is bigger than @var{amt}, then this operation is cheap, amounting to a
bit of pointer arithmetic. Otherwise, it requires copying the packet
data and possibly creating a new packet header.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{push} method. Manipulate the returned @w{@code{WritablePacket
*}} instead.

The result may be a null pointer if there was not enough memory to make a
required new packet. In this case, the old packet is freed.
@end deftypemethod

@deftypemethod Packet void pull (unsigned @var{amt})
Removes @var{amt} bytes of space from the beginning of the packet's
data. @var{amt} must be less than or equal to the packet's
@code{length()}. This operation is always cheap, amounting to a bit of
pointer arithmetic.
@end deftypemethod

@deftypemethod Packet {WritablePacket *} put (unsigned @var{amt})
Adds @var{amt} bytes of space to the end of the packet's data and
returns the resulting packet. The new space is uninitialized. The result
will not share data with any other packet; thus, it is a
@w{@code{WritablePacket *}}. If this packet is unshared and its tailroom
is bigger than @var{amt}, then this operation is cheap, amounting to a
bit of pointer arithmetic. Otherwise, it requires copying the packet
data and possibly creating a new packet header.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{put} method. Manipulate the returned @w{@code{WritablePacket *}}
instead.

The result may be a null pointer if there was not enough memory to make a
required new packet. In this case, the old packet is freed.
@end deftypemethod

@deftypemethod Packet void take (unsigned @var{amt})
Removes @var{amt} bytes of space from the end of the packet's data.
@var{amt} must be less than or equal to the packet's @code{length()}.
This operation is always cheap, amounting to a bit of pointer
arithmetic.
@end deftypemethod

The @code{push} and @code{put} methods have ``nonunique'' variants,
@code{nonunique_push} and @code{nonunique_put}, which do not have the
side effect of uniqueifying their resulting packet. These methods are
rarely used.

@deftypemethod Packet {Packet *} nonunique_push (unsigned @var{amt})
Adds @var{amt} bytes of space to the beginning of the packet's data and
returns the resulting packet. The new space is uninitialized. The result
may share data with other packets. If this packet's headroom is bigger
than @var{amt}, then this operation is cheap, amounting to a bit of
pointer arithmetic. Otherwise, it requires copying the packet data and
possibly creating a new packet header.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{nonunique_push} method. Manipulate the returned @w{@code{Packet
*}} instead.

The result may be a null pointer if there was not enough memory to make a
required new packet. In this case, the old packet is freed.
@end deftypemethod

@deftypemethod Packet {Packet *} nonunique_put (unsigned @var{amt})
Adds @var{amt} bytes of space to the end of the packet's data, returning
the resulting packet. The new space is uninitialized. The result may
share data with other packets. If this packet's tailroom is bigger than
@var{amt}, then this operation is cheap, amounting to a bit of pointer
arithmetic. Otherwise, it requires copying the packet data and possibly
creating a new packet header.

Do not use, manipulate, or free a @code{Packet} after calling its
@code{nonunique_put} method. Manipulate the returned @w{@code{Packet *}}
instead.

The result may be a null pointer if there was not enough memory to make a
required new packet. In this case, the old packet is freed.
@end deftypemethod


@node Annotations, Packet Out-of-Memory, Packet Buffer Manipulation, Packets
@section Annotations

Each packet header has space for a number of @dfn{annotations}, extra
information about the packet that is not contained in its data. Click
supports @dfn{header annotations}, which indicate where in the packet a
network header, such as an IP header, is located; @dfn{user
annotations}, whose semantics are left undefined by Click---different
elements can treat them in different ways; and other specialized
annotations, such as the @dfn{timestamp annotation}, the
@dfn{destination IP address annotation}, and so forth.

New packets begin with all annotations cleared: numeric annotations are
zero, pointer annotations are null pointers. @code{clone},
@code{uniqueify}, and their equivalents always copy each of the original
packet's annotations in the appropriate way. (For example, the new
header annotations will point into the new data, if a data copy was
made.)

@menu
* Header Annotations::          
* User Annotations::            
* Specific User Annotations::   
* Other Annotations::           
* Annotations In General::      
@end menu

@node Header Annotations, User Annotations, Annotations, Annotations
@subsection Header Annotations

Many packets contain a network header of some kind, such as an IP
header. This header may be located anywhere in the packet depending on
how the packet was encapsulated. Furthermore, the data encapsulated by
that network header may be located anywhere after the network header,
given the presence of options. With the @dfn{network header annotation}
and the @dfn{transport header annotation}, one element can determine
where a network header is and how long it is, then store this
information for other elements to use. For example, the
@click{CheckIPHeader} element sets the header annotations on packets it
receives. Elements like @click{SetIPDSCP} then require a non-null IP
header annotation on their input packets.

The header annotations on new packets are each set to a null pointer.

@deftypemethod Packet {const unsigned char *} network_header () const
@deftypemethodx WritablePacket {unsigned char *} network_header () const
Returns the network header annotation. The resulting pointer is
read-only on @code{Packet}s and read/write on @code{WritablePacket}s.
@end deftypemethod

@deftypemethod Packet {const unsigned char *} transport_header () const
@deftypemethodx WritablePacket {unsigned char *} transport_header () const
Returns the transport header annotation. The resulting pointer is
read-only on @code{Packet}s and read/write on @code{WritablePacket}s.
@end deftypemethod

@deftypemethod Packet int network_header_offset () const
Returns the offset from @code{data()} to @code{network_header()}. The
result might be negative, since the @code{data} pointer may have been
advanced past the network header annotation with the @code{pull} method.
@end deftypemethod

@deftypemethod Packet int network_header_length () const
Returns the network header's length. This equals
@code{transport_header()} @minus{} @code{network_header()}.
@end deftypemethod

@deftypemethod Packet unsigned transport_header_offset () const
Returns the offset from @code{data()} to @code{transport_header()}. The
result might be negative, since the @code{data} pointer may have been
advanced past the transport header annotation with the @code{pull} method.
@end deftypemethod

Several invariants relate these methods' values whenever the header
annotations are non-null:

@display
@code{buffer_data()} @math{@leq} @code{network_header()} @math{@leq} @code{transport_header()}
             @math{@leq} @code{buffer_data()} @math{+} @code{buffer_length()}
@code{network_header_offset()} @math{=} @code{network_header()} @minus{} @code{data()}
@code{transport_header_offset()} @math{=} @code{transport_header()} @minus{} @code{data()}
@code{network_header_length()} @math{=} @code{transport_header()} @minus{} @code{network_header()}
@end display

@sp 1

Set the network and transport header annotations simultaneously with the
@code{set_network_header} method.

@deftypemethod Packet void set_network_header (@w{const unsigned char *@var{header}}, @w{unsigned @var{len}})
Sets the network header annotation to @var{header}, which must lie
between @code{buffer_data()} and @code{buffer_data()} @math{+}
@code{buffer_length()}. The network header is @var{len} bytes long, so
@code{network_header_length()} will equal @var{len} and
@code{transport_header()} will equal @var{header} @math{+} @var{len}.
@end deftypemethod

@subsubsection Typed Header Annotations

For convenience, @code{Packet} provides methods for accessing and
setting the network header annotation as an IP or IPv6 header. These
methods use the same annotations as the generic @code{network_header}
methods; they are just typed differently.

@deftypemethod Packet {const click_ip *} ip_header () const
@deftypemethodx WritablePacket {click_ip *} ip_header () const
@deftypemethodx Packet {const click_ip6 *} ip6_header () const
@deftypemethodx WritablePacket {click_ip6 *} ip6_header () const
Returns @code{network_header()} as a pointer to an IP or IPv6 header
structure.
@end deftypemethod

@deftypemethod Packet int ip_header_offset () const
@deftypemethodx Packet unsigned ip_header_length () const
@deftypemethodx Packet int ip6_header_offset () const
@deftypemethodx Packet unsigned ip6_header_length () const
Equivalent to @code{network_header_offset()} and
@code{network_header_length()}.
@end deftypemethod

@deftypemethod Packet void set_ip_header (@w{const click_ip *@var{header}}, @w{unsigned @var{len}})
@deftypemethodx Packet void set_ip6_header (@w{const click_ip6 *@var{header}}, @w{unsigned @var{len}})
Equivalent to @code{set_network_header(@var{header}, @var{len})}.
@end deftypemethod

@deftypemethod Packet void set_ip6_header (@w{const click_ip6 *@var{header}})
Equivalent to @code{set_ip6_header(@var{header}, 40)}.
@end deftypemethod

@deftypemethod Packet {const click_tcp *} tcp_header () const
@deftypemethodx WritablePacket {click_tcp *} tcp_header () const
@deftypemethodx Packet {const click_udp *} udp_header () const
@deftypemethodx WritablePacket {click_udp *} udp_header () const
Returns @code{transport_header()} as a pointer to a TCP or UDP header
structure.
@end deftypemethod


@node User Annotations, Specific User Annotations, Header Annotations, Annotations
@subsection User Annotations

Each packet header has a @dfn{user annotation area}, space reserved for
arbitrary annotations. Different methods access this space as an array
of bytes, integers, or unsigned integers. The @code{Packet} class does
not assign semantics to any particular byte in the user annotation area.
Instead, macros in @w{@samp{<click/packet_anno.hh>}} provide names for
particular bytes. Some of these names have overlapping byte ranges; the
user must take care not to define a configuration whose elements use an
annotation byte on a packet for different purposes. The next section
describes the macros in Click's default
@w{@samp{<click/packet_anno.hh>}}.

These constants define the size of the annotation area.

@table @code
@item Packet::USER_ANNO_SIZE
The size of the annotation area in bytes.
@item Packet::USER_ANNO_US_SIZE
The size of the annotation area in @code{unsigned short}s.
@item Packet::USER_ANNO_S_SIZE
The size of the annotation area in @code{short}s.
@item Packet::USER_ANNO_U_SIZE
The size of the annotation area in @code{unsigned int}s.
@item Packet::USER_ANNO_I_SIZE
The size of the annotation area in @code{int}s.
@end table

@noindent
Currently, @code{USER_ANNO_SIZE} is 24, @code{USER_ANNO_U_SIZE} and
@code{USER_ANNO_I_SIZE} are both 6, and @code{USER_ANNO_US_SIZE} and
@code{USER_ANNO_S_SIZE} are both 12.

The user annotation area may be accessed as an array of bytes, an array
of @code{unsigned int}s, or an array of @code{int}s. The elements of
these arrays are numbered from 0 to @math{@var{k} - 1}, where @var{k} is
the appropriate @code{SIZE} constant.

@deftypemethod Packet {unsigned char} user_anno_c (@w{int @var{i}}) const
Returns the @var{i}th byte in the user annotation area. @var{i} must be
between 0 and @code{USER_ANNO_SIZE} @minus{} 1.
@end deftypemethod

@deftypemethod Packet unsigned user_anno_u (@w{int @var{i}})
@deftypemethodx Packet int user_anno_i (@w{int @var{i}})
Returns the @var{i}th @code{unsigned int} or @code{int} in the user
annotation area. @var{i} must be between 0 and @code{USER_ANNO_U_SIZE}
@minus{} 1. The @var{i}th @code{unsigned int} or @code{int} annotation
occupies bytes @math{4@var{i}} through @math{4@var{i} + 3} of the user
annotation area.
@end deftypemethod

@deftypemethod Packet void set_user_anno_c (@w{int @var{i}}, @w{unsigned char @var{value}})
@deftypemethodx Packet void set_user_anno_u (@w{int @var{i}}, @w{unsigned @var{value}})
@deftypemethodx Packet void set_user_anno_i (@w{int @var{i}}, @w{int @var{value}})
Sets the @var{i}th byte, @code{unsigned int}, or @code{int} user
annotation to @var{value}.
@end deftypemethod

@deftypemethod Packet {unsigned *} all_user_anno_u ()
Returns a pointer to the user annotation area, treated as an array of
@code{unsigned int}s.
@end deftypemethod


@node Specific User Annotations, Other Annotations, User Annotations, Annotations
@subsection Specific User Annotations

The @w{@samp{<click/packet_anno.hh>}} header file defines macros for
accessing a packet's user annotation area by name. These macros follow
some simple guidelines. Each user annotation is given a name like
@samp{PAINT} or @samp{FIX_IP_SRC}. Then, two macros are written for each
annotation, @code{@var{name}_ANNO} and @code{SET_@var{name}_ANNO}.

@deftypefn {Macro} {} {@var{name}_ANNO} (@w{const Packet *@var{p}})
Returns the value of @var{p}'s @var{name} annotation.
@end deftypefn

@deftypefn {Macro} {} {SET_@var{name}_ANNO} (@w{Packet *@var{p}}, @var{value})
Sets @var{p}'s @var{name} annotation to @var{value}.
@end deftypefn

@noindent
For example, here are the definitions of @code{PAINT_ANNO} and
@code{SET_PAINT_ANNO} from Click's default
@samp{<click/packet_anno.hh>}.

@example
#define PAINT_ANNO(p)          ((p)->user_anno_c(0))
#define SET_PAINT_ANNO(p, v)   ((p)->set_user_anno_c(0, (v)))
@end example

@sp 1

This table lists the annotations declared in Click's default
@samp{<click/packet_anno.hh>}.

@multitable {@code{ICMP_PARAM_PROB}} {@code{unsigned char}} {Bytes} {Blah,blah,blah,blah,blah,blah,blah,blah}
@item Annotation name
@tab Type
@tab Bytes
@tab Some relevant elements
@item @code{PAINT}
@tab @code{unsigned char}
@tab 0
@tab @click{Paint}, @click{CheckPaint}, @click{PaintTee}
@item @code{ICMP_PARAM_PROB}
@tab @code{unsigned char}
@tab 1
@tab @click{IPGWOptions}, @click{ICMPError}
@item @code{FIX_IP_SRC}
@tab @code{unsigned char}
@tab 3
@tab @click{ICMPError}, @click{FixIPSrc}
@item @code{FWD_RATE}
@tab @code{int}
@tab 4--7
@tab @click{IPRateMonitor}
@item @code{REV_RATE}
@tab @code{int}
@tab 8--11
@tab @click{IPRateMonitor}
@end multitable


@node Other Annotations, Annotations In General, Specific User Annotations, Annotations
@subsection Other Annotations

Packet headers have space for four other particular annotations, and
special methods for accessing them. These annotations do not overlap the
user annotation area. There are annotations that hold a destination IP
address, a timestamp, the device on which the packet arrived, a packet
type constant, and, in the Linux kernel module, a performance counter
value.

@menu
* Destination Address Annotation::  
* Timestamp Annotation::        
* Device Annotation::           
* Packet Type Annotation::      
* Performance Counter Annotation::  
@end menu

@node Destination Address Annotation, Timestamp Annotation, Other Annotations, Other Annotations
@subsubsection Destination Address

The destination address annotation stores the IP or IPv6 address of the
next hop towards the packet's destination. Elements check and manipulate
this address, rather than the IP header's destination address, since the
next-hop address often differs from the final destination. The
destination IP address and IPv6 address are different annotations, but
they overlap; you may set only one at a time.

@deftypemethod Packet IPAddress dst_ip_anno () const
Returns this packet's destination IP address annotation.
@end deftypemethod

@deftypemethod Packet {const IP6Address &} dst_ip6_anno () const
Returns a reference to this packet's destination IPv6 address
annotation.
@end deftypemethod

@deftypemethod Packet void set_dst_ip_anno (@w{IPAddress @var{value}})
@deftypemethodx Packet void set_dst_ip6_anno (@w{const IP6Address &@var{value}})
Sets this packet's destination IP or IPv6 address annotation to
@var{value}.
@end deftypemethod

The destination IP address annotation is set by the @click{GetIPAddress}
and @click{SetIPAddress} elements, manipulated by @click{LookupIPRoute}
and its cousins, and used by @click{ARPQuerier}. It defaults to zero.

@node Timestamp Annotation, Device Annotation, Destination Address Annotation, Other Annotations
@subsubsection Timestamp

The timestamp annotation generally indicates when a packet was received.

@deftypemethod Packet {const struct timeval &} timestamp_anno () const
@deftypemethodx Packet {struct timeval &} timestamp_anno ()
Returns a reference to this packet's timestamp annotation.
@end deftypemethod

@deftypemethod Packet void set_timestamp_anno (@w{const struct timeval &@var{value}})
Sets this packet's timestamp annotation to @var{value}.
@end deftypemethod

@deftypemethod Packet void set_timestamp_anno (@w{int @var{sec}}, @w{int @var{usec}})
Sets this packet's timestamp annotation to @var{sec} and @var{usec}.
Equivalent to @code{struct timeval tv; tv.tv_sec = @var{sec}; tv.tv_usec
= @var{usec}; set_timestamp_anno(tv)}.
@end deftypemethod

Linux device drivers set this annotation, so packets emitted by
@click{FromDevice} and @click{PollDevice} in the Linux kernel driver
have the annotation set. Packet sources like @click{InfiniteSource} and
@click{RatedSource} also set the annotation, as does @click{FromDump} in
the user-level driver. Debugging elements like @click{Print} generally
take a keyword argument that makes them print packet timestamps.

The timestamp annotation defaults to zero.

@node Device Annotation, Packet Type Annotation, Timestamp Annotation, Other Annotations
@subsubsection Device

In the Linux kernel, packets received from some device are annotated
with a pointer to the relevant @code{struct net_device} object. (In
versions of the kernel prior to 2.3, this type was called @code{struct
device}.) The @code{Packet} class provides access to this annotation.
The annotation has type @w{@code{net_device *}}; Click defines
@code{net_device} as a synonym for @code{struct device} in kernel
versions 2.2 and prior.

@deftypemethod Packet {net_device *} device_anno () const
Returns this packet's device annotation.
@end deftypemethod

@deftypemethod Packet void set_device_anno (@w{net_device *@var{value}})
Sets this packet's device annotation to @var{value}.
@end deftypemethod

@noindent
In the user-level driver, @code{device_anno} always returns 0, and
@code{set_device_anno} does nothing.

The @click{ARPResponder} element sets this annotation on every generated
response to the value of the annotation on the relevant query. Because
of this, those responses can be safely forwarded to Linux: Linux's
ARP-response code requires a correct device annotation.

The device annotation defaults to a null pointer.

@node Packet Type Annotation, Performance Counter Annotation, Device Annotation, Other Annotations
@subsubsection Packet Type

The packet type annotation specifies how a packet was received. Its
value is one of the following constants, which are defined in the
@code{Packet::PacketType} enumeration.

@table @asis
@item @samp{HOST}
The packet was sent to this host.

@item @samp{BROADCAST}
The packet was sent to a link-level broadcast address.

@item @samp{MULTICAST}
The packet was sent to a link-level multicast address.

@item @samp{OTHERHOST}
The packet was sent to a different host, but received anyway. The
relevant device is probably in promiscuous mode.

@item @samp{OUTGOING}
The packet was generated at this host and is being sent to another host.

@item @samp{LOOPBACK}, @samp{FASTROUTE}
See the Linux kernel documentation. These values correspond to
@samp{PACKET_LOOPBACK} and @samp{PACKET_FASTROUTE}, which are defined in
@samp{<linux/if_packet.h>}.
@end table

@deftypemethod Packet {Packet::PacketType} packet_type_anno () const
Returns this packet's packet type annotation.
@end deftypemethod

@deftypemethod Packet void set_packet_type_anno (@w{Packet::PacketType @var{value}})
Sets this packet's packet type annotation to @var{value}.
@end deftypemethod

In the Linux kernel, device drivers set the packet type annotation for
the packets they receive. Thus, the @click{FromDevice} and
@click{PollDevice} elements generate packets with correct packet type
annotations. The user-level driver's @click{FromDevice} also sets the
packet type annotation. The @click{ICMPError} and @click{DropBroadcasts}
elements use the annotation's value.

The packet type annotation defaults to @code{Packet::HOST}.

@node Performance Counter Annotation,  , Packet Type Annotation, Other Annotations
@subsubsection Performance Counter

This annotation is available only in the Linux kernel driver. Its value
is an @code{unsigned long long} that generally corresponds to some
performance counter value.

@deftypemethod Packet {unsigned long long} perfctr_anno () const
Returns this packet's performance counter annotation.
@end deftypemethod

@deftypemethod Packet void set_perfctr_anno (@w{unsigned long long @var{value}})
Sets this packet's performance counter annotation to @var{value}.
@end deftypemethod

The @click{SetCycleCount}, @click{SetPerfCount},
@click{CycleCountAccum}, and @click{PerfCountAccum} elements manipulate
this annotation. Its default value is zero.


@node Annotations In General,  , Other Annotations, Annotations
@subsection Annotations In General

@code{Packet} provides methods for clearing a packet's annotations, and
for copying all of a packet's annotations from another packet.

@deftypemethod Packet void clear_annotations ()
Clears all of this packet's annotations to their default state, which is
generally zero.
@end deftypemethod

@deftypemethod Packet void copy_annotations (const Packet *@var{p})
Copies all of @var{p}'s annotations into this packet except for its
header annotations. (This packet's current header annotations are left
unchanged.)
@end deftypemethod


@node Packet Out-of-Memory,  , Annotations, Packets
@section Out-of-Memory Conditions

Any method that potentially allocates memory for a @code{Packet} may
fail due to an out-of-memory condition. The complete list of these
methods follows:

@itemize @bullet
@item @code{make} variants
@item @code{clone}
@item @code{uniqueify}
@item @code{push}
@item @code{put}
@item @code{nonunique_push}
@item @code{nonunique_put}
@end itemize

@noindent
These methods always return a null pointer on out-of-memory. Methods
that manipulate existing packets---@code{uniqueify}, @code{push},
@code{put}, @code{nonunique_push}, and
@code{nonunique_put}---additionally free any existing packet before
returning a null pointer. You should always check the results of these
methods to see if you have run out of memory.


@node Element Characteristics, Element Initialization, Packets, Top
@chapter Element Characteristics

See the Doxygen documentation on class @code{Element} for information
on element characteristics.

@node Element Initialization, Element Runtime, Element Characteristics, Top
@chapter Element Initialization

See the Doxygen documentation on class @code{Element} for information
on element initialization.


@node Element Runtime, Configuration Strings, Element Initialization, Top
@chapter Element Runtime

See the Doxygen documentation on class @code{Element} for information
on moving packets, handling packets, running tasks.

@menu
* Handling Packets::            
* Handlers::                    
@end menu


@node Handling Packets, Handlers, Element Runtime, Element Runtime
@section Handling Packets

Every @code{Packet} object should be single-threaded through Click: the
same @code{Packet} pointer should never be in use in two different
places. In particular, an element should not use a @code{Packet} after
passing it downstream to the rest of the configuration (by calling
@code{output().push}, for example).

This, for example, is the wrong way to write a @click{Tee} with two
outputs.

@example
void
BadTee::push(int, Packet *p)
@{
    output(0).push(p);
    output(1).push(p);
@}
@end example

@noindent
The same packet pointer, @code{p}, has been pushed to two different
outputs. This is always illegal; the rest of the configuration may have
modified or even freed the packet before returning control to
@code{BadTee}. The correct definition uses the @code{clone} method:

@example
void
GoodTee::push(int, Packet *p)
@{
    output(0).push(p->clone());
    output(1).push(p);
@}
@end example

Every @code{push} or @code{pull} method must account for every packet it
receives by freeing it, emitting it on some output, or perhaps
explicitly storing it for later. This @code{push} method, for example,
contains a memory leak:

@example
void
Leaky::push(int, Packet *p)
@{
    const click_ip *iph = p->ip_header();
    // @r{@dots{} more processing @dots{}}
    _counter++;
    return;  // XXX @r{Oops!}
    // @r{Must push the packet on, store it, or kill it before returning.}
@}
@end example


@node Handlers,  , Handling Packets, Element Runtime
@section Handlers

@dfn{Handlers} are access points through which users can interact with
elements in a running Click router, or with the router as a whole.
@dfn{Read} and @dfn{write handlers} behave like files in a file system,
while @dfn{LLRPCs} provide a remote procedure call interface.

@menu
* Read and Write Handler Overview::  
* Adding Handlers::             
* Default Handlers::            
* Accessing Handlers Internally::  
* LLRPC Overview::              
@end menu


@node Read and Write Handler Overview, Adding Handlers, Handlers, Handlers
@subsection Read and Write Handler Overview

Read and write handlers appear to the user like files in a file system,
or alternatively, like a limited RPC mechanism that uses ASCII strings
for data transfer. To the element programmer, a read handler is simply a
function that takes an element and returns a String; a write handler is
a function that takes an element and a String and returns an error code.

@deftypefn {Function Type} String {(*ReadHandler)} (@w{Element *@var{element}}, @w{void *@var{thunk}})
Read handler functions have this type. When the user accesses a read
handler on an element, Click calls some @code{ReadHandler} function
and passes the element as an argument. The @var{thunk} argument
contains callback data specified when the handler was added. The
function's String return value is passed back to the user.
@end deftypefn

@deftypefn {Function Type} int {(*WriteHandler)} (@w{const String &@var{data}}, @w{Element *@var{element}}, @w{void *@var{thunk}}, @w{ErrorHandler *@var{errh}})
Write handler functions have this type. When the user accesses some
element write handler by passing in a string, Click calls some
@code{WriteHandler} function and passes the data and the relevant
element as arguments. The @var{thunk} argument contains callback data
specified when the handler was added. The return value is an error
code: zero when there are no errors, and the negative of some
@code{errno} value when there is an error. More detailed information
about any errors should be reported to the @var{errh} argument.
@end deftypefn

Each handler has an ASCII @dfn{name}. Handler names must be unique
within each element; for example, there can be at most one @samp{x} read
handler in a given element. A given name can be shared by a read handler
and a write handler, however. Such a handler pair is colloquially called
a ``read/write handler'', although its two components need not have
anything to do with one another.

There is currently no way to pass data to a read handler or return data
from a write handler. Use LLRPCs if you need a more RPC-like read-write
interface.

Note that read and write handler functions are regular functions, not
virtual functions. Often, therefore, handler functions are defined as
private static member functions in the relevant element class.

Read and write handlers need not use ASCII-formatted data. Most existing
handlers do format their data in ASCII, however, and use
@code{cp_uncomment} to ignore leading and trailing whitespace and
comments (@pxref{Quoting and Unquoting}). You may want to do the same
for consistency's sake.

Be careful when writing handlers that modify element state, or read
state that packet processing can modify. On an SMP machine, a handler
may be called on one processor while packets are passing through the
router on another processor. Furthermore, multiple read handlers and
safe LLRPCs (@pxref{LLRPC Overview}) may be active simultaneously on
different processors. Write handlers are serialized with respect to
other handlers and LLRPCs (but not packet processing). That is, no other
handler or LLRPC will proceed while a write handler is active.


@node Adding Handlers, Default Handlers, Read and Write Handler Overview, Handlers
@subsection Adding Handlers

Use @code{Element}'s @code{add_read_handler} and
@code{add_write_handler} methods to add handlers for an element. You
will generally call these methods only from within your element's
@code{add_handlers} method, although nothing prevents you from adding
handlers at any time.

@deftypemethod Element void add_read_handler (@w{const String &@var{name}}, @w{ReadHandler @var{func}}, @w{void *@var{thunk}})
Adds a read handler named @var{name} for this element. When the handler
is accessed, @var{func} will be called with @code{this} and @var{thunk}
as parameters.
@end deftypemethod

@deftypemethod Element void add_write_handler (@w{const String &@var{name}}, @w{WriteHandler @var{func}}, @w{void *@var{thunk}})
Adds a write handler named @var{name} for this element. When the handler
is accessed, @var{func} will be called with the relevant data,
@code{this}, @var{thunk}, and an @code{ErrorHandler} as parameters.
@end deftypemethod

To create a read/write handler, call @code{add_read_handler} and
@code{add_write_handler} and supply the same handler name.

These methods simply forward their requests to static
@code{add_read_handler} and @code{add_write_handler} methods on the
@code{Router} class. Call those methods directly to add handlers to
other elements, or to add global handlers.

@deftypeop {Static Method} Router void add_read_handler (@w{const Element *@var{element}}, @w{const String &@var{name}}, @w{ReadHandler @var{func}}, @w{void *@var{thunk}})
@deftypeopx {Static Method} Router void add_write_handler (@w{const Element *@var{element}}, @w{const String &@var{name}}, @w{WriteHandler @var{func}}, @w{void *@var{thunk}})
Adds a read or write handler for @var{element}, or a global read or
write handler if @var{element} is null. The handler is named
@var{name}.
@end deftypeop

The @code{change_handler_flags} method lets you change a handler's flags
word (@pxref{Handler Objects}).

@anchor{Changing Handler Flags}
@deftypeop {Static Method} Router void change_handler_flags (@w{Element *@var{element}}, @w{const String &@var{name}}, @w{uint32_t @var{clear_flags}}, @w{uint32_t @var{set_flags}})
Changes the flags for @var{element}'s @var{name} handler, or the global
@var{name} handler if @var{element} is null. The flags are changed by
first clearing the bits set in @var{clear_flags}, then setting the bits
set in @var{set_flags}. This method fails and returns @math{-1} when the
specified handler does not exist; otherwise, it returns 0.
@end deftypeop


@node Default Handlers, Accessing Handlers Internally, Adding Handlers, Handlers
@subsection Default Read and Write Handlers

Every element automatically provides five handlers, @handler{class},
@handler{name}, @handler{config}, @handler{ports}, and
@handler{handlers}. There is no need to add these handlers yourself. The
default handlers behave as follows:

@table @asis
@item @handler{class}
Returns the element's class name, as returned by @code{class_name()},
followed by a newline. Example result: @strcode{"ARPQuerier\n"}.

@item @handler{name}
Returns the element's name, as returned by @code{id()}, followed by a
newline. Example result: @strcode{"arpq_0\n"}.

@item @handler{config}
Returns the element's configuration string. If the configuration string
does not end in newline, the hander appends a newline itself. Example
result: @strcode{"18.26.7.1, 00:00:C0:4F:71:EF\n"}.

If @code{can_live_reconfigure} returns true, @handler{config} is also a
write handler, and writing to it reconfigures the element.

@item @handler{ports}
Returns a multi-line string describing the element's ports and what they
are connected to. The string has the form

@example
@var{M} input[s]
@r{@dots{} @var{M} input port descriptions, one per line @dots{}}
@var{N} output[s]
@r{@dots{} @var{N} output port descriptions, one per line @dots{}}
@end example

@noindent
Each port description lists the port's processing type, a dash, and then
a comma-separated list of all the ports to which this port is connected.
The processing type is either @samp{push} or @samp{pull}; formerly
agnostic ports are indicated by a trailing tilde (@samp{push~} or
@samp{pull~}). Example result:

@example
1 input
push~   -       Strip@@2 [0]
2 outputs
push~   -       [0] GetIPAddress@@4
push    -       [0] Print@@7
@end example

@noindent
If Click was compiled with statistics collection enabled, the dash on
each line is replaced by a packet count.

@item @handler{handlers}
Returns a string listing the element's visible handlers, one per line.
Each line contains the handler name, a tab, and then either @samp{r},
@samp{w}, or @samp{rw}, depending on whether the handler is read-only,
write-only, or read/write. Example result for an @click{InfiniteSource}
element, which has many handlers:

@example
scheduled       r
tickets r
reset   w
count   r
active  rw
burstsize       rw
limit   rw
data    rw
handlers        r
ports   r
config  rw
name    r
class   r
@end example
@end table


@node Accessing Handlers Internally, LLRPC Overview, Default Handlers, Handlers
@subsection Accessing Handlers Internally

Element handlers are stored in the relevant @code{Router} as objects
of type @code{Router::Handler}. (This design allows handler objects to
be shared between elements when possible.) Handlers are often referred
to by index; indexes between 0 and @code{Router::FIRST_GLOBAL_HANDLER
@minus{} 1} refer to element handlers, while indexes above
@code{Router::FIRST_GLOBAL_HANDLER} refer to global handlers. Indexes
less than 0 are used for error returns, such as nonexistent handlers.
@code{Router} methods translate between handler indexes and
@code{Router::Handler} objects, and find handlers or handler indexes
given handler names.

@menu
* Handler Objects::             
* Handlers By Name or Index::   
@end menu

@node Handler Objects, Handlers By Name or Index, Accessing Handlers Internally, Accessing Handlers Internally
@subsubsection The Router::Handler Type

The @code{Router::Handler} type allows you to check a handler's
properties and call the handler. All of its methods are @code{const};
you must go through @code{Router} to change a handler's properties.
@code{Router::Handler} objects do not contain element references, since
they are shared among elements. That means you can't easily find the
element (if any) to which a particular @code{Router::Handler} is
attached.

@deftypemethod Router::Handler {const String &} name () const
Returns the handler's name.
@end deftypemethod

@deftypemethod Router::Handler uint32_t flags () const
Returns the handler's flags as an integer. The lower bits of the flags
word are reserved for the system, and four bits are reserved for
drivers, but the upper bits (at least 16) are left uninterpreted, and
may be used by elements. The first user flag bit is called
@code{Router::Handler::USER_FLAG_0}; its position in the word equals
@code{Router::Handler::USER_FLAG_SHIFT}. To change a handler's flags,
use the @code{Router::change_handler_flags} method (@pxref{Changing
Handler Flags}).
@end deftypemethod

@deftypemethod Router::Handler bool readable () const
Returns true iff this handler is readable.
@end deftypemethod

@deftypemethod Router::Handler bool read_visible () const
Returns true iff this handler is readable, and that read handler should
be externally visible. Drivers and the ControlSocket element use
@code{read_visible} rather than @code{readable} when deciding whether to
tell the user that a read handler exists. Inter-element communication
within the router, however, may use @code{readable} rather than
@code{read_visible}.
@end deftypemethod

@deftypemethod Router::Handler bool writable () const
@deftypemethodx Router::Handler bool write_visible () const
The analogous methods for write handlers.
@end deftypemethod

@deftypemethod Router::Handler bool visible () const
Equivalent to @code{read_visible() || write_visible()}.
@end deftypemethod

@deftypemethod Router::Handler String unparse_name (@w{Element *@var{element}}) const
Returns the handler's name, including its attached element's name if
@var{element} is non-null. For example, calling @code{unparse_name} on
element @samp{e}'s @samp{foo} handler would return @samp{e.foo}, while
calling it on a global @samp{bar} handler would return @samp{bar}.
@end deftypemethod

@deftypeop {Static Method} Router::Handler String unparse_name (@w{Element *@var{element}}, @w{const String &@var{name}})
Returns a string representing @var{element}'s hypothetical @var{name}
handler, or the global @var{name} handler if @var{element} is null.
@end deftypeop

@deftypemethod Router::Handler String call_read (@w{Element *@var{element}}) const
Calls this read handler on @var{element} and returns the result. Do not
use this method unless you know the handler is @code{readable()}.
@end deftypemethod

@deftypemethod Router::Handler int call_write (@w{const String &@var{data}}, @w{Element *@var{element}}, @w{ErrorHandler *@var{errh}}) const
Calls this write handler on @var{element}, passing it @var{data} and
@var{errh}, and returns the result. Do not use this method unless you
know the handler is @code{writable()}.
@end deftypemethod


@node Handlers By Name or Index,  , Handler Objects, Accessing Handlers Internally
@subsubsection Handlers By Name or Index

These @code{Router} methods locate handlers by name, returning either
a pointer to a handler object or a handler index. The methods are
static to allow access to global handlers outside the context of a
running router.

@deftypeop {Static Method} Router {const Router::Handler *} handler (@w{const Element *@var{element}}, @w{const String &@var{name}})
Returns a pointer to the handler object for @var{element}'s handler
named @var{name}, or null if no such handler exists. @var{Element} may
be null, in which case the method looks for a global handler named
@var{name}.
@end deftypeop

@quotation
@strong{Caution}: Handler pointers returned by @code{Router::handler}
and similar methods should be treated as transient, since they may
become invalid when new handlers are added.
@end quotation

@deftypeop {Static Method} Router int hindex (@w{const Element *@var{element}}, @w{const String &@var{name}})
Like @code{Router::handler}, above, but returns an integer handler
index for the named handler, or a negative number if no such handler
exists. All valid handler indexes are nonnegative.
@end deftypeop

@deftypeop {Static Method} Router {const Router::Handler *} handler (@w{const Router *@var{router}}, @w{int @var{hindex}})
Returns @var{router}'s handler object corresponding to @var{hindex},
or a null pointer if @var{hindex} is invalid with respect to
@var{router}. There are three possibilities: (1) @var{hindex}
coresponds to a valid global handler, which is returned. In this case,
@var{router} need not be valid. (2) @var{hindex} corresponds to a
valid local handler in class @var{router}, which is returned. (3)
Otherwise, a null pointer is returned.
@end deftypeop

@deftypeop {Static Method} Router {const Router::Handler *} handler (@w{const Element *@var{element}}, @w{int @var{hindex}})
Convenience function equivalent to
@code{handler(@var{element}->router(), @var{hindex})}. Note that
@var{hindex} need not refer to one of @var{element}'s handlers.
@end deftypeop

@deftypemethod Router {const Router::Handler *} handler (@w{int @var{hindex}}) const
Convenience function equivalent to @code{handler(this, @var{hindex})}.
@end deftypemethod

Finally, the @code{element_hindexes} static method returns all the
handler indices that apply to a given element.

@deftypeop {Static Method} Router void element_hindexes (@w{const Element *@var{element}}, @w{Vector<int> &@var{results}})
Appends to @var{results} all the handler indexes for @var{element}'s
handlers, or all global handlers if @var{element} is null.
@end deftypeop


@node LLRPC Overview,  , Accessing Handlers Internally, Handlers
@subsection LLRPC Overview


@node Configuration Strings, Tasks, Element Runtime, Top
@chapter Configuration Strings

@menu
* Parsing Functions::           
* cp_va::                       
@end menu

@node Parsing Functions, cp_va, Configuration Strings, Configuration Strings
@section Parsing Functions

Click's @dfn{parsing functions} parse strings into various kinds of
data, such as integers, fixed-point real numbers, and IP addresses.
Parsing functions follow some consistent conventions:

@itemize @bullet
@item
Their first argument, @code{const String &@var{str}}, contains the
string to be parsed.

@item
At least one additional argument points to a location where any parsed
result should be stored. These @var{result} arguments have pointer type.

@item
Their return type is @code{bool}.

@item
They return true if and only if parsing succeeds.

@item
The values pointed to by the @var{result} arguments are modified only if
parsing succeeds.

@item
Most parsing functions expect to parse the entire supplied string. Any
extraneous characters, such as trailing whitespace, cause parsing to
fail.

@item
Parsing functions never report errors to any source; they simply return
false when parsing fails.
@end itemize

@menu
* Parsing IPv6 Addresses::      
* Parsing Ethernet Addresses::  
* Parsing Elements::            
* Parsing Handlers::            
* Parsing Miscellaneous::       
@end menu

@node Parsing IPv6 Addresses, Parsing Ethernet Addresses, Parsing Functions, Parsing Functions
@subsection IPv6 Addresses

The @code{cp_ip6_address} functions parse strings into IPv6 addresses.
Related @code{cp_ip6_prefix} functions parse strings into IPv6
address/netmask pairs.

Parsable IPv6 addresses and prefixes take any of the forms described in
@uref{ftp://ftp.ietf.org/rfc/rfc2373.txt,,RFC 2373}, @i{IP Version 6
Addressing Architecture}. A nonabbreviated address consists of eight
colon-separated 16-bit hexadecimal numbers, as in
@samp{1080:0:0:0:8:800:200C:417A}. Strings of zero bits may be
abbreviated with two colons, as in @samp{1080::8:800:200C:417A}, and an
address may end in an embedded IPv4 address, as in @samp{::13.1.68.3}
and @samp{::FFFF:129.144.52.38}. IPv6 prefixes are written in
@samp{@var{address}/@var{prefixlen}} form, like
@samp{12AB:0:0:CD30::/60}. Click also supports
@samp{@var{address}/@var{netmask}} syntax, where @var{netmask} is an
IPv6 address. @var{netmask} must correspond to some contiguous prefix,
however: @samp{12AB:0:0:CD30::/60} and
@samp{12AB:0:0:CD30::/FFFF:FFFF:FFFF:FFF0::} are equivalent, but
@samp{12AB:0:0:CD30::/FFFF::1} is illegal.

Analogously to the @code{cp_ip} functions (@pxref{Parsing IP
Addresses}), the @code{cp_ip6} functions understand
@click{AddressInfo}'s shorthand names for IPv6 addresses, and take
optional @w{@code{Element *@var{context}}} arguments to specify any
router and compound-element context.

@deftypefn {Parsing Function} bool cp_ip6_address (@w{const String &@var{str}}, @w{unsigned char *@var{result}}, @w{Element *@var{context} = 0})
@deftypefnx {Parsing Function} bool cp_ip6_address (@w{const String &@var{str}}, @w{IP6Address *@var{result}}, @w{Element *@var{context} = 0})
Parses @var{str} into an IPv6 address and stores the result in
@code{*@var{result}}. @var{context} supplies any element context.
@end deftypefn

@deftypefn {Parsing Function} bool cp_ip6_prefix (@w{const String &@var{str}}, @w{unsigned char *@var{result_addr}}, @w{int *@var{result_prefix_len}}, @w{bool @var{allow_bare_addr}}, @w{Element *@var{context} = 0})
@deftypefnx {Parsing Function} bool cp_ip6_prefix (@w{const String &@var{str}}, @w{IP6Address *@var{result_addr}}, @w{int *@var{result_prefix_len}}, @w{bool @var{allow_bare_addr}}, @w{Element *@var{context} = 0})
Parse @var{str} into an IPv6 address/prefix length pair and stores the
resulting address in @code{*@var{result_addr}}, and the resulting prefix
length in @code{*@var{result_prefix_len}}. Bare addresses, such as
@samp{1080::8:800:200C:417A}, are allowed if and only if
@var{allow_bare_addr} is true. The prefix length corresponding to a bare
address is 128.
@end deftypefn

@deftypefn {Parsing Function} bool cp_ip6_prefix (@w{const String &@var{str}}, @w{unsigned char *@var{result_addr}}, @w{unsigned char *@var{result_mask}}, @w{bool @var{allow_bare_addr}}, @w{Element *@var{context} = 0})
@deftypefnx {Parsing Function} bool cp_ip6_prefix (@w{const String &@var{str}}, @w{IP6Address *@var{result_addr}}, @w{IP6Address *@var{result_mask}}, @w{bool @var{allow_bare_addr}}, @w{Element *@var{context} = 0})
Parse @var{str} into an IPv6 address/prefix length pair and stores the
resulting address in @code{*@var{result_addr}}, and the netmask
corresponding to the resulting prefix length in
@code{*@var{result_mask}}. Bare addresses are allowed if and only if
@var{allow_bare_addr} is true.
@end deftypefn


@node Parsing Ethernet Addresses, Parsing Elements, Parsing IPv6 Addresses, Parsing Functions
@subsection Ethernet Addresses

The @code{cp_ethernet_address} functions parse strings into Ethernet
addresses. A parsable Ethernet address consists of six colon-separated
8-bit hexadecimal numbers, as in @samp{0:2:B3:06:36:EE}.

Analogously to the @code{cp_ip} functions (@pxref{Parsing IP
Addresses}), the @code{cp_ethernet_address} functions understand
@click{AddressInfo}'s shorthand names for Ethernet addresses, and take
optional @w{@code{Element *@var{context}}} arguments to specify any
router and compound-element context.

@deftypefn {Parsing Function} bool cp_ethernet_address (@w{const String &@var{str}}, @w{unsigned char *@var{result}}, @w{Element *@var{context} = 0})
@deftypefnx {Parsing Function} bool cp_ethernet_address (@w{const String &@var{str}}, @w{EtherAddress *@var{result}}, @w{Element *@var{context} = 0})
Parses @var{str} into an Ethernet address and stores the result in
@code{*@var{result}}. @var{context} supplies any element context.
@end deftypefn


@node Parsing Elements, Parsing Handlers, Parsing Ethernet Addresses, Parsing Functions
@subsection Elements

@code{cp_element} parses an element name into a pointer to an element in
some router configuration. It differs from other parsing functions in two
important ways. First, it returns its result, or a null pointer on
error; parsing functions store their results in some pointer. Second, it
reports errors to the supplied @code{ErrorHandler}.

The @code{cp_element} function follows lexical scoping rules when called
from a compound element: it will check for components of that compound
element first. For instance, say you've called @code{cp_element} on the
string @samp{e}. Normally, this would check the router for an element
named, simply, @samp{e}. However, if called within a compound element
@samp{x}, @code{cp_element} will first check for an element named
@samp{x/e} before looking for the global @samp{e} element. The function
uses its @var{context} argument, an element pointer, to determine both
the relevant router object and any compound element context.

More explicitly, the @code{cp_element} function uses the following
procedure to search for an element named @var{str}:

@enumerate
@item
Set @var{prefix} to @code{@var{context}->id()}.

@item
Remove the final component of @var{prefix}.

@item
Search for an element named @samp{@var{prefix}@var{str}} in
@code{@var{context}->router()}. If one is found, return it.

@item
Otherwise, no element was found. If @var{prefix} is already empty,
parsing fails; report an error to @var{errh} and return a null pointer.
Otherwise, return to step 2.
@end enumerate

@deftypefn {Function} {Element *} cp_element (@w{const String &@var{str}}, @w{Element *@var{context}}, @w{ErrorHandler *@var{errh}})
Returns a element named @var{str} in @var{context}'s router
configuration. @var{str} is first processed as by @code{cp_unquote}.
@var{context} determines both the relevant router configuration and any
compound element context. Returns a null pointer if no element is found;
if @var{errh} is nonnull and no element is found, additionally reports
an error to @var{errh}.
@end deftypefn

A variant function does not perform a lexically scoped search, so its
@var{str} argument must contain a fully-qualified element name.

@deftypefn {Function} {Element *} cp_element (@w{const String &@var{str}}, @w{Router *@var{router}}, @w{ErrorHandler *@var{errh}})
Returns a element named @var{str} in @var{router}. @var{str} is first
processed as by @code{cp_unquote}. Returns a null pointer if no element
is found; if @var{errh} is nonnull and no element is found, additionally
reports an error to @var{errh}.
@end deftypefn


@node Parsing Handlers, Parsing Miscellaneous, Parsing Elements, Parsing Functions
@subsection Handlers

The @code{cp_handler} functions parse a handler specification, such as
@samp{e.config}, into the relevant pair of element and handler ID.
Unlike most other parsing functions, it can report errors to an
@code{ErrorHandler}, if one is supplied.

Most handler specifications consists of an element name and a handler
name separated by a period: @samp{@var{element}.@var{handler}}. The
simplest @code{cp_handler} function parses such a specification into an
element pointer, corresponding to @var{element}, and the handler name,
@var{handler}. Like @code{cp_element} (@pxref{Parsing Elements}),
@code{cp_handler} uses a lexically-scoped search to find the element
corresponding to a given name.

Click also supports a few global handlers, such as @samp{config}.
@code{cp_handler} will also parse global handler names, returning null
for the element pointer.

@deftypefn {Parsing Function} {bool} cp_handler (@w{const String &@var{str}}, @w{Element *@var{context}}, @w{Element **@var{result_element}}, @w{String *@var{result_hname}}, @w{ErrorHandler *@var{errh}})
Parses @var{str} into a handler specification, storing the resulting
element (if any) in @code{*@var{result_element}} and handler name in
@code{*@var{result_hname}}. @var{str} is first processed as by
@code{cp_unquote}. @var{context} determines both the relevant router
configuration and any compound element context. Returns true if and only
if @var{str} contained a valid handler specification whose element part
named an actual element. Note that this function will not check whether
@code{*@var{result_element}} actually has a handler named
@code{*@var{result_hname}}---or, for global handlers, whether the global
handler @code{*@var{result_hname}} actually exists.
@end deftypefn

The other @code{cp_handler} variants ensure that the input string names
an actual handler. These variants are useless until handlers are added
to the router configuration. Therefore, they should be called in
elements' @code{initialize} methods, not their @code{configure} methods,
since handlers are not added until @code{initialize} time.

@deftypefn {Parsing Function} {bool} cp_handler (@w{const String &@var{str}}, @w{Element *@var{context}}, @w{Element **@var{result_element}}, @w{int *@var{result_hid}}, @w{ErrorHandler *@var{errh}})
Parses @var{str} into a handler specification, storing the resulting
element in @code{*@var{result_element}} and handler ID in
@code{*@var{result_hid}}. This function just calls the simpler
@code{cp_handler}, above, then checks that the resulting element has the
named handler.
@end deftypefn

@deftypefn {Parsing Function} {bool} cp_handler (@w{const String &@var{str}}, @w{Element *@var{context}}, @w{bool @var{need_read}}, @w{bool @var{need_write}}, @w{Element **@var{result_element}}, @w{int *@var{result_hid}}, @w{ErrorHandler *@var{errh}})
Similar, but additionally checks for read and/or write handlers. If
@var{need_read} is true, then @var{str} must name a valid read handler;
if @var{need_write} is true, then @var{str} must name a valid write
handler. Returns false if these checks aren't met.
@end deftypefn


@node Parsing Miscellaneous,  , Parsing Handlers, Parsing Functions
@subsection Miscellaneous

The @code{cp_seconds_as} and @code{cp_timeval} functions parse strings
into time.

@deftypefn {Parsing Function} bool cp_seconds_as (@w{int @var{p}}, @w{const String &@var{str}}, @w{int *@var{result}})
Parses @var{str} as a possibly fractional length of time in seconds. The
returned @var{result} is measured in
@tex
$(@r{seconds} * 10^{-p})$;
@end tex
@ifnottex
@math{(@r{seconds} * 10^-@var{p})};
@end ifnottex
for example, if @var{p} is 3, then @var{result} is measured in
milliseconds, and @code{cp_seconds_as(3, "8", @var{result})} stores 8000
in @code{*@var{result}}. 

@var{Str} may contain an optional time unit suffix. Valid units are
@samp{h} or @samp{hr} for hours, @samp{m}/@samp{min} for minutes,
@samp{s}/@samp{sec} for seconds, @samp{ms}/@samp{msec} for milliseconds,
@samp{us}/@samp{usec} for microseconds, and @samp{ns}/@samp{nsec} for
nanoseconds. For example, @code{cp_seconds_as(0, "1h", @var{result})}
stores 3600 in @code{*@var{result}}.

Negative values are not allowed.
@end deftypefn

@deftypefn {Parsing Function} bool cp_seconds_as_milli (@w{const String &@var{str}}, @w{int *@var{result}})
@deftypefnx {Parsing Function} bool cp_seconds_as_micro (@w{const String &@var{str}}, @w{int *@var{result}})
Same as @code{cp_seconds_as(3, @var{s}, @var{result})} and
@code{cp_seconds_as(6, @var{s}, @var{result})}, respectively.
@end deftypefn

@deftypefn {Parsing Function} bool cp_timeval (@w{const String &@var{str}}, @w{struct timeval *@var{result}})
Parses @var{str} as a @code{struct timeval} representing some number of
seconds and microseconds. Textually, this looks like a nonnegative real
number with 6 decimal digits of fraction. Stores the integer part of the
result in @code{@var{result}->tv_sec} and the fraction part in
@code{@var{result}->tv_usec}. Basically equivalent to
@code{cp_unsigned_real10(@var{str}, 6, 0, &@var{result}->tv_sec,
&@var{result}->tv_usec)}.
@end deftypefn


@node cp_va,  , Parsing Functions, Configuration Strings
@section Parsing Argument Lists

@cindex cp_va

@menu
* cp_va Concepts::              
* cp_va Initialization::        
@end menu

@node cp_va Concepts, cp_va Initialization, cp_va, cp_va
@subsection Concepts

@node cp_va Initialization,  , cp_va Concepts, cp_va
@subsection Global Initialization

The @code{cp_va} functions maintain some private global state---for
example, a list of the data types they understand. You must explicitly
initialize this state with @code{cp_va_static_initialize} before calling
any other @code{cp_va} function. You can free this state, if you'd like,
with @code{cp_va_static_cleanup}.

@deftypefun void cp_va_static_initialize ()
Call this function exactly once, at the beginning of the program, before
calling any other @code{cp_va} functions.
@end deftypefun

@deftypefun void cp_va_static_cleanup ()
Call this function exactly once, at the end of the program. It is an
error to call any @code{cp_va} function after calling
@code{cp_va_static_cleanup}.
@end deftypefun

@multitable @columnfractions .3 .7
@item @strong{Constant}
@tab @strong{Storage Arguments}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpArgument}
@tab @code{String *@var{result}}
@item @code{cpString}
@tab @code{String *@var{result}}
@item @code{cpWord}
@tab @code{String *@var{result}}
@item @code{cpKeyword}
@tab @code{String *@var{result}}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpByte}
@tab @code{unsigned char *@var{result}}
@item @code{cpShort}
@tab @code{short *@var{result}}
@item @code{cpUnsignedShort}
@tab @code{unsigned short *@var{result}}
@item @code{cpInteger}
@tab @code{int *@var{result}}
@item @code{cpUnsigned}
@tab @code{unsigned *@var{result}}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpReal2}
@tab @code{@w{int @var{frac_bits}}, @w{int *@var{result}}}
@item @code{cpUnsignedReal2}
@tab @code{@w{int @var{frac_bits}}, @w{unsigned *@var{result}}}
@item @code{cpReal10}
@tab @code{@w{int @var{frac_digits}}, @w{int *@var{result}}}
@item @code{cpUnsignedReal10}
@tab @code{@w{int @var{frac_digits}}, @w{unsigned *@var{result}}}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpIPAddress}
@tab @code{IPAddress *@var{result}}
@item @code{cpIPPrefix}
@tab @code{@w{IPAddress *@var{result_address}}, @w{IPAddress *@var{result_mask}}}
@item @code{cpIPAddressOrPrefix}
@tab @code{@w{IPAddress *@var{result_address}}, @w{IPAddress *@var{result_mask}}}
@item @code{cpIPAddressList}
@tab @code{@w{IPAddressList *@var{result}}}
@item @code{cpEtherAddress}
@tab @code{@w{EtherAddress *@var{result}}}
@item @code{cpIP6Address}
@tab @code{IP6Address *@var{result}}
@item @code{cpIP6Prefix}
@tab @code{@w{IP6Address *@var{result_address}}, @w{IP6Address *@var{result_mask}}}
@item @code{cpIP6AddressOrPrefix}
@tab @code{@w{IP6Address *@var{result_address}}, @w{IP6Address *@var{result_mask}}}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpElement}
@tab @code{@w{Element **@var{result}}}
@item @code{cpHandlerName}
@tab @code{@w{Element **@var{result_element}},} @code{@w{String
*@var{result_hname}}}
@item @code{cpHandler}
@tab @code{@w{Element **@var{result_element}}, @w{int *@var{result_hid}}}
@item @code{cpReadHandler}
@tab @code{@w{Element **@var{result_element}}, @w{int *@var{result_hid}}}
@item @code{cpWriteHandler}
@tab @code{@w{Element **@var{result_element}}, @w{int *@var{result_hid}}}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpBool}
@tab @code{@w{bool *@var{result}}}
@item @code{cpSeconds}
@tab @code{@w{int *@var{result}}}
@item @code{cpSecondsAsMilli}
@tab @code{@w{int *@var{result}}}
@item @code{cpSecondsAsMicro}
@tab @code{@w{int *@var{result}}}
@item @code{cpTimeval}
@tab @code{@w{struct timeval *@var{result}}}
@end multitable



@multitable @columnfractions .3 .7
@item @strong{Constant}
@tab @strong{Corresponding Parsing Function}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpArgument}
@tab @code{*@var{result} = arg}
@item @code{cpString}
@tab @code{cp_string(arg, @var{result})}
@item @code{cpWord}
@tab @code{cp_string(arg, @var{result})}
@item @code{cpKeyword}
@tab @code{cp_keyword(arg, @var{result})}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpByte}
@tab @code{cp_unsigned(arg, &tmp)}, check range, store in
@var{result}
@item @code{cpShort}
@tab @code{cp_integer(arg, &tmp)}, check range, store in
@var{result}
@item @code{cpUnsignedShort}
@tab @code{cp_unsigned(arg, &tmp)}, check range, store in
@var{result}
@item @code{cpInteger}
@tab @code{cp_integer(arg, @var{result})}
@item @code{cpUnsigned}
@tab @code{cp_unsigned(arg, @var{result})}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpReal2}
@tab @code{cp_real2(arg, @var{frac_bits}, @var{result})}
@item @code{cpUnsignedReal2}
@tab @code{cp_unsigned_real2(arg, @var{frac_bits}, @var{result})}
@item @code{cpReal10}
@tab @code{cp_real10(arg, @var{frac_digits}, @var{result})}
@item @code{cpUnsignedReal10}
@tab @code{cp_unsigned_real10(arg, @var{frac_digits}, @var{result})}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpIPAddress}
@tab @code{cp_ip_address(arg, @var{result}, context)}
@item @code{cpIPPrefix}
@tab @code{cp_ip_prefix(arg, @var{result_address},
@var{result_mask}, false, context)}
@item @code{cpIPAddressOrPrefix}
@tab @code{cp_ip_prefix(arg, @var{result_address},
@var{result_mask}, true, context)}
@item @code{cpIPAddressList}
@tab @code{cp_ip_address_list(arg, @var{result}, context)}
@item @code{cpEtherAddress}
@tab @code{cp_ether_address(arg, @var{result}, context)}
@item @code{cpIP6Address}
@tab @code{cp_ip6_address(arg, @var{result}, context)}
@item @code{cpIP6Prefix}
@tab @code{cp_ip6_prefix(arg, @var{result_address},
@var{result_mask}, false, context)}
@item @code{cpIP6AddressOrPrefix}
@tab @code{cp_ip6_prefix(arg, @var{result_address},
@var{result_mask}, false, context)}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpElement}
@tab @code{cp_element(arg, context, @var{result})}
@item @code{cpHandlerName}
@tab @code{cp_handler(arg, context, @var{result_element},
@var{result_hname})}
@item @code{cpHandler}
@tab @code{cp_handler(arg, context, @var{result_element},
@var{result_hid})}
@item @code{cpReadHandler}
@tab @code{cp_handler(arg, context, true, false, @var{result_element},
@var{result_hid})}
@item @code{cpWriteHandler}
@tab @code{cp_handler(arg, context, false, true, @var{result_element},
@var{result_hid})}
@end multitable

@multitable @columnfractions .3 .7
@item @code{cpBool}
@tab @code{cp_bool(arg, @var{result})}
@item @code{cpSeconds}
@tab @code{cp_seconds_as(0, arg, @var{result})}
@item @code{cpSecondsAsMilli}
@tab @code{cp_seconds_as(3, arg, @var{result})}
@item @code{cpSecondsAsMicro}
@tab @code{cp_seconds_as(6, arg, @var{result})}
@item @code{cpTimeval}
@tab @code{cp_timeval(arg, @var{result})}
@end multitable


@node Tasks, Timers, Configuration Strings, Top
@chapter Tasks

Click schedules a router's CPU or CPUs with one or more @dfn{task
queues}. These queues are simply lists of @dfn{tasks}, which represent
functions that would like access to the CPU. Tasks are generally
associated with elements. When scheduled, most tasks call some element's
@code{run_task} method.

Click tasks are represented by @code{Task} objects. An element that
would like special access to a router's CPU should include and
initialize a @code{Task} instance variable.

Tasks are generally called very frequently, up to tens of thousands of
times per second. For infrequent events, it is far more efficient to use
timers than to use tasks; see @ref{Timers}.

Executing a task should not take a long time. The Click driver loop is
not currently adaptive, so very long tasks can inappropriately delay
timers and other periodic events. We may address this problem in a
future release, but for now, keep tasks short.

See the Doxygen documentation on class @code{Task} for more
information.

The @code{Task} class is defined in the @code{<click/task.hh>} header
file.

@menu
* Task Initialization::         
* Scheduling Tasks::            
* Tickets::                     
* Task Thread Choice::          
* Task Status::                 
* Task Handlers::               
* Task Cleanup::                
@end menu


@node Task Initialization, Scheduling Tasks, Tasks, Tasks
@section Task Initialization

Task initialization is a two-step process. First, when a @code{Task}
object is constructed, you must supply information about the function
that it should call when it is scheduled. Second, when the router is
initialized, you must initialize the task by supplying it with the
relevant router. (You must initialize the task even if it will not be
scheduled right away.)

@code{Task} has two constructors. One of them asks the task to call an
element's @code{run_task} method when scheduled; the other asks it
to call an arbitrary function pointer.

@deftypeop Constructor Task {} Task (Element *@var{e})
When this task is scheduled, call @code{@var{e}->run_task()}.
@end deftypeop

@deftypeop Constructor Task {} Task (TaskHook @var{hook}, void *@var{thunk})
When this task is scheduled, call @code{@var{hook}(this, @var{thunk})}.
The @var{hook} argument is a function pointer with type @code{void
(*)(Task *, void *)}.
@end deftypeop

The @code{Task::initialize} method places the task on a router-wide list
of @code{Task}s, associates the task with a particular task queue, and,
optionally, schedules it. Typically, an element's @code{initialize}
method calls @code{Task::initialize}.

@deftypemethod Task void initialize (Router *@var{r}, bool @var{scheduled})
@deftypemethodx Task void initialize (Element *@var{e}, bool @var{scheduled})
Attaches the task to the router object @var{r} (or
@code{@var{e}->router()}). Additionally sets the task's tickets to a
default value, and schedules the task if @var{scheduled} is true.
@end deftypemethod

Many elements call @code{ScheduleInfo::initialize_task} instead of
calling @code{Task::initialize} directly. This method queries any
@click{ScheduleInfo} elements in the configuration to determine the
task's scheduling parameters, sets those parameters, and calls
@code{Task::initialize} to schedule the task. The
@code{ScheduleInfo::initialize_task} method is defined in the
@code{<click/standard/scheduleinfo.hh>} header file.

@deftypeop {Static Method} ScheduleInfo void initialize_task (Element *@var{e}, @w{Task *@var{task}}, @w{bool @var{schedule}}, @w{ErrorHandler *@var{errh}})
Sets @var{task}'s scheduling parameters as specified by any
@click{ScheduleInfo} elements in the router configuration. The element
@var{e} is used to find the correct router, and provides the relevant
name for parameter lookup---the user supplies parameters to
@click{ScheduleInfo} by element name. If @var{schedule} is true, also
schedules @var{task} on @code{@var{e}->router()}'s task queue. Reports
any errors to @var{errh}.
@end deftypeop

@deftypeop {Static Method} ScheduleInfo void initialize_task (Element *@var{e}, @w{Task *@var{task}}, @w{ErrorHandler *@var{errh}})
A synonym for @code{initialize_task(@var{e}, @var{task}, true,
@var{errh})}.
@end deftypeop

@deftypeop {Static Method} ScheduleInfo void join_scheduler (Element *@var{e}, @w{Task *@var{task}}, @w{ErrorHandler *@var{errh}})
A synonym for @code{initialize_task(@var{e}, @var{task}, true,
@var{errh})}.
@end deftypeop

The @code{initialize_task} method is generally called like this:

@example
int
SomeElement::initialize(ErrorHandler *errh)
@{
    ScheduleInfo::initialize_task(this, &_task, errh);
@}
@end example

@noindent
Here, @code{_task}, a @code{Task} object, is one of @code{SomeElement}'s
instance variables.


@node Scheduling Tasks, Tickets, Task Initialization, Tasks
@section Scheduling Tasks

The user may take a task off its task queue with the @code{unschedule}
method, and place it back onto its task queue with the @code{reschedule}
method. As tasks move to the head of the task queue, they are
unscheduled and their callbacks are called. Within these callback
functions, the user will typically call @code{fast_reschedule}, which is
like @code{reschedule} without the locking overhead.

@deftypemethod Task void unschedule ()
Unschedules the task by removing it from its task queue. Does nothing if
if the task is currently unscheduled, or if it was never initialized.
When this function returns, the task will not be scheduled.
@end deftypemethod

@deftypemethod Task void reschedule ()
Reschedules the task by placing it on its task queue. If the task is
already scheduled, then this method does nothing.
@end deftypemethod

All three functions lock the task queue before manipulating it. This
avoids corruption when there are multiple processors executing
simultaneously. If @code{reschedule} cannot immediately lock a task
queue---perhaps because it is being used on another processor---then
they register a task request, which will be executed in the near
future. In contrast, the @code{unschedule} function will wait until it
can lock the task queue.

Sometimes unscheduling a task is not enough: you don't want the task
to run, even if someone else (an upstream queue, for example) were to
reschedule it. The @code{strong_unschedule} method both unschedules
the task and shifts the task to the quiescent thread, which never
runs. Thus, a @code{strong_unschedule}d task will not run until
someone calls @code{strong_reschedule}, which reschedules the task on
its original preferred thread.

@deftypemethod Task void strong_unschedule ()
Unschedules the task by removing it from its task queue and shifting
it to the quiescent thread. Does nothing if if the task is currently
unscheduled, or if it was never initialized. When this function
returns, the task will not be scheduled.
@end deftypemethod

@deftypemethod Task void strong_reschedule ()
Reschedules the task by placing it on the task queue corresponding to
its thread preference. The task will not be scheduled immediately upon
return, but it will become scheduled soon---@code{strong_reschedule}
uses a task request to avoid locking.
@end deftypemethod

The @code{fast_reschedule} method avoids locking overhead in the common
case that a task must be rescheduled from within its callback.

@deftypemethod Task void fast_reschedule ()
Reschedules the task by placing it on its preferred task queue. This
method avoids locking overhead, so it is faster than @code{reschedule}.

@quotation
@strong{Caution}: You may call a @code{Task}'s @code{fast_reschedule}
method only from within its callback function. For instance, if an
element has a task, @w{@code{_task}}, that calls the element's
@code{run_task} method when scheduled, and if @code{run_task}
is called only by that task's callback, then that element's
@code{run_task} method should call @code{_task.fast_reschedule()}
instead of @code{_task.reschedule()}.
@end quotation
@end deftypemethod

The @code{fast_unschedule} method is to @code{unschedule} as
@code{fast_reschedule} is to @code{reschedule}. It is rarely used,
since tasks are automatically unscheduled before they are run.

@deftypemethod Task void fast_unschedule ()
Unschedules the task by removing it from its task queue. Does nothing if
if the task is currently unscheduled, or if it was never initialized.
This method avoids locking overhead, so it is faster than
@code{unschedule}.

@quotation
@strong{Caution}: You may call a @code{Task}'s @code{fast_unschedule}
method only from within its callback function.
@end quotation
@end deftypemethod


@node Tickets, Task Thread Choice, Scheduling Tasks, Tasks
@section Tickets

Click tasks are scheduled using the flexible, lightweight stride
scheduling algorithm.@footnote{For more information, see MIT Laboratory
for Computer Science Technical Memo MIT/LCS/TM-528, @cite{Stride
scheduling: deterministic proportional-share resource management}, by
Carl A. Waldspurger and William E. Weihl, June 1995.} This algorithm
assigns each task a parameter called its @dfn{tickets}. A task with
twice as many tickets as usual is scheduled twice as frequently.

@code{Task}s have methods for querying, setting, and adjusting their
tickets.

@deftypemethod Task int tickets () const
Returns this task's tickets. This number will be at least 1 and no more
than @code{Task::MAX_TICKETS}, which equals 32768.
@end deftypemethod

@deftypemethod Task void set_tickets (int @var{t})
Sets this task's tickets to @var{t}. The @var{t} parameter should lie
between 1 and @code{Task::MAX_TICKETS}, inclusive; numbers outside this
range are constrained to the nearest valid value.
@end deftypemethod

@deftypemethod Task void adj_tickets (int @var{delta})
Equivalent to @code{set_tickets(tickets() + @var{delta})}.
@end deftypemethod


@node Task Thread Choice, Task Status, Tickets, Tasks
@section Choosing a Thread

Each task belongs to some task queue, which generally corresponds to a
thread of control. Single-threaded Click has one active thread, and
therefore one task queue, but multithreaded Click can have an
arbitrary number of threads. Either Click has a special thread, the
@dfn{quiescent thread}, numbered @math{-1}; tasks belonging to the
quiescent thread never run, whether or not they are scheduled. Every
task starts out belonging to the first thread, @w{thread 0}. The
@code{change_thread} method moves a task to another thread.

@deftypemethod Task void change_thread (int @var{thread_id})
Move this task to thread @var{thread_id}, which should be a number
between @math{-1} and the relevant @code{Router}'s @code{nthreads()}.

The task is scheduled on the new task queue if and only if it was
scheduled on the old task queue.
@end deftypemethod

Like @code{reschedule}, @code{change_thread} must lock the task queue
before manipulating it. (Unlike those methods, @code{change_thread}
must lock two task queues, the old and the new.) If
@code{change_thread} cannot lock a task queue, then it registers a
task request that will be executed in the near future. This implies
that a task may remain on the same thread, or become unscheduled, for
some time after @code{change_thread} is called.


@node Task Status, Task Handlers, Task Thread Choice, Tasks
@section Task Status Methods

These methods let a user check various properties of a task---for
instance, whether it is initialized or scheduled.

@deftypemethod Task bool initialized () const
Returns true iff the task has been initialized---that is, if it is
associated with some router.
@end deftypemethod

@deftypemethod Task bool scheduled () const
Returns true iff the task is currently scheduled on some task queue.
@end deftypemethod

@deftypemethod Task {RouterThread *} scheduled_list () const
Returns the task queue with which this task is associated. Even
unscheduled tasks are associated with some task queue; this is the task
queue on which the task will be placed if @code{reschedule} is called.
@end deftypemethod

@deftypemethod Task TaskHook hook () const
Returns the callback function that is called when the task is scheduled.
If the task is associated with some element, this method returns a null
pointer.
@end deftypemethod

@deftypemethod Task {void *} thunk () const
Returns the extra data passed to the callback function when the task is
scheduled.
@end deftypemethod

@deftypemethod Task {Element *} element () const
If the task is associated with some element, this method returns that
element. Otherwise, returns a null pointer.
@end deftypemethod


@node Task Handlers, Task Cleanup, Task Status, Tasks
@section Task Handlers

By convention, elements with tasks should provide handlers that access
task properties. The @code{Element::add_task_handlers} method
automatically adds these handlers for a given @code{Task} object.

@deftypemethod Element void add_task_handlers (@w{Task *@var{task}}, @w{const String &@var{prefix} = String()})
Adds task handlers for @var{task} to this element. The string
@var{prefix} is prepended to every handler name.
@end deftypemethod

This method adds at least the following handlers:

@table @asis
@item @handler{scheduled}
Returns a Boolean value saying whether the task is currently scheduled
on some task queue. Example result: @strcode{"true\n"}.

@item @handler{tickets}
Returns or sets the task's currently allocated tickets. This handler
is only available if Click was compiled to support stride scheduling.
Example result: @strcode{"1024\n"}.

@item @handler{thread_preference}
Returns the task's thread preference. This handler is only available on
multithreaded Click. Example result: @strcode{"2\n"}.
@end table


@node Task Cleanup,  , Task Handlers, Tasks
@section Task Cleanup

You generally don't need to worry about destroying @code{Task} objects:
they are automatically unscheduled and removed when the @code{Router} is
destroyed. This only works if the @code{Task} objects have the same
lifetime as the @code{Router}, however. This includes the normal case,
when @code{Task}s are element instance variables. If you create and
destroy @code{Task} objects as the router runs, however, you will need
to call the following method before deleting the @code{Task}.

@deftypemethod Task void cleanup ()
Cleans up the @code{Task} object.
@end deftypemethod


@node Timers, Notification, Tasks, Top
@chapter Timers

Click @dfn{timers}, like Click tasks, represent callback functions that
the driver calls when appropriate. Unlike tasks, however, you schedule
timers to go off at a specified time. Timers are intended for more
infrequent and/or slower tasks.

As with @code{Task}, most @code{Timer} objects are declared as instance
variables of elements and scheduled when needed.

Timers may be scheduled with microsecond precision, but on current
hardware, only millisecond precision is likely to be achievable.

The @code{Timer} class is defined in the @code{<click/timer.hh>} header
file.

@menu
* Timer Initialization::        
* Scheduling Timers::           
* Timer Status Methods::        
* Timer Cleanup::               
@end menu


@node Timer Initialization, Scheduling Timers, Timers, Timers
@section Timer Initialization

Timer initialization resembles task initialization. When the timer is
constructed, you must supply it with information about its callback
function. Later, after the router is initialized, you must initialize
and, optionally, schedule it.

@deftypeop Constructor Timer {} Timer (@w{Element *@var{e}})
When this timer goes off, call @code{@var{e}->run_timer()}.
@end deftypeop

@deftypeop Constructor Timer {} Timer (@w{Task *@var{t}})
When this timer goes off, call @code{@var{t}->reschedule()}.
@end deftypeop

@deftypeop Constructor Timer {} Timer (@w{TimerHook @var{hook}}, @w{void *@var{thunk}})
When this timer goes off, call @code{@var{hook}(this, @var{thunk})}. The
@var{hook} argument is a function pointer with type @code{void (*)(Timer
*, void *)}.
@end deftypeop

@deftypemethod Timer void initialize (@w{Router *@var{r}})
@deftypemethodx Timer void initialize (@w{Element *@var{e}})
Attaches the timer to the router object @var{r} (or
@code{@var{e}->router()}).
@end deftypemethod

Typically, an element's @code{initialize} method
calls @code{Timer::initialize}, and possibly one of the @code{schedule}
functions described below.


@node Scheduling Timers, Timer Status Methods, Timer Initialization, Timers
@section Scheduling Timers

A variety of methods schedule timers to go off at specified times. The
basic method is @code{schedule_at}, which schedules the timer for a
specified time. Subsidiary methods schedule the timer relative to the
current time (the @code{schedule_after} methods), or relative to the
last time the timer was scheduled to run (the @code{reschedule_after}
methods). Finally, @code{unschedule} unschedules the timer.

All @code{schedule} and @code{reschedule} functions first unschedule the
timer if it was already scheduled.

The @code{reschedule} methods are particularly useful for timers that
should occur periodically. For example, this callback function will
cause its timer to go off at 20-second intervals:

@example
void timer_callback(Timer *t, void *) @{
    t->reschedule_after_s(20);
@}
@end example


@deftypemethod Timer void schedule_at (@w{const struct timeval &@var{when}})
Schedule the timer to go off at @var{when}. You must have initialized
the timer earlier.
@end deftypemethod

@deftypemethod Timer void schedule_now ()
Schedule the timer to go off as soon as possible.
@end deftypemethod

@deftypemethod Timer void schedule_after (@w{const struct timeval &@var{delay}})
Schedule the timer to go off @var{delay} after the current time.
@end deftypemethod

@deftypemethod Timer void schedule_after_s (@w{uint32_t @var{delay}})
Schedule the timer to go off @var{delay} seconds after the current time.
@end deftypemethod

@deftypemethod Timer void schedule_after_ms (@w{uint32_t @var{delay}})
Schedule the timer to go off @var{delay} milliseconds after the current
time.
@end deftypemethod

@deftypemethod Timer void reschedule_after (@w{const struct timeval &@var{delay}})
Schedule the timer to go off @var{delay} after it was last scheduled
to go off. If the timer was never previously scheduled, this method
will schedule the timer for some arbitrary time.
@end deftypemethod

@deftypemethod Timer void reschedule_after_s (@w{uint32_t @var{delay}})
Schedule the timer to go off @var{delay} seconds after it was last
scheduled to go off.
@end deftypemethod

@deftypemethod Timer void reschedule_after_ms (@w{uint32_t @var{delay}})
Schedule the timer to go off @var{delay} milliseconds after it was last
scheduled to go off.
@end deftypemethod

@deftypemethod Timer void unschedule ()
Unschedules the timer, if it was scheduled.
@end deftypemethod


@node Timer Status Methods, Timer Cleanup, Scheduling Timers, Timers
@section Timer Status Methods

These methods return information about a timer, including when it is
scheduled to expire.

@deftypemethod Timer bool initialized () const
Returns true iff the timer has been initialized with a call to
@code{initialize()}. Uninitialized timers must not be scheduled.
@end deftypemethod

@deftypemethod Timer bool scheduled () const
Returns true iff the timer is scheduled to expire some time in the
future.
@end deftypemethod

@deftypemethod Timer {const struct timeval &} expiry () const
Returns the time that the timer is set to expire. If the timer has never
been scheduled, the value is garbage. If the timer was scheduled but is
not scheduled currently, the value is most recently set expiry time.
@end deftypemethod


@node Timer Cleanup,  , Timer Status Methods, Timers
@section Timer Cleanup

You don't need to worry about cleaning up @code{Timer} objects. They are
automatically unscheduled and removed when the @code{Router} is
destroyed, and deleting a @code{Timer} automatically removes it from any
relevant lists. The following function is nevertheless provided for
consistency with @code{Task}s, which do need to be cleaned up in certain
circumstances (@pxref{Task Cleanup}).

@deftypemethod Timer void cleanup ()
Cleans up the @code{Timer} object.
@end deftypemethod


@node Notification, Coding Standards, Timers, Top
@chapter Notification


@node Coding Standards, Index, Notification, Top
@chapter Coding Standards


@menu
* Upper and lower case names::  
* Common name patterns::        
@end menu


@node Upper and lower case names, Common name patterns, Coding Standards, Coding Standards
@section Upper and Lower Case in Names

Keep to the following consistent scheme for choosing between upper and
lower case when naming variables, types, and functions.

@table @strong
@item Classes
Use mixed case with an initial capital letter and no underscores:
@code{LookupIPRoute}.

@item Methods
Use all lower case with underscores separating words:
@code{negation_is_simple}.

@item Constants
Use all upper case with underscores separating words:
@code{TYPE_ICMP_TYPE}.

@item Instance variables
Begin with an underscore, then use all lower case with underscores
separating words: @code{_length}.

@item Regular variables
Use all lower case with underscores separating words: @code{i},
@code{the_handler}.

@item Class variables
These variables are declared as @code{static} in the class header. Name
them like regular variables: @code{nelements_allocated}.

@item Functions
Name them like methods: @code{quicksort_hook}.

@item Other types
This includes typedefs and enumerated types. Name them like classes:
@code{CpVaParseCmd}, @code{ConfigurePhase}.
@end table

There are exceptions to these guidelines. In particular:

@itemize @bullet
@item
Instance variables in C structs---that is, classes with few methods
whose instance variables are mostly public---may be named like regular
variables, without a preceding underscore. The same goes for the
components of unions.

@item
Classes that act like simple types, such as @code{uatomic32_t}, take
names similar to the types they replace (in this case @code{uint32_t}).
@end itemize


@node Common name patterns,  , Upper and lower case names, Coding Standards
@section Common Name Patterns

@itemize @bullet
@item
Many instance variables have associated @dfn{getter methods} that return
their values, and/or @dfn{setter methods} that change their values. For
an instance variable named @code{_x}, the getter method should be named
@code{x()} and the setter method should be named @code{set_x()}.

@item
A variable or method which counts something is often named
@code{n@var{object}s}---for instance, @code{_nwarnings},
@code{ninputs()}, @code{_npackets}.

@item
Use a bare @samp{0} for a null pointer, except where some ambiguity
might arise (for example, where an incorrect overloading might be
selected).
@end itemize


@node Index,  , Coding Standards, Top
@unnumbered Index

@printindex cp

@bye
