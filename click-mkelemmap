#!/usr/bin/perl -w

# click-mkelemmap -- make map of element name to C++ class and file
# Eddie Kohler
#
# Copyright (c) 1999-2001 Massachusetts Institute of Technology
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, subject to the conditions
# listed in the Click LICENSE file. These conditions include: you must
# preserve this copyright notice, and you cannot mention the copyright
# holders in advertising related to the Software without their permission.
# The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
# notice is a summary of the Click LICENSE file; the license in that file is
# legally binding.

my(%processing_constants) =
    ('AGNOSTIC' => 'a/a', 'PUSH' => 'h/h', 'PULL' => 'l/l',
     'PUSH_TO_PULL' => 'h/l', 'PULL_TO_PUSH' => 'l/h');
my(%flow_code_constants) =
    ('COMPLETE_FLOW' => 'x/x');
my(@class_file, @click_name, @cxx_name,
   @parents, @processing, @flow_code, @flags, @requirements, @provisions,
   %click_name_to_id, %cxx_name_to_id);

sub process_file ($) {
  my($filename) = @_;
  my($headername) = $filename;
  $headername =~ s/\.cc$/\.hh/;
  if (!open(IN, $headername)) {
    print STDERR "$headername: $!\n" if $headername eq $filename;
    return;
  }
  my $text = <IN>;
  close IN;

  my $first;
  $first = @cxx_name;
  foreach $_ (split(m{^class(?=.*\{)}m, $text)) {
    my($cxx_class) = (/^\s*(\w+)(\s|:\s).*\{/);
    next if !$cxx_class;
    push @cxx_name, $cxx_class;
    push @class_file, $headername;
    $cxx_name_to_id{$cxx_class} = @cxx_name - 1;
    if (/\A\s*\w*\s*:\s*([\w\s,]+)/) {
      my $p = $1;
      $p =~ s/\bpublic\b//g;
      push @parents, [ split(/[\s,]+/, $p) ];
    } else {
      push @parents, [];
    }
    if (/class_name.*return\s*\"([^\"]+)\"/) {
      push @click_name, $1;
    } else {
      push @click_name, "";
    }
    if (/processing.*return\s*(.*?);/) {
      my $p = $1;
      $p = $processing_constants{$p} if exists($processing_constants{$p});
      $p =~ tr/\" \t\r\n//d;
      push @processing, $p;
    } else {
      push @processing, "";
    }
    if (/flow_code.*return\s*(.*?);/) {
      my $p = $1;
      $p = $flow_code_constants{$p} if exists($flow_code_constants{$p});
      $p =~ tr/\" \t\r\n//d;
      push @flow_code, $p;
    } else {
      push @flow_code, "";
    }
    if (/\bflags\(\).*return\s*"(.*?)";/) {
      push @flags, $1;
    } else {
      push @flags, undef;
    }
  }

  # process ELEMENT_REQUIRES and ELEMENT_PROVIDES
  if (!open(IN, $filename)) {
    print STDERR "$filename: $!\n";
    return;
  }
  $text = <IN>;
  close IN;

  my($req, $prov, $i) = ('', '');
  $req .= " " . $1 while $text =~ /^ELEMENT_REQUIRES\((.*)\)/mg;
  $prov .= " " . $1 while $text =~ /^ELEMENT_PROVIDES\((.*)\)/mg;
  $req =~ s/^\s+//;
  $req =~ s/"/\\"/g;
  $prov =~ s/^\s+//;
  $prov =~ s/"/\\"/g;
  for ($i = $first; $i < @processing; $i++) {
    push @requirements, $req;
    push @provisions, $prov;
    
    # check to see if overloading is valid
    if ($click_name[$i] && exists($click_name_to_id{$click_name[$i]})) {
      my($j) = $click_name_to_id{$click_name[$i]};
      if (($requirements[$i] =~ /\blinuxmodule\b/ && $requirements[$j] =~ /\buserlevel\b/)
	  || ($requirements[$i] =~ /\buserlevel\b/ && $requirements[$j] =~ /\blinuxmodule\b/)) {
	# ok
      } else {
	print STDERR "invalid multiple definition of element class \`$click_name[$i]'\n";
	print STDERR $class_file[$j], ": first definition here\n";
	print STDERR $class_file[$i], ": second definition here\n";
	print STDERR "(Two classes may share a name only if one of them is valid only at userlevel\nand the other is valid only in the Linux kernel module. Add explicit\nELEMENT_REQUIRES(linuxmodule) and ELEMENT_REQUIRES(userlevel) statements.)\n";
      }
    }
    $click_name_to_id{$click_name[$i]} = $i;
  }
}

sub parents_processing ($) {
  my($classid) = @_;
  if (!$processing[$classid]) {
    my($parent);
    foreach $parent (@{$parents[$classid]}) {
      if ($parent eq 'Element') {
	$processing[$classid] = 'a/a';
	last;
      } elsif ($parent ne '') {
	$processing[$classid] = &parents_processing($cxx_name_to_id{$parent});
	last if $processing[$classid];
      }
    }
  }
  return $processing[$classid];
}

sub parents_flow_code ($) {
  my($classid) = @_;
  if (!$flow_code[$classid]) {
    my($parent);
    foreach $parent (@{$parents[$classid]}) {
      if ($parent eq 'Element') {
	$flow_code[$classid] = 'x/x';
	last;
      } elsif ($parent ne '') {
	$flow_code[$classid] = &parents_flow_code($cxx_name_to_id{$parent});
	last if $flow_code[$classid];
      }
    }
  }
  return $flow_code[$classid];
}

sub parents_flags ($) {
  my($classid) = @_;
  if (!defined $flags[$classid]) {
    my($parent);
    foreach $parent (@{$parents[$classid]}) {
      if ($parent eq 'Element') {
	last;
      } elsif ($parent ne '') {
	$flags[$classid] = &parents_flags($cxx_name_to_id{$parent});
	last if defined $flags[$classid];
      }
    }
  }
  return $flags[$classid];
}

# main program: parse options
sub read_files_from ($) {
  my($fn) = @_;
  if (open(IN, ($fn eq '-' ? "<&STDIN" : $fn))) {
    my(@a, @b, $t);
    $t = <IN>;
    close IN;
    $t =~ s/^#.*//mg;
    @a = split(/\s+/, $t);
    foreach $t (@a) {
      next if $t eq '';
      if ($t =~ /[*?\[]/) {
	push @b, glob($t);
      } else {
	push @b, $t;
      }
    }
    @b;
  } else {
    print STDERR "$fn: $!\n";
    ();
  }
}

sub long_option_match ($$$) {
  my($have, $want, $len) = @_;
  $have = $1 if $have =~ /^(--[^=]*)=/;
  my($hl) = length($have);
  ($hl <= length($want) && $hl >= $len && $have eq substr($want, 0, $hl));
}

undef $/;
my(@files, @provides, $fn, $prefix);
$prefix = "";
while (@ARGV) {
  $_ = shift @ARGV;
  if (/^-f$/ || long_option_match($_, '--files', 3)) {
    die "not enough arguments" if !@ARGV;
    push @files, read_files_from(shift @ARGV);
  } elsif (long_option_match($_, '--files', 3) && /^[^=]*=(.*)$/) {
    push @files, read_files_from($1);
  } elsif (/^-p$/ || long_option_match($_, '--prefix', 5)) {
    die "not enough arguments" if !@ARGV;
    $prefix = shift @ARGV;
  } elsif (long_option_match($_, '--prefix', 5) && /^[^=]*=(.*)$/) {
    $prefix = $1;
  } elsif (/^-r$/ || long_option_match($_, '--provide', 5)) {
    die "not enough arguments" if !@ARGV;
    push @provides, split(/\s+/, shift @ARGV);
  } elsif (long_option_match($_, '--provide', 5) && /^[^=]*=(.*)$/) {
    push @provides, split(/\s+/, $1);
  } elsif (/^-./) {
    die "unknown option `$_'\n";
  } elsif (/^-$/) {
    push @files, "-";
  } else {
    push @files, glob($_);
  }
}
push @files, "-" if !@files;

foreach $fn (@files) {
  process_file($fn);
}

umask(022);
open(OUT, ">&STDOUT");

my($sourcedir) = `/bin/pwd`;
$sourcedir =~ s{\s+$}{}s;
print OUT "\$sourcedir\t\"$sourcedir\"\n";
print OUT "\$provides\t\"", join(' ', @provides), "\"\n";

print OUT "# Click class name\tC++ class name\theader file\tprocessing code\tflow code\tflag word\trequirements\tprovisions\n";

foreach $id (sort { $click_name[$a] cmp $click_name[$b] } 0..$#click_name) {
  my($n) = $click_name[$id];
  $n = '""' if !$n;
  
  my($f) = $class_file[$id];
  $f =~ s/^$prefix\/*//;

  my($p) = $processing[$id];
  $p = parents_processing($id) if !$p;
  $p = '""' if !$p;

  my($flow) = $flow_code[$id];
  $flow = parents_flow_code($id) if !$flow;
  $flow = '""' if !$flow;

  my($flags) = $flags[$id];
  $flags = parents_flags($id) if !defined($flags);
  $flags = "" if !defined($flags);
  
  my($req) = $requirements[$id];
  my($prov) = $provisions[$id];
  
  print OUT $n, "\t", $cxx_name[$id], "\t", $f, "\t", $p, "\t", $flow,
  "\t\"", $flags, "\"\t\"", $req, "\"\t\"", $prov, "\"\n";
}
close OUT;
