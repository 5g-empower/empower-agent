diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/Makefile.in ns-2.30/Makefile.in
--- ns-2.30-pure/Makefile.in	2006-09-24 22:11:19.000000000 -0700
+++ ns-2.30/Makefile.in	2006-12-30 17:22:27.000000000 -0800
@@ -58,7 +58,7 @@
 LDFLAGS	= @LDFLAGS@
 LDOUT	= -o $(BLANK)
 
-DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test
+DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test -DALLOW_RANDOM
 
 INCLUDES = \
 	-I. \
@@ -155,7 +155,7 @@
 
 OBJ_CC = \
 	tools/random.o tools/rng.o tools/ranvar.o common/misc.o common/timer-handler.o \
-	common/scheduler.o common/object.o common/packet.o \
+	common/scheduler.o common/object.o common/packet.o common/rawpacket.o \
 	common/ip.o routing/route.o common/connector.o common/ttl.o \
 	trace/trace.o trace/trace-ip.o \
 	classifier/classifier.o classifier/classifier-addr.o \
@@ -167,6 +167,7 @@
 	classifier/classifier-mac.o \
 	classifier/classifier-qs.o \
 	classifier/classifier-port.o src_rtg/classifier-sr.o \
+	classifier/classifier-ext.o classifier/classifier-click.o \
         src_rtg/sragent.o src_rtg/hdr_src.o adc/ump.o \
 	qs/qsagent.o qs/hdr_qs.o \
 	apps/app.o apps/telnet.o tcp/tcplib-telnet.o \
@@ -200,7 +201,7 @@
 	sctp/sctpDebug.o \
 	tools/integrator.o tools/queue-monitor.o \
 	tools/flowmon.o tools/loss-monitor.o \
-	queue/queue.o queue/drop-tail.o \
+	queue/queue.o queue/drop-tail.o queue/clickqueue.o \
 	adc/simple-intserv-sched.o queue/red.o \
 	queue/semantic-packetqueue.o queue/semantic-red.o \
 	tcp/ack-recons.o \
@@ -228,14 +229,15 @@
 	common/pkt-counter.o \
 	common/Decapsulator.o common/Encapsulator.o \
 	common/encap.o \
-	mac/channel.o mac/mac.o mac/ll.o mac/mac-802_11.o \
+	mac/channel.o mac/mac.o mac/ll.o mac/ll-ext.o mac/mac-802_11.o \
 	mac/mac-802_3.o mac/mac-tdma.o mac/smac.o \
 	mobile/mip.o mobile/mip-reg.o mobile/gridkeeper.o \
 	mobile/propagation.o mobile/tworayground.o \
-	mobile/antenna.o mobile/omni-antenna.o \
+	mobile/antenna.o mobile/omni-antenna.o mobile/uni-antenna.o \
+	mobile/pattern-antenna.o \
 	mobile/shadowing.o mobile/shadowing-vis.o mobile/dumb-agent.o \
 	common/bi-connector.o common/node.o \
-	common/mobilenode.o \
+	common/mobilenode.o common/clicknode.o \
 	mac/arp.o mobile/god.o mobile/dem.o \
 	mobile/topography.o mobile/modulation.o \
 	queue/priqueue.o queue/dsr-priqueue.o \
@@ -299,6 +301,7 @@
 	pgm/classifier-pgm.o pgm/pgm-agent.o pgm/pgm-sender.o \
 	pgm/pgm-receiver.o mcast/rcvbuf.o \
 	mcast/classifier-lms.o mcast/lms-agent.o mcast/lms-receiver.o \
+	routing/extrouter.o routing/extclickrouter.o \
 	mcast/lms-sender.o \
 	queue/delayer.o \
 	xcp/xcpq.o xcp/xcp.o xcp/xcp-end-sys.o \
@@ -462,6 +465,7 @@
 	tcl/lib/ns-srcrt.tcl \
 	tcl/mcast/ns-lms.tcl \
 	tcl/lib/ns-qsnode.tcl \
+	tcl/lib/ns-clicknode.tcl \
 	@V_NS_TCL_LIB_STL@
 
 $(GEN_DIR)ns_tcl.cc: $(NS_TCL_LIB)
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/Makefile.in.orig ns-2.30/Makefile.in.orig
--- ns-2.30-pure/Makefile.in.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/Makefile.in.orig	2006-09-24 22:11:19.000000000 -0700
@@ -0,0 +1,560 @@
+#  Copyright (c) 1994, 1995, 1996
+# 	The Regents of the University of California.  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that: (1) source code distributions
+#  retain the above copyright notice and this paragraph in its entirety, (2)
+#  distributions including binary code include the above copyright notice and
+#  this paragraph in its entirety in the documentation or other materials
+#  provided with the distribution, and (3) all advertising materials mentioning
+#  features or use of this software display the following acknowledgement:
+#  ``This product includes software developed by the University of California,
+#  Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+#  the University nor the names of its contributors may be used to endorse
+#  or promote products derived from this software without specific prior
+#  written permission.
+#  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+#  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+#
+# @(#) $Header: 2002/10/09 15:34:11
+
+#
+# Various configurable paths (remember to edit Makefile.in, not Makefile)
+#
+
+# Top level hierarchy
+prefix	= @prefix@
+# Pathname of directory to install the binary
+BINDEST	= @prefix@/bin
+# Pathname of directory to install the man page
+MANDEST	= @prefix@/man
+
+BLANK	= # make a blank space.  DO NOT add anything to this line
+
+# The following will be redefined under Windows (see WIN32 lable below)
+CC	= @CC@
+CPP	= @CXX@
+LINK	= $(CPP)
+MKDEP	= ./conf/mkdep
+TCLSH	= @V_TCLSH@
+TCL2C	= @V_TCL2CPP@
+AR	= ar rc $(BLANK)
+
+RANLIB	= @V_RANLIB@
+INSTALL	= @INSTALL@
+LN	= ln
+TEST	= test
+RM	= rm -f
+MV      = mv
+PERL	= @PERL@
+
+# for diffusion
+#DIFF_INCLUDES = "./diffusion3/main ./diffusion3/lib ./diffusion3/nr ./diffusion3/ns"
+
+CCOPT	= @V_CCOPT@ 
+STATIC	= @V_STATIC@
+#LDFLAGS	= $(STATIC)
+LDFLAGS	= @LDFLAGS@
+LDOUT	= -o $(BLANK)
+
+DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test
+
+INCLUDES = \
+	-I. \
+	@V_INCLUDES@ \
+	-I./tcp -I./sctp -I./common -I./link -I./queue \
+	-I./adc -I./apps -I./mac -I./mobile -I./trace \
+	-I./routing -I./tools -I./classifier -I./mcast \
+	-I./diffusion3/lib/main -I./diffusion3/lib \
+	-I./diffusion3/lib/nr -I./diffusion3/ns \
+	-I./diffusion3/filter_core -I./asim/ -I./qs \
+	-I./diffserv -I./satellite \
+	-I./wpan
+
+
+LIB	= \
+	@V_LIBS@ \
+	@V_LIB@ \
+	-lm @LIBS@
+#	-L@libdir@ \
+
+CFLAGS	+= $(CCOPT) $(DEFINE)
+
+# Explicitly define compilation rules since SunOS 4's make doesn't like gcc.
+# Also, gcc does not remove the .o before forking 'as', which can be a
+# problem if you don't own the file but can write to the directory.
+.SUFFIXES: .cc	# $(.SUFFIXES)
+
+.cc.o:
+	@rm -f $@
+	$(CPP) -c $(CFLAGS) $(INCLUDES) -o $@ $*.cc
+
+.c.o:
+	@rm -f $@
+	$(CC) -c $(CFLAGS) $(INCLUDES) -o $@ $*.c
+
+
+GEN_DIR	= gen/
+LIB_DIR	= lib/
+NS	= ns
+NSX	= nsx
+NSE	= nse
+
+# To allow conf/makefile.win overwrite this macro
+# We will set these two macros to empty in conf/makefile.win since VC6.0
+# does not seem to support the STL in gcc 2.8 and up. 
+OBJ_STL = diffusion3/lib/nr/nr.o diffusion3/lib/dr.o \
+	diffusion3/filters/diffusion/one_phase_pull.o \
+	diffusion3/filters/diffusion/two_phase_pull.o \
+	diffusion3/lib/diffapp.o \
+	diffusion3/ns/diffagent.o diffusion3/ns/diffrtg.o \
+	diffusion3/ns/difftimer.o \
+	diffusion3/filter_core/filter_core.o \
+	diffusion3/filter_core/iolog.o \
+	diffusion3/filter_core/iostats.o \
+	diffusion3/lib/main/attrs.o \
+	diffusion3/lib/main/events.o \
+	diffusion3/lib/main/iodev.o \
+	diffusion3/lib/main/iohook.o \
+	diffusion3/lib/main/timers.o \
+	diffusion3/lib/main/message.o \
+	diffusion3/lib/main/tools.o \
+	diffusion3/apps/gear_examples/gear_common.o \
+	diffusion3/apps/gear_examples/gear_receiver.o \
+	diffusion3/apps/gear_examples/gear_sender.o \
+	diffusion3/apps/rmst_examples/rmst_sink.o \
+	diffusion3/apps/rmst_examples/rmst_source.o \
+	diffusion3/apps/ping/1pp_ping_sender.o \
+	diffusion3/apps/ping/1pp_ping_receiver.o \
+	diffusion3/apps/ping/2pp_ping_sender.o \
+	diffusion3/apps/ping/2pp_ping_receiver.o \
+	diffusion3/apps/ping/ping_common.o \
+	diffusion3/apps/ping/push_receiver.o \
+	diffusion3/apps/ping/push_sender.o \
+	diffusion3/filters/gear/gear_attr.o \
+	diffusion3/filters/gear/gear.o \
+	diffusion3/filters/gear/gear_tools.o \
+	diffusion3/filters/misc/log.o \
+	diffusion3/filters/misc/srcrt.o \
+	diffusion3/filters/misc/tag.o \
+	diffusion3/filters/rmst/rmst.o \
+	diffusion3/filters/rmst/rmst_filter.o \
+	delaybox/delaybox.o \
+	packmime/packmime_HTTP.o packmime/packmime_HTTP_rng.o \
+	packmime/packmime_OL.o packmime/packmime_OL_ranvar.o\
+	packmime/packmime_ranvar.o
+
+NS_TCL_LIB_STL = tcl/lib/ns-diffusion.tcl \
+	tcl/delaybox/delaybox.tcl \
+	tcl/packmime/packmime.tcl
+
+
+# WIN32: uncomment the following line to include specific make for VC++
+# !include <conf/makefile.win>
+
+OBJ_CC = \
+	tools/random.o tools/rng.o tools/ranvar.o common/misc.o common/timer-handler.o \
+	common/scheduler.o common/object.o common/packet.o \
+	common/ip.o routing/route.o common/connector.o common/ttl.o \
+	trace/trace.o trace/trace-ip.o \
+	classifier/classifier.o classifier/classifier-addr.o \
+	classifier/classifier-hash.o \
+	classifier/classifier-virtual.o \
+	classifier/classifier-mcast.o \
+	classifier/classifier-bst.o \
+	classifier/classifier-mpath.o mcast/replicator.o \
+	classifier/classifier-mac.o \
+	classifier/classifier-qs.o \
+	classifier/classifier-port.o src_rtg/classifier-sr.o \
+        src_rtg/sragent.o src_rtg/hdr_src.o adc/ump.o \
+	qs/qsagent.o qs/hdr_qs.o \
+	apps/app.o apps/telnet.o tcp/tcplib-telnet.o \
+	tools/trafgen.o trace/traffictrace.o tools/pareto.o \
+	tools/expoo.o tools/cbr_traffic.o \
+	adc/tbf.o adc/resv.o adc/sa.o tcp/saack.o \
+	tools/measuremod.o adc/estimator.o adc/adc.o adc/ms-adc.o \
+	adc/timewindow-est.o adc/acto-adc.o \
+        adc/pointsample-est.o adc/salink.o adc/actp-adc.o \
+	adc/hb-adc.o adc/expavg-est.o\
+	adc/param-adc.o adc/null-estimator.o \
+	adc/adaptive-receiver.o apps/vatrcvr.o adc/consrcvr.o \
+	common/agent.o common/message.o apps/udp.o \
+	common/session-rtp.o apps/rtp.o tcp/rtcp.o \
+	common/ivs.o \
+	common/messpass.o common/tp.o common/tpm.o apps/worm.o \
+	tcp/tcp.o tcp/tcp-sink.o tcp/tcp-reno.o \
+	tcp/tcp-newreno.o \
+	tcp/tcp-vegas.o tcp/tcp-rbp.o tcp/tcp-full.o tcp/rq.o \
+	baytcp/tcp-full-bay.o baytcp/ftpc.o baytcp/ftps.o \
+	tcp/scoreboard.o tcp/scoreboard-rq.o tcp/tcp-sack1.o tcp/tcp-fack.o \
+	tcp/tcp-asym.o tcp/tcp-asym-sink.o tcp/tcp-fs.o \
+	tcp/tcp-asym-fs.o \
+	tcp/tcp-int.o tcp/chost.o tcp/tcp-session.o \
+	tcp/nilist.o \
+	sctp/sctp.o apps/sctp_app1.o\
+	sctp/sctp-timestamp.o sctp/sctp-hbAfterRto.o \
+	sctp/sctp-multipleFastRtx.o sctp/sctp-mfrHbAfterRto.o \
+	sctp/sctp-mfrTimestamp.o \
+	sctp/sctp-cmt.o \
+	sctp/sctpDebug.o \
+	tools/integrator.o tools/queue-monitor.o \
+	tools/flowmon.o tools/loss-monitor.o \
+	queue/queue.o queue/drop-tail.o \
+	adc/simple-intserv-sched.o queue/red.o \
+	queue/semantic-packetqueue.o queue/semantic-red.o \
+	tcp/ack-recons.o \
+	queue/sfq.o queue/fq.o queue/drr.o queue/srr.o queue/cbq.o \
+	queue/jobs.o queue/marker.o queue/demarker.o \
+	link/hackloss.o queue/errmodel.o queue/fec.o\
+	link/delay.o tcp/snoop.o \
+	gaf/gaf.o \
+	link/dynalink.o routing/rtProtoDV.o common/net-interface.o \
+	mcast/ctrMcast.o mcast/mcast_ctrl.o mcast/srm.o \
+	common/sessionhelper.o queue/delaymodel.o \
+	mcast/srm-ssm.o mcast/srm-topo.o \
+	routing/alloc-address.o routing/address.o \
+	$(LIB_DIR)int.Vec.o $(LIB_DIR)int.RVec.o \
+	$(LIB_DIR)dmalloc_support.o \
+	webcache/http.o webcache/tcp-simple.o webcache/pagepool.o \
+	webcache/inval-agent.o webcache/tcpapp.o webcache/http-aux.o \
+	webcache/mcache.o webcache/webtraf.o \
+	webcache/webserver.o \
+	webcache/logweb.o \
+	empweb/empweb.o \
+	empweb/empftp.o \
+	realaudio/realaudio.o \
+	mac/lanRouter.o classifier/filter.o \
+	common/pkt-counter.o \
+	common/Decapsulator.o common/Encapsulator.o \
+	common/encap.o \
+	mac/channel.o mac/mac.o mac/ll.o mac/mac-802_11.o \
+	mac/mac-802_3.o mac/mac-tdma.o mac/smac.o \
+	mobile/mip.o mobile/mip-reg.o mobile/gridkeeper.o \
+	mobile/propagation.o mobile/tworayground.o \
+	mobile/antenna.o mobile/omni-antenna.o \
+	mobile/shadowing.o mobile/shadowing-vis.o mobile/dumb-agent.o \
+	common/bi-connector.o common/node.o \
+	common/mobilenode.o \
+	mac/arp.o mobile/god.o mobile/dem.o \
+	mobile/topography.o mobile/modulation.o \
+	queue/priqueue.o queue/dsr-priqueue.o \
+	mac/phy.o mac/wired-phy.o mac/wireless-phy.o \
+	mac/mac-timers.o trace/cmu-trace.o mac/varp.o \
+	mac/mac-simple.o \
+	satellite/sat-hdlc.o \
+	dsdv/dsdv.o dsdv/rtable.o queue/rtqueue.o \
+	routing/rttable.o \
+	imep/imep.o imep/dest_queue.o imep/imep_api.o \
+	imep/imep_rt.o imep/rxmit_queue.o imep/imep_timers.o \
+	imep/imep_util.o imep/imep_io.o \
+	tora/tora.o tora/tora_api.o tora/tora_dest.o \
+	tora/tora_io.o tora/tora_logs.o tora/tora_neighbor.o \
+	dsr/dsragent.o dsr/hdr_sr.o dsr/mobicache.o dsr/path.o \
+	dsr/requesttable.o dsr/routecache.o dsr/add_sr.o \
+	dsr/dsr_proto.o dsr/flowstruct.o dsr/linkcache.o \
+	dsr/simplecache.o dsr/sr_forwarder.o \
+	aodv/aodv_logs.o aodv/aodv.o \
+	aodv/aodv_rtable.o aodv/aodv_rqueue.o \
+	common/ns-process.o \
+	satellite/satgeometry.o satellite/sathandoff.o \
+	satellite/satlink.o satellite/satnode.o \
+	satellite/satposition.o satellite/satroute.o \
+	satellite/sattrace.o \
+	rap/raplist.o rap/rap.o rap/media-app.o rap/utilities.o \
+	common/fsm.o tcp/tcp-abs.o \
+	diffusion/diffusion.o diffusion/diff_rate.o diffusion/diff_prob.o \
+	diffusion/diff_sink.o diffusion/flooding.o diffusion/omni_mcast.o \
+	diffusion/hash_table.o diffusion/routing_table.o diffusion/iflist.o \
+	tcp/tfrc.o tcp/tfrc-sink.o mobile/energy-model.o apps/ping.o tcp/tcp-rfc793edu.o \
+	queue/rio.o queue/semantic-rio.o tcp/tcp-sack-rh.o tcp/scoreboard-rh.o \
+	plm/loss-monitor-plm.o plm/cbr-traffic-PP.o \
+	linkstate/hdr-ls.o \
+	mpls/classifier-addr-mpls.o mpls/ldp.o mpls/mpls-module.o \
+	routing/rtmodule.o classifier/classifier-hier.o \
+	routing/addr-params.o \
+         nix/hdr_nv.o nix/classifier-nix.o \
+         nix/nixnode.o \
+         routealgo/rnode.o \
+         routealgo/bfs.o \
+         routealgo/rbitmap.o \
+         routealgo/rlookup.o \
+         routealgo/routealgo.o \
+         nix/nixvec.o \
+	nix/nixroute.o \
+	diffserv/dsred.o diffserv/dsredq.o \
+	diffserv/dsEdge.o diffserv/dsCore.o \
+	diffserv/dsPolicy.o diffserv/ew.o diffserv/dewp.o \
+	queue/red-pd.o queue/pi.o queue/vq.o queue/rem.o \
+	queue/gk.o \
+	pushback/rate-limit.o pushback/rate-limit-strategy.o \
+	pushback/ident-tree.o pushback/agg-spec.o \
+	pushback/logging-data-struct.o \
+	pushback/rate-estimator.o \
+	pushback/pushback-queue.o pushback/pushback.o \
+	common/parentnode.o trace/basetrace.o \
+	common/simulator.o asim/asim.o \
+	common/scheduler-map.o common/splay-scheduler.o \
+	linkstate/ls.o linkstate/rtProtoLS.o \
+	pgm/classifier-pgm.o pgm/pgm-agent.o pgm/pgm-sender.o \
+	pgm/pgm-receiver.o mcast/rcvbuf.o \
+	mcast/classifier-lms.o mcast/lms-agent.o mcast/lms-receiver.o \
+	mcast/lms-sender.o \
+	queue/delayer.o \
+	xcp/xcpq.o xcp/xcp.o xcp/xcp-end-sys.o \
+	wpan/p802_15_4csmaca.o wpan/p802_15_4fail.o \
+	wpan/p802_15_4hlist.o wpan/p802_15_4mac.o \
+	wpan/p802_15_4nam.o wpan/p802_15_4phy.o \
+	wpan/p802_15_4sscs.o wpan/p802_15_4timer.o \
+	wpan/p802_15_4trace.o wpan/p802_15_4transac.o \
+	@V_STLOBJ@
+
+
+# don't allow comments to follow continuation lines
+
+#  mac-csma.o mac-multihop.o\
+#	sensor-nets/landmark.o mac-simple-wireless.o \
+#	sensor-nets/tags.o sensor-nets/sensor-query.o \
+#	sensor-nets/flood-agent.o \
+
+# what was here before is now in emulate/
+OBJ_C =
+
+OBJ_COMPAT = $(OBJ_GETOPT) common/win32.o
+#XXX compat/win32x.o compat/tkConsole.o
+
+OBJ_EMULATE_CC = \
+	emulate/net-ip.o \
+	emulate/net.o \
+	emulate/tap.o \
+	emulate/ether.o \
+	emulate/internet.o \
+	emulate/ping_responder.o \
+	emulate/arp.o \
+	emulate/icmp.o \
+	emulate/net-pcap.o \
+	emulate/nat.o  \
+	emulate/iptap.o \
+	emulate/tcptap.o
+
+OBJ_EMULATE_C = \
+	emulate/inet.o
+
+OBJ_GEN = $(GEN_DIR)version.o $(GEN_DIR)ns_tcl.o $(GEN_DIR)ptypes.o
+
+SRC =	$(OBJ_C:.o=.c) $(OBJ_CC:.o=.cc) \
+	$(OBJ_EMULATE_C:.o=.c) $(OBJ_EMULATE_CC:.o=.cc) \
+	common/tclAppInit.cc common/tkAppInit.cc 
+
+OBJ =	$(OBJ_C) $(OBJ_CC) $(OBJ_GEN) $(OBJ_COMPAT)
+
+CLEANFILES = ns nse nsx ns.dyn $(OBJ) $(OBJ_EMULATE_CC) \
+	$(OBJ_EMULATE_C) common/tclAppInit.o \
+	$(GEN_DIR)* $(NS).core core core.$(NS) core.$(NSX) core.$(NSE) \
+	common/ptypes2tcl common/ptypes2tcl.o 
+
+SUBDIRS=\
+	indep-utils/cmu-scen-gen/setdest \
+	indep-utils/webtrace-conv/dec \
+	indep-utils/webtrace-conv/epa \
+	indep-utils/webtrace-conv/nlanr \
+	indep-utils/webtrace-conv/ucb
+
+BUILD_NSE = @build_nse@
+
+all: $(NS) $(BUILD_NSE) all-recursive
+
+
+all-recursive:
+	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) all; ) done
+
+$(NS): $(OBJ) common/tclAppInit.o Makefile
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ \
+		common/tclAppInit.o $(OBJ) $(LIB)
+
+Makefile: Makefile.in
+	@echo "Makefile.in is newer than Makefile."
+	@echo "You need to re-run configure."
+	false
+
+$(NSE): $(OBJ) common/tclAppInit.o $(OBJ_EMULATE_CC) $(OBJ_EMULATE_C)
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ \
+		common/tclAppInit.o $(OBJ) \
+		$(OBJ_EMULATE_CC) $(OBJ_EMULATE_C)  $(LIB) 
+
+ns.dyn: $(OBJ) common/tclAppInit.o
+	$(LINK) $(LDFLAGS) -o $@ \
+		common/tclAppInit.o $(OBJ) $(LIB)
+
+PURIFY	= purify -cache-dir=/tmp
+ns-pure: $(OBJ) common/tclAppInit.o
+	$(PURIFY) $(LINK) $(LDFLAGS) -o $@ \
+		common/tclAppInit.o $(OBJ) $(LIB)
+
+NS_TCL_LIB = \
+	tcl/lib/ns-compat.tcl \
+	tcl/lib/ns-default.tcl \
+	tcl/lib/ns-errmodel.tcl \
+	tcl/lib/ns-lib.tcl \
+	tcl/lib/ns-link.tcl \
+	tcl/lib/ns-mobilenode.tcl \
+	tcl/lib/ns-sat.tcl \
+	tcl/lib/ns-cmutrace.tcl \
+	tcl/lib/ns-node.tcl \
+	tcl/lib/ns-rtmodule.tcl \
+	tcl/lib/ns-hiernode.tcl \
+	tcl/lib/ns-packet.tcl \
+	tcl/lib/ns-queue.tcl \
+	tcl/lib/ns-source.tcl \
+	tcl/lib/ns-nam.tcl \
+	tcl/lib/ns-trace.tcl \
+	tcl/lib/ns-agent.tcl \
+	tcl/lib/ns-random.tcl \
+	tcl/lib/ns-namsupp.tcl \
+	tcl/lib/ns-address.tcl \
+	tcl/lib/ns-intserv.tcl \
+	tcl/lib/ns-autoconf.tcl \
+	tcl/rtp/session-rtp.tcl \
+	tcl/lib/ns-mip.tcl \
+	tcl/rtglib/dynamics.tcl \
+	tcl/rtglib/route-proto.tcl \
+	tcl/rtglib/algo-route-proto.tcl \
+	tcl/rtglib/ns-rtProtoLS.tcl \
+        tcl/interface/ns-iface.tcl \
+	tcl/mcast/BST.tcl \
+        tcl/mcast/ns-mcast.tcl \
+        tcl/mcast/McastProto.tcl \
+        tcl/mcast/DM.tcl \
+	tcl/mcast/srm.tcl \
+	tcl/mcast/srm-adaptive.tcl \
+	tcl/mcast/srm-ssm.tcl \
+	tcl/mcast/timer.tcl \
+	tcl/mcast/McastMonitor.tcl \
+	tcl/mobility/dsdv.tcl \
+	tcl/mobility/dsr.tcl \
+        tcl/ctr-mcast/CtrMcast.tcl \
+        tcl/ctr-mcast/CtrMcastComp.tcl \
+        tcl/ctr-mcast/CtrRPComp.tcl \
+	tcl/rlm/rlm.tcl \
+	tcl/rlm/rlm-ns.tcl \
+	tcl/session/session.tcl \
+	tcl/lib/ns-route.tcl \
+	tcl/emulate/ns-emulate.tcl \
+	tcl/lan/vlan.tcl \
+	tcl/lan/abslan.tcl \
+	tcl/lan/ns-ll.tcl \
+	tcl/lan/ns-mac.tcl \
+	tcl/webcache/http-agent.tcl \
+	tcl/webcache/http-server.tcl \
+	tcl/webcache/http-cache.tcl \
+	tcl/webcache/http-mcache.tcl \
+	tcl/webcache/webtraf.tcl \
+	tcl/webcache/empweb.tcl \
+	tcl/webcache/empftp.tcl \
+	tcl/plm/plm.tcl \
+	tcl/plm/plm-ns.tcl \
+	tcl/plm/plm-topo.tcl \
+	tcl/mpls/ns-mpls-classifier.tcl \
+	tcl/mpls/ns-mpls-ldpagent.tcl \
+	tcl/mpls/ns-mpls-node.tcl \
+	tcl/mpls/ns-mpls-simulator.tcl \
+	tcl/lib/ns-pushback.tcl \
+	tcl/lib/ns-srcrt.tcl \
+	tcl/mcast/ns-lms.tcl \
+	tcl/lib/ns-qsnode.tcl \
+	@V_NS_TCL_LIB_STL@
+
+$(GEN_DIR)ns_tcl.cc: $(NS_TCL_LIB)
+	$(TCLSH) bin/tcl-expand.tcl tcl/lib/ns-lib.tcl @V_NS_TCL_LIB_STL@ | $(TCL2C) et_ns_lib > $@
+
+$(GEN_DIR)version.c: VERSION
+	$(RM) $@
+	$(TCLSH) bin/string2c.tcl version_string < VERSION > $@
+
+$(GEN_DIR)ptypes.cc: common/ptypes2tcl common/packet.h
+	./common/ptypes2tcl > $@
+
+common/ptypes2tcl: common/ptypes2tcl.o
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ common/ptypes2tcl.o
+
+common/ptypes2tcl.o: common/ptypes2tcl.cc common/packet.h
+
+dirs:
+	for d in $(DESTDIR)$(MANDEST)/man1; do \
+		if [ ! -d $$d ]; then \
+			mkdir -p $$d ;\
+		fi;\
+	done
+
+
+install: dirs force install-ns install-man
+
+install-ns: force
+	$(INSTALL) -m 755 ns $(DESTDIR)$(BINDEST)
+
+install-man: force
+	$(INSTALL) -m 644 ns.1 $(DESTDIR)$(MANDEST)/man1
+
+install-recursive: force
+	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) install; ) done
+
+clean:
+	$(RM) $(CLEANFILES)
+
+AUTOCONF_GEN = tcl/lib/ns-autoconf.tcl
+distclean: distclean-recursive
+	$(RM) $(CLEANFILES) Makefile config.cache config.log config.status \
+	    autoconf.h gnuc.h os-proto.h $(AUTOCONF_GEN); \
+	$(MV) .configure .configure- ;\
+	echo "Moved .configure to .configure-"
+
+distclean-recursive:
+	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) clean; $(RM) Makefile; ) done
+
+tags:	force
+	ctags -wtd *.cc *.h webcache/*.cc webcache/*.h dsdv/*.cc dsdv/*.h \
+	dsr/*.cc dsr/*.h webcache/*.cc webcache/*.h lib/*.cc lib/*.h \
+	../Tcl/*.cc ../Tcl/*.h 
+
+TAGS:	force
+	etags *.cc *.h webcache/*.cc webcache/*.h dsdv/*.cc dsdv/*.h \
+	dsr/*.cc dsr/*.h webcache/*.cc webcache/*.h lib/*.cc lib/*.h \
+	../Tcl/*.cc ../Tcl/*.h
+
+tcl/lib/TAGS:	force
+	( \
+		cd tcl/lib; \
+		$(TCLSH) ../../bin/tcl-expand.tcl ns-lib.tcl | grep '^### tcl-expand.tcl: begin' | awk '{print $$5}' >.tcl_files; \
+		etags --lang=none -r '/^[ \t]*proc[ \t]+\([^ \t]+\)/\1/' `cat .tcl_files`; \
+		etags --append --lang=none -r '/^\([A-Z][^ \t]+\)[ \t]+\(instproc\|proc\)[ \t]+\([^ \t]+\)[ \t]+/\1::\3/' `cat .tcl_files`; \
+	)
+
+depend: $(SRC)
+	$(MKDEP) $(CFLAGS) $(INCLUDES) -- $(SRC) >& /dev/null
+
+srctar:
+	@cwd=`pwd` ; dir=`basename $$cwd` ; \
+	    name=ns-`cat VERSION | tr A-Z a-z` ; \
+	    tar=ns-src-`cat VERSION`.tar.gz ; \
+	    list="" ; \
+	    for i in `cat FILES` ; do list="$$list $$name/$$i" ; done; \
+	    echo \
+	    "(rm -f $$tar; cd .. ; ln -s $$dir $$name)" ; \
+	     (rm -f $$tar; cd .. ; ln -s $$dir $$name) ; \
+	    echo \
+	    "(cd .. ; tar cfh $$tar [lots of files])" ; \
+	     (cd .. ; tar cfh - $$list) | gzip -c > $$tar ; \
+	    echo \
+	    "rm ../$$name; chmod 444 $$tar" ;  \
+	     rm ../$$name; chmod 444 $$tar
+
+force:
+
+test:	force
+	./validate
+
+# Create makefile.vc for Win32 development by replacing:
+# "# !include ..." 	-> 	"!include ..."
+makefile.vc:	Makefile.in
+	$(PERL) bin/gen-vcmake.pl < Makefile.in > makefile.vc
+#	$(PERL) -pe 's/^# (\!include)/\!include/o' < Makefile.in > makefile.vc
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/apps/udp.cc ns-2.30/apps/udp.cc
--- ns-2.30-pure/apps/udp.cc	2006-09-24 22:10:59.000000000 -0700
+++ ns-2.30/apps/udp.cc	2006-12-30 17:22:27.000000000 -0800
@@ -104,7 +104,8 @@
 		if (flags && (0 ==strcmp(flags, "NEW_BURST")))
 			rh->flags() |= RTP_M;
 		p->setdata(data);
-		target_->recv(p);
+		//target_->recv(p);
+		Agent::send(p,0);
 	}
 	n = nbytes % size_;
 	if (n > 0) {
@@ -119,7 +120,8 @@
 		if (flags && (0 == strcmp(flags, "NEW_BURST")))
 			rh->flags() |= RTP_M;
 		p->setdata(data);
-		target_->recv(p);
+		//target_->recv(p);
+		Agent::send(p,0);
 	}
 	idle();
 }
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/classifier/classifier-click.cc ns-2.30/classifier/classifier-click.cc
--- ns-2.30-pure/classifier/classifier-click.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/classifier/classifier-click.cc	2006-12-30 17:22:28.000000000 -0800
@@ -0,0 +1,663 @@
+/*
+ * classifier-click classifier file for nsclick
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#include "config.h"
+#include <stdlib.h>
+#include <ctype.h>
+#include <sys/time.h>
+#include <unistd.h>
+//#include <stl.h>
+//#include <hash_map.h>
+#include <map>
+#include <string>
+
+#include "agent.h"
+#include "packet.h"
+#include "rawpacket.h"
+#include "ip.h"
+#include "extrouter.h"
+#include "classifier.h"
+#include "classifier-ext.h"
+#include "mobilenode.h"
+#include "clicknode.h"
+#include "address.h"
+#include <click/simclick.h>
+#include "scheduler.h"
+#include "classifier-click.h"
+#include "ll-ext.h"
+#include "clickqueue.h"
+
+static class ClickClassifierClass : public TclClass {
+public:
+  ClickClassifierClass() : TclClass("Classifier/Ext/Click") {}
+  TclObject* create(int, const char*const*) {
+    return (new ClickClassifier());
+  }
+} class_click_classifier;
+
+
+void
+ClickEventHandler::handle(Event* event) {
+  // XXX dangerous downcast - should use RTTI
+  ClickEvent* cevent = (ClickEvent*) event;
+  simclick_simstate esimstate;
+  esimstate.curtime = cevent->when_;
+  //fprintf(stderr,"Should be calling simclick_click_run: %lf\n",event->time_);
+
+  simclick_click_run(cevent->clickinst_,&esimstate);
+  delete cevent;
+}
+
+map<MACAddr,int> ClickClassifier::global_mactonodemap_;
+map<MACAddr,int> ClickClassifier::global_mactonsmacmap_;
+map<u_int32_t,int> ClickClassifier::global_ipmap_;
+
+ClickClassifier::ClickClassifier() {
+  extrouter_ = this;
+  clickinst_ = NULL;
+}
+
+int
+ClickClassifier::command(int argc, const char*const* argv)
+{
+  Tcl& tcl = Tcl::instance();
+  if (2 == argc) {
+    if (strcmp(argv[1], "getnodename") == 0) {
+      // getnodename
+      tcl.resultf(nodename_.c_str());
+      return TCL_OK;
+    }
+    if (strcmp(argv[1], "runclick") == 0) {
+      // runclick
+      if (clickinst_) {
+        simclick_simstate simstate;
+        simstate.curtime = GetSimTime();
+        simclick_click_run(clickinst_,&simstate);
+      }
+      return TCL_OK;
+    }
+  }
+  else if (3 == argc) {
+    if(strcmp(argv[1], "loadclick") == 0) {
+      simclick_simstate simstate;
+      simstate.curtime = GetSimTime();
+      clickinst_ = simclick_click_create((simclick_sim)this,argv[2],&simstate);
+      simclick_click_run(clickinst_,&simstate);
+
+      return TCL_OK;
+    }
+    if (strcmp(argv[1], "getip") == 0) {
+      // getip <ifname>
+      int theif = simclick_sim_ifid_from_name((simclick_sim)this,argv[2]);
+      //fprintf(stderr,"get ipaddr is %s\n",ifipaddrs_[theif].c_str());
+      tcl.resultf(ifipaddrs_[theif].c_str());
+      return TCL_OK;
+    }
+    if (strcmp(argv[1], "getmac") == 0) {
+      // getmac <ifname>
+      int theif = simclick_sim_ifid_from_name((simclick_sim)this,argv[2]);
+      //fprintf(stderr,"get macaddr is %s\n",ifmacaddrs_[theif].c_str());
+      tcl.resultf(ifmacaddrs_[theif].c_str());
+      return TCL_OK;
+    }
+    if (strcmp(argv[1], "setnodename") == 0) {
+      // setnodename <ifname>
+      nodename_ = argv[2];
+      return TCL_OK;
+    }
+    if (strcmp(argv[1], "setnodeaddr") == 0) {
+      // setnodeaddr <nodeaddress>
+      nodeaddr_ =  Address::instance().str2addr(argv[2]);
+      return TCL_OK;
+    }
+    //mvhaen -- meant to set the trace file
+    if (strcmp(argv[1], "tracetarget") == 0) {
+      logtarget_ = ( CMUTrace* ) TclObject::lookup(argv[2]);
+      if (logtarget_ == 0)
+          return TCL_ERROR;
+      return TCL_OK;
+    }
+  }
+  else if (4 == argc) {
+    if(strcmp(argv[1], "setip") == 0) {
+      // setip <ifname> <ipaddr>
+      int theif = simclick_sim_ifid_from_name((simclick_sim)this,argv[2]);
+      ifipaddrs_[theif] = string(argv[3]);
+      //fprintf(stderr,"ipaddr is %s\n",ifipaddrs_[theif].c_str());
+      // Also save the binary form of this IP address in a static
+      // (i.e. simulator global) hash map of IP addresses to ns-2
+      // addresses. This lets us track map IP to ns-2 address when
+      // we might need it.
+      global_ipmap_[inet_addr(argv[3])] = nodeaddr_;
+      return TCL_OK;
+    }
+    else if(strcmp(argv[1], "setmac") == 0) {
+      // setmac <ifname> <macaddr>
+      int theif = simclick_sim_ifid_from_name((simclick_sim)this,argv[2]);
+      ifmacaddrs_[theif] = string(argv[3]);
+
+      //fprintf(stderr,"macaddr is %s\n",ifmacaddrs_[theif].c_str());
+
+      // Also save the binary form of this MAC address in a static
+      // (i.e. simulator global) hash map of MAC addresses to ns-2
+      // addresses. This lets us set the destination address in the
+      // ns-2 packet header.
+      MACAddr thismacaddr = MACAddr(string(argv[3]));
+      global_mactonodemap_[thismacaddr] = nodeaddr_;
+      LL* mylink = (LL*) slot_[theif];
+      global_mactonsmacmap_[thismacaddr] = mylink->macDA();
+      return TCL_OK;
+    }
+    else if (strcmp(argv[1], "readhandler") == 0) {
+      char* readreturn = 0;
+      simclick_simstate simstate;
+      simstate.curtime = GetSimTime();
+      readreturn = simclick_click_read_handler(clickinst_,argv[2],argv[3],0,0, &simstate);
+      //fprintf(stderr, "readhandler: %s\n",clickretc);
+      if (readreturn) {
+	tcl.resultf("%s", readreturn);
+	free(readreturn);
+	readreturn = 0;
+      }
+      else {
+	tcl.resultf("");
+      }
+      return TCL_OK;
+    }
+  } else if (argc == 5) {
+    if (strcmp(argv[1], "writehandler") == 0) {
+      int clickret;
+      simclick_simstate simstate;
+      simstate.curtime = GetSimTime();
+      clickret = simclick_click_write_handler(clickinst_, argv[2], argv[3],
+					      argv[4], &simstate);
+      //fprintf(stderr, "writehandler: %i\n",clickret);
+      tcl.resultf("%i", clickret);
+      return TCL_OK;
+    }
+  }
+
+  return ExtClassifier::command(argc, argv);
+}
+
+
+ClickClassifier::~ClickClassifier() {
+}
+
+int
+ClickClassifier::route(Packet* p) {
+  int result = 0;
+  if (clickinst_) {
+    unsigned char* data = NULL;
+    int len = ((PacketData*)(p->userdata()))->size();
+    simclick_simpacketinfo simpinfo;
+    hdr_cmn* chdr = HDR_CMN(p);
+    int ifid = chdr->iface_;
+    hdr_ip* iphdr = hdr_ip::access(p);
+    simpinfo.id = chdr->uid();
+    simpinfo.fid = iphdr->flowid();
+    hdr_raw* rhdr = hdr_raw::access(p);
+    int nssubtype = rhdr->subtype;
+    int clicktype = GetClickPacketType(nssubtype);
+    simpinfo.simtype = rhdr->ns_type;
+    unsigned char* pdat = p->accessdata();
+    data = new unsigned char[len];
+    memcpy(data,pdat,len);
+    /*
+     * XXX Destroy packet for now. This may change if we wind
+     * up having to track and reuse ns packets after they've gone through
+     * click.
+     */
+    Packet::free(p);
+    p = NULL;
+
+    simclick_simstate simstate;
+    simstate.curtime = GetSimTime();
+    //fprintf(stderr,"Sending packet up to click...\n");
+    simclick_click_send(clickinst_,&simstate,ifid,clicktype,data,len,&simpinfo);
+    delete[] data;
+    data = 0;
+  }
+  else {
+    fprintf(stderr,"No click upcall set!\n");
+  }
+  return result;
+}
+
+string
+ClickClassifier::GetIPAddr(int ifid) {
+  return ifipaddrs_[ifid];
+}
+
+string
+ClickClassifier::GetMACAddr(int ifid) {
+  return ifmacaddrs_[ifid];
+}
+
+string
+ClickClassifier::GetNodeName() {
+  return nodename_;
+}
+
+int
+ClickClassifier::GetNodeAddr()
+{
+  return nodeaddr_;
+}
+
+/*
+ * Click service methods
+ */
+int simclick_sim_ifid_from_name(simclick_sim simid, const char* ifname) {
+  int ifid = -1;
+  char* devname = NULL;
+
+  /*
+   * Provide a mapping between a textual interface name
+   * and the id numbers used. This is mostly for the
+   * benefit of click scripts, i.e. you can still refer to
+   * an interface as, say, /dev/eth0.
+   */
+  if (strstr(ifname,"tap") || strstr(ifname,"tun")) {
+    /*
+     * A tapX or tunX interface goes to and from the kernel -
+     * always IFID_KERNELTAP
+     */
+    ifid = ExtRouter::IFID_KERNELTAP;
+  }
+  else if ((devname = strstr(ifname,"eth"))) {
+    /*
+     * Anything with an "eth" followed by a number is
+     * a regular interface. Add the number to IFID_FIRSTIF
+     * to get the handle.
+     */
+    while (*devname && !isdigit(*devname)) {
+      devname++;
+    }
+    if (*devname) {
+      ifid = atoi(devname) + ExtRouter::IFID_FIRSTIF;
+    }
+  }
+  else if ((devname = strstr(ifname,"drop"))) {
+    /*
+     * Anything with an "drop" followed by a number is
+     * a special interface on which we place packets that
+     * get dropped due to MAC layer feedback. Add the number to
+     * IFID_FIRSTIFDROP to get the handle.
+     */
+    while (*devname && !isdigit(*devname)) {
+      devname++;
+    }
+    if (*devname) {
+      ifid = atoi(devname) + ExtRouter::IFID_FIRSTIFDROP;
+    }
+  }
+  return ifid;
+}
+
+int
+simclick_sim_send_to_if(simclick_sim siminst,simclick_click clickinst,
+			int ifid,int type, const unsigned char* data,int len,
+			simclick_simpacketinfo* pinfo) {
+
+  if (NULL == siminst) {
+    return -1;
+  }
+
+  /*
+   * Bail out if we get a bad ifid
+   */
+  if (ExtRouter::IFID_LASTIF < ifid) {
+    return -1;
+  }
+  /*
+   * XXX should probably use RTTI typesafe casts if they are now
+   * reliably implemented across the compilers/platforms we want
+   * to run on.
+   */
+  ClickClassifier* theclassifier = (ClickClassifier*)siminst;
+
+  return theclassifier->send_to_if(ifid,type,data,len,pinfo);
+}
+
+int
+simclick_sim_schedule(simclick_sim siminst,simclick_click clickinst,
+		      struct timeval* when) {
+
+  int result = 0;
+  double simtime = when->tv_sec + (when->tv_usec/1.0e6);
+  double simdelay = simtime - Scheduler::instance().clock();
+  ClickClassifier* theclassifier = (ClickClassifier*)siminst;
+  ClickEvent* ev = new ClickEvent();
+  ev->clickinst_ = clickinst;
+  ev->when_ = *when;
+  Scheduler::instance().schedule(&(theclassifier->cevhandler_),ev,simdelay);
+  //fprintf(stderr,"Event scheduled in %f seconds\n",simdelay);
+
+  return result;
+}
+
+void
+simclick_sim_ipaddr_from_name(simclick_sim siminst,const char* ifname,
+			      char* buf,int len) {
+  ClickClassifier* theclassifier = (ClickClassifier*)siminst;
+  int theif = simclick_sim_ifid_from_name(siminst,ifname);
+  string ipaddr = theclassifier->GetIPAddr(theif);
+  memset(buf,0,len);
+  ipaddr.copy(buf,len-1);
+}
+
+void
+simclick_sim_macaddr_from_name(simclick_sim siminst,const char* ifname,
+			       char* buf,int len) {
+  ClickClassifier* theclassifier = (ClickClassifier*)siminst;
+  int theif = simclick_sim_ifid_from_name(siminst,ifname);
+  string macaddr = theclassifier->GetMACAddr(theif);
+  memset(buf,0,len);
+  macaddr.copy(buf,len-1);
+}
+
+void
+simclick_sim_get_node_name(simclick_sim siminst,char* buf,int len) {
+  ClickClassifier* theclassifier = (ClickClassifier*)siminst;
+  string nodename = theclassifier->GetNodeName();
+  memset(buf,0,len);
+  nodename.copy(buf,len-1);
+}
+
+int
+ClickClassifier::send_to_if(int ifid,int type,const unsigned char* data,
+			 int len,simclick_simpacketinfo* pinfo) {
+  int result = 0;
+
+  /*
+   * Package raw data into an ns-2 format raw packet, then send
+   * it on down the line.
+   */
+
+  Packet* pkt = MakeRawPacket(type,ifid,data,len,pinfo);
+  //fprintf(stderr,"simclickid == %d\n",simclickid);
+  recv(pkt,0);
+
+  return result;
+}
+
+int
+ClickClassifier::IFReady(int ifid) {
+  NsObject* target = NULL;
+  int ready = 0;
+
+  // XXX assumes direct ifid->slot mapping
+  if (ExtRouter::IFID_KERNELTAP == ifid) {
+    return 1;
+  }
+
+  target = slot_[ifid];
+  if (target) {
+    LLExt* llext = (LLExt*) target;
+    ready = llext->ready();
+  }
+  else {
+    ready = 0;
+    fprintf(stderr,"ERROR: network interface does not exist\n");
+  }
+
+  return ready;
+}
+
+int
+simclick_sim_if_ready(simclick_sim siminst,simclick_click clickinst,int ifid) {
+  int result = 0;
+  ClickClassifier* theclassifier = (ClickClassifier*)siminst;
+  result = theclassifier->IFReady(ifid);
+  return result;
+}
+
+int
+simclick_sim_trace(simclick_sim siminst, simclick_click clickinst, const char* event)
+{
+
+	ClickClassifier * theclassifier = ( ClickClassifier* ) siminst;
+	theclassifier->trace( "%s", event );
+	return 1;
+}
+
+int
+simclick_sim_get_node_id(simclick_sim siminst, simclick_click clickinst)
+{
+	ClickClassifier * theclassifier = ( ClickClassifier* ) siminst;
+	return theclassifier->GetNodeAddr();
+}
+
+int
+simclick_sim_get_next_pkt_id(simclick_sim siminst, simclick_click clickinst)
+{
+	ClickClassifier * theclassifier = ( ClickClassifier* ) siminst;
+	return theclassifier->GetNextPktID();
+}
+
+int
+ClickClassifier::GetNSSubtype(int type) {
+  switch (type) {
+  case SIMCLICK_PTYPE_ETHER:
+    return hdr_raw::ETHERNET;
+
+  case SIMCLICK_PTYPE_IP:
+    return hdr_raw::IP;
+
+  default:
+    return hdr_raw::NONE;
+  }
+
+  return hdr_raw::NONE;
+}
+
+int
+ClickClassifier::GetClickPacketType(int nssubtype) {
+  switch (nssubtype) {
+  case hdr_raw::ETHERNET:
+    return SIMCLICK_PTYPE_ETHER;
+
+  case hdr_raw::IP:
+    return SIMCLICK_PTYPE_IP;
+
+  default:
+    return SIMCLICK_PTYPE_UNKNOWN;
+  }
+
+  return SIMCLICK_PTYPE_UNKNOWN;
+}
+
+// XXX 
+// Normally I'd bitterly complain about code like this. However,
+// I don't really want to worry about annoying differences
+// between IP header files across different platforms, and I
+// want to get this code up and running ASAP. So... I'm defining
+// a few things here to handle the minimal packet cracking I
+// need to do to create raw packets. If more complicated
+// packet munging is called for, something better should be created.
+#define NS_ETHER_OFFSET_DADDR 0
+#define NS_ETHER_OFFSET_SADDR 6
+#define NS_ETHER_HEADER_SIZE 14
+
+
+void
+ClickClassifier::LinkLayerFailedCallback(Packet* p, void* arg) {
+  // Hit the callback and then free the packet
+  ((ClickClassifier*)arg)->LinkLayerFailed(p);
+  Packet::free(p);
+}
+
+void
+ClickClassifier::LinkLayerFailed(Packet* p) {
+  //fprintf(stderr,"XXX Lost a packet!!!\n");
+  if (clickinst_) {
+    unsigned char* data = NULL;
+    int len = ((PacketData*)(p->userdata()))->size();
+    simclick_simpacketinfo simpinfo;
+    hdr_cmn* chdr = HDR_CMN(p);
+    int ifid = chdr->iface_ + IFID_LASTIF;
+    hdr_ip* iphdr = hdr_ip::access(p);
+    simpinfo.id = chdr->uid();
+    simpinfo.fid = iphdr->flowid();
+    hdr_raw* rhdr = hdr_raw::access(p);
+    int nssubtype = rhdr->subtype;
+    int clicktype = GetClickPacketType(nssubtype);
+    unsigned char* pdat = p->accessdata();
+    data = new unsigned char[len];
+    memcpy(data,pdat,len);
+    simclick_simstate simstate;
+    simstate.curtime = GetSimTime();
+    //fprintf(stderr,"Sending packet up to click...\n");
+    simclick_click_send(clickinst_,&simstate,ifid,clicktype,data,len,&simpinfo);
+    delete[] data;
+    data = 0;
+  }
+  else {
+    fprintf(stderr,"No click upcall set!\n");
+  }
+}
+
+Packet*
+ClickClassifier::MakeRawPacket(int type,int ifid,const unsigned char* data,
+			       int len,simclick_simpacketinfo* pinfo){
+  Packet* pkt = Packet::alloc(len);
+  /*
+   * Shovel raw data into packet
+   */
+  hdr_raw* rhdr = hdr_raw::access(pkt);
+  rhdr->subtype = GetNSSubtype(type);
+  unsigned char* pdat = pkt->accessdata();
+  memcpy(pdat,data,len);
+
+  /*
+   * Set some of the packet header stuff ns-2 wants
+   */
+  struct hdr_cmn* chdr = HDR_CMN(pkt);
+  chdr->iface() = ifid;
+  chdr->ptype() = PT_RAW;
+  chdr->size() = len;
+  if (pinfo->id >= 0) {
+    chdr->uid() = pinfo->id;
+  }
+  else {
+    chdr->uid() = Agent::getnextuid();
+  }
+  rhdr->ns_type = (-1 == pinfo->simtype) ? PT_RAW : pinfo->simtype;
+  chdr->xmit_failure_ = LinkLayerFailedCallback;
+  chdr->xmit_failure_data_ = (void*)this;
+
+  hdr_ip* iphdr = hdr_ip::access(pkt);
+  iphdr->flowid() = 0;
+  if (pinfo->fid >= 0) {
+    iphdr->flowid() = pinfo->fid;
+  }
+
+  /*
+   * A packet coming in from click on the kernel tap device is
+   * considered to be going up into the node, on any other device
+   * going down out of it.
+   */
+  if (ExtRouter::IFID_KERNELTAP == ifid) {
+    chdr->direction() = hdr_cmn::UP;
+  }
+  else {
+    chdr->direction() = hdr_cmn::DOWN;
+    // Going out to a network adapter, and we're already 
+    // ethernet encapsulated. The ns-2 interface code will
+    // tack on ethernet header overhead as well, so we subtract
+    // it out of our simulated size here to avoid actual packet
+    // size inflation
+    if (hdr_raw::ETHERNET == rhdr->subtype) {
+      chdr->size() -= NS_ETHER_HEADER_SIZE;
+    }
+  }
+
+  // If we've got ethernet encapsulation, translate mac address
+  // to ns address. Otherwise we're SOL.
+  struct hdr_mac* mhdr = HDR_MAC(pkt);
+  if (hdr_raw::ETHERNET == rhdr->subtype) {
+    MACAddr dmac(data + NS_ETHER_OFFSET_DADDR);
+    MACAddr smac(data + NS_ETHER_OFFSET_SADDR);
+    if (dmac.is_broadcast()) {
+      mhdr->macDA_ = MAC_BROADCAST;
+    }
+    else {
+      mhdr->macDA_ = global_mactonsmacmap_[dmac];
+      //fprintf(stderr,"XXX using real MAC: %s -> %d\n",dmac.to_string().c_str(),mhdr->macDA_);
+    }
+    mhdr->macSA_ = global_mactonsmacmap_[smac];
+    chdr->next_hop_ = global_mactonodemap_[dmac];
+    chdr->prev_hop_ = global_mactonodemap_[smac];
+  }
+  else {
+    //fprintf(stderr,"XXX using broadcast mac XXX\n");
+    mhdr->macDA_ = MAC_BROADCAST;
+  }
+
+  // Got an IP packet? Must have come from click, and therefore
+  // the next hop is us.
+  if ((ExtRouter::IFID_KERNELTAP == ifid) && (hdr_raw::IP == rhdr->subtype)) {
+    chdr->next_hop() = nodeaddr_;
+  }
+
+  return pkt;
+}
+
+struct timeval
+ClickClassifier::GetSimTime() {
+  struct timeval curtime;
+  double ns2time = Scheduler::instance().clock();
+  double fracp,intp;
+  fracp = modf(ns2time,&intp);
+  curtime.tv_sec = (long) intp;
+  curtime.tv_usec = (long) (fracp * 1.0e6 + 0.5); 
+  return curtime;
+}
+
+void
+ClickClassifier::trace(char* fmt, ...)
+{
+	va_list ap;
+
+	if ( !logtarget_ ) {
+		printf( "ClickClassifier: need to configure tracetarget\n" );
+		return ;
+	}
+	va_start( ap, fmt );
+	vsprintf( logtarget_->pt_->buffer(), fmt, ap );
+	logtarget_->pt_->dump();
+	va_end( ap );
+}
+
+int
+ClickClassifier::GetNextPktID()
+{
+	return Agent::getnextuid();
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/classifier/classifier-click.h ns-2.30/classifier/classifier-click.h
--- ns-2.30-pure/classifier/classifier-click.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/classifier/classifier-click.h	2006-12-30 17:22:28.000000000 -0800
@@ -0,0 +1,168 @@
+/*
+ *
+ * This might not seem like a regular classifier, and it isn't.
+ * It essentially has a fixed interface ID which it sends along
+ * with its packet to the ClickNode it lives on, the idea being
+ * that the Click subsystem will be the thing which actually
+ * does the classifying, not the classifier.
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#ifndef ns_classifier_click_h
+#define ns_classifier_click_h
+
+#include "object.h"
+#include "cmu-trace.h"
+
+class Packet;
+
+
+class ClickEvent : public Event {
+ public:
+  simclick_click clickinst_;
+  // Store an extra copy of the call time in sec/usec format.
+  // This is to sidestep some roundoff errors which occured
+  // when going back and forth between sec/usec and doubles.
+  struct timeval when_;
+};
+
+class ClickEventHandler : public Handler {
+ public:
+  virtual void handle(Event* event);
+};
+
+class MACAddr {
+ public:
+  MACAddr() {
+    memset(macaddr_,0,6);
+  }
+  explicit MACAddr(const string straddr) {
+      unsigned crap[6];
+      sscanf(straddr.c_str(), "%02X:%02X:%02X:%02X:%02X:%02X", &crap[0],
+	     &crap[1], &crap[2], &crap[3], &crap[4], &crap[5]);
+      for (int i = 0; i < 6; i++)
+	  macaddr_[i] = crap[i];
+  }  
+  explicit MACAddr(const unsigned char* rawaddr) {
+    memcpy(macaddr_,rawaddr,6);
+  }
+  bool operator==(const MACAddr& rhs) const {
+    return(0 == memcmp(macaddr_,rhs.macaddr_,6));
+  }
+
+  bool is_broadcast() {
+    for (int i=0;i<6;i++) {
+      if (macaddr_[i] != 0xff) {
+	return false;
+      }
+    }
+    return true;
+  }
+
+  string to_string() {
+    char tmp[64];
+    sprintf(tmp, "%02X:%02X:%02X:%02X:%02X:%02X", macaddr_[0],
+	   macaddr_[1], macaddr_[2], macaddr_[3], macaddr_[4],
+	   macaddr_[5]);
+
+    return string(tmp);
+  }
+  unsigned char macaddr_[6];
+};
+
+namespace std {
+template<>
+struct less<MACAddr> {
+  bool operator()(const MACAddr& l, const MACAddr& r) const {
+    // Treat MAC as a big old integer...
+    uint32_t leftu = *((uint32_t*)(l.macaddr_));
+    uint32_t rightu = *((uint32_t*)(r.macaddr_));
+    uint16_t leftl = *((uint16_t*)(l.macaddr_+4));
+    uint16_t rightl = *((uint16_t*)(r.macaddr_+4));
+    
+    // Check the upper bytes first, if those are equal check lower
+    if (leftu < rightu) {
+      return true;
+    }
+    else if (leftu == rightu) {
+      return (leftl < rightl);
+    }
+    return false;
+  }
+};
+}
+
+class ClickClassifier : public ExtClassifier,public ExtRouter {
+ public:
+  ClickClassifier();
+  virtual ~ClickClassifier();
+  virtual int command(int argc, const char*const* argv);
+  
+  /*
+   * Stuff to handle click requests
+   */
+ public:
+  virtual int send_to_if(int ifid,int type,const unsigned char* data,
+			 int len,simclick_simpacketinfo* pinfo);
+  ClickEventHandler cevhandler_;
+
+  // ExtRouter method
+  virtual int route(Packet* p);
+
+  string GetIPAddr(int ifid);
+  string GetMACAddr(int ifid);
+  string GetNodeName();
+  int GetNodeAddr(); /// ToNSTrace
+  int IFReady(int ifid);
+  simclick_click GetClickinst() { return clickinst_; }
+  static void LinkLayerFailedCallback(Packet* p, void* arg);
+  void LinkLayerFailed(Packet* p);
+  void trace(char* fmt, ...); /// ToNSTrace
+  int GetNextPktID(); /// ToNSTrace
+ protected:
+  int GetNSSubtype(int clicktype);
+  int GetClickPacketType(int nssubtype);
+  struct timeval GetSimTime();
+  Packet* MakeRawPacket(int type,int ifid,const unsigned char* data,int len,
+			simclick_simpacketinfo* pinfo);
+  simclick_click clickinst_;
+  typedef map<int,string> STRmap;
+  map<int,string> ifipaddrs_;
+  map<int,string> ifmacaddrs_;
+  static map<MACAddr,int> global_mactonodemap_;
+  static map<MACAddr,int> global_mactonsmacmap_;
+  static map<u_int32_t,int> global_ipmap_;
+  string nodename_;
+  int nodeaddr_;
+
+
+
+  //mvhaen -- meant to allow a click router to add to an ns2 trace file.
+  Trace *logtarget_;
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/classifier/classifier-ext.cc ns-2.30/classifier/classifier-ext.cc
--- ns-2.30-pure/classifier/classifier-ext.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/classifier/classifier-ext.cc	2006-12-30 17:22:28.000000000 -0800
@@ -0,0 +1,160 @@
+/*
+ * classifier-ext.cc
+ * Base external router classifier
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#include <stdlib.h>
+#include "config.h"
+#include "packet.h"
+#include "ip.h"
+#include "extrouter.h"
+#include "classifier.h"
+#include "classifier-hash.h"
+#include "classifier-ext.h"
+
+
+static class ExtClassifierClass : public TclClass {
+public:
+  ExtClassifierClass() : TclClass("Classifier/Ext") {}
+  TclObject* create(int, const char*const*) {
+    return (new ExtClassifier());
+  }
+} class_ext_classifier;
+
+
+ExtClassifier::ExtClassifier() {
+  extrouter_ = NULL;
+}
+
+ExtClassifier::~ExtClassifier() {
+}
+
+int ExtClassifier::command(int argc, const char*const* argv) {
+  int result = TCL_OK;
+  Tcl& tcl = Tcl::instance();
+
+  result = Classifier::command(argc,argv);
+  return result;
+}
+
+void ExtClassifier::recv(Packet* p, Handler* h) {
+  /*
+   * Use the interface and direction to decide what to do. If the
+   * packet is going down and came from an agent, it needs to
+   * go to the external router for processing. If coming up
+   * from the external router it needs to be sent to the appropriate
+   * local agent for processing. Otherwise, it just goes either down
+   * to the ns network interface or up to the external router.
+   */
+  struct hdr_cmn* hdr = HDR_CMN(p);
+  int extid = hdr->iface();
+  if (hdr_cmn::DOWN == hdr->direction()) {
+    if (ExtRouter::IFID_KERNELTAP == extid) {
+      /*
+       * Packet came from an agent - needs to go to the external router
+       */
+      //fprintf(stderr,"To external router\n");
+      if (NULL != extrouter_) {
+	extrouter_->route(p);
+      }
+      else {
+	fprintf(stderr,"No external router set!\n");
+      }
+    }
+    else {
+      /*
+       * Packet came from the external router - needs to go to the net
+       */
+      int cl = classify(p);
+      if ((cl >= 0) && (cl <= maxslot_)) {
+	NsObject* target = NULL;
+	target = slot_[cl];
+	if (NULL == target) {
+	  /*
+	   * "Drop" the packet
+	   */
+	  //puts("Dropping the packet");
+	  Packet::free(p);
+	}
+	else {
+	  //puts("Sending packet out!!!");
+	  target->recv(p,h);
+	}
+      }
+      else {
+	fprintf(stderr,"Invalid slot: %d maxslot is %d\n",cl,maxslot_);
+      }
+    }
+  }
+  else if (hdr_cmn::UP == hdr->direction()) {
+    if (ExtRouter::IFID_KERNELTAP == extid) {
+      /*
+       * Packet came from the external router - needs to go to an agent.
+       */
+      NsObject* target = NULL;
+      target = slot_[0];
+      if (NULL == target) {
+	/*
+	 * "Drop" the packet
+	 */
+	//fprintf(stderr,"Dropping the packet\n");
+	Packet::free(p);
+      }
+      else {
+	//fprintf(stderr,"Packet going to agent\n");
+	target->recv(p,h);
+      }
+
+      //fprintf(stderr,"Hey! Send packets to agents!\n");
+    }
+    else {
+      /*
+       * Packet came from the net - needs to go to the external router
+       */
+      if (NULL != extrouter_) {
+	extrouter_->route(p);
+      }
+    }
+  }
+  else {
+    fprintf(stderr,"No packet direction set...");
+  }
+}
+
+int
+ExtClassifier::classify(Packet* p) {
+  struct hdr_cmn* hdr = HDR_CMN(p);
+  int extid = hdr->iface();
+
+  /*
+   * Simple  mapping between extid and slot number.
+   * No real reason to make things more complicated right now.
+   */
+  int slot = extid;
+  return slot;
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/classifier/classifier-ext.h ns-2.30/classifier/classifier-ext.h
--- ns-2.30-pure/classifier/classifier-ext.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/classifier/classifier-ext.h	2006-12-30 17:22:28.000000000 -0800
@@ -0,0 +1,57 @@
+/*
+ *
+ * This classifier is intended for use with external routers bolted
+ * on to ns-2, e.g. Click. It uses a combination of the packet direction
+ * and interface ID to decide where to send stuff.
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#ifndef ns_classifier_ext_h
+#define ns_classifier_ext_h
+
+#include "object.h"
+
+class Packet;
+
+class ExtClassifier : public Classifier {
+ public:
+	ExtClassifier();
+	virtual ~ExtClassifier();
+	
+	virtual void recv(Packet* p, Handler* h);
+
+	void setExtRouter(ExtRouter* ext) {extrouter_ = ext;}
+	ExtRouter* getExtRouter() {return extrouter_;}
+
+	virtual int classify(Packet*);
+
+ protected:
+	virtual int command(int argc, const char*const* argv);
+	ExtRouter* extrouter_;
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/common/agent.cc ns-2.30/common/agent.cc
--- ns-2.30-pure/common/agent.cc	2006-09-24 22:11:00.000000000 -0700
+++ ns-2.30/common/agent.cc	2006-12-30 17:22:28.000000000 -0800
@@ -43,6 +43,7 @@
 #include "config.h"
 #include "agent.h"
 #include "ip.h"
+#include "tcp.h"
 #include "flags.h"
 #include "address.h"
 #include "app.h"
@@ -51,7 +52,14 @@
 #include "nix/nixnode.h"
 #endif //HAVE_STL
 
+#include "rawpacket.h"
+#include "extrouter.h"
 
+#include <click/config.h>
+#include <click/confparse.hh>
+#include <clicknet/ip.h>
+#include <clicknet/tcp.h>
+#include <clicknet/udp.h>
 
 #ifndef min
 #define min(a, b) (((a) < (b)) ? (a) : (b))
@@ -70,7 +78,7 @@
 Agent::Agent(packet_t pkttype) : 
 	size_(0), type_(pkttype), 
 	channel_(0), traceName_(NULL),
-	oldValueList_(NULL), app_(0), et_(0)
+	oldValueList_(NULL), app_(0), rawcvt_(false), et_(0)
 {
 }
 
@@ -170,6 +178,24 @@
 		} else if (strcmp(argv[1], "set_pkttype") == 0) {
 			set_pkttype(packet_t(atoi(argv[2])));
 			return (TCL_OK);
+		} else if (strcmp(argv[1], "set-srcip") == 0) {
+			if (!Click::cp_ip_address(Click::String(argv[2]), (unsigned char *) &srcip_))
+				return TCL_ERROR;
+			return (TCL_OK);
+		} else if (strcmp(argv[1], "set-srcport") == 0) {
+			srcport_ = atoi(argv[2]);
+			return (TCL_OK);
+		}
+		else if (strcmp(argv[1], "set-destip") == 0) {
+			if (!Click::cp_ip_address(Click::String(argv[2]), (unsigned char *) &destip_))
+				return TCL_ERROR;
+			return (TCL_OK);
+		} else if (strcmp(argv[1], "set-destport") == 0) {
+			destport_ = atoi(argv[2]);
+			return (TCL_OK);
+		} else if (strcmp(argv[1],"rawconvert") == 0) {
+			rawcvt_ = atoi(argv[2]);
+			return(TCL_OK);
 		}
 	}
 	else if (argc == 4) {	
@@ -438,10 +464,140 @@
 {
 }
 
+bool
+Agent::toraw(Packet* p) {
+	// XXX What about AppData and other such junk? Need to
+	// figure out if anyone actually sends payloads.
+	// XXX What about TCP option headers? Won't work with SACK right now
+	bool result = false;
+	struct hdr_tcp* htcp = HDR_TCP(p);
+	struct hdr_ip* hip = HDR_IP(p);
+	struct hdr_cmn* hcmn = HDR_CMN(p);
+	struct hdr_raw* hraw = hdr_raw::access(p);
+	int packetlen = sizeof(click_ip) + hcmn->size_;
+	int paylen = hcmn->size_;
+	unsigned char* pdat = 0;
+
+	// build packet length
+	if (hcmn->ptype_ == PT_ACK || hcmn->ptype_ == PT_TCP)
+		packetlen += sizeof(click_tcp);
+	else if (hcmn->ptype_ == PT_CBR)
+		packetlen += sizeof(click_udp);
+	else
+		return false;
+
+	// build packet
+	p->allocdata(packetlen);
+	pdat = p->accessdata();
+	memset(pdat, 0, packetlen);
+
+	// build IP header
+	click_ip *ip = (click_ip *) pdat;
+	ip->ip_v = 4;
+	ip->ip_hl = sizeof(click_ip) >> 2;
+	ip->ip_len = htons(packetlen);
+	ip->ip_id = htons(ipseq_);
+	ip->ip_p = (hcmn->ptype_ == PT_CBR ? IP_PROTO_UDP : IP_PROTO_TCP);
+	ip->ip_src.s_addr = srcip_;
+	ip->ip_dst.s_addr = destip_;
+	ip->ip_tos = 0;
+	ip->ip_off = 0;
+	ip->ip_ttl = hip->ttl_;
+	ip->ip_sum = 0;
+#if HAVE_FAST_CHECKSUM
+	ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
+#else
+	ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
+#endif
+
+	// build TCP/UDP header and payload
+	if (paylen > 0)
+		memset(pdat + (packetlen - paylen), 'A', paylen);
+	
+	if (hcmn->ptype_ == PT_CBR) {
+		click_udp *udp = (click_udp *) (ip + 1);
+		udp->uh_sport = htons(srcport_);
+		udp->uh_dport = htons(destport_);
+		uint16_t len = packetlen - sizeof(click_ip);
+		udp->uh_ulen = htons(len); 
+		udp->uh_sum = 0;
+		unsigned csum = click_in_cksum((unsigned char *)udp, len);
+		udp->uh_sum = click_in_cksum_pseudohdr(csum, ip, len);
+	} else {
+		click_tcp *tcp = (click_tcp *) (ip + 1);
+		tcp->th_sport = htons(srcport_);
+		tcp->th_dport = htons(destport_);
+		tcp->th_seq = htonl(htcp->seqno_);
+		tcp->th_ack = htonl(htcp->ackno_);
+		tcp->th_flags2 = 0;
+		tcp->th_off = sizeof(click_tcp) >> 2;
+		tcp->th_flags = htcp->tcp_flags_;
+		if (hcmn->ptype_ == PT_ACK)
+			tcp->th_flags |= TH_ACK;
+		tcp->th_win = 0; /* XXX */
+		tcp->th_urp = 0;
+		tcp->th_sum = 0;
+		uint16_t len = packetlen - sizeof(click_ip);
+		unsigned csum = click_in_cksum((unsigned char *)tcp, len);
+		tcp->th_sum = click_in_cksum_pseudohdr(csum, ip, len);
+	}
+
+	hcmn->direction() = hdr_cmn::DOWN;
+	hcmn->iface() = ExtRouter::IFID_KERNELTAP;
+	hraw->subtype = hdr_raw::IP;
+	hraw->ns_type = hcmn->ptype();
+	hcmn->ptype() = PT_RAW;
+	hcmn->size() = packetlen;
+	ipseq_++;
+
+	return result;
+}
+
+bool
+Agent::fromraw(Packet* p) {
+	struct hdr_tcp* htcp = HDR_TCP(p);
+	struct hdr_ip* hip = HDR_IP(p);
+	struct hdr_cmn* hcmn = HDR_CMN(p);
+	struct hdr_flags* hflg = hdr_flags::access(p);
+	struct click_ip* ip = 0;
+	struct click_tcp* tcp = 0;
+	struct click_udp* udp = 0;
+	unsigned char* pdat = 0;
+	bool result = false;
+
+	if (PT_RAW != hcmn->ptype()) return false;
+
+	pdat = p->accessdata();
+	ip = (click_ip*)pdat;
+
+	switch (ip->ip_p) {
+	case IPPROTO_TCP:
+		tcp = (click_tcp*)(pdat + (ip->ip_hl << 2));
+		htcp->seqno_ = ntohl(tcp->th_seq);
+		htcp->ackno_ = ntohl(tcp->th_ack);
+		htcp->tcp_flags_ = tcp->th_flags;
+		htcp->hlen_ = (ip->ip_hl << 2) + (tcp->th_off << 2);
+		hcmn->ptype_ = (tcp->th_flags & TH_ACK) ? PT_ACK : PT_TCP;
+		result = true;
+		break;
+	case IPPROTO_UDP:
+		hcmn->ptype_ = PT_CBR;
+		result = true;
+		break;
+	default:
+		result = false;
+		break;
+	}
+
+	return result;
+}
+
 void Agent::recv(Packet* p, Handler*)
 {
-	if (app_)
+	if (app_) {
+		if (rawcvt_) fromraw(p);
 		app_->recv(hdr_cmn::access(p)->size());
+	}
 	/*
 	 * didn't expect packet (or we're a null agent?)
 	 */
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/common/agent.h ns-2.30/common/agent.h
--- ns-2.30-pure/common/agent.h	2006-09-24 22:10:59.000000000 -0700
+++ ns-2.30/common/agent.h	2006-12-30 17:22:28.000000000 -0800
@@ -43,6 +43,7 @@
 #include "ns-process.h"
 #include "app.h"
 //#include "basetrace.h"
+
 #define TIME_FORMAT "%.15g"
 // TIME_FORMAT is in basetrace.h, but including that header leads to problems
 
@@ -77,7 +78,14 @@
 	//added for edrop tracing - ratul
 	void recvOnly(Packet *) {};
 
-	void send(Packet* p, Handler* h) { target_->recv(p, h); }
+	void send(Packet* p, Handler* h) { 
+	  if (rawcvt_) toraw(p);
+	  target_->recv(p, h);
+	}
+
+        bool toraw(Packet* p);
+	bool fromraw(Packet* p);
+
 	virtual void timeout(int tno);
 
 	virtual void sendmsg(int sz, AppData*, const char* flags = 0);
@@ -102,6 +110,7 @@
 	inline nsaddr_t& dport() { return dst_.port_; }
 	void set_pkttype(packet_t pkttype) { type_ = pkttype; }
 	inline packet_t get_pkttype() { return type_; }
+	static int getnextuid() { return uidcnt_++; }
 
  protected:
 	int command(int argc, const char*const* argv);
@@ -135,6 +144,18 @@
 	OldValue *oldValueList_; 
 
 	Application *app_;		// ptr to application for callback
+	
+	// If this is set to "true" convert packets to and from
+	// raw format as they go to and from attached applications.
+	bool rawcvt_;
+	
+	// We also need to keep src and dest ip and port addresses
+	// around if we're going to use raw packets.
+	u_int16_t ipseq_;
+	u_long srcip_;
+	u_short srcport_;
+	u_long destip_;
+	u_short destport_;
 
 	virtual void trace(TracedVar *v);
 	void deleteAgentTrace();
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/common/clicknode.cc ns-2.30/common/clicknode.cc
--- ns-2.30-pure/common/clicknode.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/common/clicknode.cc	2006-12-30 17:22:28.000000000 -0800
@@ -0,0 +1,132 @@
+/*
+ * clicknode.cc 
+ * Base class for nsclick nodes.
+ *
+ * XXX Should probably move a bunch of the functionality in this
+ * class to a superclass, i.e. something called ExtNode, since a lot
+ * of this should work with most Ext routing stuff, not just click.
+ *
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "connector.h"
+#include "delay.h"
+#include "packet.h"
+#include "agent.h"
+#include "rawpacket.h"
+#include "random.h"
+#include "trace.h"
+#include "address.h"
+
+#include "arp.h"
+#include "topography.h"
+#include "ll.h"
+#include "mac.h"
+#include "propagation.h"
+#include "mobilenode.h"
+#include "phy.h"
+#include "wired-phy.h"
+#include "god.h"
+#include "extrouter.h"
+#include "extclickrouter.h"
+#include <sys/time.h>
+#include <click/simclick.h>
+#include "clicknode.h"
+
+
+static class ClickNodeClass : public TclClass {
+public:
+  ClickNodeClass() : TclClass("Node/MobileNode/ClickNode") {}
+  TclObject* create(int, const char*const*) {
+    ClickNode* thenode = new ClickNode;
+    if (!thenode) {
+      return NULL;
+    }
+
+    /*
+     * Do post-constructor initialization.
+     */
+    int result = thenode->cinit();
+    if (0 > result) {
+      delete thenode;
+      thenode = NULL;
+    }
+
+    return thenode;
+  }
+} class_clicknode;
+
+
+ClickNode::ClickNode(void) {
+}
+
+int
+ClickNode::cinit() {
+  int result = 0;
+  return result;
+}
+
+int
+ClickNode::command(int argc, const char*const* argv)
+{
+  Tcl& tcl = Tcl::instance();
+  if (2 == argc) {
+  }
+  else if (3 == argc) {
+    if(strcmp(argv[1], "addif") == 0) {
+      Phy* phyp = (Phy*)TclObject::lookup(argv[2]);
+      if(phyp == 0) {
+	return TCL_ERROR;
+      }
+      phyp->insertnode(&ifhead_);
+      phyp->setnode(this);
+      return TCL_OK;
+    }
+  }
+  else if (4 == argc) {
+  }
+  else if (5 == argc) {
+  }
+
+  return MobileNode::command(argc, argv);
+}
+
+
+/* ======================================================================
+   Other class functions
+   ====================================================================== */
+void
+ClickNode::dump(void) {
+  printf("Dumping a clicknode...\n");
+}
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/common/clicknode.h ns-2.30/common/clicknode.h
--- ns-2.30-pure/common/clicknode.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/common/clicknode.h	2006-12-30 17:22:28.000000000 -0800
@@ -0,0 +1,64 @@
+/*
+ * clicknode.h
+ *
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#ifndef __ns_clicknode_h__
+#define __ns_clicknode_h__
+
+#include "object.h"
+#include "trace.h"
+#include "lib/bsd-list.h"
+#include "node.h"
+
+class ClickNode : public MobileNode
+{
+
+public:
+  ClickNode();
+  virtual int cinit();
+  virtual int command(int argc, const char*const* argv);
+  inline ClickNode* nextnode() { return link_.le_next; }
+  
+  void dump(void);
+  
+private:
+
+  /*
+   * A global list of click nodes
+   */
+  LIST_ENTRY(ClickNode) link_;
+  
+  /*
+   * Trace Target
+   */
+  Trace* log_target_;
+
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/common/packet-stamp.h ns-2.30/common/packet-stamp.h
--- ns-2.30-pure/common/packet-stamp.h	2006-09-24 22:11:00.000000000 -0700
+++ ns-2.30/common/packet-stamp.h	2006-12-30 17:22:28.000000000 -0800
@@ -23,6 +23,7 @@
 public:
 
   PacketStamp() : ant(0), node(0), Pr(-1), lambda(-1) { }
+  void clear() { ant = 0; node = 0; Pr = -1; lambda = -1; }
 
   void init(const PacketStamp *s) {
 	  Antenna* ant;
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/common/packet.h ns-2.30/common/packet.h
--- ns-2.30-pure/common/packet.h	2006-09-24 22:11:00.000000000 -0700
+++ ns-2.30/common/packet.h	2006-12-30 17:22:28.000000000 -0800
@@ -170,6 +170,9 @@
 	// Bell Labs Traffic Trace Type (PackMime OL)
 	PT_BLTRACE, 
 
+	// nsclick RAW packet
+	PT_RAW,
+
 	// insert new packet types here
 	PT_NTYPE // This MUST be the LAST one
 };
@@ -177,6 +180,7 @@
 class p_info {
 public:
 	p_info() {
+		name_[PT_RAW] = "raw";
 		name_[PT_TCP]= "tcp";
 		name_[PT_UDP]= "udp";
 		name_[PT_CBR]= "cbr";
@@ -539,6 +543,7 @@
 inline void Packet::init(Packet* p)
 {
 	bzero(p->bits_, hdrlen_);
+	p->txinfo_.clear();
 }
 
 inline Packet* Packet::alloc()
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/common/packet.h.orig ns-2.30/common/packet.h.orig
--- ns-2.30-pure/common/packet.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/common/packet.h.orig	2006-09-24 22:11:00.000000000 -0700
@@ -0,0 +1,650 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) $Header: /home/kohler/click-cvsroot-copy/release/one/etc/ns-2.30-patch,v 1.1 2006/12/31 01:54:25 eddietwo Exp $ (LBL)
+ */
+
+#ifndef ns_packet_h
+#define ns_packet_h
+
+#include <string.h>
+#include <assert.h>
+
+#include "config.h"
+#include "scheduler.h"
+#include "object.h"
+#include "lib/bsd-list.h"
+#include "packet-stamp.h"
+#include "ns-process.h"
+
+// Used by wireless routing code to attach routing agent
+#define RT_PORT		255	/* port that all route msgs are sent to */
+
+#define HDR_CMN(p)      (hdr_cmn::access(p))
+#define HDR_ARP(p)      (hdr_arp::access(p))
+#define HDR_MAC(p)      (hdr_mac::access(p))
+#define HDR_MAC802_11(p) ((hdr_mac802_11 *)hdr_mac::access(p))
+#define HDR_MAC_TDMA(p) ((hdr_mac_tdma *)hdr_mac::access(p))
+#define HDR_SMAC(p)     ((hdr_smac *)hdr_mac::access(p))
+#define HDR_LL(p)       (hdr_ll::access(p))
+#define HDR_HDLC(p)     ((hdr_hdlc *)hdr_ll::access(p))
+#define HDR_IP(p)       (hdr_ip::access(p))
+#define HDR_RTP(p)      (hdr_rtp::access(p))
+#define HDR_TCP(p)      (hdr_tcp::access(p))
+#define HDR_SCTP(p)     (hdr_sctp::access(p))
+#define HDR_SR(p)       (hdr_sr::access(p))
+#define HDR_TFRC(p)     (hdr_tfrc::access(p))
+#define HDR_TORA(p)     (hdr_tora::access(p))
+#define HDR_IMEP(p)     (hdr_imep::access(p))
+#define HDR_CDIFF(p)    (hdr_cdiff::access(p))  /* chalermak's diffusion*/
+//#define HDR_DIFF(p)     (hdr_diff::access(p))  /* SCADD's diffusion ported into ns */
+#define HDR_LMS(p)		(hdr_lms::access(p))
+
+/* --------------------------------------------------------------------*/
+
+enum packet_t {
+	PT_TCP,
+	PT_UDP,
+	PT_CBR,
+	PT_AUDIO,
+	PT_VIDEO,
+	PT_ACK,
+	PT_START,
+	PT_STOP,
+	PT_PRUNE,
+	PT_GRAFT,
+	PT_GRAFTACK,
+	PT_JOIN,
+	PT_ASSERT,
+	PT_MESSAGE,
+	PT_RTCP,
+	PT_RTP,
+	PT_RTPROTO_DV,
+	PT_CtrMcast_Encap,
+	PT_CtrMcast_Decap,
+	PT_SRM,
+	/* simple signalling messages */
+	PT_REQUEST,	
+	PT_ACCEPT,	
+	PT_CONFIRM,	
+	PT_TEARDOWN,	
+	PT_LIVE,	// packet from live network
+	PT_REJECT,
+
+	PT_TELNET,	// not needed: telnet use TCP
+	PT_FTP,
+	PT_PARETO,
+	PT_EXP,
+	PT_INVAL,
+	PT_HTTP,
+
+	/* new encapsulator */
+	PT_ENCAPSULATED,
+	PT_MFTP,
+
+	/* CMU/Monarch's extnsions */
+	PT_ARP,
+	PT_MAC,
+	PT_TORA,
+	PT_DSR,
+	PT_AODV,
+	PT_IMEP,
+
+	// RAP packets
+	PT_RAP_DATA,
+	PT_RAP_ACK,
+
+	PT_TFRC,
+	PT_TFRC_ACK,
+	PT_PING,
+
+	// Diffusion packets - Chalermek
+	PT_DIFF,
+
+	// LinkState routing update packets
+	PT_RTPROTO_LS,
+
+	// MPLS LDP header
+	PT_LDP,
+
+	// GAF packet
+        PT_GAF,  
+
+	// ReadAudio traffic
+	PT_REALAUDIO,
+
+	// Pushback Messages
+	PT_PUSHBACK,
+
+#ifdef HAVE_STL
+	// Pragmatic General Multicast
+	PT_PGM,
+#endif //STL
+
+	// LMS packets
+	PT_LMS,
+	PT_LMS_SETUP,
+
+	PT_SCTP,
+	PT_SCTP_APP1,
+
+	// SMAC packet
+	PT_SMAC,
+
+	// XCP packet
+	PT_XCP,
+	
+	// HDLC packet
+	PT_HDLC,
+
+	// Bell Labs Traffic Trace Type (PackMime OL)
+	PT_BLTRACE, 
+
+	// insert new packet types here
+	PT_NTYPE // This MUST be the LAST one
+};
+
+class p_info {
+public:
+	p_info() {
+		name_[PT_TCP]= "tcp";
+		name_[PT_UDP]= "udp";
+		name_[PT_CBR]= "cbr";
+		name_[PT_AUDIO]= "audio";
+		name_[PT_VIDEO]= "video";
+		name_[PT_ACK]= "ack";
+		name_[PT_START]= "start";
+		name_[PT_STOP]= "stop";
+		name_[PT_PRUNE]= "prune";
+		name_[PT_GRAFT]= "graft";
+		name_[PT_GRAFTACK]= "graftAck";
+		name_[PT_JOIN]= "join";
+		name_[PT_ASSERT]= "assert";
+		name_[PT_MESSAGE]= "message";
+		name_[PT_RTCP]= "rtcp";
+		name_[PT_RTP]= "rtp";
+		name_[PT_RTPROTO_DV]= "rtProtoDV";
+		name_[PT_CtrMcast_Encap]= "CtrMcast_Encap";
+		name_[PT_CtrMcast_Decap]= "CtrMcast_Decap";
+		name_[PT_SRM]= "SRM";
+
+		name_[PT_REQUEST]= "sa_req";	
+		name_[PT_ACCEPT]= "sa_accept";
+		name_[PT_CONFIRM]= "sa_conf";
+		name_[PT_TEARDOWN]= "sa_teardown";
+		name_[PT_LIVE]= "live"; 
+		name_[PT_REJECT]= "sa_reject";
+
+		name_[PT_TELNET]= "telnet";
+		name_[PT_FTP]= "ftp";
+		name_[PT_PARETO]= "pareto";
+		name_[PT_EXP]= "exp";
+		name_[PT_INVAL]= "httpInval";
+		name_[PT_HTTP]= "http";
+		name_[PT_ENCAPSULATED]= "encap";
+		name_[PT_MFTP]= "mftp";
+		name_[PT_ARP]= "ARP";
+		name_[PT_MAC]= "MAC";
+		name_[PT_TORA]= "TORA";
+		name_[PT_DSR]= "DSR";
+		name_[PT_AODV]= "AODV";
+		name_[PT_IMEP]= "IMEP";
+
+		name_[PT_RAP_DATA] = "rap_data";
+		name_[PT_RAP_ACK] = "rap_ack";
+
+ 		name_[PT_TFRC]= "tcpFriend";
+		name_[PT_TFRC_ACK]= "tcpFriendCtl";
+		name_[PT_PING]="ping";
+
+	 	/* For diffusion : Chalermek */
+ 		name_[PT_DIFF] = "diffusion";
+
+		// Link state routing updates
+		name_[PT_RTPROTO_LS] = "rtProtoLS";
+
+		// MPLS LDP packets
+		name_[PT_LDP] = "LDP";
+
+		// for GAF
+                name_[PT_GAF] = "gaf";      
+
+		// RealAudio packets
+		name_[PT_REALAUDIO] = "ra";
+
+		//pushback 
+		name_[PT_PUSHBACK] = "pushback";
+
+#ifdef HAVE_STL
+		// for PGM
+		name_[PT_PGM] = "PGM";
+#endif //STL
+
+		// LMS entries
+		name_[PT_LMS]="LMS";
+		name_[PT_LMS_SETUP]="LMS_SETUP";
+
+		name_[PT_SCTP]= "sctp";
+ 		name_[PT_SCTP_APP1] = "sctp_app1";
+		
+		// smac
+		name_[PT_SMAC]="smac";
+
+		// HDLC
+		name_[PT_HDLC]="HDLC";
+
+		// XCP
+		name_[PT_XCP]="xcp";
+
+		// Bell Labs (PackMime OL)
+		name_[PT_BLTRACE]="BellLabsTrace";
+		
+		name_[PT_NTYPE]= "undefined";
+	}
+	const char* name(packet_t p) const { 
+		if ( p <= PT_NTYPE ) return name_[p];
+		return 0;
+	}
+	static bool data_packet(packet_t type) {
+		return ( (type) == PT_TCP || \
+			 (type) == PT_TELNET || \
+			 (type) == PT_CBR || \
+			 (type) == PT_AUDIO || \
+			 (type) == PT_VIDEO || \
+			 (type) == PT_ACK || \
+			 (type) == PT_SCTP || \
+			 (type) == PT_SCTP_APP1 || \
+			 (type) == PT_HDLC \
+			);
+	}
+private:
+	static char* name_[PT_NTYPE+1];
+};
+extern p_info packet_info; /* map PT_* to string name */
+//extern char* p_info::name_[];
+
+
+#define DATA_PACKET(type) ( (type) == PT_TCP || \
+                            (type) == PT_TELNET || \
+                            (type) == PT_CBR || \
+                            (type) == PT_AUDIO || \
+                            (type) == PT_VIDEO || \
+                            (type) == PT_ACK || \
+                            (type) == PT_SCTP || \
+                            (type) == PT_SCTP_APP1 \
+                            )
+
+
+//#define OFFSET(type, field)	((long) &((type *)0)->field)
+#define OFFSET(type, field) ( (char *)&( ((type *)256)->field )  - (char *)256)
+
+class PacketData : public AppData {
+public:
+	PacketData(int sz) : AppData(PACKET_DATA) {
+		datalen_ = sz;
+		if (datalen_ > 0)
+			data_ = new unsigned char[datalen_];
+		else
+			data_ = NULL;
+	}
+	PacketData(PacketData& d) : AppData(d) {
+		datalen_ = d.datalen_;
+		if (datalen_ > 0) {
+			data_ = new unsigned char[datalen_];
+			memcpy(data_, d.data_, datalen_);
+		} else
+			data_ = NULL;
+	}
+	virtual ~PacketData() { 
+		if (data_ != NULL) 
+			delete []data_; 
+	}
+	unsigned char* data() { return data_; }
+
+	virtual int size() const { return datalen_; }
+	virtual AppData* copy() { return new PacketData(*this); }
+private:
+	unsigned char* data_;
+	int datalen_;
+};
+
+//Monarch ext
+typedef void (*FailureCallback)(Packet *,void *);
+
+class Packet : public Event {
+private:
+	unsigned char* bits_;	// header bits
+//	unsigned char* data_;	// variable size buffer for 'data'
+//  	unsigned int datalen_;	// length of variable size buffer
+	AppData* data_;		// variable size buffer for 'data'
+	static void init(Packet*);     // initialize pkt hdr 
+	bool fflag_;
+protected:
+	static Packet* free_;	// packet free list
+	int	ref_count_;	// free the pkt until count to 0
+public:
+	Packet* next_;		// for queues and the free list
+	static int hdrlen_;
+
+	Packet() : bits_(0), data_(0), ref_count_(0), next_(0) { }
+	inline unsigned char* const bits() { return (bits_); }
+	inline Packet* copy() const;
+	inline Packet* refcopy() { ++ref_count_; return this; }
+	inline int& ref_count() { return (ref_count_); }
+	static inline Packet* alloc();
+	static inline Packet* alloc(int);
+	inline void allocdata(int);
+	// dirty hack for diffusion data
+	inline void initdata() { data_  = 0;}
+	static inline void free(Packet*);
+	inline unsigned char* access(int off) const {
+		if (off < 0)
+			abort();
+		return (&bits_[off]);
+	}
+	// This is used for backward compatibility, i.e., assuming user data
+	// is PacketData and return its pointer.
+	inline unsigned char* accessdata() const { 
+		if (data_ == 0)
+			return 0;
+		assert(data_->type() == PACKET_DATA);
+		return (((PacketData*)data_)->data()); 
+	}
+	// This is used to access application-specific data, not limited 
+	// to PacketData.
+	inline AppData* userdata() const {
+		return data_;
+	}
+	inline void setdata(AppData* d) { 
+		if (data_ != NULL)
+			delete data_;
+		data_ = d; 
+	}
+	inline int datalen() const { return data_ ? data_->size() : 0; }
+
+	// Monarch extn
+
+	static void dump_header(Packet *p, int offset, int length);
+
+	// the pkt stamp carries all info about how/where the pkt
+        // was sent needed for a receiver to determine if it correctly
+        // receives the pkt
+        PacketStamp	txinfo_;  
+
+	/*
+         * According to cmu code:
+	 * This flag is set by the MAC layer on an incoming packet
+         * and is cleared by the link layer.  It is an ugly hack, but
+         * there's really no other way because NS always calls
+         * the recv() function of an object.
+	 * 
+         */
+        u_int8_t        incoming;
+
+	//monarch extns end;
+};
+
+/* 
+ * static constant associations between interface special (negative) 
+ * values and their c-string representations that are used from tcl
+ */
+class iface_literal {
+public:
+	enum iface_constant { 
+		UNKN_IFACE= -1, /* 
+				 * iface value for locally originated packets 
+				 */
+		ANY_IFACE= -2   /* 
+				 * hashnode with iif == ANY_IFACE_   
+				 * matches any pkt iface (imported from TCL);
+				 * this value should be different from 
+				 * hdr_cmn::UNKN_IFACE (packet.h)
+				 */ 
+	};
+	iface_literal(const iface_constant i, const char * const n) : 
+		value_(i), name_(n) {}
+	inline int value() const { return value_; }
+	inline const char * const name() const { return name_; }
+private:
+	const iface_constant value_;
+	/* strings used in TCL to access those special values */
+	const char * const name_; 
+};
+
+static const iface_literal UNKN_IFACE(iface_literal::UNKN_IFACE, "?");
+static const iface_literal ANY_IFACE(iface_literal::ANY_IFACE, "*");
+
+/*
+ * Note that NS_AF_* doesn't necessarily correspond with
+ * the constants used in your system (because many
+ * systems don't have NONE or ILINK).
+ */
+enum ns_af_enum { NS_AF_NONE, NS_AF_ILINK, NS_AF_INET };
+
+struct hdr_cmn {
+	enum dir_t { DOWN= -1, NONE= 0, UP= 1 };
+	packet_t ptype_;	// packet type (see above)
+	int	size_;		// simulated packet size
+	int	uid_;		// unique id
+	int	error_;		// error flag
+	int     errbitcnt_;     // # of corrupted bits jahn
+	int     fecsize_;
+	double	ts_;		// timestamp: for q-delay measurement
+	int	iface_;		// receiving interface (label)
+	dir_t	direction_;	// direction: 0=none, 1=up, -1=down
+	// source routing 
+        char src_rt_valid;
+	double ts_arr_; // Required by Marker of JOBS 
+
+	//Monarch extn begins
+	nsaddr_t prev_hop_;     // IP addr of forwarding hop
+	nsaddr_t next_hop_;	// next hop for this packet
+	int      addr_type_;    // type of next_hop_ addr
+	nsaddr_t last_hop_;     // for tracing on multi-user channels
+
+        // called if pkt can't obtain media or isn't ack'd. not called if
+        // droped by a queue
+        FailureCallback xmit_failure_; 
+        void *xmit_failure_data_;
+
+        /*
+         * MONARCH wants to know if the MAC layer is passing this back because
+         * it could not get the RTS through or because it did not receive
+         * an ACK.
+         */
+        int     xmit_reason_;
+#define XMIT_REASON_RTS 0x01
+#define XMIT_REASON_ACK 0x02
+
+        // filled in by GOD on first transmission, used for trace analysis
+        int num_forwards_;	// how many times this pkt was forwarded
+        int opt_num_forwards_;   // optimal #forwards
+	// Monarch extn ends;
+
+	// tx time for this packet in sec
+	double txtime_;
+	inline double& txtime() { return(txtime_); }
+
+	static int offset_;	// offset for this header
+	inline static int& offset() { return offset_; }
+	inline static hdr_cmn* access(const Packet* p) {
+		return (hdr_cmn*) p->access(offset_);
+	}
+	
+        /* per-field member functions */
+	inline packet_t& ptype() { return (ptype_); }
+	inline int& size() { return (size_); }
+	inline int& uid() { return (uid_); }
+	inline int& error() { return error_; }
+	inline int& errbitcnt() {return errbitcnt_; }
+	inline int& fecsize() {return fecsize_; }
+	inline double& timestamp() { return (ts_); }
+	inline int& iface() { return (iface_); }
+	inline dir_t& direction() { return (direction_); }
+	// monarch_begin
+	inline nsaddr_t& next_hop() { return (next_hop_); }
+	inline int& addr_type() { return (addr_type_); }
+	inline int& num_forwards() { return (num_forwards_); }
+	inline int& opt_num_forwards() { return (opt_num_forwards_); }
+        //monarch_end
+};
+
+
+class PacketHeaderClass : public TclClass {
+protected:
+	PacketHeaderClass(const char* classname, int hdrsize);
+	virtual int method(int argc, const char*const* argv);
+	void field_offset(const char* fieldname, int offset);
+	inline void bind_offset(int* off) { offset_ = off; }
+	inline void offset(int* off) {offset_= off;}
+	int hdrlen_;		// # of bytes for this header
+	int* offset_;		// offset for this header
+public:
+	virtual void bind();
+	virtual void export_offsets();
+	TclObject* create(int argc, const char*const* argv);
+};
+
+
+inline void Packet::init(Packet* p)
+{
+	bzero(p->bits_, hdrlen_);
+}
+
+inline Packet* Packet::alloc()
+{
+	Packet* p = free_;
+	if (p != 0) {
+		assert(p->fflag_ == FALSE);
+		free_ = p->next_;
+		assert(p->data_ == 0);
+		p->uid_ = 0;
+		p->time_ = 0;
+	} else {
+		p = new Packet;
+		p->bits_ = new unsigned char[hdrlen_];
+		if (p == 0 || p->bits_ == 0)
+			abort();
+	}
+	init(p); // Initialize bits_[]
+	(HDR_CMN(p))->next_hop_ = -2; // -1 reserved for IP_BROADCAST
+	(HDR_CMN(p))->last_hop_ = -2; // -1 reserved for IP_BROADCAST
+	p->fflag_ = TRUE;
+	(HDR_CMN(p))->direction() = hdr_cmn::DOWN;
+	/* setting all direction of pkts to be downward as default; 
+	   until channel changes it to +1 (upward) */
+	p->next_ = 0;
+	return (p);
+}
+
+/* 
+ * Allocate an n byte data buffer to an existing packet 
+ * 
+ * To set application-specific AppData, use Packet::setdata()
+ */
+inline void Packet::allocdata(int n)
+{
+	assert(data_ == 0);
+	data_ = new PacketData(n);
+	if (data_ == 0)
+		abort();
+}
+
+/* allocate a packet with an n byte data buffer */
+inline Packet* Packet::alloc(int n)
+{
+	Packet* p = alloc();
+	if (n > 0) 
+		p->allocdata(n);
+	return (p);
+}
+
+
+inline void Packet::free(Packet* p)
+{
+	if (p->fflag_) {
+		if (p->ref_count_ == 0) {
+			/*
+			 * A packet's uid may be < 0 (out of a event queue), or
+			 * == 0 (newed but never gets into the event queue.
+			 */
+			assert(p->uid_ <= 0);
+			// Delete user data because we won't need it any more.
+			if (p->data_ != 0) {
+				delete p->data_;
+				p->data_ = 0;
+			}
+			init(p);
+			p->next_ = free_;
+			free_ = p;
+			p->fflag_ = FALSE;
+		} else {
+			--p->ref_count_;
+		}
+	}
+}
+
+inline Packet* Packet::copy() const
+{
+	
+	Packet* p = alloc();
+	memcpy(p->bits(), bits_, hdrlen_);
+	if (data_) 
+		p->data_ = data_->copy();
+	p->txinfo_.init(&txinfo_);
+ 
+	return (p);
+}
+
+inline void
+Packet::dump_header(Packet *p, int offset, int length)
+{
+        assert(offset + length <= p->hdrlen_);
+        struct hdr_cmn *ch = HDR_CMN(p);
+
+        fprintf(stderr, "\nPacket ID: %d\n", ch->uid());
+
+        for(int i = 0; i < length ; i+=16) {
+                fprintf(stderr, "%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+                        p->bits_[offset + i],     p->bits_[offset + i + 1],
+                        p->bits_[offset + i + 2], p->bits_[offset + i + 3],
+                        p->bits_[offset + i + 4], p->bits_[offset + i + 5],
+                        p->bits_[offset + i + 6], p->bits_[offset + i + 7],
+                        p->bits_[offset + i + 8], p->bits_[offset + i + 9],
+                        p->bits_[offset + i + 10], p->bits_[offset + i + 11],
+                        p->bits_[offset + i + 12], p->bits_[offset + i + 13],
+                        p->bits_[offset + i + 14], p->bits_[offset + i + 15]);
+        }
+}
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/common/rawpacket.cc ns-2.30/common/rawpacket.cc
--- ns-2.30-pure/common/rawpacket.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/common/rawpacket.cc	2006-12-30 17:22:28.000000000 -0800
@@ -0,0 +1,205 @@
+/*
+ * rawpacket.cc
+ * Main file for the raw packet type
+ *
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#include <stdio.h>
+#include "agent.h"
+#include "packet.h"
+#include "rawpacket.h"
+#include "extrouter.h"
+
+#include <click/config.h>
+#include <click/confparse.hh>
+#include <clicknet/ip.h>
+#include <clicknet/udp.h>
+
+int hdr_raw::offset_;
+
+/*
+ * RawHeaderClass based on the ping example in the ns-2 tutorial.
+ */
+static class RawHeaderClass : public PacketHeaderClass {
+public:
+  RawHeaderClass() : PacketHeaderClass("PacketHeader/Raw",sizeof(hdr_raw)){
+    bind_offset(&hdr_raw::offset_);
+  }
+} class_rawhdr;
+
+static class RawClass : public TclClass {
+public:
+  RawClass() : TclClass("Agent/Raw") {}
+  TclObject* create(int,const char*const*) {
+    return (new RawAgent());
+  }
+} class_raw;
+  
+
+RawAgent::RawAgent() : Agent(PT_RAW) {
+  ipseq_ = 0;
+}
+
+int RawAgent::command(int argc,const char*const* argv) {
+  if (argc == 2) {
+    if (strcmp(argv[1], "send") == 0) {
+      char* testmsg = "Howdy Howdy Howdy\n";
+      send_udp_str(srcip_,srcport_,destip_,destport_,testmsg);
+      return (TCL_OK);
+    }
+  }
+  else if (argc == 3) {
+    if (strcmp(argv[1], "send") == 0) {
+      const char* testmsg = argv[2];
+      send_udp_str(srcip_,srcport_,destip_,destport_,testmsg);
+      return (TCL_OK);
+    }
+    if (strcmp(argv[1], "set-srcip") == 0) {
+	if (!Click::cp_ip_address(Click::String(argv[2]), (unsigned char *) &srcip_))
+	    return TCL_ERROR;
+	return (TCL_OK);
+    }
+    if (strcmp(argv[1], "set-srcport") == 0) {
+      srcport_ = atoi(argv[2]);
+      return (TCL_OK);
+    }
+    if (strcmp(argv[1], "set-destip") == 0) {
+	if (!Click::cp_ip_address(Click::String(argv[2]), (unsigned char *) &destip_))
+	    return TCL_ERROR;
+	return (TCL_OK);
+    }
+    if (strcmp(argv[1], "set-destport") == 0) {
+      destport_ = atoi(argv[2]);
+      return (TCL_OK);
+    }
+  }
+  else if (argc == 7) {
+    if (strcmp(argv[1],"send-udp") == 0) {
+      // saddr,sport,daddr,dport,payload
+      // For right now only text strings can be sent
+      // as payload.
+	u_long saddr, daddr;
+	if (!Click::cp_ip_address(Click::String(argv[2]), (unsigned char *) &saddr)
+	    || !Click::cp_ip_address(Click::String(argv[4]), (unsigned char *) &daddr))
+	    return TCL_ERROR;
+      u_short sport = atoi(argv[3]);
+      u_short dport = atoi(argv[5]);
+      send_udp_str(saddr,sport,daddr,dport,argv[6]);
+      // return TCL_OK, so the calling function knows that the
+      // command has been processed
+      return (TCL_OK);
+    }
+  }
+
+  // If the command hasn't been processed by RawAgent()::command,
+  // call the command() function for the base class
+  return (Agent::command(argc, argv));
+}
+
+void
+RawAgent::sendmsg(int nbytes, const char *flags) {
+  // Make a string full of 'A's and use it for the payload
+  char* stuff = new char[nbytes];
+  memset(stuff,'A',nbytes);
+  send_udp(srcip_,srcport_,destip_,destport_,stuff,nbytes);
+  delete[] stuff;
+  stuff = 0;
+}
+
+void
+RawAgent::send_udp_str(u_long saddr,u_short sport,u_long daddr,u_short dport,
+		       const char* payload) {
+  send_udp(saddr,sport,daddr,dport,payload,strlen(payload));
+}
+
+void
+RawAgent::send_udp(u_long saddr,u_short sport,u_long daddr,u_short dport,
+		   const char* payload,int paylen) {
+    int packetlen = paylen + sizeof(click_ip) + sizeof(click_udp);
+    Packet* pkt = allocpkt(packetlen);
+    hdr_cmn* hcmn = HDR_CMN(pkt);
+    hcmn->direction() = hdr_cmn::DOWN;
+    hcmn->iface() = ExtRouter::IFID_KERNELTAP;
+    hcmn->ptype() = PT_RAW;
+    hcmn->size() = packetlen;
+    // Access the raw header for the new packet:
+    hdr_raw* hdr = hdr_raw::access(pkt);
+    hdr->subtype = hdr_raw::IP;
+    hdr->ns_type = PT_RAW;
+    unsigned char* pdat = pkt->accessdata();
+    memset(pdat,0,packetlen);
+
+    click_ip *ip = reinterpret_cast<click_ip *>(pdat);
+    click_udp *udp = reinterpret_cast<click_udp *>(ip + 1);
+
+    // set up IP header
+    ip->ip_v = 4;
+    ip->ip_hl = sizeof(click_ip) >> 2;
+    ip->ip_len = htons(packetlen);
+    ip->ip_id = htons(ipseq_);
+    ip->ip_p = IP_PROTO_UDP;
+    ip->ip_src.s_addr = saddr;
+    ip->ip_dst.s_addr = daddr;
+    ip->ip_tos = 0;
+    ip->ip_off = 0;
+    ip->ip_ttl = 255;
+
+    ip->ip_sum = 0;
+#if HAVE_FAST_CHECKSUM
+    ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
+#else
+    ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
+#endif
+    
+    // set up UDP header
+    udp->uh_sport = htons(sport);
+    udp->uh_dport = htons(dport);
+    uint16_t len = packetlen - sizeof(click_ip);
+    udp->uh_ulen = htons(len);
+    udp->uh_sum = 0;
+    unsigned csum = click_in_cksum((unsigned char *)udp, len);
+    udp->uh_sum = click_in_cksum_pseudohdr(csum, ip, len);
+  
+    // Send the packet
+    send(pkt, 0);
+    ipseq_++;
+}
+
+void RawAgent::recv(Packet* pkt, Handler*)
+{
+  // Access the raw header for the received packet
+  hdr_raw* hdr = hdr_raw::access(pkt);
+
+  if (hdr_raw::PSTRING == hdr->subtype) {
+    unsigned char* pdat = pkt->accessdata();
+    unsigned int len = pdat[0];
+
+    // Shovel the string to the screen...
+    fwrite(pdat+1,sizeof(char),len,stdout);
+  }
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/common/rawpacket.h ns-2.30/common/rawpacket.h
--- ns-2.30-pure/common/rawpacket.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/common/rawpacket.h	2006-12-30 17:22:28.000000000 -0800
@@ -0,0 +1,90 @@
+/*
+ * rawpacket.h
+ *
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+/*
+ * Raw packet type. 
+ */
+struct hdr_raw {
+  /*
+   * This indicates the actual type of the stuff in the
+   * packet. The actual packet stuff is pointed to by 
+   * the data thing.
+   */
+  int subtype;
+
+  /*
+   * Not many raw subtypes defined so far.
+   */
+  enum {
+    NONE,
+    PSTRING,
+    IP,
+    ETHERNET,
+  };
+
+  /*
+   * This is the equivalent packet type in ns-2. Sometimes we
+   * want to maintain the raw packet data _and_ the ns-2 headers
+   * for that particular type in parallel, e.g. so we can use
+   * the existing ns-2 trace printing routines. However, we
+   * still want to keep the packet type as PT_RAW, so we store
+   * the ns-2 type in this field.
+   */
+  int ns_type;
+ 
+  /* Packet header access functions */
+  static int offset_;
+  inline static int& offset() { return offset_; }
+  inline static hdr_raw* access(const Packet* p) {
+    return (hdr_raw*) p->access(offset_);
+  }
+};
+
+/*
+ * The base RawAgent class
+ */
+class RawAgent : public Agent {
+ public:
+  RawAgent();
+  int command(int argc,const char*const* argv);
+  void recv(Packet*, Handler*);
+  virtual void sendmsg(int nbytes, const char *flags = 0);
+ protected:
+  void send_udp_str(u_long saddr,u_short sport,u_long daddr,u_short dport,
+		    const char* payload);
+  void send_udp(u_long saddr,u_short sport,u_long daddr,u_short dport,
+		const char* payload,int paylen);
+
+  u_int16_t ipseq_;
+  u_long srcip_;
+  u_short srcport_;
+  u_long destip_;
+  u_short destport_;
+};
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/conf/configure.in.click ns-2.30/conf/configure.in.click
--- ns-2.30-pure/conf/configure.in.click	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/conf/configure.in.click	2006-12-30 17:22:28.000000000 -0800
@@ -0,0 +1,29 @@
+dnl autoconf rules to find click - copied from dmalloc example
+
+AC_ARG_WITH(click,	--with-click=path specify a pathname for the click modular router, d="$withval", d="")
+
+CLICK_VERS=1.3
+
+CLICK_PATH="$PWD/../click \
+	$PWD/../../click \
+	$PWD/../click-$CLICK_VERS \
+	$PWD/../../click-$CLICK_VERS \
+	$PWD/../click/include \
+	$PWD/../../click/include \
+	$PWD/../click-$CLICK_VERS/include \
+	$PWD/../../click-$CLICK_VERS/include \
+	$PWD/../click/ns \
+	$PWD/../../click/ns \
+	$PWD/../click-$CLICK_VERS/ns \
+	$PWD/../../click-$CLICK_VERS/ns \
+	"
+CLICK_PATH_D="$d \
+	$d/lib \
+	$d/include \
+	"
+
+NS_BEGIN_PACKAGE(click)
+NS_CHECK_HEADER_PATH(click/simclick.h,$CLICK_PATH,$d,$CLICK_PATH_D,V_HEADER_CLICK,click)
+NS_CHECK_LIB_PATH(nsclick,$CLICK_PATH,$d,$CLICK_PATH_D,V_LIB_CLICK,click)
+V_DEFINES="-DCLICK_NS $V_DEFINES"
+NS_END_PACKAGE(click,yes)
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/configure ns-2.30/configure
--- ns-2.30-pure/configure	2006-09-24 22:11:19.000000000 -0700
+++ ns-2.30/configure	2006-12-30 17:22:28.000000000 -0800
@@ -873,6 +873,7 @@
 --with-tclcl=path	specify a pathname for TclCL (the ex-libTcl)
 --with-tcldebug=path specify a pathname for the tcl debugger (path=no disables the debugger)
 --with-dmalloc=path specify a pathname for the dmalloc debugger (path=no disables the dmalloc)
+--with-click=path specify a pathname for the click modular router
 --with-perl=path specify a pathname for perl
 
 Some influential environment variables:
@@ -977,7 +978,7 @@
     else
       echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi
-    cd "$ac_popdir"
+    cd $ac_popdir
   done
 fi
 
@@ -2085,7 +2086,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2143,7 +2145,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2259,7 +2262,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2313,7 +2317,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2358,7 +2363,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2402,7 +2408,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2586,7 +2593,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2644,7 +2652,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2715,7 +2724,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -2759,7 +2769,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3076,7 +3087,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3246,7 +3258,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3313,7 +3326,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3470,7 +3484,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3537,7 +3552,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3604,7 +3620,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3671,7 +3688,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3738,7 +3756,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -3841,7 +3860,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4008,7 +4028,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4065,7 +4086,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4122,7 +4144,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4179,7 +4202,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -4236,7 +4260,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6242,6 +6267,207 @@
 
 
 
+
+
+# Check whether --with-click or --without-click was given.
+if test "${with_click+set}" = set; then
+  withval="$with_click"
+  d="$withval"
+else
+  d=""
+fi;
+
+CLICK_VERS=1.3
+
+CLICK_PATH="$PWD/../click \
+	$PWD/../../click \
+	$PWD/../click-$CLICK_VERS \
+	$PWD/../../click-$CLICK_VERS \
+	$PWD/../click/include \
+	$PWD/../../click/include \
+	$PWD/../click-$CLICK_VERS/include \
+	$PWD/../../click-$CLICK_VERS/include \
+	$PWD/../click/ns \
+	$PWD/../../click/ns \
+	$PWD/../click-$CLICK_VERS/ns \
+	$PWD/../../click-$CLICK_VERS/ns \
+	"
+CLICK_PATH_D="$d \
+	$d/lib \
+	$d/include \
+	"
+
+
+NS_PACKAGE_click_UNDERWAY=false
+NS_PACKAGE_click_COMPLETE=true
+
+
+echo "$as_me:$LINENO: checking for click/simclick.h" >&5
+echo $ECHO_N "checking for click/simclick.h... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable header
+	V_HEADER_CLICK=FAIL
+
+NS_PACKAGE_click_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$CLICK_PATH"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$CLICK_PATH_D"
+	fi
+
+	V_HEADER_CLICK=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/click/simclick.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_HEADER_CLICK="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_click_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+
+				  ac_tr_hdr=HAVE_`echo click/simclick.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_HEADER_CLICK $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_click_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_HEADER_CLICK" >&5
+echo "${ECHO_T}$V_HEADER_CLICK" >&6
+	fi
+fi
+
+
+echo "$as_me:$LINENO: checking for libnsclick" >&5
+echo $ECHO_N "checking for libnsclick... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_CLICK=FAIL
+
+NS_PACKAGE_click_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$CLICK_PATH"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$CLICK_PATH_D"
+	fi
+
+	V_LIB_CLICK=""
+		full_lib_name="nsclick"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_CLICK="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_CLICK" = "FAIL" ; then
+
+NS_PACKAGE_click_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+		if test "$solaris"; then
+			V_LIB_CLICK="-R$dir $V_LIB_CLICK"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo nsclick | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_CLICK $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_click_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_LIB_CLICK" >&5
+echo "${ECHO_T}$V_LIB_CLICK" >&6
+	fi
+fi
+
+V_DEFINES="-DCLICK_NS $V_DEFINES"
+
+NS_PACKAGE_click_VALID=false
+if $NS_PACKAGE_click_UNDERWAY; then
+	if $NS_PACKAGE_click_COMPLETE; then
+		: All components of click found.
+		NS_PACKAGE_click_VALID=true
+	else
+		{ { echo "$as_me:$LINENO: error: Installation of click seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where click is
+using the argument --with-click=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-click=no." >&5
+echo "$as_me: error: Installation of click seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where click is
+using the argument --with-click=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-click=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xyes" = xyes; then
+	if $NS_PACKAGE_click_VALID; then
+		:
+	else
+		{ { echo "$as_me:$LINENO: error: click is required but could not be completely found.
+Please correct the problem by telling configure where click is
+using the argument --with-click=/path/to/package,
+or the package is not required, disable it with --with-click=no." >&5
+echo "$as_me: error: click is required but could not be completely found.
+Please correct the problem by telling configure where click is
+using the argument --with-click=/path/to/package,
+or the package is not required, disable it with --with-click=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+
 default_classinstvar=yes
 
 
@@ -6469,7 +6695,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6643,7 +6870,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6791,7 +7019,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -6904,7 +7133,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7028,7 +7258,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7093,7 +7324,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7158,7 +7390,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7223,7 +7456,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7288,7 +7522,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7353,7 +7588,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7418,7 +7654,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7483,7 +7720,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7588,7 +7826,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7657,7 +7896,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7719,7 +7959,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7759,7 +8000,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7815,7 +8057,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7855,7 +8098,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7919,7 +8163,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -7950,8 +8195,10 @@
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: internal error: not reached in cross-compile" >&5
-echo "$as_me: error: internal error: not reached in cross-compile" >&2;}
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
@@ -8099,7 +8346,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8329,7 +8577,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8397,7 +8646,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8498,7 +8748,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8614,7 +8865,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8680,7 +8932,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8739,7 +8992,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8806,7 +9060,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -8932,7 +9187,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -9004,7 +9260,8 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -10062,6 +10319,11 @@
   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
   esac
 
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
   # Let's still pretend it is `configure' which instantiates (i.e., don't
   # use $as_me), people would be surprised to read:
   #    /* config.h.  Generated by config.status.  */
@@ -10100,12 +10362,6 @@
 	 fi;;
       esac
     done` || { (exit 1); exit 1; }
-
-  if test x"$ac_file" != x-; then
-    { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    rm -f "$ac_file"
-  fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
   sed "$ac_vpsub
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/configure.in ns-2.30/configure.in
--- ns-2.30-pure/configure.in	2006-09-24 22:11:19.000000000 -0700
+++ ns-2.30/configure.in	2006-12-30 17:22:28.000000000 -0800
@@ -25,6 +25,7 @@
 builtin(include, ./conf/configure.in.misc)
 builtin(include, ./conf/configure.in.tcldebug)
 builtin(include, ./conf/configure.in.dmalloc)
+builtin(include, ./conf/configure.in.click)
 default_classinstvar=yes
 builtin(include, ./conf/configure.in.debugopts)
 
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/configure.orig ns-2.30/configure.orig
--- ns-2.30-pure/configure.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/configure.orig	2006-09-24 22:11:19.000000000 -0700
@@ -0,0 +1,10406 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.59.
+#
+# Copyright (C) 2003 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+exec 6>&1
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+
+ac_unique_file="ns_tclsh.cc"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#if HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# if HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#if HAVE_STRING_H
+# if !STDC_HEADERS && HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#if HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#if HAVE_INTTYPES_H
+# include <inttypes.h>
+#else
+# if HAVE_STDINT_H
+#  include <stdint.h>
+# endif
+#endif
+#if HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CXX CXXFLAGS ac_ct_CXX CPP EGREP CPP_NAMESPACE V_TCL_LIBRARY_FILES V_TCLSH V_LIBRARY_TCL V_TKDOSNAMES V_LIBRARY_TK V_TCL2CPP PERL build_nse V_INCLUDES V_LIBS V_DEFINES V_STATIC V_TAR_TARGET V_LIB_TCLCL V_LIB_OTCL V_LIB_TCL V_LIB_TK V_ALL V_CCOPT V_TAR_EXTRA V_LIB V_DEFINE V_SIGRET V_SHELL V_TARCMD V_INCLUDE V_OBJ V_BROKEN_OBJ V_OBJ_CRYPT V_RANLIB V_AR V_STLOBJ V_NS_TCL_LIB_STL V_LSSCRIPT INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA LIBOBJS LTLIBOBJS'
+ac_subst_files=''
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+ac_prev=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_option in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval "enable_$ac_feature=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_$ac_feature='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_$ac_package='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval "with_$ac_package=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
+    eval "$ac_envvar='$ac_optarg'"
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+	      localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname "$0") 2>/dev/null ||
+$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$0" : 'X\(//\)[^/]' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$0" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or .." >&2
+   { (exit 1); exit 1; }; }
+  else
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
+  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
+   { (exit 1); exit 1; }; }
+srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+ac_env_CC_set=${CC+set}
+ac_env_CC_value=$CC
+ac_cv_env_CC_set=${CC+set}
+ac_cv_env_CC_value=$CC
+ac_env_CFLAGS_set=${CFLAGS+set}
+ac_env_CFLAGS_value=$CFLAGS
+ac_cv_env_CFLAGS_set=${CFLAGS+set}
+ac_cv_env_CFLAGS_value=$CFLAGS
+ac_env_LDFLAGS_set=${LDFLAGS+set}
+ac_env_LDFLAGS_value=$LDFLAGS
+ac_cv_env_LDFLAGS_set=${LDFLAGS+set}
+ac_cv_env_LDFLAGS_value=$LDFLAGS
+ac_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_env_CPPFLAGS_value=$CPPFLAGS
+ac_cv_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_cv_env_CPPFLAGS_value=$CPPFLAGS
+ac_env_CXX_set=${CXX+set}
+ac_env_CXX_value=$CXX
+ac_cv_env_CXX_set=${CXX+set}
+ac_cv_env_CXX_value=$CXX
+ac_env_CXXFLAGS_set=${CXXFLAGS+set}
+ac_env_CXXFLAGS_value=$CXXFLAGS
+ac_cv_env_CXXFLAGS_set=${CXXFLAGS+set}
+ac_cv_env_CXXFLAGS_value=$CXXFLAGS
+ac_env_CPP_set=${CPP+set}
+ac_env_CPP_value=$CPP
+ac_cv_env_CPP_set=${CPP+set}
+ac_cv_env_CPP_value=$CPP
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+_ACEOF
+
+  cat <<_ACEOF
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+			  [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+			  [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
+_ACEOF
+
+  cat <<\_ACEOF
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+--enable-release	do a release build
+--enable-debug		build with debugging enabled
+--enable-devel		do a development build
+--enable-static	enable/disable static building
+--enable-stl		include code that needs the Standard Template Library
+--enable-tclcl-classinstvar	assume classinstvars are present in tclcl
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+-with-defaultoptions=filename	use <filename> as default options file
+--with-tcl=path	specify a pathname for tcl
+--with-tcl-ver=path specify the version of tcl/tk
+--with-tk=path	specify a pathname for tk
+--with-tk-ver=path specify the version of tcl/tk
+--with-otcl=path	specify a pathname for otcl
+--with-Tcl: old command now replaced by --with-tclcl
+--with-tclcl=path	specify a pathname for TclCL (the ex-libTcl)
+--with-tcldebug=path specify a pathname for the tcl debugger (path=no disables the debugger)
+--with-dmalloc=path specify a pathname for the dmalloc debugger (path=no disables the dmalloc)
+--with-perl=path specify a pathname for perl
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  CPPFLAGS    C/C++ preprocessor flags, e.g. -I<include dir> if you have
+              headers in a nonstandard directory <include dir>
+  CXX         C++ compiler command
+  CXXFLAGS    C++ compiler flags
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+_ACEOF
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d $ac_dir || continue
+    ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+	   test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
+    else
+      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi
+    cd "$ac_popdir"
+  done
+fi
+
+test -n "$ac_init_help" && exit 0
+if $ac_init_version; then
+  cat <<\_ACEOF
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit 0
+fi
+exec 5>config.log
+cat >&5 <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  echo "PATH: $as_dir"
+done
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_sep=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
+      # Get rid of the leading space.
+      ac_sep=" "
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+{
+  (set) 2>&1 |
+    case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      sed -n \
+	"s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+      ;;
+    *)
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+}
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo "$ac_var='"'"'$ac_val'"'"'"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+	echo "$ac_var='"'"'$ac_val'"'"'"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      sed "/^$/d" confdefs.h | sort
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      echo "$as_me: caught signal $ac_signal"
+    echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core &&
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+     ' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo >confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
+echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
+    esac
+  fi
+else
+  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
+echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in `(set) 2>&1 |
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val="\$ac_cv_env_${ac_var}_value"
+  eval ac_new_val="\$ac_env_${ac_var}_value"
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+echo "$as_me:   former value:  $ac_old_val" >&2;}
+	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+echo "$as_me:   current value: $ac_new_val" >&2;}
+	ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+cat >>confdefs.h <<\_ACEOF
+#define _GNU_SOURCE 1
+_ACEOF
+
+
+
+          ac_config_headers="$ac_config_headers autoconf.h"
+
+
+V_PROG="ns"
+V_LIB=""
+V_SHELL=""
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+enable_static=no
+
+
+
+
+# Check whether --with-defaultoptions or --without-defaultoptions was given.
+if test "${with_defaultoptions+set}" = set; then
+  withval="$with_defaultoptions"
+
+else
+  with_defaultoptions=".configure"
+fi;
+
+if test "$with_defaultoptions" = "yes" ; then
+	with_defaultoptions=".configure"
+elif test "$with_defaultoptions" = "no" ; then
+	with_defaultoptions=""
+fi
+
+if test -n "$with_defaultoptions" ; then
+	if test -f "$with_defaultoptions" ; then
+		read arglist < $with_defaultoptions
+
+		if test -n "$arglist" ; then
+			arguments="$0 $arglist $* --without-defaultoptions"
+			echo "Restarting: $arguments"
+			exec $arguments
+		fi
+	else
+		if test "$with_defaultoptions" = ".configure" ; then
+			echo No .configure file found in current directory
+			echo Continuing with default options...
+		else
+			echo Cannot find file $with_defaultoptions
+			echo Aborting configure...
+			exit 1
+		fi
+	fi
+fi
+
+
+ac_aux_dir=
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f $ac_dir/shtool; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&5
+echo "$as_me: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"
+ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
+
+# Make sure we can run config.sub.
+$ac_config_sub sun4 >/dev/null 2>&1 ||
+  { { echo "$as_me:$LINENO: error: cannot run $ac_config_sub" >&5
+echo "$as_me: error: cannot run $ac_config_sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+echo "$as_me:$LINENO: checking build system type" >&5
+echo $ECHO_N "checking build system type... $ECHO_C" >&6
+if test "${ac_cv_build+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_build_alias=$build_alias
+test -z "$ac_cv_build_alias" &&
+  ac_cv_build_alias=`$ac_config_guess`
+test -z "$ac_cv_build_alias" &&
+  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_build_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+echo "${ECHO_T}$ac_cv_build" >&6
+build=$ac_cv_build
+build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking host system type" >&5
+echo $ECHO_N "checking host system type... $ECHO_C" >&6
+if test "${ac_cv_host+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_host_alias=$host_alias
+test -z "$ac_cv_host_alias" &&
+  ac_cv_host_alias=$ac_cv_build_alias
+ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_host_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+echo "${ECHO_T}$ac_cv_host" >&6
+host=$ac_cv_host
+host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking target system type" >&5
+echo $ECHO_N "checking target system type... $ECHO_C" >&6
+if test "${ac_cv_target+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_target_alias=$target_alias
+test "x$ac_cv_target_alias" = "x" &&
+  ac_cv_target_alias=$ac_cv_host_alias
+ac_cv_target=`$ac_config_sub $ac_cv_target_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_target_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_target_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+echo "${ECHO_T}$ac_cv_target" >&6
+target=$ac_cv_target
+target_cpu=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$ac_ct_CC" && break
+done
+
+  CC=$ac_ct_CC
+fi
+
+fi
+
+
+test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&5
+echo "$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+
+# Provide some information about the compiler.
+echo "$as_me:$LINENO:" \
+     "checking for C compiler version" >&5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
+  (eval $ac_compiler --version </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -v </dev/null >&5\"") >&5
+  (eval $ac_compiler -v </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -V </dev/null >&5\"") >&5
+  (eval $ac_compiler -V </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
+echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6
+ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+if { (eval echo "$as_me:$LINENO: \"$ac_link_default\"") >&5
+  (eval $ac_link_default) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # Find the output, starting from the most likely.  This scheme is
+# not robust to junk in `.', hence go to wildcards (a.*) only as a last
+# resort.
+
+# Be careful to initialize this variable, since it used to be cached.
+# Otherwise an old cache value of `no' led to `EXEEXT = no' in a Makefile.
+ac_cv_exeext=
+# b.out is created by i960 compilers.
+for ac_file in a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj )
+	;;
+    conftest.$ac_ext )
+	# This is the source file.
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	# FIXME: I believe we export ac_cv_exeext for Libtool,
+	# but it would be cool to find out if it's true.  Does anybody
+	# maintain Libtool? --akim.
+	export ac_cv_exeext
+	break;;
+    * )
+	break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: C compiler cannot create executables
+See \`config.log' for more details." >&5
+echo "$as_me: error: C compiler cannot create executables
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }
+fi
+
+ac_exeext=$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_file" >&5
+echo "${ECHO_T}$ac_file" >&6
+
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether the C compiler works" >&5
+echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
+# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
+# If not cross compiling, check that we can run a simple program.
+if test "$cross_compiling" != yes; then
+  if { ac_try='./$ac_file'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+fi
+echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+rm -f a.out a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6
+echo "$as_me:$LINENO: result: $cross_compiling" >&5
+echo "${ECHO_T}$cross_compiling" >&6
+
+echo "$as_me:$LINENO: checking for suffix of executables" >&5
+echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  export ac_cv_exeext
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+echo "${ECHO_T}$ac_cv_exeext" >&6
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+echo "$as_me:$LINENO: checking for suffix of object files" >&5
+echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6
+if test "${ac_cv_objext+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2>/dev/null`; do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+echo "${ECHO_T}$ac_cv_objext" >&6
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
+if test "${ac_cv_c_compiler_gnu+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_compiler_gnu=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_compiler_gnu=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
+GCC=`test $ac_compiler_gnu = yes && echo yes`
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+CFLAGS="-g"
+echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_g+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_prog_cc_g=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+echo "$as_me:$LINENO: checking for $CC option to accept ANSI C" >&5
+echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_prog_cc_stdc=no
+ac_save_CC=$CC
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std1 is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std1.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+# Don't try gcc -ansi; that turns off useful extensions and
+# breaks some systems' header files.
+# AIX			-qlanglvl=ansi
+# Ultrix and OSF/1	-std1
+# HP-UX 10.20 and later	-Ae
+# HP-UX older versions	-Aa -D_HPUX_SOURCE
+# SVR4			-Xc -D__EXTENSIONS__
+for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_stdc=$ac_arg
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext
+done
+rm -f conftest.$ac_ext conftest.$ac_objext
+CC=$ac_save_CC
+
+fi
+
+case "x$ac_cv_prog_cc_stdc" in
+  x|xno)
+    echo "$as_me:$LINENO: result: none needed" >&5
+echo "${ECHO_T}none needed" >&6 ;;
+  *)
+    echo "$as_me:$LINENO: result: $ac_cv_prog_cc_stdc" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
+    CC="$CC $ac_cv_prog_cc_stdc" ;;
+esac
+
+# Some people use a C++ compiler to compile C.  Since we use `exit',
+# in C++ we need to declare it.  In case someone uses the same compiler
+# for both compiling C and C++ we need to have the C++ compiler decide
+# the declaration of exit, since it's the most demanding environment.
+cat >conftest.$ac_ext <<_ACEOF
+#ifndef __cplusplus
+  choke me
+#endif
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  for ac_declaration in \
+   '' \
+   'extern "C" void std::exit (int) throw (); using std::exit;' \
+   'extern "C" void std::exit (int); using std::exit;' \
+   'extern "C" void exit (int) throw ();' \
+   'extern "C" void exit (int);' \
+   'void exit (int);'
+do
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+#include <stdlib.h>
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+continue
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n "$ac_declaration"; then
+  echo '#ifdef __cplusplus' >>confdefs.h
+  echo $ac_declaration      >>confdefs.h
+  echo '#endif'             >>confdefs.h
+fi
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  for ac_prog in $CCC g++ c++ gpp aCC CC cxx cc++ cl FCC KCC RCC xlC_r xlC
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CXX+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CXX"; then
+  ac_cv_prog_CXX="$CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CXX=$ac_cv_prog_CXX
+if test -n "$CXX"; then
+  echo "$as_me:$LINENO: result: $CXX" >&5
+echo "${ECHO_T}$CXX" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+    test -n "$CXX" && break
+  done
+fi
+if test -z "$CXX"; then
+  ac_ct_CXX=$CXX
+  for ac_prog in $CCC g++ c++ gpp aCC CC cxx cc++ cl FCC KCC RCC xlC_r xlC
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CXX+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CXX"; then
+  ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CXX="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
+if test -n "$ac_ct_CXX"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CXX" >&5
+echo "${ECHO_T}$ac_ct_CXX" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$ac_ct_CXX" && break
+done
+test -n "$ac_ct_CXX" || ac_ct_CXX="g++"
+
+  CXX=$ac_ct_CXX
+fi
+
+
+# Provide some information about the compiler.
+echo "$as_me:$LINENO:" \
+     "checking for C++ compiler version" >&5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
+  (eval $ac_compiler --version </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -v </dev/null >&5\"") >&5
+  (eval $ac_compiler -v </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -V </dev/null >&5\"") >&5
+  (eval $ac_compiler -V </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+echo "$as_me:$LINENO: checking whether we are using the GNU C++ compiler" >&5
+echo $ECHO_N "checking whether we are using the GNU C++ compiler... $ECHO_C" >&6
+if test "${ac_cv_cxx_compiler_gnu+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_compiler_gnu=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_compiler_gnu=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_cxx_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_cxx_compiler_gnu" >&6
+GXX=`test $ac_compiler_gnu = yes && echo yes`
+ac_test_CXXFLAGS=${CXXFLAGS+set}
+ac_save_CXXFLAGS=$CXXFLAGS
+CXXFLAGS="-g"
+echo "$as_me:$LINENO: checking whether $CXX accepts -g" >&5
+echo $ECHO_N "checking whether $CXX accepts -g... $ECHO_C" >&6
+if test "${ac_cv_prog_cxx_g+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cxx_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_prog_cxx_g=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_cxx_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cxx_g" >&6
+if test "$ac_test_CXXFLAGS" = set; then
+  CXXFLAGS=$ac_save_CXXFLAGS
+elif test $ac_cv_prog_cxx_g = yes; then
+  if test "$GXX" = yes; then
+    CXXFLAGS="-g -O2"
+  else
+    CXXFLAGS="-g"
+  fi
+else
+  if test "$GXX" = yes; then
+    CXXFLAGS="-O2"
+  else
+    CXXFLAGS=
+  fi
+fi
+for ac_declaration in \
+   '' \
+   'extern "C" void std::exit (int) throw (); using std::exit;' \
+   'extern "C" void std::exit (int); using std::exit;' \
+   'extern "C" void exit (int) throw ();' \
+   'extern "C" void exit (int);' \
+   'void exit (int);'
+do
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+#include <stdlib.h>
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+continue
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n "$ac_declaration"; then
+  echo '#ifdef __cplusplus' >>confdefs.h
+  echo $ac_declaration      >>confdefs.h
+  echo '#endif'             >>confdefs.h
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+echo "$as_me:$LINENO: result: $CPP" >&5
+echo "${ECHO_T}$CPP" >&6
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&5
+echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
+    fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
+
+
+echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
+if test "${ac_cv_header_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_stdc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_stdc=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      exit(2);
+  exit (0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+
+
+
+
+
+
+
+
+
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_Header=no"
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in string.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+V_INCLUDE=""
+V_LIB=""
+V_OBJ=""
+V_BROKEN_OBJ="strtol.o strtoul.o"
+
+V_SHELL=""
+V_TARCMD="tar cfh"
+V_SIGRET="void"
+
+echo "$as_me:$LINENO: checking for main in -lXbsd" >&5
+echo $ECHO_N "checking for main in -lXbsd... $ECHO_C" >&6
+if test "${ac_cv_lib_Xbsd_main+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lXbsd  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+main ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_Xbsd_main=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_Xbsd_main=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_Xbsd_main" >&5
+echo "${ECHO_T}$ac_cv_lib_Xbsd_main" >&6
+if test $ac_cv_lib_Xbsd_main = yes; then
+  V_LIB="$V_LIB -lXbsd"
+fi
+
+echo "$as_me:$LINENO: checking for socket in -lsocket" >&5
+echo $ECHO_N "checking for socket in -lsocket... $ECHO_C" >&6
+if test "${ac_cv_lib_socket_socket+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsocket  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char socket ();
+int
+main ()
+{
+socket ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_socket_socket=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_socket_socket=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_socket_socket" >&5
+echo "${ECHO_T}$ac_cv_lib_socket_socket" >&6
+if test $ac_cv_lib_socket_socket = yes; then
+  V_LIB="$V_LIB -lsocket"
+fi
+
+echo "$as_me:$LINENO: checking for gethostbyname in -lnsl" >&5
+echo $ECHO_N "checking for gethostbyname in -lnsl... $ECHO_C" >&6
+if test "${ac_cv_lib_nsl_gethostbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+int
+main ()
+{
+gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_nsl_gethostbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_nsl_gethostbyname=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
+echo "${ECHO_T}$ac_cv_lib_nsl_gethostbyname" >&6
+if test $ac_cv_lib_nsl_gethostbyname = yes; then
+  V_LIB="$V_LIB -lnsl"
+fi
+
+echo "$as_me:$LINENO: checking for dcgettext in -lintl" >&5
+echo $ECHO_N "checking for dcgettext in -lintl... $ECHO_C" >&6
+if test "${ac_cv_lib_intl_dcgettext+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lintl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dcgettext ();
+int
+main ()
+{
+dcgettext ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_intl_dcgettext=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_intl_dcgettext=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_intl_dcgettext" >&5
+echo "${ECHO_T}$ac_cv_lib_intl_dcgettext" >&6
+if test $ac_cv_lib_intl_dcgettext = yes; then
+  V_LIB="$V_LIB -lintl"
+fi
+
+echo "$as_me:$LINENO: checking for getnodebyname in -ldnet_stub" >&5
+echo $ECHO_N "checking for getnodebyname in -ldnet_stub... $ECHO_C" >&6
+if test "${ac_cv_lib_dnet_stub_getnodebyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldnet_stub  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getnodebyname ();
+int
+main ()
+{
+getnodebyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dnet_stub_getnodebyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_dnet_stub_getnodebyname=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_dnet_stub_getnodebyname" >&5
+echo "${ECHO_T}$ac_cv_lib_dnet_stub_getnodebyname" >&6
+if test $ac_cv_lib_dnet_stub_getnodebyname = yes; then
+  V_LIB="$V_LIB -ldnet_stub"
+fi
+
+
+V_TAR_EXTRA=""
+V_DEFINE=""
+
+V_RANLIB=ranlib
+V_AR="ar cr"
+
+#XXX
+V_SHM="-DUSE_SHM"
+
+# Check whether --enable-release or --disable-release was given.
+if test "${enable_release+set}" = set; then
+  enableval="$enable_release"
+
+else
+  enable_release="no"
+fi;
+# Check whether --enable-debug or --disable-debug was given.
+if test "${enable_debug+set}" = set; then
+  enableval="$enable_debug"
+
+else
+  enable_debug="no"
+fi;
+# Check whether --enable-devel or --disable-devel was given.
+if test "${enable_devel+set}" = set; then
+  enableval="$enable_devel"
+
+else
+  enable_devel="no"
+fi;
+
+if test "$enable_devel" = "yes" ; then
+	enable_debug="yes"
+fi
+
+if test -f .devel -o "$enable_devel" = "yes"; then
+	OonS=""
+else
+    if test "$CC" = gcc ; then
+	    echo "$as_me:$LINENO: checking that $CXX can handle -O2" >&5
+echo $ECHO_N "checking that $CXX can handle -O2... $ECHO_C" >&6
+	    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#if __GNUC__ < 2  || __GNUC_MINOR__ < 8
+		/* gcc */
+		error
+		#endif
+		#if __GNUC_MINOR__ < 92
+		/* egcs */
+		int error;
+		#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+	    OonS="-O2"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+# Optimize on Steroids
+	    echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+    fi
+fi
+
+if test "$enable_debug" = "yes" ; then
+	V_CCOPT="-g"
+	if test "$CC" = gcc ; then
+		V_CCOPT="$V_CCOPT -Wall -Werror"
+		V_DEFINE="$V_DEFINE -fsigned-char -fno-inline"
+	fi
+else
+	V_CCOPT="$OonS"
+	V_DEFINE="$V_DEFINE -DNDEBUG"
+fi
+
+if test "$CC" = gcc ; then
+      V_CCOPT="$V_CCOPT -Wall"
+fi
+
+
+# XXX Some stupid sh on solaris does not set PWD correctly, i.e.,
+# after chdir $PWD remains at the parent directory. :(
+# We'll just do this every time. Doesn't hurt anyway.
+PWD=`pwd`
+
+solaris=""
+if test `echo "$target_os" | sed 's/\..*//'` = solaris2 ; then
+	solaris="yes"
+fi
+
+#places="Tcl \
+#	/usr/src/local/Tcl \
+#	../../Tcl \
+#	../Tcl"
+#for d in $places; do
+#	if test -f $d/tclcl.h ; then
+#		V_LIB="$V_LIB $d/libTcl.a"
+#		V_INCLUDE="$V_INCLUDE -I$d"
+#    		break
+#	fi
+#done
+
+
+# we now default to non-static linking, although if the "magic" file
+# .devel exists in the current directory, we try for a static link
+# under the assumption we are trying to produce re-distributable
+# binaries.
+#
+# Yatin: Moved this code here from configure.in.tail, since the mash
+# configure.in file needs to set this variable appropriately before invoking
+# configure.in.tail and the presence of the .devel file can mess things up for
+# the linux release build
+#
+# Check whether --enable-static or --disable-static was given.
+if test "${enable_static+set}" = set; then
+  enableval="$enable_static"
+
+else
+  enable_static=""
+fi;
+
+if test -f .devel -o "$enable_devel" = "yes"; then
+	echo -n "Development version: considering static"
+		if test "$enable_static" != no; then
+		echo ", and static enabled"
+		V_STATIC="-static"
+	else
+		echo ", but static disabled anyway"
+	fi
+else
+	V_STATIC=""
+fi
+
+
+# This can be extended to support compilation-time module selection
+V_STLOBJ=""
+V_LSSCRIPT=""
+
+# This is required by configure.in.tcl to provide absolute pathnames for
+# tclsh, and configure.in.tail to absolutize V_INCLUDES and V_LIBS.
+absolutize() {
+    case $1 in
+    -L*) p=`echo $1 | sed 's/^-L//'` ;;
+    -I*) p=`echo $1 | sed 's/^-I//'` ;;
+    *) p=$1 ;;
+    esac
+    d=`dirname $p`
+    f=`basename $p`
+    ad=`(
+	cd $d
+	pwd
+    )`
+    case $1 in
+    -L*) echo -L$ad/$f ;;
+    -I*) echo -I$ad/$f ;;
+    *) echo $ad/$f ;;
+    esac
+}
+
+
+
+
+
+ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+
+cpp_namespace=no
+stl_namespace=no
+
+if test x$cpp_namespace = xno
+then
+	echo "$as_me:$LINENO: checking if C++ libraries work without any namespace" >&5
+echo $ECHO_N "checking if C++ libraries work without any namespace... $ECHO_C" >&6
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <iostream>
+
+int
+main ()
+{
+cout.fail();
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+		cpp_namespace="none"
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+if test x$cpp_namespace = xno
+then
+	echo "$as_me:$LINENO: checking if C++ libraries work with namespace std" >&5
+echo $ECHO_N "checking if C++ libraries work with namespace std... $ECHO_C" >&6
+	cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <iostream>
+	using namespace std;
+
+int
+main ()
+{
+cout.fail();
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+		cpp_namespace=std
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+if test x$stl_namespace = xno
+then
+	echo "$as_me:$LINENO: checking if STL works without any namespace" >&5
+echo $ECHO_N "checking if STL works without any namespace... $ECHO_C" >&6
+	cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <list>
+
+int
+main ()
+{
+list<int> test;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+		stl_namespace="none"
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+if test x$stl_namespace = xno
+then
+	echo "$as_me:$LINENO: checking if STL works with namespace std" >&5
+echo $ECHO_N "checking if STL works with namespace std... $ECHO_C" >&6
+	cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <list>
+	using namespace std;
+
+int
+main ()
+{
+list<int> test;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+		stl_namespace=std
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+if test x$stl_namespace = xno
+then
+	echo "$as_me:$LINENO: checking if STL works with namespace stl" >&5
+echo $ECHO_N "checking if STL works with namespace stl... $ECHO_C" >&6
+	cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <list>
+	using namespace stl;
+
+int
+main ()
+{
+list<int> test;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+		stl_namespace=stl
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+echo "$as_me:$LINENO: checking should use STL" >&5
+echo $ECHO_N "checking should use STL... $ECHO_C" >&6
+# Check whether --enable-stl or --disable-stl was given.
+if test "${enable_stl+set}" = set; then
+  enableval="$enable_stl"
+
+	enable_stl=$enableval
+	echo "$as_me:$LINENO: result: user specified $enable_stl" >&5
+echo "${ECHO_T}user specified $enable_stl" >&6
+
+else
+
+if test x$stl_namespace = xno
+then
+	enable_stl=no
+	echo "$as_me:$LINENO: result: no, couldn't find STL" >&5
+echo "${ECHO_T}no, couldn't find STL" >&6
+else
+	if test x$stl_namespace != x$cpp_namespace
+	then
+						enable_stl=no
+		echo "$as_me:$LINENO: result: std/STL namespaces are too hard for your system, abandoning STL" >&5
+echo "${ECHO_T}std/STL namespaces are too hard for your system, abandoning STL" >&6
+	else
+		enable_stl=yes
+		echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+	fi
+fi
+
+fi;
+
+
+if test x$enable_stl = xno
+then
+	V_STLOBJ=""
+	V_NS_TCL_LIB_STL=""
+else
+	V_STLOBJ='$(OBJ_STL)'
+	V_NS_TCL_LIB_STL='$(NS_TCL_LIB_STL)'
+	cat >>confdefs.h <<\_ACEOF
+#define HAVE_STL 1
+_ACEOF
+
+fi
+if test x$cpp_namespace != xnone
+then
+	cat >>confdefs.h <<\_ACEOF
+#define CPP_REQUIRES_NAMESPACE 1
+_ACEOF
+
+fi
+CPP_NAMESPACE=$cpp_namespace
+
+
+
+
+
+
+
+
+# Check whether --with-tcl or --without-tcl was given.
+if test "${with_tcl+set}" = set; then
+  withval="$with_tcl"
+  d=$withval
+else
+  d=""
+fi;
+
+
+# Check whether --with-tcl-ver or --without-tcl-ver was given.
+if test "${with_tcl_ver+set}" = set; then
+  withval="$with_tcl_ver"
+  TCL_VERS=$withval
+else
+  TCL_VERS=8.4.11
+fi;
+
+
+TCL_HI_VERS=`echo $TCL_VERS | sed 's/^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1.\2/'`
+TCL_MAJOR_VERS=`echo $TCL_VERS | sed 's/^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1/'`
+TCL_ALT_VERS=`echo $TCL_HI_VERS | sed 's/\.//'`
+
+TCL_OLD_VERS=8.3
+TCL_OLD_ALT_VERS=`echo $TCL_OLD_VERS | sed 's/\.//'`
+
+TCL_TCL_PLACES_D="$d \
+		$d/lib/tcl$TCL_HI_VERS \
+		$d/lib/tcl$TCL_VERS \
+		$d/lib/tcl$TCL_ALT_VERS \
+		$d/lib/tcl \
+		$d/../lib/tcl$TCL_HI_VERS \
+		$d/../lib/tcl$TCL_VERS \
+		$d/../lib/tcl$TCL_ALT_VERS \
+		$d/lib/tcl$TCL_OLD_VERS \
+		$d/lib/tcl$TCL_OLD_ALT_VERS \
+		$d/../lib/tcl$TCL_OLD_VERS \
+		$d/../lib/tcl$TCL_OLD_ALT_VERS \
+		$d/lib \
+		/System/Library/Frameworks/Tcl.framework/Versions/8.4/Resources/Scripts \
+		$d/library \
+		"
+TCL_TCL_PLACES="../lib/tcl$TCL_HI_VERS \
+		../lib/tcl$TCL_ALT_VERS \
+		../lib/tcl$TCL_VERS \
+		../lib/tcl \
+		../tcl$TCL_HI_VERS/library \
+		../tcl$TCL_VERS/library \
+                ../tcl$TCL_ALT_VERS/library \
+		/usr/lib/tcl$TCL_VERS \
+		/usr/lib/tcl$TCL_HI_VERS \
+		/usr/lib/tcl$TCL_ALT_VERS \
+		/usr/lib/tcl \
+		/usr/share/tcl$TCL_VERS \
+		/usr/share/tcl$TCL_HI_VERS \
+		/usr/share/tcl$TCL_ALT_VERS \
+		/usr/share/tcl \
+		/lib/tcl$TCL_VERS \
+		/lib/tcl$TCL_HI_VERS \
+		/lib/tcl$TCL_ALT_VERS \
+		/usr/lib/tcl$TCL_OLD_VERS \
+		/usr/lib/tcl$TCL_OLD_ALT_VERS \
+		/lib/tcl$TCL_OLD_VERS \
+		/lib/tcl$TCL_OLD_ALT_VERS \
+		/usr/lib \
+                /usr/src/local/tcl$TCL_VERS/library \
+                /usr/src/local/tcl$TCL_HI_VERS/library \
+                /usr/src/local/tcl$TCL_ALT_VERS/library \
+                /usr/local/lib/tcl$TCL_VERS \
+                /usr/local/lib/tcl$TCL_HI_VERS \
+                /usr/local/lib/tcl$TCL_ALT_VERS \
+                /usr/local/include/tcl$TCL_VERS \
+                /usr/local/include/tcl$TCL_HI_VERS \
+                /usr/local/include/tcl$TCL_ALT_VERS \
+		../tcl$TCL_OLD_VERS/library \
+                ../tcl$TCL_OLD_ALT_VERS/library \
+                /usr/src/local/tcl$TCL_OLD_VERS/library \
+                /usr/src/local/tcl$TCL_OLD_ALT_VERS/library \
+                /usr/local/lib/tcl$TCL_OLD_VERS \
+                /usr/local/lib/tcl$TCL_OLD_ALT_VERS \
+                /usr/local/include/tcl$TCL_OLD_VERS \
+                /usr/local/include/tcl$TCL_OLD_ALT_VERS \
+                /usr/local/include \
+                $prefix/include \
+		$prefix/lib/tcl \
+                $x_includes/tk \
+                $x_includes \
+                /usr/contrib/include \
+                /usr/include"
+TCL_H_PLACES_D="$d/generic \
+		$d/unix \
+		$d/include/tcl$TCL_HI_VERS \
+		$d/include/tcl$TCL_VERS \
+		$d/include/tcl$TCL_ALT_VERS \
+		$d/include \
+		"
+TCL_H_PLACES=" \
+		../include \
+		../tcl$TCL_VERS/unix \
+		../tcl$TCL_ALT_VERS/unix \
+		../tcl$TCL_HI_VERS/generic \
+		../tcl$TCL_VERS/generic \
+		../tcl$TCL_ALT_VERS/generic \
+		/usr/src/local/tcl$TCL_VERS/generic \
+		/usr/src/local/tcl$TCL_HI_VERS/generic \
+		/usr/src/local/tcl$TCL_ALT_VERS/generic \
+		/usr/src/local/tcl$TCL_VERS/unix \
+		/usr/src/local/tcl$TCL_HI_VERS/unix \
+		/usr/src/local/tcl$TCL_ALT_VERS/unix \
+		/usr/contrib/include \
+		/usr/local/lib/tcl$TCL_VERS \
+		/usr/local/lib/tcl$TCL_HI_VERS \
+		/usr/local/lib/tcl$TCL_ALT_VERS \
+		/usr/local/include/tcl$TCL_VERS \
+		/usr/local/include/tcl$TCL_HI_VERS \
+		/usr/local/include/tcl$TCL_ALT_VERS \
+		/usr/local/include \
+		/import/tcl/include/tcl$TCL_VERS \
+		/import/tcl/include/tcl$TCL_HI_VERS \
+		/import/tcl/include/tcl$TCL_ALT_VERS \
+		../tcl$TCL_OLD_VERS/generic \
+		../tcl$TCL_OLD_ALT_VERS/generic \
+		/usr/src/local/tcl$TCL_OLD_VERS/generic \
+		/usr/src/local/tcl$TCL_OLD_ALT_VERS/generic \
+		../tcl$TCL_OLD_VERS/unix \
+		../tcl$TCL_OLD_ALT_VERS/unix \
+		/usr/src/local/tcl$TCL_OLD_VERS/unix \
+		/usr/src/local/tcl$TCL_OLD_ALT_VERS/unix \
+		/usr/local/lib/tcl$TCL_OLD_VERS \
+		/usr/local/lib/tcl$TCL_OLD_ALT_VERS \
+		/usr/local/include/tcl$TCL_OLD_VERS \
+		/usr/local/include/tcl$TCL_OLD_ALT_VERS \
+		/import/tcl/include/tcl$TCL_OLD_VERS \
+		/import/tcl/include/tcl$TCL_OLD_ALT_VERS \
+		$prefix/include \
+		$x_includes/tk \
+		$x_includes \
+		/usr/include \
+		/usr/include/tcl$TCL_VERS \
+		/usr/include/tcl$TCL_HI_VERS \
+		/usr/include/tcl$TCL_ALT_VERS \
+		/usr/include/tcl"
+TCL_LIB_PLACES_D="$d \
+		$d/lib \
+		$d/unix"
+TCL_LIB_PLACES=" \
+		../lib \
+		../tcl$TCL_VERS/unix \
+		../tcl$TCL_HI_VERS/unix \
+                ../tcl$TCL_ALT_VERS/unix \
+                /usr/src/local/tcl$TCL_VERS/unix \
+                /usr/src/local/tcl$TCL_HI_VERS/unix \
+                /usr/src/local/tcl$TCL_ALT_VERS/unix \
+                /usr/contrib/lib \
+                /usr/local/lib/tcl$TCL_VERS \
+                /usr/local/lib/tcl$TCL_HI_VERS \
+                /usr/local/lib/tcl$TCL_ALT_VERS \
+		/usr/lib/tcl$TCL_VERS \
+		/usr/lib/tcl$TCL_HI_VERS \
+		/usr/lib/tcl$TCL_ALT_VERS \
+		../tcl$TCL_OLD_VERS/unix \
+                ../tcl$TCL_OLD_ALT_VERS/unix \
+                /usr/src/local/tcl$TCL_OLD_VERS/unix \
+                /usr/src/local/tcl$TCL_OLD_ALT_VERS/unix \
+                /usr/local/lib/tcl$TCL_OLD_VERS \
+                /usr/local/lib/tcl$TCL_OLD_ALT_VERS \
+		/usr/lib/tcl$TCL_OLD_VERS \
+		/usr/lib/tcl$TCL_OLD_ALT_VERS \
+                /usr/local/lib \
+                $prefix/lib \
+                $x_libs/tk \
+                $x_libs \
+                /usr/lib \
+		"
+
+
+
+V_TCL_LIBRARY_FILES="\$(TCL_`echo $TCL_ALT_VERS`_LIBRARY_FILES)"
+test "x$TCL_VERS" = x8.3.5 && V_TCL_LIBRARY_FILES="\$(TCL_835_LIBRARY_FILES)"
+
+
+
+
+
+NS_PACKAGE_tcl_UNDERWAY=false
+NS_PACKAGE_tcl_COMPLETE=true
+
+
+echo "$as_me:$LINENO: checking for tcl.h" >&5
+echo $ECHO_N "checking for tcl.h... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable header
+	V_INCLUDE_TCL=FAIL
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$TCL_H_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCL_H_PLACES_D"
+	fi
+
+	V_INCLUDE_TCL=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/tcl.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_INCLUDE_TCL="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+
+				  ac_tr_hdr=HAVE_`echo tcl.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_INCLUDE_TCL $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_tcl_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_INCLUDE_TCL" >&5
+echo "${ECHO_T}$V_INCLUDE_TCL" >&6
+	fi
+fi
+
+
+echo "$as_me:$LINENO: checking for libtcl$TCL_HI_VERS" >&5
+echo $ECHO_N "checking for libtcl$TCL_HI_VERS... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_TCL=FAIL
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$TCL_LIB_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCL_LIB_PLACES_D"
+	fi
+
+	V_LIB_TCL=""
+		full_lib_name="tcl$TCL_HI_VERS"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_TCL="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_TCL" = "FAIL" ; then
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+		if test "$solaris"; then
+			V_LIB_TCL="-R$dir $V_LIB_TCL"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo tcl$TCL_HI_VERS | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_TCL $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_tcl_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_LIB_TCL" >&5
+echo "${ECHO_T}$V_LIB_TCL" >&6
+	fi
+fi
+
+
+echo "$as_me:$LINENO: checking for init.tcl" >&5
+echo $ECHO_N "checking for init.tcl... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable header
+	V_LIBRARY_TCL=FAIL
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$TCL_TCL_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCL_TCL_PLACES_D"
+	fi
+
+	V_LIBRARY_TCL=""
+	for dir in $places; do
+		if test -r $dir/init.tcl; then
+			V_LIBRARY_TCL="$dir"
+			break
+		fi
+	done
+	if test "FAIL$V_LIBRARY_TCL" = "FAIL" ; then
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+
+		NS_PACKAGE_tcl_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_LIBRARY_TCL" >&5
+echo "${ECHO_T}$V_LIBRARY_TCL" >&6
+	fi
+fi
+
+
+#
+# check for tclsh
+#
+oldpath=$PATH
+# $d/unix works if $d is the 8.0 distribution
+# $d/bin is for the ns-allinone distribution (kind of hacky, isn't it?)
+PATH=../bin:../tcl$TCL_HI_VERS/unix:../tcl$TCL_VERS/unix:$d/unix:$d/bin:$PATH
+for ac_prog in tclsh$TCL_VERS tclsh$TCL_HI_VERS tclsh tclsh$TCL_OLD_VERS
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_V_TCLSH+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $V_TCLSH in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_V_TCLSH="$V_TCLSH" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_V_TCLSH="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  ;;
+esac
+fi
+V_TCLSH=$ac_cv_path_V_TCLSH
+
+if test -n "$V_TCLSH"; then
+  echo "$as_me:$LINENO: result: $V_TCLSH" >&5
+echo "${ECHO_T}$V_TCLSH" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$V_TCLSH" && break
+done
+test -n "$V_TCLSH" || V_TCLSH="no"
+
+if test x"$V_TCLSH" = xno
+then
+	# out of luck
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+fi
+# absolutize it
+V_TCLSH=`absolutize $V_TCLSH`
+PATH=$oldpath
+
+
+NS_PACKAGE_tcl_VALID=false
+if $NS_PACKAGE_tcl_UNDERWAY; then
+	if $NS_PACKAGE_tcl_COMPLETE; then
+		: All components of tcl found.
+		NS_PACKAGE_tcl_VALID=true
+	else
+		{ { echo "$as_me:$LINENO: error: Installation of tcl seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tcl is
+using the argument --with-tcl=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tcl=no." >&5
+echo "$as_me: error: Installation of tcl seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tcl is
+using the argument --with-tcl=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tcl=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xyes" = xyes; then
+	if $NS_PACKAGE_tcl_VALID; then
+		:
+	else
+		{ { echo "$as_me:$LINENO: error: tcl is required but could not be completely found.
+Please correct the problem by telling configure where tcl is
+using the argument --with-tcl=/path/to/package,
+or the package is not required, disable it with --with-tcl=no." >&5
+echo "$as_me: error: tcl is required but could not be completely found.
+Please correct the problem by telling configure where tcl is
+using the argument --with-tcl=/path/to/package,
+or the package is not required, disable it with --with-tcl=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+
+
+
+
+
+
+# Check whether --with-tk or --without-tk was given.
+if test "${with_tk+set}" = set; then
+  withval="$with_tk"
+  d=$withval
+else
+  d=""
+fi;
+
+
+# Check whether --with-tk-ver or --without-tk-ver was given.
+if test "${with_tk_ver+set}" = set; then
+  withval="$with_tk_ver"
+  TK_VERS=$withval
+else
+  TK_VERS=8.4.11
+fi;
+
+
+
+TK_HI_VERS=`echo $TK_VERS | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1.\2/'`
+TK_MAJOR_VERS=`echo $TK_VERS | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1/'`
+TK_ALT_VERS=`echo $TK_VERS | sed 's/\.//'`
+
+TK_OLD_VERS=8.3
+TK_OLD_ALT_VERS=`echo $TK_OLD_VERS | sed 's/\.//'`
+
+TK_TCL_PLACES_D="$d \
+                $d/lib/tk$TK_VERS \
+                $d/lib/tk$TK_ALT_VERS \
+		$d/lib/tk$TK_HI_VERS \
+                $d/library \
+                $d/lib/tk \
+                $d/../lib/tk$TK_VERS \
+                $d/../lib/tk$TK_ALT_VERS \
+                $d/../lib/tk$TK_HI_VERS \
+                $d/../lib/tk \
+                $d/lib/tk$TK_OLD_VERS \
+                $d/lib/tk$TK_OLD_ALT_VERS \
+                $d/../lib/tk$TK_OLD_VERS \
+                $d/../lib/tk$TK_OLD_ALT_VERS \
+                $d/../lib/tk \
+                $d/lib \
+		/System/Library/Frameworks/Tk.framework/Versions/8.4/Resources/Scripts \
+                $d/library"
+TK_TCL_PLACES=" \
+		../lib/tk$TK_HI_VERS \
+		../lib/tk$TK_VERS \
+		../lib/tk$TK_ALT_VERS \
+		../tk$TK_VERS/library \
+                ../tk$TK_ALT_VERS/library \
+                ../tk$TK_HI_VERS/library \
+		../tk/library \
+                /usr/src/local/tk$TK_VERS/library \
+                /usr/src/local/tk$TK_ALT_VERS/library \
+                /usr/src/local/tk$TK_HI_VERS/library \
+                /usr/contrib/include \
+                /usr/local/lib/tk$TK_VERS \
+                /usr/local/lib/tk$TK_ALT_VERS \
+                /usr/local/lib/tk$TK_HI_VERS \
+                /usr/local/include/tk$TK_VERS \
+                /usr/local/include/tk$TK_ALT_VERS \
+                /usr/local/include/tk$TK_HI_VERS \
+                /usr/local/include \
+                /usr/lib/tk$TK_VERS \
+                /usr/lib/tk$TK_ALT_VERS \
+                /usr/lib/tk$TK_HI_VERS \
+                /usr/lib/tk \
+                /usr/share/tk$TK_VERS \
+                /usr/share/tk$TK_ALT_VERS \
+                /usr/share/tk$TK_HI_VERS \
+                /usr/share/tk \
+		../tk$TK_OLD_VERS/library \
+                ../tk$TK_OLD_ALT_VERS/library \
+                /usr/src/local/tk$TK_OLD_VERS/library \
+                /usr/src/local/tk$TK_OLD_ALT_VERS/library \
+                /usr/local/lib/tk$TK_OLD_VERS \
+                /usr/local/lib/tk$TK_OLD_ALT_VERS \
+                /usr/local/include/tk$TK_OLD_VERS \
+                /usr/local/include/tk$TK_OLD_ALT_VERS \
+                /usr/lib/tk$TK_OLD_VERS \
+                /usr/lib/tk$TK_OLD_ALT_VERS \
+                $prefix/include \
+		$prefix/lib/tk \
+                $x_includes/tk \
+                $x_includes \
+                /usr/include"
+TK_H_PLACES_D="$d \
+                $d/generic \
+                $d/../include/tk$TK_VERS \
+                $d/../include/tk$TK_HI_VERS \
+                $d/../include/tk$TK_OLD_VERS \
+		$d/include/tk$TK_VERS \
+		$d/include/tk$TK_HI_VERS \
+		$d/include/tk$TK_OLD_VERS \
+                $d/include"
+TK_H_PLACES=" \
+		../include \
+		../tk$TK_VERS/generic \
+                ../tk$TK_ALT_VERS/generic \
+                ../tk$TK_HI_VERS/generic \
+		/usr/src/local/tk$TK_VERS/generic \
+                /usr/src/local/tk$TK_ALT_VERS/generic \
+                /usr/src/local/tk$TK_HI_VERS/generic \
+                /usr/contrib/include \
+                /usr/local/lib/tk$TK_VERS \
+                /usr/local/lib/tk$TK_ALT_VERS \
+                /usr/local/lib/tk$TK_HI_VERS \
+                /usr/local/include/tk$TK_VERS \
+                /usr/local/include/tk$TK_ALT_VERS \
+                /usr/local/include/tk$TK_HI_VERS \
+                /usr/local/include \
+                /import/tk/include/tk$TK_VERS \
+                /import/tk/include/tk$TK_ALT_VERS \
+                /import/tk/include/tk$TK_HI_VERS \
+		../tk$TK_OLD_VERS/generic \
+                ../tk$TK_OLD_ALT_VERS/generic \
+		/usr/src/local/tk$TK_OLD_VERS/generic \
+                /usr/src/local/tk$TK_OLD_ALT_VERS/generic \
+                /usr/local/lib/tk$TK_OLD_VERS \
+                /usr/local/lib/tk$TK_OLD_ALT_VERS \
+                /usr/local/include/tk$TK_OLD_VERS \
+                /usr/local/include/tk$TK_OLD_ALT_VERS \
+                /import/tk/include/tk$TK_OLD_VERS \
+                /import/tk/include/tk$TK_OLD_ALT_VERS \
+                $prefix/include \
+                $x_includes/tk \
+                $x_includes \
+                /usr/include \
+                /usr/include/tcl \
+                /usr/include/tcl$TK_VERS \
+                /usr/include/tcl$TK_ALT_VERS \
+                /usr/include/tcl$TK_HI_VERS"
+TK_LIB_PLACES_D="$d \
+                $d/lib \
+		$d/unix"
+TK_LIB_PLACES=" \
+		../lib \
+		../lib/tk$TK_HI_VERS \
+		../lib/tk$TK_VERS \
+		../lib/tk$TK_ALT_VERS \
+		../tk$TK_VERS/unix \
+                ../tk$TK_ALT_VERS/unix \
+                ../tk$TK_HI_VERS/unix \
+                /usr/src/local/tk$TK_VERS/unix \
+                /usr/src/local/tk$TK_ALT_VERS/unix \
+                /usr/src/local/tk$TK_HI_VERS/unix \
+                /usr/contrib/lib \
+                /usr/local/lib/tk$TK_VERS \
+                /usr/local/lib/tk$TK_ALT_VERS \
+                /usr/local/lib/tk$TK_HI_VERS \
+		../tk$TK_OLD_VERS/unix \
+                ../tk$TK_OLD_ALT_VERS/unix \
+                /usr/src/local/tk$TK_OLD_VERS/unix \
+                /usr/src/local/tk$TK_OLD_ALT_VERS/unix \
+                /usr/local/lib/tk$TK_OLD_VERS \
+                /usr/local/lib/tk$TK_OLD_ALT_VERS \
+                /usr/local/lib \
+                $prefix/lib \
+                $x_libs/tk \
+                $x_libs \
+                /usr/lib"
+
+
+NS_PACKAGE_tk_UNDERWAY=false
+NS_PACKAGE_tk_COMPLETE=true
+
+
+echo "$as_me:$LINENO: checking for tk.h" >&5
+echo $ECHO_N "checking for tk.h... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable header
+	V_INCLUDE_TK=FAIL
+
+NS_PACKAGE_tk_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$TK_H_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TK_H_PLACES_D"
+	fi
+
+	V_INCLUDE_TK=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/tk.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_INCLUDE_TK="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_tk_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+
+				  ac_tr_hdr=HAVE_`echo tk.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_INCLUDE_TK $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_tk_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_INCLUDE_TK" >&5
+echo "${ECHO_T}$V_INCLUDE_TK" >&6
+	fi
+fi
+
+
+echo "$as_me:$LINENO: checking for libtk$TK_HI_VERS" >&5
+echo $ECHO_N "checking for libtk$TK_HI_VERS... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_TK=FAIL
+
+NS_PACKAGE_tk_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$TK_LIB_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TK_LIB_PLACES_D"
+	fi
+
+	V_LIB_TK=""
+		full_lib_name="tk$TK_HI_VERS"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_TK="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_TK" = "FAIL" ; then
+
+NS_PACKAGE_tk_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+		if test "$solaris"; then
+			V_LIB_TK="-R$dir $V_LIB_TK"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo tk$TK_HI_VERS | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_TK $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_tk_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_LIB_TK" >&5
+echo "${ECHO_T}$V_LIB_TK" >&6
+	fi
+fi
+
+
+echo "$as_me:$LINENO: checking for tk.tcl" >&5
+echo $ECHO_N "checking for tk.tcl... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable header
+	V_LIBRARY_TK=FAIL
+
+NS_PACKAGE_tk_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$TK_TCL_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TK_TCL_PLACES_D"
+	fi
+
+	V_LIBRARY_TK=""
+	for dir in $places; do
+		if test -r $dir/tk.tcl; then
+			V_LIBRARY_TK="$dir"
+			break
+		fi
+	done
+	if test "FAIL$V_LIBRARY_TK" = "FAIL" ; then
+
+NS_PACKAGE_tk_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+
+		NS_PACKAGE_tk_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_LIBRARY_TK" >&5
+echo "${ECHO_T}$V_LIBRARY_TK" >&6
+	fi
+fi
+
+
+NS_PACKAGE_tk_VALID=false
+if $NS_PACKAGE_tk_UNDERWAY; then
+	if $NS_PACKAGE_tk_COMPLETE; then
+		: All components of tk found.
+		NS_PACKAGE_tk_VALID=true
+	else
+		{ { echo "$as_me:$LINENO: error: Installation of tk seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tk is
+using the argument --with-tk=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tk=no." >&5
+echo "$as_me: error: Installation of tk seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tk is
+using the argument --with-tk=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tk=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xno" = xyes; then
+	if $NS_PACKAGE_tk_VALID; then
+		:
+	else
+		{ { echo "$as_me:$LINENO: error: tk is required but could not be completely found.
+Please correct the problem by telling configure where tk is
+using the argument --with-tk=/path/to/package,
+or the package is not required, disable it with --with-tk=no." >&5
+echo "$as_me: error: tk is required but could not be completely found.
+Please correct the problem by telling configure where tk is
+using the argument --with-tk=/path/to/package,
+or the package is not required, disable it with --with-tk=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+
+if test -r $V_LIBRARY_TK/optionMenu.tcl ; then
+	V_TKDOSNAMES='$(LIBRARY_TK)/optionMenu.tcl $(LIBRARY_TK)/scrollbar.tcl'
+	V_NEED_DL=""
+else
+	V_TKDOSNAMES='$(LIBRARY_TK)/optMenu.tcl $(LIBRARY_TK)/scrlbar.tcl'
+	V_NEED_DL=YES
+fi
+
+
+
+
+
+
+# Check whether --with-otcl or --without-otcl was given.
+if test "${with_otcl+set}" = set; then
+  withval="$with_otcl"
+  d=$withval
+else
+  d=""
+fi;
+
+OTCL_VERS=1.12
+OTCL_ALT_VERS=1.0
+
+OTCL_H_PLACES_D="$d \
+		$d/include"
+OTCL_H_PLACES="../otcl \
+		/usr/src/local/otcl \
+		../otcl-$OTCL_VERS \
+		/import/otcl/include \
+		/usr/src/local/otcl-$OTCL_VERS \
+		/usr/src/local/otcl-$OTCL_ALT_VERS \
+		$prefix/include \
+		/usr/local/include \
+		/usr/contrib/include \
+		/usr/include"
+OTCL_LIB_PLACES_D="$d \
+		$d/lib \
+		"
+OTCL_LIB_PLACES="../otcl \
+		../otcl-$OTCL_VERS \
+		../otcl-$OTCL_ALT_VERS \
+		$prefix/lib \
+		$x_libraries \
+		/usr/contrib/lib \
+		/usr/local/lib \
+		/usr/lib \
+		/usr/src/local/otcl \
+		/usr/src/local/otcl-$OTCL_VERS \
+		/usr/src/local/otcl-$OTCL_ALT_VERS \
+		"
+
+
+NS_PACKAGE_otcl_UNDERWAY=false
+NS_PACKAGE_otcl_COMPLETE=true
+
+
+echo "$as_me:$LINENO: checking for otcl.h" >&5
+echo $ECHO_N "checking for otcl.h... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable header
+	V_INCLUDE_OTCL=FAIL
+
+NS_PACKAGE_otcl_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$OTCL_H_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$OTCL_H_PLACES_D"
+	fi
+
+	V_INCLUDE_OTCL=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/otcl.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_INCLUDE_OTCL="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_otcl_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+
+				  ac_tr_hdr=HAVE_`echo otcl.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_INCLUDE_OTCL $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_otcl_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_INCLUDE_OTCL" >&5
+echo "${ECHO_T}$V_INCLUDE_OTCL" >&6
+	fi
+fi
+
+
+echo "$as_me:$LINENO: checking for libotcl$OTCL_VERS" >&5
+echo $ECHO_N "checking for libotcl$OTCL_VERS... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_OTCL=FAIL
+
+NS_PACKAGE_otcl_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$OTCL_LIB_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$OTCL_LIB_PLACES_D"
+	fi
+
+	V_LIB_OTCL=""
+		full_lib_name="otcl$OTCL_VERS"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_OTCL="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_OTCL" = "FAIL" ; then
+
+NS_PACKAGE_otcl_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+		if test "$solaris"; then
+			V_LIB_OTCL="-R$dir $V_LIB_OTCL"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo otcl$OTCL_VERS | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_OTCL $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_otcl_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_LIB_OTCL" >&5
+echo "${ECHO_T}$V_LIB_OTCL" >&6
+	fi
+fi
+
+
+NS_PACKAGE_otcl_VALID=false
+if $NS_PACKAGE_otcl_UNDERWAY; then
+	if $NS_PACKAGE_otcl_COMPLETE; then
+		: All components of otcl found.
+		NS_PACKAGE_otcl_VALID=true
+	else
+		{ { echo "$as_me:$LINENO: error: Installation of otcl seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where otcl is
+using the argument --with-otcl=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-otcl=no." >&5
+echo "$as_me: error: Installation of otcl seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where otcl is
+using the argument --with-otcl=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-otcl=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xyes" = xyes; then
+	if $NS_PACKAGE_otcl_VALID; then
+		:
+	else
+		{ { echo "$as_me:$LINENO: error: otcl is required but could not be completely found.
+Please correct the problem by telling configure where otcl is
+using the argument --with-otcl=/path/to/package,
+or the package is not required, disable it with --with-otcl=no." >&5
+echo "$as_me: error: otcl is required but could not be completely found.
+Please correct the problem by telling configure where otcl is
+using the argument --with-otcl=/path/to/package,
+or the package is not required, disable it with --with-otcl=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+
+
+
+
+# Check whether --with-Tcl or --without-Tcl was given.
+if test "${with_Tcl+set}" = set; then
+  withval="$with_Tcl"
+  { { echo "$as_me:$LINENO: error: The --with-Tcl option has been replaced with --with-tclcl.
+Please insure you have an up-to-date copy of TclCL and re-run your configuration." >&5
+echo "$as_me: error: The --with-Tcl option has been replaced with --with-tclcl.
+Please insure you have an up-to-date copy of TclCL and re-run your configuration." >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+
+# Check whether --with-tclcl or --without-tclcl was given.
+if test "${with_tclcl+set}" = set; then
+  withval="$with_tclcl"
+  d=$withval
+else
+  d=""
+fi;
+
+TCLCL_VERS=1.18
+TCLCL_ALT_VERS=1.0
+
+TCLCL_H_PLACES="\
+		../tclcl-$TCLCL_VERS \
+		../tclcl-$TCLCL_ALT_VERS \
+		../tclcl \
+		../TclCL \
+		../Tcl-$TCLCL_VERS \
+		../Tcl-$TCLCL_ALT_VERS \
+		../Tcl \
+                /usr/src/local/Tcl \
+                /usr/src/local/Tcl-1.0 \
+                /import/Tcl/include \
+                /usr/local/include \
+                /usr/contrib/include \
+                /usr/include"
+TCLCL_H_PLACES_D="$d \
+ 		$d/include"
+TCLCL_LIB_PLACES="\
+		../tclcl-$TCLCL_VERS \
+		../tclcl-$TCLCL_ALT_VERS \
+		../tclcl \
+		../TclCL \
+		../Tcl-$TCLCL_VERS \
+		../Tcl-$TCLCL_ALT_VERS \
+		../Tcl \
+                $x_libraries \
+                /usr/contrib/lib \
+                /usr/local/lib \
+                /usr/lib \
+                /usr/src/local/Tcl \
+                /usr/src/local/Tcl-1.0"
+TCLCL_LIB_PLACES_D="\
+        $d \
+        $d/lib \
+        $d/bin"
+TCLCL_PROG_PLACES="\
+		../tclcl-$TCLCL_VERS \
+		../tclcl-$TCLCL_ALT_VERS \
+		../tclcl \
+		../TclCL \
+		../Tcl-$TCLCL_VERS \
+		../Tcl-$TCLCL_ALT_VERS \
+		../Tcl \
+                $prefix/bin \
+                $x_libraries \
+                /usr/contrib/bin \
+                /usr/local/bin \
+                /usr/bin \
+                /usr/src/local/Tcl \
+                /usr/src/local/Tcl-1.0 \
+                "
+TCLCL_PROG_PLACES_D="
+	$d \
+	$d/bin"
+
+
+
+NS_PACKAGE_tclcl_UNDERWAY=false
+NS_PACKAGE_tclcl_COMPLETE=true
+
+
+echo "$as_me:$LINENO: checking for tclcl.h" >&5
+echo $ECHO_N "checking for tclcl.h... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable header
+	V_INCLUDE_TCLCL=FAIL
+
+NS_PACKAGE_tclcl_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$TCLCL_H_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCLCL_H_PLACES_D"
+	fi
+
+	V_INCLUDE_TCLCL=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/tclcl.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_INCLUDE_TCLCL="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_tclcl_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+
+				  ac_tr_hdr=HAVE_`echo tclcl.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_INCLUDE_TCLCL $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_tclcl_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_INCLUDE_TCLCL" >&5
+echo "${ECHO_T}$V_INCLUDE_TCLCL" >&6
+	fi
+fi
+
+
+echo "$as_me:$LINENO: checking for libtclcl$tclcl_VERS" >&5
+echo $ECHO_N "checking for libtclcl$tclcl_VERS... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_TCLCL=FAIL
+
+NS_PACKAGE_tclcl_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$TCLCL_LIB_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCLCL_LIB_PLACES_D"
+	fi
+
+	V_LIB_TCLCL=""
+		full_lib_name="tclcl$tclcl_VERS"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_TCLCL="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_TCLCL" = "FAIL" ; then
+
+NS_PACKAGE_tclcl_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+		if test "$solaris"; then
+			V_LIB_TCLCL="-R$dir $V_LIB_TCLCL"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo tclcl$tclcl_VERS | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_TCLCL $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_tclcl_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_LIB_TCLCL" >&5
+echo "${ECHO_T}$V_LIB_TCLCL" >&6
+	fi
+fi
+
+
+echo "$as_me:$LINENO: checking for tcl2c++" >&5
+echo $ECHO_N "checking for tcl2c++... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable header
+	V_TCL2CPP_DIR=FAIL
+
+NS_PACKAGE_tclcl_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$TCLCL_PROG_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCLCL_PROG_PLACES_D"
+	fi
+
+	V_TCL2CPP_DIR=""
+	for dir in $places; do
+		if test -r $dir/tcl2c++; then
+			V_TCL2CPP_DIR="$dir"
+			break
+		fi
+	done
+	if test "FAIL$V_TCL2CPP_DIR" = "FAIL" ; then
+
+NS_PACKAGE_tclcl_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+
+		NS_PACKAGE_tclcl_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_TCL2CPP_DIR" >&5
+echo "${ECHO_T}$V_TCL2CPP_DIR" >&6
+	fi
+fi
+
+
+V_TCL2CPP=$V_TCL2CPP_DIR/tcl2c++
+
+
+
+NS_PACKAGE_tclcl_VALID=false
+if $NS_PACKAGE_tclcl_UNDERWAY; then
+	if $NS_PACKAGE_tclcl_COMPLETE; then
+		: All components of tclcl found.
+		NS_PACKAGE_tclcl_VALID=true
+	else
+		{ { echo "$as_me:$LINENO: error: Installation of tclcl seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tclcl is
+using the argument --with-tclcl=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tclcl=no." >&5
+echo "$as_me: error: Installation of tclcl seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tclcl is
+using the argument --with-tclcl=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tclcl=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xyes" = xyes; then
+	if $NS_PACKAGE_tclcl_VALID; then
+		:
+	else
+		{ { echo "$as_me:$LINENO: error: tclcl is required but could not be completely found.
+Please correct the problem by telling configure where tclcl is
+using the argument --with-tclcl=/path/to/package,
+or the package is not required, disable it with --with-tclcl=no." >&5
+echo "$as_me: error: tclcl is required but could not be completely found.
+Please correct the problem by telling configure where tclcl is
+using the argument --with-tclcl=/path/to/package,
+or the package is not required, disable it with --with-tclcl=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+
+
+
+case "$target" in
+*-dec-*)
+					V_DEFINE="$V_DEFINE -D_XOPEN_SOURCE_EXTENDED"
+	cat >>confdefs.h <<\_ACEOF
+#define _XOPEN_SOURCE_EXTENDED 1
+_ACEOF
+
+	;;
+sparc-sun-solaris*)
+	if test $CC = gcc ; then
+		V_DEFINE="$V_DEFINE -mv8 -msupersparc"
+	fi
+	V_DEFINE="$V_DEFINE -D__svr4__"
+	V_LIB="$V_LIB -ldl"
+	;;
+sparc-sun-sunos*)
+	V_DEFINE="$V_DEFINE -DNEED_SUNOS_PROTOS"
+	;;
+*-sgi-irix5*)
+	V_DEFINE="$V_DEFINE -DIRIX5 -D_BSD_SIGNALS"
+	if test "$target_os" = irix5.3 ; then
+		V_DEFINE="$V_DEFINE -DIRIX5_3"
+	fi
+	V_TARCMD="tar cfL"
+	V_SHELL="SHELL = /bin/sh"
+	if test $CC != gcc ; then
+		V_DEFINE="$V_DEFINE -signed -g3"
+		V_CXXOPT="$V_CXXOPT +p -float"
+		CC="cc -xansi -D__STDC__ -Dinline="
+		CXX="CC +p -float -DSGI_COMPAT"
+	fi
+	V_RANLIB="ar ts"
+	;;
+*-sgi-irix6*)
+	V_DEFINE="$V_DEFINE -DIRIX6 -D_BSD_SIGNALS"
+	V_TARCMD="tar cfL"
+	V_SHELL="SHELL = /bin/sh"
+	if test $CC != gcc ; then
+		V_DEFINE="$V_DEFINE -signed -g3"
+		V_CXXOPT="$V_CXXOPT +p -float"
+		CC="cc -xansi -D__STDC__ -Dinline="
+		CXX="CC +p -float -DSGI_COMPAT"
+	fi
+	V_RANLIB="ar ts"
+	;;
+*-*-bsdi1*)
+	V_SHM=""
+	V_TARCMD="tar cfL"
+	;;
+*-*-bsdi2.0*)
+	V_SHM=""
+	V_TARCMD="tar cfL"
+	;;
+*-*-bsdi2.1*)
+	# bsdi2.1 added sys-v shared memory support but their implementation
+	# is broken so we have to turn it off.  If they ever fix libipc,
+	# the following line should be deleted.
+	V_SHM=""
+	V_TARCMD="tar cfL"
+	V_CCOPT="-O2 -m486"
+	V_LIB="$V_LIB -lipc -ldl"
+	;;
+*-*-bsdi3*)
+	V_SHM=""
+	V_TARCMD="tar cfL"
+	V_LIB="$V_LIB -lipc -ldl"
+	V_OBJ="$V_OBJ misc/serial.o"
+	;;
+*-*-freebsd*)
+	V_OBJ="$V_OBJ misc/serial.o"
+	;;
+*-*-netbsd*)
+	V_TARCMD="tar -h -c -f"
+	V_LIB="$V_LIB -L/usr/local/lib"
+	;;
+*-*-hpux*)
+	cat >>confdefs.h <<\_ACEOF
+#define random lrand48
+_ACEOF
+
+	cat >>confdefs.h <<\_ACEOF
+#define srandom srand
+_ACEOF
+
+	V_CCOPT="-O"
+	;;
+*-*-aix3*)
+	V_DEFINE="$V_DEFINE -DSIGARGS=int"
+	if test "$V_LIB_AIXSHM" != "" ; then
+		V_LIB="$V_LIB $V_LIB_AIXSHM"
+	else
+		V_SHM=""
+	fi
+	CXX="xlC -+"
+	;;
+*-*-aix4*)
+	V_DEFINE="$V_DEFINE -DSIGARGS=int -D_AIX41"
+	if test "$V_LIB_AIXSHM" != "" ; then
+		V_LIB="$V_LIB $V_LIB_AIXSHM"
+	else
+		V_SHM=""
+	fi
+	CXX="g++"
+	;;
+*-*-linux*)
+	V_BROKEN_OBJ=
+	;;
+powerpc-apple-darwin*)
+	V_CCOPT="-fno-common -fPIC -pipe"
+	;;
+esac
+
+
+
+# Check whether --with-tcldebug or --without-tcldebug was given.
+if test "${with_tcldebug+set}" = set; then
+  withval="$with_tcldebug"
+  d=$withval
+else
+  d=""
+fi;
+
+#xxx: Don't know anything about 1.8
+# 2.0 = tcl 8.3
+# 1.9 = tcl 7.5, 7.6, 8.0
+TCLDEBUG_VERS="2.0 1.9 1.8 1.7"
+pwd_vers=""
+local_vers=""
+for vers in $TCLDEBUG_VERS; do
+	 pwd_vers="$pwd_vers $PWD/../tcl-debug-$vers"
+	 local_vers="$local_vers /usr/src/local/otcl-debug-$vers"
+done
+TCLDEBUG_PATH="\
+		$PWD/../tcl-debug \
+		$pwd_vers
+		/usr/contrib/lib \
+		/usr/local/lib \
+		/usr/lib \
+		/usr/src/local/tcl-debug \
+		$local_vers \
+		"
+TCLDEBUG_PATH_D="$d \
+		$d/lib \
+		$d/../lib \
+		"
+
+
+NS_PACKAGE_tcldebug_UNDERWAY=false
+NS_PACKAGE_tcldebug_COMPLETE=true
+
+
+
+echo "$as_me:$LINENO: checking for libtcldbg" >&5
+echo $ECHO_N "checking for libtcldbg... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_TCLDEBUG=FAIL
+
+NS_PACKAGE_tcldebug_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$TCLDEBUG_PATH"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCLDEBUG_PATH_D"
+	fi
+
+	V_LIB_TCLDEBUG=""
+		full_lib_name="tcldbg"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_TCLDEBUG="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_TCLDEBUG" = "FAIL" ; then
+
+NS_PACKAGE_tcldebug_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+		if test "$solaris"; then
+			V_LIB_TCLDEBUG="-R$dir $V_LIB_TCLDEBUG"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo tcldbg | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_TCLDEBUG $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_tcldebug_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_LIB_TCLDEBUG" >&5
+echo "${ECHO_T}$V_LIB_TCLDEBUG" >&6
+	fi
+fi
+
+#if $NS_PACKAGE_tcldebug_COMPLETE; then
+	# look for debugger entry point function
+	#tmpLIBS=$LIBS
+	#LIBS="$V_LIB_TCL $V_LIB_TCLDEBUG"
+
+	# the following two may be needed for linking during tcldbg CHECK_LIB
+	#AC_CHECK_LIB(m, main)
+        #AC_CHECK_LIB(dl, dlopen)
+
+	#notfound=false
+	#AC_CHECK_LIB(tcldbg, Dbg_Init, V_DEFINES="-DHAVE_Dbg_Init $V_DEFINES",notfound=true)
+	#if $notfound; then
+	#	notfound=false
+	#	AC_CHECK_LIB(tcldbg, Tcldbg_Init, V_DEFINES="-DHAVE_Tcldbg_Init $V_DEFINES",notfound=true)
+	#fi
+	#LIBS=$tmpLIBS
+	#if $notfound; then
+	#	echo "configure: warning: Tcl debugger init point is not found.  You \
+#will not be able to use Tcl debugger." 1>&2
+	#	NS_PACKAGE_tcldebug_COMPLETE=false
+	#fi
+#fi
+
+if $NS_PACKAGE_tcldebug_COMPLETE; then
+
+NS_PACKAGE_tcldebug_VALID=false
+if $NS_PACKAGE_tcldebug_UNDERWAY; then
+	if $NS_PACKAGE_tcldebug_COMPLETE; then
+		: All components of tcldebug found.
+		NS_PACKAGE_tcldebug_VALID=true
+	else
+		{ { echo "$as_me:$LINENO: error: Installation of tcldebug seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tcldebug is
+using the argument --with-tcldebug=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tcldebug=no." >&5
+echo "$as_me: error: Installation of tcldebug seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tcldebug is
+using the argument --with-tcldebug=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tcldebug=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xno" = xyes; then
+	if $NS_PACKAGE_tcldebug_VALID; then
+		:
+	else
+		{ { echo "$as_me:$LINENO: error: tcldebug is required but could not be completely found.
+Please correct the problem by telling configure where tcldebug is
+using the argument --with-tcldebug=/path/to/package,
+or the package is not required, disable it with --with-tcldebug=no." >&5
+echo "$as_me: error: tcldebug is required but could not be completely found.
+Please correct the problem by telling configure where tcldebug is
+using the argument --with-tcldebug=/path/to/package,
+or the package is not required, disable it with --with-tcldebug=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+fi
+
+
+
+# Check whether --with-dmalloc or --without-dmalloc was given.
+if test "${with_dmalloc+set}" = set; then
+  withval="$with_dmalloc"
+  d="$withval"
+else
+  d="UNDEF"
+fi;
+
+DMALLOC_VERS=3.2.1
+
+DMALLOC_PATH="$PWD/../dmalloc \
+	$PWD/../dmalloc-$DMALLOC_VERS \
+	/usr/contrib/lib \
+	/usr/local/lib \
+	/usr/lib \
+	/usr/contrib/include \
+	/usr/local/include \
+	/usr/include \
+	"
+DMALLOC_PATH_D="$d $d/lib $d/include"
+
+if test "x$d" = xUNDEF; then
+	echo "$as_me:$LINENO: checking dmalloc" >&5
+echo $ECHO_N "checking dmalloc... $ECHO_C" >&6
+	echo "$as_me:$LINENO: result: not requested with --with-dmalloc" >&5
+echo "${ECHO_T}not requested with --with-dmalloc" >&6
+else
+
+NS_PACKAGE_dmalloc_UNDERWAY=false
+NS_PACKAGE_dmalloc_COMPLETE=true
+
+
+echo "$as_me:$LINENO: checking for libdmalloc" >&5
+echo $ECHO_N "checking for libdmalloc... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_DMALLOC=FAIL
+
+NS_PACKAGE_dmalloc_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$DMALLOC_PATH"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$DMALLOC_PATH_D"
+	fi
+
+	V_LIB_DMALLOC=""
+		full_lib_name="dmalloc"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_DMALLOC="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_DMALLOC" = "FAIL" ; then
+
+NS_PACKAGE_dmalloc_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+		if test "$solaris"; then
+			V_LIB_DMALLOC="-R$dir $V_LIB_DMALLOC"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo dmalloc | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_DMALLOC $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_dmalloc_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_LIB_DMALLOC" >&5
+echo "${ECHO_T}$V_LIB_DMALLOC" >&6
+	fi
+fi
+
+
+echo "$as_me:$LINENO: checking for dmalloc.h" >&5
+echo $ECHO_N "checking for dmalloc.h... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable header
+	V_HEADER_DMALLOC=FAIL
+
+NS_PACKAGE_dmalloc_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$DMALLOC_PATH"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$DMALLOC_PATH_D"
+	fi
+
+	V_HEADER_DMALLOC=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/dmalloc.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_HEADER_DMALLOC="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_dmalloc_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+
+				  ac_tr_hdr=HAVE_`echo dmalloc.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_HEADER_DMALLOC $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_dmalloc_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_HEADER_DMALLOC" >&5
+echo "${ECHO_T}$V_HEADER_DMALLOC" >&6
+	fi
+fi
+
+
+echo "$as_me:$LINENO: checking for return.h" >&5
+echo $ECHO_N "checking for return.h... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable header
+	V_HEADER_RETURN=FAIL
+
+NS_PACKAGE_dmalloc_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$DMALLOC_PATH"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$DMALLOC_PATH_D"
+	fi
+
+	V_HEADER_RETURN=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/return.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_HEADER_RETURN="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_dmalloc_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+
+				  ac_tr_hdr=HAVE_`echo return.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_HEADER_RETURN $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_dmalloc_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_HEADER_RETURN" >&5
+echo "${ECHO_T}$V_HEADER_RETURN" >&6
+	fi
+fi
+
+
+NS_PACKAGE_dmalloc_VALID=false
+if $NS_PACKAGE_dmalloc_UNDERWAY; then
+	if $NS_PACKAGE_dmalloc_COMPLETE; then
+		: All components of dmalloc found.
+		NS_PACKAGE_dmalloc_VALID=true
+	else
+		{ { echo "$as_me:$LINENO: error: Installation of dmalloc seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where dmalloc is
+using the argument --with-dmalloc=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-dmalloc=no." >&5
+echo "$as_me: error: Installation of dmalloc seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where dmalloc is
+using the argument --with-dmalloc=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-dmalloc=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xno" = xyes; then
+	if $NS_PACKAGE_dmalloc_VALID; then
+		:
+	else
+		{ { echo "$as_me:$LINENO: error: dmalloc is required but could not be completely found.
+Please correct the problem by telling configure where dmalloc is
+using the argument --with-dmalloc=/path/to/package,
+or the package is not required, disable it with --with-dmalloc=no." >&5
+echo "$as_me: error: dmalloc is required but could not be completely found.
+Please correct the problem by telling configure where dmalloc is
+using the argument --with-dmalloc=/path/to/package,
+or the package is not required, disable it with --with-dmalloc=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+fi
+
+
+
+default_classinstvar=yes
+
+
+if test x$default_classinstvar = x
+then
+	default_classinstvar=no
+fi
+
+# Check whether --enable-tclcl-classinstvar or --disable-tclcl-classinstvar was given.
+if test "${enable_tclcl_classinstvar+set}" = set; then
+  enableval="$enable_tclcl_classinstvar"
+  enable_classinstvar=$enableval
+else
+  enable_classinstvar=$default_classinstvar
+fi;
+if test "$enable_classinstvar" = "yes";
+then
+	V_DEFINE="-DTCLCL_CLASSINSTVAR $V_DEFINE"
+fi
+
+
+
+
+PERL_OPTIONAL=true
+
+
+
+# Check whether --with-perl or --without-perl was given.
+if test "${with_perl+set}" = set; then
+  withval="$with_perl"
+  d=$withval
+else
+  d=""
+fi;
+
+# Next line is the minimum version of perl required.
+# 5.000 and 5.001 are generally scorned because of age and bugs.
+PERL_VERSION=${PERL_VERSION:-5.002}
+
+PERL_PLACES=`echo $PATH | sed 's/:/ /g'`
+
+PERL_OPTIONAL=${PERL_OPTIONAL:-false}
+
+
+
+
+echo "$as_me:$LINENO: checking for perl" >&5
+echo $ECHO_N "checking for perl... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable header
+	PERL=FAIL
+
+NS_PACKAGE_no_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$PERL_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$d"
+	fi
+
+	PERL=""
+	for dir in $places; do
+		if test -r $dir/perl; then
+			PERL="$dir"
+			break
+		fi
+	done
+	if test "FAIL$PERL" = "FAIL" ; then
+
+NS_PACKAGE_no_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+
+		NS_PACKAGE_no_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $PERL" >&5
+echo "${ECHO_T}$PERL" >&6
+	fi
+fi
+
+if test "x$PERL" != x
+then
+    PERL=$PERL/perl
+
+echo $PERL -e "require $PERL_VERSION" 1>&5
+if $PERL -e "require $PERL_VERSION" 2>&5
+then
+    : good version
+else
+    : non-good version => zero pathname
+    echo "$as_me:$LINENO: result:     not version $PERL_VERSION" >&5
+echo "${ECHO_T}    not version $PERL_VERSION" >&6
+    PERL=''
+fi
+
+fi
+
+if test "x$PERL" = "x"
+then
+
+echo "$as_me:$LINENO: checking for perl5" >&5
+echo $ECHO_N "checking for perl5... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable header
+	PERL=FAIL
+
+NS_PACKAGE_no_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$PERL_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$d"
+	fi
+
+	PERL=""
+	for dir in $places; do
+		if test -r $dir/perl5; then
+			PERL="$dir"
+			break
+		fi
+	done
+	if test "FAIL$PERL" = "FAIL" ; then
+
+NS_PACKAGE_no_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+
+		NS_PACKAGE_no_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $PERL" >&5
+echo "${ECHO_T}$PERL" >&6
+	fi
+fi
+
+    if test "x$PERL" != "x"
+    then
+	PERL=$PERL/perl5
+
+echo $PERL -e "require $PERL_VERSION" 1>&5
+if $PERL -e "require $PERL_VERSION" 2>&5
+then
+    : good version
+else
+    : non-good version => zero pathname
+    echo "$as_me:$LINENO: result:     not version $PERL_VERSION" >&5
+echo "${ECHO_T}    not version $PERL_VERSION" >&6
+    PERL=''
+fi
+
+    fi
+fi
+
+if test "x$PERL" = x
+then
+    if $PERL_OPTIONAL
+    then
+        echo "$as_me:$LINENO: result:     perl version $PERL_VERSION not found" >&5
+echo "${ECHO_T}    perl version $PERL_VERSION not found" >&6
+    else
+        { { echo "$as_me:$LINENO: error: Cannot find Perl 5." >&5
+echo "$as_me: error: Cannot find Perl 5." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+fi
+
+
+
+
+if test "x$PERL" = x
+then
+	{ echo "$as_me:$LINENO: WARNING: Perl5 not found; test scripts will not run succesfully." >&5
+echo "$as_me: WARNING: Perl5 not found; test scripts will not run succesfully." >&2;}
+fi
+
+echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
+if test "${ac_cv_header_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_stdc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_stdc=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      exit(2);
+  exit (0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+
+
+
+
+
+
+
+
+
+for ac_header in arpa/inet.h fenv.h netinet/in.h string.h strings.h time.h unistd.h net/ethernet.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+echo "$as_me:$LINENO: checking for main in -lm" >&5
+echo $ECHO_N "checking for main in -lm... $ECHO_C" >&6
+if test "${ac_cv_lib_m_main+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lm  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+main ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_m_main=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_m_main=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_m_main" >&5
+echo "${ECHO_T}$ac_cv_lib_m_main" >&6
+if test $ac_cv_lib_m_main = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBM 1
+_ACEOF
+
+  LIBS="-lm $LIBS"
+
+else
+  { { echo "$as_me:$LINENO: error: Could not find math library" >&5
+echo "$as_me: error: Could not find math library" >&2;}
+   { (exit cannot continue.); exit cannot continue.; }; }
+fi
+
+
+
+
+
+
+
+
+for ac_func in bcopy bzero fesetprecision feenableexcept getrusage sbrk snprintf
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+echo "$as_me:$LINENO: checking return type of random" >&5
+echo $ECHO_N "checking return type of random... $ECHO_C" >&6
+touch confdefs.h
+if test "$cross_compiling" = yes; then
+  echo "$as_me:$LINENO: result: cross compiling--guessing int" >&5
+echo "${ECHO_T}cross compiling--guessing int" >&6
+cat >>confdefs.h <<\_ACEOF
+#define RANDOM_RETURN_TYPE int
+_ACEOF
+
+
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include "confdefs.h"
+long random() { return 1; }
+main() { exit(0); }
+
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: long" >&5
+echo "${ECHO_T}long" >&6
+cat >>confdefs.h <<\_ACEOF
+#define RANDOM_RETURN_TYPE long
+_ACEOF
+
+
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+echo "$as_me:$LINENO: result: int" >&5
+echo "${ECHO_T}int" >&6
+cat >>confdefs.h <<\_ACEOF
+#define RANDOM_RETURN_TYPE int
+_ACEOF
+
+
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+echo "$as_me:$LINENO: checking for int8_t" >&5
+echo $ECHO_N "checking for int8_t... $ECHO_C" >&6
+if test "${ac_cv_type_int8_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((int8_t *) 0)
+  return 0;
+if (sizeof (int8_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_int8_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_int8_t=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_int8_t" >&5
+echo "${ECHO_T}$ac_cv_type_int8_t" >&6
+if test $ac_cv_type_int8_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define int8_t signed char
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for int16_t" >&5
+echo $ECHO_N "checking for int16_t... $ECHO_C" >&6
+if test "${ac_cv_type_int16_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((int16_t *) 0)
+  return 0;
+if (sizeof (int16_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_int16_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_int16_t=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_int16_t" >&5
+echo "${ECHO_T}$ac_cv_type_int16_t" >&6
+if test $ac_cv_type_int16_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define int16_t short
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for int32_t" >&5
+echo $ECHO_N "checking for int32_t... $ECHO_C" >&6
+if test "${ac_cv_type_int32_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((int32_t *) 0)
+  return 0;
+if (sizeof (int32_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_int32_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_int32_t=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_int32_t" >&5
+echo "${ECHO_T}$ac_cv_type_int32_t" >&6
+if test $ac_cv_type_int32_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define int32_t int
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for u_int8_t" >&5
+echo $ECHO_N "checking for u_int8_t... $ECHO_C" >&6
+if test "${ac_cv_type_u_int8_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((u_int8_t *) 0)
+  return 0;
+if (sizeof (u_int8_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_u_int8_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_u_int8_t=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_u_int8_t" >&5
+echo "${ECHO_T}$ac_cv_type_u_int8_t" >&6
+if test $ac_cv_type_u_int8_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define u_int8_t unsigned char
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for u_int16_t" >&5
+echo $ECHO_N "checking for u_int16_t... $ECHO_C" >&6
+if test "${ac_cv_type_u_int16_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((u_int16_t *) 0)
+  return 0;
+if (sizeof (u_int16_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_u_int16_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_u_int16_t=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_u_int16_t" >&5
+echo "${ECHO_T}$ac_cv_type_u_int16_t" >&6
+if test $ac_cv_type_u_int16_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define u_int16_t unsigned short
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for u_int32_t" >&5
+echo $ECHO_N "checking for u_int32_t... $ECHO_C" >&6
+if test "${ac_cv_type_u_int32_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((u_int32_t *) 0)
+  return 0;
+if (sizeof (u_int32_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_u_int32_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_u_int32_t=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_u_int32_t" >&5
+echo "${ECHO_T}$ac_cv_type_u_int32_t" >&6
+if test $ac_cv_type_u_int32_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define u_int32_t unsigned int
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for u_char" >&5
+echo $ECHO_N "checking for u_char... $ECHO_C" >&6
+if test "${ac_cv_type_u_char+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((u_char *) 0)
+  return 0;
+if (sizeof (u_char))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_u_char=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_u_char=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_u_char" >&5
+echo "${ECHO_T}$ac_cv_type_u_char" >&6
+if test $ac_cv_type_u_char = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define u_char unsigned char
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for u_int" >&5
+echo $ECHO_N "checking for u_int... $ECHO_C" >&6
+if test "${ac_cv_type_u_int+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((u_int *) 0)
+  return 0;
+if (sizeof (u_int))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_u_int=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_u_int=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_u_int" >&5
+echo "${ECHO_T}$ac_cv_type_u_int" >&6
+if test $ac_cv_type_u_int = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define u_int unsigned int
+_ACEOF
+
+fi
+
+
+
+
+
+for ac_func in strtoq strtoll
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+INT64_T_ALTERNATIVE=none
+HAVE_SUPPORTING_FUNC=false
+
+echo "$as_me:$LINENO: checking for long" >&5
+echo $ECHO_N "checking for long... $ECHO_C" >&6
+if test "${ac_cv_type_long+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((long *) 0)
+  return 0;
+if (sizeof (long))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_long=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_long=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_long" >&5
+echo "${ECHO_T}$ac_cv_type_long" >&6
+
+echo "$as_me:$LINENO: checking size of long" >&5
+echo $ECHO_N "checking size of long... $ECHO_C" >&6
+if test "${ac_cv_sizeof_long+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$ac_cv_type_long" = yes; then
+  # The cast to unsigned long works around a bug in the HP C Compiler
+  # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+  # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+  # This bug is HP SR number 8606223364.
+  if test "$cross_compiling" = yes; then
+  # Depending upon the size, compute the lo and hi bounds.
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long) (sizeof (long))) >= 0)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_lo=0 ac_mid=0
+  while :; do
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long) (sizeof (long))) <= $ac_mid)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_hi=$ac_mid; break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_lo=`expr $ac_mid + 1`
+		    if test $ac_lo -le $ac_mid; then
+		      ac_lo= ac_hi=
+		      break
+		    fi
+		    ac_mid=`expr 2 '*' $ac_mid + 1`
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long) (sizeof (long))) < 0)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_hi=-1 ac_mid=-1
+  while :; do
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long) (sizeof (long))) >= $ac_mid)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_lo=$ac_mid; break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_hi=`expr '(' $ac_mid ')' - 1`
+		       if test $ac_mid -le $ac_hi; then
+			 ac_lo= ac_hi=
+			 break
+		       fi
+		       ac_mid=`expr 2 '*' $ac_mid`
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_lo= ac_hi=
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+# Binary search between lo and hi bounds.
+while test "x$ac_lo" != "x$ac_hi"; do
+  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long) (sizeof (long))) <= $ac_mid)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_hi=$ac_mid
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_lo=`expr '(' $ac_mid ')' + 1`
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+case $ac_lo in
+?*) ac_cv_sizeof_long=$ac_lo;;
+'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute sizeof (long), 77
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; } ;;
+esac
+else
+  if test "$cross_compiling" = yes; then
+  { { echo "$as_me:$LINENO: error: internal error: not reached in cross-compile" >&5
+echo "$as_me: error: internal error: not reached in cross-compile" >&2;}
+   { (exit 1); exit 1; }; }
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+long longval () { return (long) (sizeof (long)); }
+unsigned long ulongval () { return (long) (sizeof (long)); }
+#include <stdio.h>
+#include <stdlib.h>
+int
+main ()
+{
+
+  FILE *f = fopen ("conftest.val", "w");
+  if (! f)
+    exit (1);
+  if (((long) (sizeof (long))) < 0)
+    {
+      long i = longval ();
+      if (i != ((long) (sizeof (long))))
+	exit (1);
+      fprintf (f, "%ld\n", i);
+    }
+  else
+    {
+      unsigned long i = ulongval ();
+      if (i != ((long) (sizeof (long))))
+	exit (1);
+      fprintf (f, "%lu\n", i);
+    }
+  exit (ferror (f) || fclose (f) != 0);
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_sizeof_long=`cat conftest.val`
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute sizeof (long), 77
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+rm -f conftest.val
+else
+  ac_cv_sizeof_long=0
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_sizeof_long" >&5
+echo "${ECHO_T}$ac_cv_sizeof_long" >&6
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_LONG $ac_cv_sizeof_long
+_ACEOF
+
+
+if test $ac_cv_sizeof_long -ge 8
+then
+	INT64_T_ALTERNATIVE=long
+	echo "$as_me:$LINENO: checking for strtol" >&5
+echo $ECHO_N "checking for strtol... $ECHO_C" >&6
+if test "${ac_cv_func_strtol+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define strtol to an innocuous variant, in case <limits.h> declares strtol.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define strtol innocuous_strtol
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char strtol (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef strtol
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char strtol ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_strtol) || defined (__stub___strtol)
+choke me
+#else
+char (*f) () = strtol;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != strtol;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_strtol=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_strtol=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_strtol" >&5
+echo "${ECHO_T}$ac_cv_func_strtol" >&6
+
+fi
+
+echo "$as_me:$LINENO: checking for __int64_t" >&5
+echo $ECHO_N "checking for __int64_t... $ECHO_C" >&6
+if test "${int64_t_HAVE___INT64_T+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "$cross_compiling" = yes; then
+  int64_t_HAVE___INT64_T=cross
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+main() { __int64_t x; exit (sizeof(x) >= 8 ? 0 : 1); }
+
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  int64_t_HAVE___INT64_T=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+int64_t_HAVE___INT64_T=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $int64_t_HAVE___INT64_T" >&5
+echo "${ECHO_T}$int64_t_HAVE___INT64_T" >&6
+if test x"$int64_t_HAVE___INT64_T" = x"yes" -a "x$INT64_T_ALTERNATIVE" = xnone; then
+	INT64_T_ALTERNATIVE=__int64_t
+fi
+
+echo "$as_me:$LINENO: checking for long long" >&5
+echo $ECHO_N "checking for long long... $ECHO_C" >&6
+if test "${int64_t_HAVE_LONG_LONG+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "$cross_compiling" = yes; then
+  int64_t_HAVE_LONG_LONG=cross
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+main() { long long x; exit (sizeof(x) >= 8 ? 0 : 1); }
+
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  int64_t_HAVE_LONG_LONG=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+int64_t_HAVE_LONG_LONG=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $int64_t_HAVE_LONG_LONG" >&5
+echo "${ECHO_T}$int64_t_HAVE_LONG_LONG" >&6
+if test x"$int64_t_HAVE_LONG_LONG" = x"yes" -a "x$INT64_T_ALTERNATIVE" = xnone; then
+	INT64_T_ALTERNATIVE="long long"
+fi
+
+
+
+echo "$as_me:$LINENO: checking for int64_t" >&5
+echo $ECHO_N "checking for int64_t... $ECHO_C" >&6
+if test "${ac_cv_type_int64_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "(^|[^a-zA-Z_0-9])int64_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
+  ac_cv_type_int64_t=yes
+else
+  ac_cv_type_int64_t=no
+fi
+rm -f conftest*
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_int64_t" >&5
+echo "${ECHO_T}$ac_cv_type_int64_t" >&6
+if test $ac_cv_type_int64_t = no; then
+  cat >>confdefs.h <<_ACEOF
+#define int64_t $INT64_T_ALTERNATIVE
+_ACEOF
+
+fi
+
+
+echo "$as_me:$LINENO: checking which kind of 64-bit int to use" >&5
+echo $ECHO_N "checking which kind of 64-bit int to use... $ECHO_C" >&6
+if test $ac_cv_type_int64_t = yes -o "$INT64_T_ALTERNATIVE" != none
+then
+	if test "$INT64_T_ALTERNATIVE" = long -o "$ac_cv_func_strtoq" = yes -o "$ac_cv_func_strtoll" = yes
+	then
+		cat >>confdefs.h <<\_ACEOF
+#define HAVE_INT64 1
+_ACEOF
+
+		if test $ac_cv_type_int64_t = yes
+		then
+			echo "$as_me:$LINENO: result: int64_t" >&5
+echo "${ECHO_T}int64_t" >&6
+		else
+			echo "$as_me:$LINENO: result: $INT64_T_ALTERNATIVE" >&5
+echo "${ECHO_T}$INT64_T_ALTERNATIVE" >&6
+		fi
+	else
+		echo "$as_me:$LINENO: result: missing strto 64-bit-type" >&5
+echo "${ECHO_T}missing strto 64-bit-type" >&6
+	fi
+else
+	echo "$as_me:$LINENO: result: none" >&5
+echo "${ECHO_T}none" >&6
+fi
+
+
+
+
+
+
+
+echo "$as_me:$LINENO: checking for struct ether_header" >&5
+echo $ECHO_N "checking for struct ether_header... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#include <net/ethernet.h>
+
+int
+main ()
+{
+
+int main()
+{
+	struct ether_header etherHdr;
+
+	return 1;
+}
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ETHER_HEADER_STRUCT 1
+_ACEOF
+
+echo "$as_me:$LINENO: result: found" >&5
+echo "${ECHO_T}found" >&6
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+echo "$as_me:$LINENO: result: not found" >&5
+echo "${ECHO_T}not found" >&6
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+echo "$as_me:$LINENO: checking for struct ether_addr" >&5
+echo $ECHO_N "checking for struct ether_addr... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#include <net/ethernet.h>
+
+int
+main ()
+{
+
+int main()
+{
+	struct ether_addr etherAddr;
+
+	return 0;
+}
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ETHER_ADDRESS_STRUCT 1
+_ACEOF
+
+echo "$as_me:$LINENO: result: found" >&5
+echo "${ECHO_T}found" >&6
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+echo "$as_me:$LINENO: result: not found" >&5
+echo "${ECHO_T}not found" >&6
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+cross_compiling=no
+
+for ac_func in addr2ascii
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+if test "$cross_compiling" = yes; then
+  echo 1
+
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdio.h>
+#include <sys/ioctl.h>
+int main()
+{
+	int i = SIOCGIFHWADDR;
+	return 0;
+}
+
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_SIOCGIFHWADDR 1
+_ACEOF
+
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+tcphdr=no
+pcap=no
+
+echo "$as_me:$LINENO: checking for Linux compliant tcphdr" >&5
+echo $ECHO_N "checking for Linux compliant tcphdr... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#include <netinet/tcp.h>
+
+int
+main ()
+{
+
+int main()
+{
+	struct tcphdr *tcp;
+	tcp->source= 1;
+
+	return 0;
+}
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+
+V_DEFINE="$V_DEFINE -DLINUX_TCP_HEADER"
+echo "$as_me:$LINENO: result: found" >&5
+echo "${ECHO_T}found" >&6
+tcphdr=yes
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+echo "$as_me:$LINENO: result: not found" >&5
+echo "${ECHO_T}not found" >&6
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+echo "$as_me:$LINENO: checking for BSD compliant tcphdr" >&5
+echo $ECHO_N "checking for BSD compliant tcphdr... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#include <netinet/tcp.h>
+
+int
+main ()
+{
+
+int main()
+{
+	struct tcphdr *tcp;
+	tcp->th_sport= 1;
+
+	return 0;
+}
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+
+echo "$as_me:$LINENO: result: found" >&5
+echo "${ECHO_T}found" >&6
+tcphdr=yes
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+echo "$as_me:$LINENO: result: not found" >&5
+echo "${ECHO_T}not found" >&6
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+echo "$as_me:$LINENO: checking for socklen_t" >&5
+echo $ECHO_N "checking for socklen_t... $ECHO_C" >&6
+if test "${ac_cv_type_socklen_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+   #include <sys/socket.h>
+int
+main ()
+{
+socklen_t len = 42; return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_socklen_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_socklen_t=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_socklen_t" >&5
+echo "${ECHO_T}$ac_cv_type_socklen_t" >&6
+
+if test x"$ac_cv_type_socklen_t" = xyes; then
+    cat >>confdefs.h <<\_ACEOF
+#define HAVE_SOCKLEN_T 1
+_ACEOF
+
+fi
+
+
+
+
+echo "$as_me:$LINENO: checking for main in -lpcap" >&5
+echo $ECHO_N "checking for main in -lpcap... $ECHO_C" >&6
+if test "${ac_cv_lib_pcap_main+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpcap  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+main ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_pcap_main=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_pcap_main=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_pcap_main" >&5
+echo "${ECHO_T}$ac_cv_lib_pcap_main" >&6
+if test $ac_cv_lib_pcap_main = yes; then
+  V_LIB="$V_LIB -lpcap" pcap=yes
+fi
+
+V_INCLUDES="$V_INCLUDES -I/usr/include/pcap"
+
+
+echo "$as_me:$LINENO: checking to make nse" >&5
+echo $ECHO_N "checking to make nse... $ECHO_C" >&6
+if test $tcphdr = yes && test $pcap = yes; then
+		build_nse="nse"
+		echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+else
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+
+
+
+
+if test "$enable_static" = "yes" ; then
+	echo Explicitly enabling static compilation
+	V_STATIC="-static"
+elif test "$enable_static" = "no" ; then
+	echo Explicitly disabling static compilation
+	V_STATIC=""
+else
+	echo No explicit static compilation flag\; setting V_STATIC to \"$V_STATIC\"
+fi
+
+
+
+#
+# tcl7.x needs a dynamic loading library (unless built with the
+# -disable-load flag).  Try to find the appropriate one.
+
+if test ! -z "$V_NEED_DL" ; then
+	V_LIB_DL=""
+	case "$target" in
+	*-*-solaris*)
+		V_LIB_DL="dl"
+		;;
+	sparc-sun-sunos*)
+		V_LIB_DL="dl"
+		;;
+	*-*-bsdi2.1)
+		V_LIB_DL="dl"
+		;;
+	*-*-bsdi3.0)
+		V_LIB_DL="dl"
+		;;
+	*-*-hpux*)
+		V_LIB_DL="dld"
+		;;
+	*-*-linux*)
+		echo "$as_me:$LINENO: checking for dlopen in -ldl" >&5
+echo $ECHO_N "checking for dlopen in -ldl... $ECHO_C" >&6
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dlopen ();
+int
+main ()
+{
+dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dl_dlopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_dl_dlopen=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlopen" >&5
+echo "${ECHO_T}$ac_cv_lib_dl_dlopen" >&6
+if test $ac_cv_lib_dl_dlopen = yes; then
+  V_LIB_DL="dl"
+else
+  V_LIB_DL="dld"
+fi
+
+		;;
+	esac
+	if test ! -z "$V_LIB_DL" ; then
+		case "$target" in
+		*-*-linux*)
+			;;
+		*)
+
+as_ac_Lib=`echo "ac_cv_lib_$V_LIB_DL''_main" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for main in -l$V_LIB_DL" >&5
+echo $ECHO_N "checking for main in -l$V_LIB_DL... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Lib+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-l$V_LIB_DL $V_STATIC $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+main ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_Lib=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_Lib=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Lib'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Lib'}'`" >&6
+if test `eval echo '${'$as_ac_Lib'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_LIB$V_LIB_DL" | $as_tr_cpp` 1
+_ACEOF
+
+  LIBS="-l$V_LIB_DL $LIBS"
+
+else
+  V_LIB_DL=""
+fi
+
+			;;
+		esac
+	fi
+	if test ! -z "$V_LIB_DL" ; then
+		case "$target" in
+		*-*-bsdi*)
+			;;
+		*-*-linux*)
+			if test -z "$V_STATIC" ; then
+				V_LIB="$V_LIB -l$V_LIB_DL"
+			fi
+			;;
+		*)
+			V_LIB="$V_LIB -l$V_LIB_DL"
+			;;
+		esac
+	else
+		echo "no dynamic load lib"
+	fi
+fi
+
+
+if test "$host_cpu" = alpha ; then
+	V_DEFINE="$V_DEFINE -DINT_64=u_long"
+fi
+
+# various include hacks
+dirs="/usr/src/local/include-fixes \
+	/import/mcast/include"
+for dir in $dirs; do
+	if test -d $dir ; then
+		V_INCLUDE="$V_INCLUDE -I$dir"
+	fi
+done
+
+# always use -g with gcc during development (even with -O)
+# force noline so that we can debug all functions
+if test "$CC" = gcc && test -f .devel ; then
+	V_CCOPT="$V_CCOPT -g -Wall -Werror"
+	V_DEFINE="$V_DEFINE -fsigned-char -fno-inline"
+fi
+
+V_DEFINE="$V_DEFINE $V_SHM"
+
+V_TAR_TARGET=$target_os
+
+
+absolutize_list() {
+    tmp=""
+    for p
+    do
+	case $p in
+	-L* | -I*) tmp="$tmp `absolutize $p`";;
+	*) tmp="$tmp $p";;
+        esac
+    done
+    echo $tmp
+}
+
+# Replace relative path with absolute path
+V_LIB_TCLCL=`absolutize_list $V_LIB_TCLCL`
+V_LIB_OTCL=`absolutize_list $V_LIB_OTCL`
+V_LIB_TCL=`absolutize_list $V_LIB_TCL`
+V_LIB_TK=`absolutize_list $V_LIB_TK`
+V_LIBS=`absolutize_list $V_LIBS`
+V_INCLUDES=`absolutize_list $V_INCLUDES`
+
+# Since SMASH and MASH need different sets of libraries, we
+# use each lib definition seperately instead of using V_LIBS.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	    break 3
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+done
+
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL=$ac_install_sh
+  fi
+fi
+echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+
+                                                                      ac_config_files="$ac_config_files Makefile tcl/lib/ns-autoconf.tcl indep-utils/webtrace-conv/ucb/Makefile indep-utils/webtrace-conv/dec/Makefile indep-utils/webtrace-conv/nlanr/Makefile indep-utils/webtrace-conv/epa/Makefile indep-utils/cmu-scen-gen/setdest/Makefile"
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+{
+  (set) 2>&1 |
+    case `(ac_space=' '; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;;
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+} |
+  sed '
+     t clear
+     : clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' >>confcache
+if diff $cache_file confcache >/dev/null 2>&1; then :; else
+  if test -w $cache_file; then
+    test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
+    cat confcache >$cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}'
+fi
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo "$ac_i" |
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+_ACEOF
+
+# Files that config.status was made for.
+if test -n "$ac_config_files"; then
+  echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_headers"; then
+  echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_links"; then
+  echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_commands"; then
+  echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+  --header=FILE[:TEMPLATE]
+		   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Report bugs to <bug-autoconf@gnu.org>."
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+ac_cs_version="\\
+config.status
+configured by $0, generated by GNU Autoconf 2.59,
+  with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=$srcdir
+INSTALL="$INSTALL"
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+
+
+
+
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+  "tcl/lib/ns-autoconf.tcl" ) CONFIG_FILES="$CONFIG_FILES tcl/lib/ns-autoconf.tcl" ;;
+  "indep-utils/webtrace-conv/ucb/Makefile" ) CONFIG_FILES="$CONFIG_FILES indep-utils/webtrace-conv/ucb/Makefile" ;;
+  "indep-utils/webtrace-conv/dec/Makefile" ) CONFIG_FILES="$CONFIG_FILES indep-utils/webtrace-conv/dec/Makefile" ;;
+  "indep-utils/webtrace-conv/nlanr/Makefile" ) CONFIG_FILES="$CONFIG_FILES indep-utils/webtrace-conv/nlanr/Makefile" ;;
+  "indep-utils/webtrace-conv/epa/Makefile" ) CONFIG_FILES="$CONFIG_FILES indep-utils/webtrace-conv/epa/Makefile" ;;
+  "indep-utils/cmu-scen-gen/setdest/Makefile" ) CONFIG_FILES="$CONFIG_FILES indep-utils/cmu-scen-gen/setdest/Makefile" ;;
+  "autoconf.h" ) CONFIG_HEADERS="$CONFIG_HEADERS autoconf.h" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "\$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
+s,@SHELL@,$SHELL,;t t
+s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
+s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
+s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
+s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
+s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
+s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
+s,@exec_prefix@,$exec_prefix,;t t
+s,@prefix@,$prefix,;t t
+s,@program_transform_name@,$program_transform_name,;t t
+s,@bindir@,$bindir,;t t
+s,@sbindir@,$sbindir,;t t
+s,@libexecdir@,$libexecdir,;t t
+s,@datadir@,$datadir,;t t
+s,@sysconfdir@,$sysconfdir,;t t
+s,@sharedstatedir@,$sharedstatedir,;t t
+s,@localstatedir@,$localstatedir,;t t
+s,@libdir@,$libdir,;t t
+s,@includedir@,$includedir,;t t
+s,@oldincludedir@,$oldincludedir,;t t
+s,@infodir@,$infodir,;t t
+s,@mandir@,$mandir,;t t
+s,@build_alias@,$build_alias,;t t
+s,@host_alias@,$host_alias,;t t
+s,@target_alias@,$target_alias,;t t
+s,@DEFS@,$DEFS,;t t
+s,@ECHO_C@,$ECHO_C,;t t
+s,@ECHO_N@,$ECHO_N,;t t
+s,@ECHO_T@,$ECHO_T,;t t
+s,@LIBS@,$LIBS,;t t
+s,@build@,$build,;t t
+s,@build_cpu@,$build_cpu,;t t
+s,@build_vendor@,$build_vendor,;t t
+s,@build_os@,$build_os,;t t
+s,@host@,$host,;t t
+s,@host_cpu@,$host_cpu,;t t
+s,@host_vendor@,$host_vendor,;t t
+s,@host_os@,$host_os,;t t
+s,@target@,$target,;t t
+s,@target_cpu@,$target_cpu,;t t
+s,@target_vendor@,$target_vendor,;t t
+s,@target_os@,$target_os,;t t
+s,@CC@,$CC,;t t
+s,@CFLAGS@,$CFLAGS,;t t
+s,@LDFLAGS@,$LDFLAGS,;t t
+s,@CPPFLAGS@,$CPPFLAGS,;t t
+s,@ac_ct_CC@,$ac_ct_CC,;t t
+s,@EXEEXT@,$EXEEXT,;t t
+s,@OBJEXT@,$OBJEXT,;t t
+s,@CXX@,$CXX,;t t
+s,@CXXFLAGS@,$CXXFLAGS,;t t
+s,@ac_ct_CXX@,$ac_ct_CXX,;t t
+s,@CPP@,$CPP,;t t
+s,@EGREP@,$EGREP,;t t
+s,@CPP_NAMESPACE@,$CPP_NAMESPACE,;t t
+s,@V_TCL_LIBRARY_FILES@,$V_TCL_LIBRARY_FILES,;t t
+s,@V_TCLSH@,$V_TCLSH,;t t
+s,@V_LIBRARY_TCL@,$V_LIBRARY_TCL,;t t
+s,@V_TKDOSNAMES@,$V_TKDOSNAMES,;t t
+s,@V_LIBRARY_TK@,$V_LIBRARY_TK,;t t
+s,@V_TCL2CPP@,$V_TCL2CPP,;t t
+s,@PERL@,$PERL,;t t
+s,@build_nse@,$build_nse,;t t
+s,@V_INCLUDES@,$V_INCLUDES,;t t
+s,@V_LIBS@,$V_LIBS,;t t
+s,@V_DEFINES@,$V_DEFINES,;t t
+s,@V_STATIC@,$V_STATIC,;t t
+s,@V_TAR_TARGET@,$V_TAR_TARGET,;t t
+s,@V_LIB_TCLCL@,$V_LIB_TCLCL,;t t
+s,@V_LIB_OTCL@,$V_LIB_OTCL,;t t
+s,@V_LIB_TCL@,$V_LIB_TCL,;t t
+s,@V_LIB_TK@,$V_LIB_TK,;t t
+s,@V_ALL@,$V_ALL,;t t
+s,@V_CCOPT@,$V_CCOPT,;t t
+s,@V_TAR_EXTRA@,$V_TAR_EXTRA,;t t
+s,@V_LIB@,$V_LIB,;t t
+s,@V_DEFINE@,$V_DEFINE,;t t
+s,@V_SIGRET@,$V_SIGRET,;t t
+s,@V_SHELL@,$V_SHELL,;t t
+s,@V_TARCMD@,$V_TARCMD,;t t
+s,@V_INCLUDE@,$V_INCLUDE,;t t
+s,@V_OBJ@,$V_OBJ,;t t
+s,@V_BROKEN_OBJ@,$V_BROKEN_OBJ,;t t
+s,@V_OBJ_CRYPT@,$V_OBJ_CRYPT,;t t
+s,@V_RANLIB@,$V_RANLIB,;t t
+s,@V_AR@,$V_AR,;t t
+s,@V_STLOBJ@,$V_STLOBJ,;t t
+s,@V_NS_TCL_LIB_STL@,$V_NS_TCL_LIB_STL,;t t
+s,@V_LSSCRIPT@,$V_LSSCRIPT,;t t
+s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
+s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
+s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+s,@LIBOBJS@,$LIBOBJS,;t t
+s,@LTLIBOBJS@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat >>$CONFIG_STATUS <<\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
+  esac
+
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+  sed "$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+s,@INSTALL@,$ac_INSTALL,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_HEADER section.
+#
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s,^\([	 ]*\)#\([	 ]*define[	 ][	 ]*\)'
+ac_dB='[	 ].*$,\1#\2'
+ac_dC=' '
+ac_dD=',;t'
+# ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_uA='s,^\([	 ]*\)#\([	 ]*\)undef\([	 ][	 ]*\)'
+ac_uB='$,\1#\2define\3'
+ac_uC=' '
+ac_uD=',;t'
+
+for ac_file in : $CONFIG_HEADERS; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  test x"$ac_file" != x- && { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 # Do quote $f, to prevent DOS paths from being IFS'd.
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+  # Remove the trailing spaces.
+  sed 's/[	 ]*$//' $ac_file_inputs >$tmp/in
+
+_ACEOF
+
+# Transform confdefs.h into two sed scripts, `conftest.defines' and
+# `conftest.undefs', that substitutes the proper values into
+# config.h.in to produce config.h.  The first handles `#define'
+# templates, and the second `#undef' templates.
+# And first: Protect against being on the right side of a sed subst in
+# config.status.  Protect against being in an unquoted here document
+# in config.status.
+rm -f conftest.defines conftest.undefs
+# Using a here document instead of a string reduces the quoting nightmare.
+# Putting comments in sed scripts is not portable.
+#
+# `end' is used to avoid that the second main sed command (meant for
+# 0-ary CPP macros) applies to n-ary macro definitions.
+# See the Autoconf documentation for `clear'.
+cat >confdef2sed.sed <<\_ACEOF
+s/[\\&,]/\\&/g
+s,[\\$`],\\&,g
+t clear
+: clear
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*\)\(([^)]*)\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
+t end
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
+: end
+_ACEOF
+# If some macros were called several times there might be several times
+# the same #defines, which is useless.  Nevertheless, we may not want to
+# sort them, since we want the *last* AC-DEFINE to be honored.
+uniq confdefs.h | sed -n -f confdef2sed.sed >conftest.defines
+sed 's/ac_d/ac_u/g' conftest.defines >conftest.undefs
+rm -f confdef2sed.sed
+
+# This sed command replaces #undef with comments.  This is necessary, for
+# example, in the case of _POSIX_SOURCE, which is predefined and required
+# on some systems where configure will not decide to define it.
+cat >>conftest.undefs <<\_ACEOF
+s,^[	 ]*#[	 ]*undef[	 ][	 ]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
+_ACEOF
+
+# Break up conftest.defines because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
+echo '  if grep "^[	 ]*#[	 ]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
+echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
+echo '  :' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.defines >/dev/null
+do
+  # Write a limited-size here document to $tmp/defines.sed.
+  echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#define' lines.
+  echo '/^[	 ]*#[	 ]*define/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.defines >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/defines.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.defines >conftest.tail
+  rm -f conftest.defines
+  mv conftest.tail conftest.defines
+done
+rm -f conftest.defines
+echo '  fi # grep' >>$CONFIG_STATUS
+echo >>$CONFIG_STATUS
+
+# Break up conftest.undefs because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #undef templates' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.undefs >/dev/null
+do
+  # Write a limited-size here document to $tmp/undefs.sed.
+  echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#undef'
+  echo '/^[	 ]*#[	 ]*undef/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.undefs >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/undefs.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.undefs >conftest.tail
+  rm -f conftest.undefs
+  mv conftest.tail conftest.undefs
+done
+rm -f conftest.undefs
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    echo "/* Generated by configure.  */" >$tmp/config.h
+  else
+    echo "/* $ac_file.  Generated by configure.  */" >$tmp/config.h
+  fi
+  cat $tmp/in >>$tmp/config.h
+  rm -f $tmp/in
+  if test x"$ac_file" != x-; then
+    if diff $ac_file $tmp/config.h >/dev/null 2>&1; then
+      { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+      { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+      rm -f $ac_file
+      mv $tmp/config.h $ac_file
+    fi
+  else
+    cat $tmp/config.h
+    rm -f $tmp/config.h
+  fi
+done
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
+
+if test ! -d gen ; then
+	echo "creating ./gen"
+	mkdir gen
+fi
+
+if test ! -d bin ; then
+	echo "creating ./bin"
+	mkdir bin
+fi
+
+if test -f .devel -o "$enable_devel" = "yes" ; then
+	make depend
+fi
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/diffusion/diffusion.h ns-2.30/diffusion/diffusion.h
--- ns-2.30-pure/diffusion/diffusion.h	2006-09-24 22:11:15.000000000 -0700
+++ ns-2.30/diffusion/diffusion.h	2006-12-30 17:22:28.000000000 -0800
@@ -138,6 +138,10 @@
 };
 
 
+void XmitFailedCallback(Packet *pkt, void *data);
+class ArpBufferTimer;
+class SendBufTimer;
+
 class DiffusionAgent : public Agent {
  public:
   DiffusionAgent();
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/diffusion/omni_mcast.h ns-2.30/diffusion/omni_mcast.h
--- ns-2.30-pure/diffusion/omni_mcast.h	2006-09-24 22:11:15.000000000 -0700
+++ ns-2.30/diffusion/omni_mcast.h	2006-12-30 17:22:28.000000000 -0800
@@ -157,6 +157,10 @@
 
 
 
+void OmniMcastXmitFailedCallback(Packet *pkt, void *data);
+
+class OmniMcastArpBufferTimer;
+class OmniMcastSendBufTimer;
 
 class OmniMcastAgent : public Agent {
  public:
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/dsr/dsragent.h ns-2.30/dsr/dsragent.h
--- ns-2.30-pure/dsr/dsragent.h	2006-09-24 22:11:17.000000000 -0700
+++ ns-2.30/dsr/dsragent.h	2006-12-30 17:22:28.000000000 -0800
@@ -110,6 +110,12 @@
 
 LIST_HEAD(DSRAgent_List, DSRAgent);
 
+void XmitFailureCallback(Packet *pkt, void *data);
+void XmitFlowFailureCallback(Packet *pkt, void *data);
+int FilterFailure(Packet *p, void *data);
+class SendBufferTimer;
+
+
 class DSRAgent : public Tap, public Agent {
 public:
 
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/mac/channel.cc ns-2.30/mac/channel.cc
--- ns-2.30-pure/mac/channel.cc	2006-09-24 22:11:19.000000000 -0700
+++ ns-2.30/mac/channel.cc	2006-12-30 17:22:28.000000000 -0800
@@ -120,6 +120,12 @@
 			((Phy*) obj)->setchnl(this);
 			return TCL_OK;
 		}
+		else if(strcmp(argv[1], "delif") == 0) {
+			// Remove phy from channel
+			((Phy*) obj)->setchnl(0);
+			((Phy*) obj)->removechnl();
+			return TCL_OK;
+		}
 
 		// add interface for grid_keeper_
 		/*else if(strncasecmp(argv[1], "grid_keeper", 5) == 0) {
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/mac/ll-ext.cc ns-2.30/mac/ll-ext.cc
--- ns-2.30-pure/mac/ll-ext.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/mac/ll-ext.cc	2006-12-30 17:22:28.000000000 -0800
@@ -0,0 +1,173 @@
+/*
+ * ll-ext.cc
+ * This is a special link layer which explicitly notifies the attached
+ * queue when it becomes free.
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+// XXX This is really a click link layer now - not just ext...
+
+#include "config.h"
+#include <stdlib.h>
+#include <ctype.h>
+#include <sys/time.h>
+#include <unistd.h>
+//#include <stl.h>
+//#include <hash_map.h>
+#include <map>
+#include <math.h>
+#include <string>
+#include "packet.h"
+#include "ip.h"
+#include "mac.h"
+#include "classifier.h"
+//#include "classifier-hash.h"
+#include "scheduler.h"
+#include "ll.h"
+#include <click/simclick.h>
+#include "ll-ext.h"
+#include "packet.h"
+#include "extrouter.h"
+#include "classifier.h"
+#include "classifier-ext.h"
+#include "classifier-click.h"
+#include "clickqueue.h"
+
+static class LLExtClass : public TclClass {
+public:
+  LLExtClass() : TclClass("LL/Ext") {}
+  TclObject* create(int, const char*const*) {
+    return (new LLExt());
+  }
+} class_ll_ext;
+
+void
+LLExtEventHandler::handle(Event* event) {
+  // XXX dangerous downcast - should use RTTI
+  LLExtEvent* myevent = (LLExtEvent*) event;
+  myevent->llext->setpending(0);
+  delete myevent;
+}
+
+
+LLExt::LLExt() {
+  extid_ = -1;
+  macDA_ = -1;
+  packetpending_ = 0;
+}
+
+LLExt::~LLExt() {
+}
+
+int LLExt::command(int argc, const char*const* argv) {
+  Tcl& tcl = Tcl::instance();
+  if(argc == 2) {
+  }
+  else if (argc == 3) {
+    if (strcmp("setid",argv[1]) == 0) {
+      extid_ = atoi(argv[2]);
+      return TCL_OK;
+    }
+    else if (strcmp("setpromiscuous",argv[1]) == 0) {
+      bool promisc = (atoi(argv[2]) != 0);
+      setpromiscuous(promisc);
+      return TCL_OK;
+    }
+  }
+  else if (argc == 4) {
+  }
+
+  return LL::command(argc,argv);
+}
+
+void LLExt::recv(Packet* p, Handler* h) {
+  /*
+   * Tag the packet and then defer to standard link layer handling.
+   */
+  struct hdr_cmn* hdr = HDR_CMN(p);
+  hdr->iface() = extid_;
+  // printf("ll = %d, ifid = %d\n",(int)this,hdr->iface());
+  LL::recv(p,h);
+}
+
+void LLExt::sendDown(Packet* p) {
+  // Someone decided that it would be A Good Thing to overlay
+  // the 802.11 MAC packet info on top of the regular MAC packet info.
+  // We need to fix the source and destination addresses here by accessing the
+  // MAC object itself.
+  struct hdr_mac* mhdr = HDR_MAC(p);
+  int macdst = mhdr->macDA();
+  int macsrc = mhdr->macSA();
+  memset(mhdr,0,sizeof(struct hdr_mac));
+  mac_->hdr_dst((char*)mhdr,macdst);
+  mac_->hdr_src((char*)mhdr,macsrc);
+
+  // Bleah. Send the packet down, mark ourself as being busy, and then
+  // schedule an event to mark ourselves unbusy.
+  packetpending_ = 1;
+  LL::sendDown(p);
+  LLExtEvent* llev = new LLExtEvent();
+  llev->llext = this;
+  Scheduler& s = Scheduler::instance();
+  s.schedule(&evhandle_,llev,delay_);
+}
+
+int LLExt::ready() {
+  ClickQueue* pcq = (ClickQueue*) ifq_;
+  if (pcq) {
+    return (!packetpending_ && pcq->ready());
+  }
+
+  // No ClickQueue? Then we're always ready.
+  return 1;
+}
+
+void
+LLExt::setpromiscuous(bool promisc) {
+  if (!mac_) {
+    return;
+  }
+
+  if (promisc) {
+    mac_->installTap(this,true);
+  }
+  else {
+    mac_->installTap(0,true);
+  }
+}
+
+void 
+LLExt::tap(const Packet *packet)
+  /* process packets that are promiscously listened to from the MAC layer tap
+  *** do not change or free packet *** */
+{
+  // XXX send a copy of packets received here up to the next layer.
+  // This code assumes that the tap is being used with the "filterown"
+  // option set, otherwise duplicate packets will get sent up the pipe.
+  Packet* newp = packet->copy();
+  recv(newp,0);
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/mac/ll-ext.h ns-2.30/mac/ll-ext.h
--- ns-2.30-pure/mac/ll-ext.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/mac/ll-ext.h	2006-12-30 17:22:28.000000000 -0800
@@ -0,0 +1,78 @@
+/*
+ * ll-ext.h
+ *
+ * Much like the multicast routing system, ext routers needs to know what
+ * interface packets come in from. However, the multicast interface
+ * thing doesn't quite do what we need it to, so you get what
+ * we've got here. 
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#ifndef ns_ll_ext_h
+#define ns_ll_ext_h
+
+#include "object.h"
+
+class Packet;
+class LLExt;
+
+class LLExtEvent : public Event {
+ public:
+  LLExt* llext;
+};
+
+class LLExtEventHandler : public Handler {
+ public:
+  virtual void handle(Event* event);
+};
+
+class LLExt : public LL, public Tap {
+ public:
+  LLExt();
+  virtual ~LLExt();
+	
+  virtual void recv(Packet* p, Handler* h);
+  virtual void sendDown(Packet* p);
+
+  // Allow us to do promiscuous mode by acting as a tap.
+  void tap(const Packet *p);
+
+  void setExtID(int newid) {extid_ = newid;}
+  int getExtID() {return extid_;}
+  int ready();
+  int getpending() { return packetpending_; }
+  void setpending(int newpend) { packetpending_ = newpend; };
+  void setpromiscuous(bool promisc);
+  
+ protected:
+  virtual int command(int argc, const char*const* argv);
+  int extid_;
+  int packetpending_;
+  LLExtEventHandler evhandle_;
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/mac/ll.cc ns-2.30/mac/ll.cc
--- ns-2.30-pure/mac/ll.cc	2006-09-24 22:11:19.000000000 -0700
+++ ns-2.30/mac/ll.cc	2006-12-30 17:22:28.000000000 -0800
@@ -203,6 +203,9 @@
 			tx = arptable_->arpresolve(dst, p, this);
 			break;
 		}
+		if (PT_RAW == ch->ptype()) {
+			break;
+		}
 		//if (varp_) {
 		//tx = varp_->arpresolve(dst, p);
 		//break;
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/mac/mac-802_11.cc ns-2.30/mac/mac-802_11.cc
--- ns-2.30-pure/mac/mac-802_11.cc	2006-09-24 22:11:19.000000000 -0700
+++ ns-2.30/mac/mac-802_11.cc	2006-12-30 17:22:28.000000000 -0800
@@ -1298,8 +1298,12 @@
 
         /* tap out - */
         if (tap_ && type == MAC_Type_Data &&
-            MAC_Subtype_Data == subtype ) 
-		tap_->tap(pktRx_);
+            MAC_Subtype_Data == subtype ) {
+		if (!tap_filterown_ ||
+		    ((dst != (u_int32_t)index_) && (dst != MAC_BROADCAST))) {
+			tap_->tap(pktRx_);
+		}
+	}
 	/*
 	 * Adaptive Fidelity Algorithm Support - neighborhood infomation 
 	 * collection
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/mac/mac-802_11.cc.orig ns-2.30/mac/mac-802_11.cc.orig
--- ns-2.30-pure/mac/mac-802_11.cc.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/mac/mac-802_11.cc.orig	2006-09-24 22:11:19.000000000 -0700
@@ -0,0 +1,1615 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*-
+ *
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $Header: /home/kohler/click-cvsroot-copy/release/one/etc/ns-2.30-patch,v 1.1 2006/12/31 01:54:25 eddietwo Exp $
+ *
+ * Ported from CMU/Monarch's code, nov'98 -Padma.
+ * Contributions by:
+ *   - Mike Holland
+ *   - Sushmita
+ */
+
+#include "delay.h"
+#include "connector.h"
+#include "packet.h"
+#include "random.h"
+#include "mobilenode.h"
+
+// #define DEBUG 99
+
+#include "arp.h"
+#include "ll.h"
+#include "mac.h"
+#include "mac-timers.h"
+#include "mac-802_11.h"
+#include "cmu-trace.h"
+
+// Added by Sushmita to support event tracing
+#include "agent.h"
+#include "basetrace.h"
+
+
+/* our backoff timer doesn't count down in idle times during a
+ * frame-exchange sequence as the mac tx state isn't idle; genreally
+ * these idle times are less than DIFS and won't contribute to
+ * counting down the backoff period, but this could be a real
+ * problem if the frame exchange ends up in a timeout! in that case,
+ * i.e. if a timeout happens we've not been counting down for the
+ * duration of the timeout, and in fact begin counting down only
+ * DIFS after the timeout!! we lose the timeout interval - which
+ * will is not the REAL case! also, the backoff timer could be NULL
+ * and we could have a pending transmission which we could have
+ * sent! one could argue this is an implementation artifact which
+ * doesn't violate the spec.. and the timeout interval is expected
+ * to be less than DIFS .. which means its not a lot of time we
+ * lose.. anyway if everyone hears everyone the only reason a ack will
+ * be delayed will be due to a collision => the medium won't really be
+ * idle for a DIFS for this to really matter!!
+ */
+
+inline void
+Mac802_11::checkBackoffTimer()
+{
+	if(is_idle() && mhBackoff_.paused())
+		mhBackoff_.resume(phymib_.getDIFS());
+	if(! is_idle() && mhBackoff_.busy() && ! mhBackoff_.paused())
+		mhBackoff_.pause();
+}
+
+inline void
+Mac802_11::transmit(Packet *p, double timeout)
+{
+	tx_active_ = 1;
+	
+	if (EOTtarget_) {
+		assert (eotPacket_ == NULL);
+		eotPacket_ = p->copy();
+	}
+
+	/*
+	 * If I'm transmitting without doing CS, such as when
+	 * sending an ACK, any incoming packet will be "missed"
+	 * and hence, must be discarded.
+	 */
+	if(rx_state_ != MAC_IDLE) {
+		//assert(dh->dh_fc.fc_type == MAC_Type_Control);
+		//assert(dh->dh_fc.fc_subtype == MAC_Subtype_ACK);
+		assert(pktRx_);
+		struct hdr_cmn *ch = HDR_CMN(pktRx_);
+		ch->error() = 1;        /* force packet discard */
+	}
+
+	/*
+	 * pass the packet on the "interface" which will in turn
+	 * place the packet on the channel.
+	 *
+	 * NOTE: a handler is passed along so that the Network
+	 *       Interface can distinguish between incoming and
+	 *       outgoing packets.
+	 */
+	downtarget_->recv(p->copy(), this);	
+	mhSend_.start(timeout);
+	mhIF_.start(txtime(p));
+}
+inline void
+Mac802_11::setRxState(MacState newState)
+{
+	rx_state_ = newState;
+	checkBackoffTimer();
+}
+
+inline void
+Mac802_11::setTxState(MacState newState)
+{
+	tx_state_ = newState;
+	checkBackoffTimer();
+}
+
+
+/* ======================================================================
+   TCL Hooks for the simulator
+   ====================================================================== */
+static class Mac802_11Class : public TclClass {
+public:
+	Mac802_11Class() : TclClass("Mac/802_11") {}
+	TclObject* create(int, const char*const*) {
+	return (new Mac802_11());
+
+}
+} class_mac802_11;
+
+
+/* ======================================================================
+   Mac  and Phy MIB Class Functions
+   ====================================================================== */
+
+PHY_MIB::PHY_MIB(Mac802_11 *parent)
+{
+	/*
+	 * Bind the phy mib objects.  Note that these will be bound
+	 * to Mac/802_11 variables
+	 */
+
+	parent->bind("CWMin_", &CWMin);
+	parent->bind("CWMax_", &CWMax);
+	parent->bind("SlotTime_", &SlotTime);
+	parent->bind("SIFS_", &SIFSTime);
+	parent->bind("PreambleLength_", &PreambleLength);
+	parent->bind("PLCPHeaderLength_", &PLCPHeaderLength);
+	parent->bind_bw("PLCPDataRate_", &PLCPDataRate);
+}
+
+MAC_MIB::MAC_MIB(Mac802_11 *parent)
+{
+	/*
+	 * Bind the phy mib objects.  Note that these will be bound
+	 * to Mac/802_11 variables
+	 */
+	
+	parent->bind("RTSThreshold_", &RTSThreshold);
+	parent->bind("ShortRetryLimit_", &ShortRetryLimit);
+	parent->bind("LongRetryLimit_", &LongRetryLimit);
+}
+
+/* ======================================================================
+   Mac Class Functions
+   ====================================================================== */
+Mac802_11::Mac802_11() : 
+	Mac(), phymib_(this), macmib_(this), mhIF_(this), mhNav_(this), 
+	mhRecv_(this), mhSend_(this), 
+	mhDefer_(this), mhBackoff_(this)
+{
+	
+	nav_ = 0.0;
+	tx_state_ = rx_state_ = MAC_IDLE;
+	tx_active_ = 0;
+	eotPacket_ = NULL;
+	pktRTS_ = 0;
+	pktCTRL_ = 0;		
+	cw_ = phymib_.getCWMin();
+	ssrc_ = slrc_ = 0;
+	// Added by Sushmita
+        et_ = new EventTrace();
+	
+	sta_seqno_ = 1;
+	cache_ = 0;
+	cache_node_count_ = 0;
+	
+	// chk if basic/data rates are set
+	// otherwise use bandwidth_ as default;
+	
+	Tcl& tcl = Tcl::instance();
+	tcl.evalf("Mac/802_11 set basicRate_");
+	if (strcmp(tcl.result(), "0") != 0) 
+		bind_bw("basicRate_", &basicRate_);
+	else
+		basicRate_ = bandwidth_;
+
+	tcl.evalf("Mac/802_11 set dataRate_");
+	if (strcmp(tcl.result(), "0") != 0) 
+		bind_bw("dataRate_", &dataRate_);
+	else
+		dataRate_ = bandwidth_;
+
+	bind_bool("bugFix_timer_", &bugFix_timer_);
+
+        EOTtarget_ = 0;
+       	bss_id_ = IBSS_ID;
+	//printf("bssid in constructor %d\n",bss_id_);
+}
+
+
+int
+Mac802_11::command(int argc, const char*const* argv)
+{
+	if (argc == 3) {
+		if (strcmp(argv[1], "eot-target") == 0) {
+			EOTtarget_ = (NsObject*) TclObject::lookup(argv[2]);
+			if (EOTtarget_ == 0)
+				return TCL_ERROR;
+			return TCL_OK;
+		} else if (strcmp(argv[1], "bss_id") == 0) {
+			bss_id_ = atoi(argv[2]);
+			return TCL_OK;
+		} else if (strcmp(argv[1], "log-target") == 0) { 
+			logtarget_ = (NsObject*) TclObject::lookup(argv[2]);
+			if(logtarget_ == 0)
+				return TCL_ERROR;
+			return TCL_OK;
+		} else if(strcmp(argv[1], "nodes") == 0) {
+			if(cache_) return TCL_ERROR;
+			cache_node_count_ = atoi(argv[2]);
+			cache_ = new Host[cache_node_count_ + 1];
+			assert(cache_);
+			bzero(cache_, sizeof(Host) * (cache_node_count_+1 ));
+			return TCL_OK;
+		} else if(strcmp(argv[1], "eventtrace") == 0) {
+			// command added to support event tracing by Sushmita
+                        et_ = (EventTrace *)TclObject::lookup(argv[2]);
+                        return (TCL_OK);
+                }
+	}
+	return Mac::command(argc, argv);
+}
+
+// Added by Sushmita to support event tracing
+void Mac802_11::trace_event(char *eventtype, Packet *p) 
+{
+        if (et_ == NULL) return;
+        char *wrk = et_->buffer();
+        char *nwrk = et_->nbuffer();
+	
+        //char *src_nodeaddr =
+	//       Address::instance().print_nodeaddr(iph->saddr());
+        //char *dst_nodeaddr =
+        //      Address::instance().print_nodeaddr(iph->daddr());
+	
+        struct hdr_mac802_11* dh = HDR_MAC802_11(p);
+	
+        //struct hdr_cmn *ch = HDR_CMN(p);
+	
+	if(wrk != 0) {
+		sprintf(wrk, "E -t "TIME_FORMAT" %s %2x ",
+			et_->round(Scheduler::instance().clock()),
+                        eventtype,
+                        //ETHER_ADDR(dh->dh_sa)
+                        ETHER_ADDR(dh->dh_ta)
+                        );
+        }
+        if(nwrk != 0) {
+                sprintf(nwrk, "E -t "TIME_FORMAT" %s %2x ",
+                        et_->round(Scheduler::instance().clock()),
+                        eventtype,
+                        //ETHER_ADDR(dh->dh_sa)
+                        ETHER_ADDR(dh->dh_ta)
+                        );
+        }
+        et_->dump();
+}
+
+/* ======================================================================
+   Debugging Routines
+   ====================================================================== */
+void
+Mac802_11::trace_pkt(Packet *p) 
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_mac802_11* dh = HDR_MAC802_11(p);
+	u_int16_t *t = (u_int16_t*) &dh->dh_fc;
+
+	fprintf(stderr, "\t[ %2x %2x %2x %2x ] %x %s %d\n",
+		*t, dh->dh_duration,
+		 ETHER_ADDR(dh->dh_ra), ETHER_ADDR(dh->dh_ta),
+		index_, packet_info.name(ch->ptype()), ch->size());
+}
+
+void
+Mac802_11::dump(char *fname)
+{
+	fprintf(stderr,
+		"\n%s --- (INDEX: %d, time: %2.9f)\n",
+		fname, index_, Scheduler::instance().clock());
+
+	fprintf(stderr,
+		"\ttx_state_: %x, rx_state_: %x, nav: %2.9f, idle: %d\n",
+		tx_state_, rx_state_, nav_, is_idle());
+
+	fprintf(stderr,
+		"\tpktTx_: %lx, pktRx_: %lx, pktRTS_: %lx, pktCTRL_: %lx, callback: %lx\n",
+		(long) pktTx_, (long) pktRx_, (long) pktRTS_,
+		(long) pktCTRL_, (long) callback_);
+
+	fprintf(stderr,
+		"\tDefer: %d, Backoff: %d (%d), Recv: %d, Timer: %d Nav: %d\n",
+		mhDefer_.busy(), mhBackoff_.busy(), mhBackoff_.paused(),
+		mhRecv_.busy(), mhSend_.busy(), mhNav_.busy());
+	fprintf(stderr,
+		"\tBackoff Expire: %f\n",
+		mhBackoff_.expire());
+}
+
+
+/* ======================================================================
+   Packet Headers Routines
+   ====================================================================== */
+inline int
+Mac802_11::hdr_dst(char* hdr, int dst )
+{
+	struct hdr_mac802_11 *dh = (struct hdr_mac802_11*) hdr;
+	
+       if (dst > -2) {
+               if ((bss_id() == ((int)IBSS_ID)) || (addr() == bss_id())) {
+                       /* if I'm AP (2nd condition above!), the dh_3a
+                        * is already set by the MAC whilst fwding; if
+                        * locally originated pkt, it might make sense
+                        * to set the dh_3a to myself here! don't know
+                        * how to distinguish between the two here - and
+                        * the info is not critical to the dst station
+                        * anyway!
+                        */
+                       STORE4BYTE(&dst, (dh->dh_ra));
+               } else {
+                       /* in BSS mode, the AP forwards everything;
+                        * therefore, the real dest goes in the 3rd
+                        * address, and the AP address goes in the
+                        * destination address
+                        */
+                       STORE4BYTE(&bss_id_, (dh->dh_ra));
+                       STORE4BYTE(&dst, (dh->dh_3a));
+               }
+       }
+
+
+       return (u_int32_t)ETHER_ADDR(dh->dh_ra);
+}
+
+inline int 
+Mac802_11::hdr_src(char* hdr, int src )
+{
+	struct hdr_mac802_11 *dh = (struct hdr_mac802_11*) hdr;
+        if(src > -2)
+               STORE4BYTE(&src, (dh->dh_ta));
+        return ETHER_ADDR(dh->dh_ta);
+}
+
+inline int 
+Mac802_11::hdr_type(char* hdr, u_int16_t type)
+{
+	struct hdr_mac802_11 *dh = (struct hdr_mac802_11*) hdr;
+	if(type)
+		STORE2BYTE(&type,(dh->dh_body));
+	return GET2BYTE(dh->dh_body);
+}
+
+
+/* ======================================================================
+   Misc Routines
+   ====================================================================== */
+inline int
+Mac802_11::is_idle()
+{
+	if(rx_state_ != MAC_IDLE)
+		return 0;
+	if(tx_state_ != MAC_IDLE)
+		return 0;
+	if(nav_ > Scheduler::instance().clock())
+		return 0;
+	
+	return 1;
+}
+
+void
+Mac802_11::discard(Packet *p, const char* why)
+{
+	hdr_mac802_11* mh = HDR_MAC802_11(p);
+	hdr_cmn *ch = HDR_CMN(p);
+
+	/* if the rcvd pkt contains errors, a real MAC layer couldn't
+	   necessarily read any data from it, so we just toss it now */
+	if(ch->error() != 0) {
+		Packet::free(p);
+		return;
+	}
+
+	switch(mh->dh_fc.fc_type) {
+	case MAC_Type_Management:
+		drop(p, why);
+		return;
+	case MAC_Type_Control:
+		switch(mh->dh_fc.fc_subtype) {
+		case MAC_Subtype_RTS:
+			 if((u_int32_t)ETHER_ADDR(mh->dh_ta) ==  (u_int32_t)index_) {
+				drop(p, why);
+				return;
+			}
+			/* fall through - if necessary */
+		case MAC_Subtype_CTS:
+		case MAC_Subtype_ACK:
+			if((u_int32_t)ETHER_ADDR(mh->dh_ra) == (u_int32_t)index_) {
+				drop(p, why);
+				return;
+			}
+			break;
+		default:
+			fprintf(stderr, "invalid MAC Control subtype\n");
+			exit(1);
+		}
+		break;
+	case MAC_Type_Data:
+		switch(mh->dh_fc.fc_subtype) {
+		case MAC_Subtype_Data:
+			if((u_int32_t)ETHER_ADDR(mh->dh_ra) == \
+                           (u_int32_t)index_ ||
+                          (u_int32_t)ETHER_ADDR(mh->dh_ta) == \
+                           (u_int32_t)index_ ||
+                          (u_int32_t)ETHER_ADDR(mh->dh_ra) == MAC_BROADCAST) {
+                                drop(p,why);
+                                return;
+			}
+			break;
+		default:
+			fprintf(stderr, "invalid MAC Data subtype\n");
+			exit(1);
+		}
+		break;
+	default:
+		fprintf(stderr, "invalid MAC type (%x)\n", mh->dh_fc.fc_type);
+		trace_pkt(p);
+		exit(1);
+	}
+	Packet::free(p);
+}
+
+void
+Mac802_11::capture(Packet *p)
+{
+	/*
+	 * Update the NAV so that this does not screw
+	 * up carrier sense.
+	 */	
+	set_nav(usec(phymib_.getEIFS() + txtime(p)));
+	Packet::free(p);
+}
+
+void
+Mac802_11::collision(Packet *p)
+{
+	switch(rx_state_) {
+	case MAC_RECV:
+		setRxState(MAC_COLL);
+		/* fall through */
+	case MAC_COLL:
+		assert(pktRx_);
+		assert(mhRecv_.busy());
+		/*
+		 *  Since a collision has occurred, figure out
+		 *  which packet that caused the collision will
+		 *  "last" the longest.  Make this packet,
+		 *  pktRx_ and reset the Recv Timer if necessary.
+		 */
+		if(txtime(p) > mhRecv_.expire()) {
+			mhRecv_.stop();
+			discard(pktRx_, DROP_MAC_COLLISION);
+			pktRx_ = p;
+			mhRecv_.start(txtime(pktRx_));
+		}
+		else {
+			discard(p, DROP_MAC_COLLISION);
+		}
+		break;
+	default:
+		assert(0);
+	}
+}
+
+void
+Mac802_11::tx_resume()
+{
+	double rTime;
+	assert(mhSend_.busy() == 0);
+	assert(mhDefer_.busy() == 0);
+
+	if(pktCTRL_) {
+		/*
+		 *  Need to send a CTS or ACK.
+		 */
+		mhDefer_.start(phymib_.getSIFS());
+	} else if(pktRTS_) {
+		if (mhBackoff_.busy() == 0) {
+			if (bugFix_timer_) {
+				mhBackoff_.start(cw_, is_idle(), 
+						 phymib_.getDIFS());
+			}
+			else {
+				rTime = (Random::random() % cw_) * 
+					phymib_.getSlotTime();
+				mhDefer_.start( phymib_.getDIFS() + rTime);
+			}
+		}
+	} else if(pktTx_) {
+		if (mhBackoff_.busy() == 0) {
+			hdr_cmn *ch = HDR_CMN(pktTx_);
+			struct hdr_mac802_11 *mh = HDR_MAC802_11(pktTx_);
+			
+			if ((u_int32_t) ch->size() < macmib_.getRTSThreshold()
+			    || (u_int32_t) ETHER_ADDR(mh->dh_ra) == MAC_BROADCAST) {
+				if (bugFix_timer_) {
+					mhBackoff_.start(cw_, is_idle(), 
+							 phymib_.getDIFS());
+				}
+				else {
+					rTime = (Random::random() % cw_)
+						* phymib_.getSlotTime();
+					mhDefer_.start(phymib_.getDIFS() + 
+						       rTime);
+				}
+                        } else {
+				mhDefer_.start(phymib_.getSIFS());
+                        }
+		}
+	} else if(callback_) {
+		Handler *h = callback_;
+		callback_ = 0;
+		h->handle((Event*) 0);
+	}
+	setTxState(MAC_IDLE);
+}
+
+void
+Mac802_11::rx_resume()
+{
+	assert(pktRx_ == 0);
+	assert(mhRecv_.busy() == 0);
+	setRxState(MAC_IDLE);
+}
+
+
+/* ======================================================================
+   Timer Handler Routines
+   ====================================================================== */
+void
+Mac802_11::backoffHandler()
+{
+	if(pktCTRL_) {
+		assert(mhSend_.busy() || mhDefer_.busy());
+		return;
+	}
+
+	if(check_pktRTS() == 0)
+		return;
+
+	if(check_pktTx() == 0)
+		return;
+}
+
+void
+Mac802_11::deferHandler()
+{
+	assert(pktCTRL_ || pktRTS_ || pktTx_);
+
+	if(check_pktCTRL() == 0)
+		return;
+	assert(mhBackoff_.busy() == 0);
+	if(check_pktRTS() == 0)
+		return;
+	if(check_pktTx() == 0)
+		return;
+}
+
+void
+Mac802_11::navHandler()
+{
+	if(is_idle() && mhBackoff_.paused())
+		mhBackoff_.resume(phymib_.getDIFS());
+}
+
+void
+Mac802_11::recvHandler()
+{
+	recv_timer();
+}
+
+void
+Mac802_11::sendHandler()
+{
+	send_timer();
+}
+
+
+void
+Mac802_11::txHandler()
+{
+	if (EOTtarget_) {
+		assert(eotPacket_);
+		EOTtarget_->recv(eotPacket_, (Handler *) 0);
+		eotPacket_ = NULL;
+	}
+	tx_active_ = 0;
+}
+
+
+/* ======================================================================
+   The "real" Timer Handler Routines
+   ====================================================================== */
+void
+Mac802_11::send_timer()
+{
+	switch(tx_state_) {
+	/*
+	 * Sent a RTS, but did not receive a CTS.
+	 */
+	case MAC_RTS:
+		RetransmitRTS();
+		break;
+	/*
+	 * Sent a CTS, but did not receive a DATA packet.
+	 */
+	case MAC_CTS:
+		assert(pktCTRL_);
+		Packet::free(pktCTRL_); 
+		pktCTRL_ = 0;
+		break;
+	/*
+	 * Sent DATA, but did not receive an ACK packet.
+	 */
+	case MAC_SEND:
+		RetransmitDATA();
+		break;
+	/*
+	 * Sent an ACK, and now ready to resume transmission.
+	 */
+	case MAC_ACK:
+		assert(pktCTRL_);
+		Packet::free(pktCTRL_); 
+		pktCTRL_ = 0;
+		break;
+	case MAC_IDLE:
+		break;
+	default:
+		assert(0);
+	}
+	tx_resume();
+}
+
+
+/* ======================================================================
+   Outgoing Packet Routines
+   ====================================================================== */
+int
+Mac802_11::check_pktCTRL()
+{
+	struct hdr_mac802_11 *mh;
+	double timeout;
+
+	if(pktCTRL_ == 0)
+		return -1;
+	if(tx_state_ == MAC_CTS || tx_state_ == MAC_ACK)
+		return -1;
+
+	mh = HDR_MAC802_11(pktCTRL_);
+							  
+	switch(mh->dh_fc.fc_subtype) {
+	/*
+	 *  If the medium is not IDLE, don't send the CTS.
+	 */
+	case MAC_Subtype_CTS:
+		if(!is_idle()) {
+			discard(pktCTRL_, DROP_MAC_BUSY); pktCTRL_ = 0;
+			return 0;
+		}
+		setTxState(MAC_CTS);
+		/*
+		 * timeout:  cts + data tx time calculated by
+		 *           adding cts tx time to the cts duration
+		 *           minus ack tx time -- this timeout is
+		 *           a guess since it is unspecified
+		 *           (note: mh->dh_duration == cf->cf_duration)
+		 */		
+		 timeout = txtime(phymib_.getCTSlen(), basicRate_)
+                        + DSSS_MaxPropagationDelay                      // XXX
+                        + sec(mh->dh_duration)
+                        + DSSS_MaxPropagationDelay                      // XXX
+                       - phymib_.getSIFS()
+                       - txtime(phymib_.getACKlen(), basicRate_);
+		break;
+		/*
+		 * IEEE 802.11 specs, section 9.2.8
+		 * Acknowledments are sent after an SIFS, without regard to
+		 * the busy/idle state of the medium.
+		 */
+	case MAC_Subtype_ACK:		
+		setTxState(MAC_ACK);
+		timeout = txtime(phymib_.getACKlen(), basicRate_);
+		break;
+	default:
+		fprintf(stderr, "check_pktCTRL:Invalid MAC Control subtype\n");
+		exit(1);
+	}
+	transmit(pktCTRL_, timeout);
+	return 0;
+}
+
+int
+Mac802_11::check_pktRTS()
+{
+	struct hdr_mac802_11 *mh;
+	double timeout;
+
+	assert(mhBackoff_.busy() == 0);
+
+	if(pktRTS_ == 0)
+ 		return -1;
+	mh = HDR_MAC802_11(pktRTS_);
+
+ 	switch(mh->dh_fc.fc_subtype) {
+	case MAC_Subtype_RTS:
+		if(! is_idle()) {
+			inc_cw();
+			mhBackoff_.start(cw_, is_idle());
+			return 0;
+		}
+		setTxState(MAC_RTS);
+		timeout = txtime(phymib_.getRTSlen(), basicRate_)
+			+ DSSS_MaxPropagationDelay                      // XXX
+			+ phymib_.getSIFS()
+			+ txtime(phymib_.getCTSlen(), basicRate_)
+			+ DSSS_MaxPropagationDelay;
+		break;
+	default:
+		fprintf(stderr, "check_pktRTS:Invalid MAC Control subtype\n");
+		exit(1);
+	}
+	transmit(pktRTS_, timeout);
+  
+
+	return 0;
+}
+
+int
+Mac802_11::check_pktTx()
+{
+	struct hdr_mac802_11 *mh;
+	double timeout;
+	
+	assert(mhBackoff_.busy() == 0);
+
+	if(pktTx_ == 0)
+		return -1;
+
+	mh = HDR_MAC802_11(pktTx_);
+
+	switch(mh->dh_fc.fc_subtype) {
+	case MAC_Subtype_Data:
+		if(! is_idle()) {
+			sendRTS(ETHER_ADDR(mh->dh_ra));
+			inc_cw();
+			mhBackoff_.start(cw_, is_idle());
+			return 0;
+		}
+		setTxState(MAC_SEND);
+		if((u_int32_t)ETHER_ADDR(mh->dh_ra) != MAC_BROADCAST)
+                        timeout = txtime(pktTx_)
+                                + DSSS_MaxPropagationDelay              // XXX
+                               + phymib_.getSIFS()
+                               + txtime(phymib_.getACKlen(), basicRate_)
+                               + DSSS_MaxPropagationDelay;             // XXX
+		else
+			timeout = txtime(pktTx_);
+		break;
+	default:
+		fprintf(stderr, "check_pktTx:Invalid MAC Control subtype\n");
+		exit(1);
+	}
+	transmit(pktTx_, timeout);
+	return 0;
+}
+/*
+ * Low-level transmit functions that actually place the packet onto
+ * the channel.
+ */
+void
+Mac802_11::sendRTS(int dst)
+{
+	Packet *p = Packet::alloc();
+	hdr_cmn* ch = HDR_CMN(p);
+	struct rts_frame *rf = (struct rts_frame*)p->access(hdr_mac::offset_);
+	
+	assert(pktTx_);
+	assert(pktRTS_ == 0);
+
+	/*
+	 *  If the size of the packet is larger than the
+	 *  RTSThreshold, then perform the RTS/CTS exchange.
+	 */
+	if( (u_int32_t) HDR_CMN(pktTx_)->size() < macmib_.getRTSThreshold() ||
+            (u_int32_t) dst == MAC_BROADCAST) {
+		Packet::free(p);
+		return;
+	}
+
+	ch->uid() = 0;
+	ch->ptype() = PT_MAC;
+	ch->size() = phymib_.getRTSlen();
+	ch->iface() = -2;
+	ch->error() = 0;
+
+	bzero(rf, MAC_HDR_LEN);
+
+	rf->rf_fc.fc_protocol_version = MAC_ProtocolVersion;
+ 	rf->rf_fc.fc_type	= MAC_Type_Control;
+ 	rf->rf_fc.fc_subtype	= MAC_Subtype_RTS;
+ 	rf->rf_fc.fc_to_ds	= 0;
+ 	rf->rf_fc.fc_from_ds	= 0;
+ 	rf->rf_fc.fc_more_frag	= 0;
+ 	rf->rf_fc.fc_retry	= 0;
+ 	rf->rf_fc.fc_pwr_mgt	= 0;
+ 	rf->rf_fc.fc_more_data	= 0;
+ 	rf->rf_fc.fc_wep	= 0;
+ 	rf->rf_fc.fc_order	= 0;
+
+	//rf->rf_duration = RTS_DURATION(pktTx_);
+	STORE4BYTE(&dst, (rf->rf_ra));
+	
+	/* store rts tx time */
+ 	ch->txtime() = txtime(ch->size(), basicRate_);
+	
+	STORE4BYTE(&index_, (rf->rf_ta));
+
+	/* calculate rts duration field */	
+	rf->rf_duration = usec(phymib_.getSIFS()
+			       + txtime(phymib_.getCTSlen(), basicRate_)
+			       + phymib_.getSIFS()
+                               + txtime(pktTx_)
+			       + phymib_.getSIFS()
+			       + txtime(phymib_.getACKlen(), basicRate_));
+	pktRTS_ = p;
+}
+
+void
+Mac802_11::sendCTS(int dst, double rts_duration)
+{
+	Packet *p = Packet::alloc();
+	hdr_cmn* ch = HDR_CMN(p);
+	struct cts_frame *cf = (struct cts_frame*)p->access(hdr_mac::offset_);
+
+	assert(pktCTRL_ == 0);
+
+	ch->uid() = 0;
+	ch->ptype() = PT_MAC;
+	ch->size() = phymib_.getCTSlen();
+
+
+	ch->iface() = -2;
+	ch->error() = 0;
+	//ch->direction() = hdr_cmn::DOWN;
+	bzero(cf, MAC_HDR_LEN);
+
+	cf->cf_fc.fc_protocol_version = MAC_ProtocolVersion;
+	cf->cf_fc.fc_type	= MAC_Type_Control;
+	cf->cf_fc.fc_subtype	= MAC_Subtype_CTS;
+ 	cf->cf_fc.fc_to_ds	= 0;
+ 	cf->cf_fc.fc_from_ds	= 0;
+ 	cf->cf_fc.fc_more_frag	= 0;
+ 	cf->cf_fc.fc_retry	= 0;
+ 	cf->cf_fc.fc_pwr_mgt	= 0;
+ 	cf->cf_fc.fc_more_data	= 0;
+ 	cf->cf_fc.fc_wep	= 0;
+ 	cf->cf_fc.fc_order	= 0;
+	
+	//cf->cf_duration = CTS_DURATION(rts_duration);
+	STORE4BYTE(&dst, (cf->cf_ra));
+	
+	/* store cts tx time */
+	ch->txtime() = txtime(ch->size(), basicRate_);
+	
+	/* calculate cts duration */
+	cf->cf_duration = usec(sec(rts_duration)
+                              - phymib_.getSIFS()
+                              - txtime(phymib_.getCTSlen(), basicRate_));
+
+
+	
+	pktCTRL_ = p;
+	
+}
+
+void
+Mac802_11::sendACK(int dst)
+{
+	Packet *p = Packet::alloc();
+	hdr_cmn* ch = HDR_CMN(p);
+	struct ack_frame *af = (struct ack_frame*)p->access(hdr_mac::offset_);
+
+	assert(pktCTRL_ == 0);
+
+	ch->uid() = 0;
+	ch->ptype() = PT_MAC;
+	// CHANGE WRT Mike's code
+	ch->size() = phymib_.getACKlen();
+	ch->iface() = -2;
+	ch->error() = 0;
+	
+	bzero(af, MAC_HDR_LEN);
+
+	af->af_fc.fc_protocol_version = MAC_ProtocolVersion;
+ 	af->af_fc.fc_type	= MAC_Type_Control;
+ 	af->af_fc.fc_subtype	= MAC_Subtype_ACK;
+ 	af->af_fc.fc_to_ds	= 0;
+ 	af->af_fc.fc_from_ds	= 0;
+ 	af->af_fc.fc_more_frag	= 0;
+ 	af->af_fc.fc_retry	= 0;
+ 	af->af_fc.fc_pwr_mgt	= 0;
+ 	af->af_fc.fc_more_data	= 0;
+ 	af->af_fc.fc_wep	= 0;
+ 	af->af_fc.fc_order	= 0;
+
+	//af->af_duration = ACK_DURATION();
+	STORE4BYTE(&dst, (af->af_ra));
+
+	/* store ack tx time */
+ 	ch->txtime() = txtime(ch->size(), basicRate_);
+	
+	/* calculate ack duration */
+ 	af->af_duration = 0;	
+	
+	pktCTRL_ = p;
+}
+
+void
+Mac802_11::sendDATA(Packet *p)
+{
+	hdr_cmn* ch = HDR_CMN(p);
+	struct hdr_mac802_11* dh = HDR_MAC802_11(p);
+
+	assert(pktTx_ == 0);
+
+	/*
+	 * Update the MAC header
+	 */
+	ch->size() += phymib_.getHdrLen11();
+
+	dh->dh_fc.fc_protocol_version = MAC_ProtocolVersion;
+	dh->dh_fc.fc_type       = MAC_Type_Data;
+	dh->dh_fc.fc_subtype    = MAC_Subtype_Data;
+	
+	dh->dh_fc.fc_to_ds      = 0;
+	dh->dh_fc.fc_from_ds    = 0;
+	dh->dh_fc.fc_more_frag  = 0;
+	dh->dh_fc.fc_retry      = 0;
+	dh->dh_fc.fc_pwr_mgt    = 0;
+	dh->dh_fc.fc_more_data  = 0;
+	dh->dh_fc.fc_wep        = 0;
+	dh->dh_fc.fc_order      = 0;
+
+	/* store data tx time */
+ 	ch->txtime() = txtime(ch->size(), dataRate_);
+
+	if((u_int32_t)ETHER_ADDR(dh->dh_ra) != MAC_BROADCAST) {
+		/* store data tx time for unicast packets */
+		ch->txtime() = txtime(ch->size(), dataRate_);
+		
+		dh->dh_duration = usec(txtime(phymib_.getACKlen(), basicRate_)
+				       + phymib_.getSIFS());
+
+
+
+	} else {
+		/* store data tx time for broadcast packets (see 9.6) */
+		ch->txtime() = txtime(ch->size(), basicRate_);
+		
+		dh->dh_duration = 0;
+	}
+	pktTx_ = p;
+}
+
+/* ======================================================================
+   Retransmission Routines
+   ====================================================================== */
+void
+Mac802_11::RetransmitRTS()
+{
+	assert(pktTx_);
+	assert(pktRTS_);
+	assert(mhBackoff_.busy() == 0);
+	macmib_.RTSFailureCount++;
+
+
+	ssrc_ += 1;			// STA Short Retry Count
+		
+	if(ssrc_ >= macmib_.getShortRetryLimit()) {
+		discard(pktRTS_, DROP_MAC_RETRY_COUNT_EXCEEDED); pktRTS_ = 0;
+		/* tell the callback the send operation failed 
+		   before discarding the packet */
+		hdr_cmn *ch = HDR_CMN(pktTx_);
+		if (ch->xmit_failure_) {
+                        /*
+                         *  Need to remove the MAC header so that 
+                         *  re-cycled packets don't keep getting
+                         *  bigger.
+                         */
+			ch->size() -= phymib_.getHdrLen11();
+                        ch->xmit_reason_ = XMIT_REASON_RTS;
+                        ch->xmit_failure_(pktTx_->copy(),
+                                          ch->xmit_failure_data_);
+                }
+		discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED); 
+		pktTx_ = 0;
+		ssrc_ = 0;
+		rst_cw();
+	} else {
+		struct rts_frame *rf;
+		rf = (struct rts_frame*)pktRTS_->access(hdr_mac::offset_);
+		rf->rf_fc.fc_retry = 1;
+
+		inc_cw();
+		mhBackoff_.start(cw_, is_idle());
+	}
+}
+
+void
+Mac802_11::RetransmitDATA()
+{
+	struct hdr_cmn *ch;
+	struct hdr_mac802_11 *mh;
+	u_int32_t *rcount, thresh;
+	assert(mhBackoff_.busy() == 0);
+
+	assert(pktTx_);
+	assert(pktRTS_ == 0);
+
+	ch = HDR_CMN(pktTx_);
+	mh = HDR_MAC802_11(pktTx_);
+
+	/*
+	 *  Broadcast packets don't get ACKed and therefore
+	 *  are never retransmitted.
+	 */
+	if((u_int32_t)ETHER_ADDR(mh->dh_ra) == MAC_BROADCAST) {
+		Packet::free(pktTx_); 
+		pktTx_ = 0;
+
+		/*
+		 * Backoff at end of TX.
+		 */
+		rst_cw();
+		mhBackoff_.start(cw_, is_idle());
+
+		return;
+	}
+
+	macmib_.ACKFailureCount++;
+
+	if((u_int32_t) ch->size() <= macmib_.getRTSThreshold()) {
+                rcount = &ssrc_;
+               thresh = macmib_.getShortRetryLimit();
+        } else {
+                rcount = &slrc_;
+               thresh = macmib_.getLongRetryLimit();
+        }
+
+	(*rcount)++;
+
+	if(*rcount >= thresh) {
+		/* IEEE Spec section 9.2.3.5 says this should be greater than
+		   or equal */
+		macmib_.FailedCount++;
+		/* tell the callback the send operation failed 
+		   before discarding the packet */
+		hdr_cmn *ch = HDR_CMN(pktTx_);
+		if (ch->xmit_failure_) {
+                        ch->size() -= phymib_.getHdrLen11();
+			ch->xmit_reason_ = XMIT_REASON_ACK;
+                        ch->xmit_failure_(pktTx_->copy(),
+                                          ch->xmit_failure_data_);
+                }
+
+		discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED); 
+		pktTx_ = 0;
+		*rcount = 0;
+		rst_cw();
+	}
+	else {
+		struct hdr_mac802_11 *dh;
+		dh = HDR_MAC802_11(pktTx_);
+		dh->dh_fc.fc_retry = 1;
+
+
+		sendRTS(ETHER_ADDR(mh->dh_ra));
+		inc_cw();
+		mhBackoff_.start(cw_, is_idle());
+	}
+}
+
+/* ======================================================================
+   Incoming Packet Routines
+   ====================================================================== */
+void
+Mac802_11::send(Packet *p, Handler *h)
+{
+	double rTime;
+	struct hdr_mac802_11* dh = HDR_MAC802_11(p);
+
+	EnergyModel *em = netif_->node()->energy_model();
+	if (em && em->sleep()) {
+		em->set_node_sleep(0);
+		em->set_node_state(EnergyModel::INROUTE);
+	}
+	
+	callback_ = h;
+	sendDATA(p);
+	sendRTS(ETHER_ADDR(dh->dh_ra));
+
+	/*
+	 * Assign the data packet a sequence number.
+	 */
+	dh->dh_scontrol = sta_seqno_++;
+
+	/*
+	 *  If the medium is IDLE, we must wait for a DIFS
+	 *  Space before transmitting.
+	 */
+	if(mhBackoff_.busy() == 0) {
+		if(is_idle()) {
+			if (mhDefer_.busy() == 0) {
+				/*
+				 * If we are already deferring, there is no
+				 * need to reset the Defer timer.
+				 */
+				if (bugFix_timer_) {
+					 mhBackoff_.start(cw_, is_idle(), 
+							  phymib_.getDIFS());
+				}
+				else {
+					rTime = (Random::random() % cw_)
+						* (phymib_.getSlotTime());
+					mhDefer_.start(phymib_.getDIFS() + 
+						       rTime);
+				}
+			}
+		} else {
+			/*
+			 * If the medium is NOT IDLE, then we start
+			 * the backoff timer.
+			 */
+			mhBackoff_.start(cw_, is_idle());
+		}
+	}
+}
+
+void
+Mac802_11::recv(Packet *p, Handler *h)
+{
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	/*
+	 * Sanity Check
+	 */
+	assert(initialized());
+
+	/*
+	 *  Handle outgoing packets.
+	 */
+	if(hdr->direction() == hdr_cmn::DOWN) {
+                send(p, h);
+                return;
+        }
+	/*
+	 *  Handle incoming packets.
+	 *
+	 *  We just received the 1st bit of a packet on the network
+	 *  interface.
+	 *
+	 */
+
+	/*
+	 *  If the interface is currently in transmit mode, then
+	 *  it probably won't even see this packet.  However, the
+	 *  "air" around me is BUSY so I need to let the packet
+	 *  proceed.  Just set the error flag in the common header
+	 *  to that the packet gets thrown away.
+	 */
+	if(tx_active_ && hdr->error() == 0) {
+		hdr->error() = 1;
+	}
+
+	if(rx_state_ == MAC_IDLE) {
+		setRxState(MAC_RECV);
+		pktRx_ = p;
+		/*
+		 * Schedule the reception of this packet, in
+		 * txtime seconds.
+		 */
+		mhRecv_.start(txtime(p));
+	} else {
+		/*
+		 *  If the power of the incoming packet is smaller than the
+		 *  power of the packet currently being received by at least
+                 *  the capture threshold, then we ignore the new packet.
+		 */
+		if(pktRx_->txinfo_.RxPr / p->txinfo_.RxPr >= p->txinfo_.CPThresh) {
+			capture(p);
+		} else {
+			collision(p);
+		}
+	}
+}
+
+void
+Mac802_11::recv_timer()
+{
+	u_int32_t src; 
+	hdr_cmn *ch = HDR_CMN(pktRx_);
+	hdr_mac802_11 *mh = HDR_MAC802_11(pktRx_);
+	u_int32_t dst = ETHER_ADDR(mh->dh_ra);
+	
+	u_int8_t  type = mh->dh_fc.fc_type;
+	u_int8_t  subtype = mh->dh_fc.fc_subtype;
+
+	assert(pktRx_);
+	assert(rx_state_ == MAC_RECV || rx_state_ == MAC_COLL);
+	
+        /*
+         *  If the interface is in TRANSMIT mode when this packet
+         *  "arrives", then I would never have seen it and should
+         *  do a silent discard without adjusting the NAV.
+         */
+        if(tx_active_) {
+                Packet::free(pktRx_);
+                goto done;
+        }
+
+	/*
+	 * Handle collisions.
+	 */
+	if(rx_state_ == MAC_COLL) {
+		discard(pktRx_, DROP_MAC_COLLISION);		
+		set_nav(usec(phymib_.getEIFS()));
+		goto done;
+	}
+
+	/*
+	 * Check to see if this packet was received with enough
+	 * bit errors that the current level of FEC still could not
+	 * fix all of the problems - ie; after FEC, the checksum still
+	 * failed.
+	 */
+	if( ch->error() ) {
+		Packet::free(pktRx_);
+		set_nav(usec(phymib_.getEIFS()));
+		goto done;
+	}
+
+	/*
+	 * IEEE 802.11 specs, section 9.2.5.6
+	 *	- update the NAV (Network Allocation Vector)
+	 */
+	if(dst != (u_int32_t)index_) {
+		set_nav(mh->dh_duration);
+	}
+
+        /* tap out - */
+        if (tap_ && type == MAC_Type_Data &&
+            MAC_Subtype_Data == subtype ) 
+		tap_->tap(pktRx_);
+	/*
+	 * Adaptive Fidelity Algorithm Support - neighborhood infomation 
+	 * collection
+	 *
+	 * Hacking: Before filter the packet, log the neighbor node
+	 * I can hear the packet, the src is my neighbor
+	 */
+	if (netif_->node()->energy_model() && 
+	    netif_->node()->energy_model()->adaptivefidelity()) {
+		src = ETHER_ADDR(mh->dh_ta);
+		netif_->node()->energy_model()->add_neighbor(src);
+	}
+	/*
+	 * Address Filtering
+	 */
+	if(dst != (u_int32_t)index_ && dst != MAC_BROADCAST) {
+		/*
+		 *  We don't want to log this event, so we just free
+		 *  the packet instead of calling the drop routine.
+		 */
+		discard(pktRx_, "---");
+		goto done;
+	}
+
+	switch(type) {
+
+	case MAC_Type_Management:
+		discard(pktRx_, DROP_MAC_PACKET_ERROR);
+		goto done;
+	case MAC_Type_Control:
+		switch(subtype) {
+		case MAC_Subtype_RTS:
+			recvRTS(pktRx_);
+			break;
+		case MAC_Subtype_CTS:
+			recvCTS(pktRx_);
+			break;
+		case MAC_Subtype_ACK:
+			recvACK(pktRx_);
+			break;
+		default:
+			fprintf(stderr,"recvTimer1:Invalid MAC Control Subtype %x\n",
+				subtype);
+			exit(1);
+		}
+		break;
+	case MAC_Type_Data:
+		switch(subtype) {
+		case MAC_Subtype_Data:
+			recvDATA(pktRx_);
+			break;
+		default:
+			fprintf(stderr, "recv_timer2:Invalid MAC Data Subtype %x\n",
+				subtype);
+			exit(1);
+		}
+		break;
+	default:
+		fprintf(stderr, "recv_timer3:Invalid MAC Type %x\n", subtype);
+		exit(1);
+	}
+ done:
+	pktRx_ = 0;
+	rx_resume();
+}
+
+
+void
+Mac802_11::recvRTS(Packet *p)
+{
+	struct rts_frame *rf = (struct rts_frame*)p->access(hdr_mac::offset_);
+
+	if(tx_state_ != MAC_IDLE) {
+		discard(p, DROP_MAC_BUSY);
+		return;
+	}
+
+	/*
+	 *  If I'm responding to someone else, discard this RTS.
+	 */
+	if(pktCTRL_) {
+		discard(p, DROP_MAC_BUSY);
+		return;
+	}
+
+	sendCTS(ETHER_ADDR(rf->rf_ta), rf->rf_duration);
+
+	/*
+	 *  Stop deferring - will be reset in tx_resume().
+	 */
+	if(mhDefer_.busy()) mhDefer_.stop();
+
+	tx_resume();
+
+	mac_log(p);
+}
+
+/*
+ * txtime()	- pluck the precomputed tx time from the packet header
+ */
+double
+Mac802_11::txtime(Packet *p)
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	double t = ch->txtime();
+	if (t < 0.0) {
+		drop(p, "XXX");
+ 		exit(1);
+	}
+	return t;
+}
+
+ 
+/*
+ * txtime()	- calculate tx time for packet of size "psz" bytes 
+ *		  at rate "drt" bps
+ */
+double
+Mac802_11::txtime(double psz, double drt)
+{
+	double dsz = psz - phymib_.getPLCPhdrLen();
+        int plcp_hdr = phymib_.getPLCPhdrLen() << 3;	
+	int datalen = (int)dsz << 3;
+	double t = (((double)plcp_hdr)/phymib_.getPLCPDataRate())
+                                       + (((double)datalen)/drt);
+	return(t);
+}
+
+
+
+void
+Mac802_11::recvCTS(Packet *p)
+{
+	if(tx_state_ != MAC_RTS) {
+		discard(p, DROP_MAC_INVALID_STATE);
+		return;
+	}
+
+	assert(pktRTS_);
+	Packet::free(pktRTS_); pktRTS_ = 0;
+
+	assert(pktTx_);	
+	mhSend_.stop();
+
+	/*
+	 * The successful reception of this CTS packet implies
+	 * that our RTS was successful. 
+	 * According to the IEEE spec 9.2.5.3, you must 
+	 * reset the ssrc_, but not the congestion window.
+	 */
+	ssrc_ = 0;
+	tx_resume();
+
+	mac_log(p);
+}
+
+void
+Mac802_11::recvDATA(Packet *p)
+{
+	struct hdr_mac802_11 *dh = HDR_MAC802_11(p);
+	u_int32_t dst, src, size;
+	struct hdr_cmn *ch = HDR_CMN(p);
+
+	dst = ETHER_ADDR(dh->dh_ra);
+	src = ETHER_ADDR(dh->dh_ta);
+	size = ch->size();
+	/*
+	 * Adjust the MAC packet size - ie; strip
+	 * off the mac header
+	 */
+	ch->size() -= phymib_.getHdrLen11();
+	ch->num_forwards() += 1;
+
+	/*
+	 *  If we sent a CTS, clean up...
+	 */
+	if(dst != MAC_BROADCAST) {
+		if(size >= macmib_.getRTSThreshold()) {
+			if (tx_state_ == MAC_CTS) {
+				assert(pktCTRL_);
+				Packet::free(pktCTRL_); pktCTRL_ = 0;
+				mhSend_.stop();
+				/*
+				 * Our CTS got through.
+				 */
+			} else {
+				discard(p, DROP_MAC_BUSY);
+				return;
+			}
+			sendACK(src);
+			tx_resume();
+		} else {
+			/*
+			 *  We did not send a CTS and there's no
+			 *  room to buffer an ACK.
+			 */
+			if(pktCTRL_) {
+				discard(p, DROP_MAC_BUSY);
+				return;
+			}
+			sendACK(src);
+			if(mhSend_.busy() == 0)
+				tx_resume();
+		}
+	}
+	
+	/* ============================================================
+	   Make/update an entry in our sequence number cache.
+	   ============================================================ */
+
+	/* Changed by Debojyoti Dutta. This upper loop of if{}else was 
+	   suggested by Joerg Diederich <dieder@ibr.cs.tu-bs.de>. 
+	   Changed on 19th Oct'2000 */
+
+        if(dst != MAC_BROADCAST) {
+                if (src < (u_int32_t) cache_node_count_) {
+                        Host *h = &cache_[src];
+
+                        if(h->seqno && h->seqno == dh->dh_scontrol) {
+                                discard(p, DROP_MAC_DUPLICATE);
+                                return;
+                        }
+                        h->seqno = dh->dh_scontrol;
+                } else {
+			static int count = 0;
+			if (++count <= 10) {
+				printf ("MAC_802_11: accessing MAC cache_ array out of range (src %u, dst %u, size %d)!\n", src, dst, cache_node_count_);
+				if (count == 10)
+					printf ("[suppressing additional MAC cache_ warnings]\n");
+			};
+		};
+	}
+
+	/*
+	 *  Pass the packet up to the link-layer.
+	 *  XXX - we could schedule an event to account
+	 *  for this processing delay.
+	 */
+	
+	/* in BSS mode, if a station receives a packet via
+	 * the AP, and higher layers are interested in looking
+	 * at the src address, we might need to put it at
+	 * the right place - lest the higher layers end up
+	 * believing the AP address to be the src addr! a quick
+	 * grep didn't turn up any higher layers interested in
+	 * the src addr though!
+	 * anyway, here if I'm the AP and the destination
+	 * address (in dh_3a) isn't me, then we have to fwd
+	 * the packet; we pick the real destination and set
+	 * set it up for the LL; we save the real src into
+	 * the dh_3a field for the 'interested in the info'
+	 * receiver; we finally push the packet towards the
+	 * LL to be added back to my queue - accomplish this
+	 * by reversing the direction!*/
+
+	if ((bss_id() == addr()) && ((u_int32_t)ETHER_ADDR(dh->dh_ra)!= MAC_BROADCAST)&& ((u_int32_t)ETHER_ADDR(dh->dh_3a) != ((u_int32_t)addr()))) {
+		struct hdr_cmn *ch = HDR_CMN(p);
+		u_int32_t dst = ETHER_ADDR(dh->dh_3a);
+		u_int32_t src = ETHER_ADDR(dh->dh_ta);
+		/* if it is a broadcast pkt then send a copy up
+		 * my stack also
+		 */
+		if (dst == MAC_BROADCAST) {
+			uptarget_->recv(p->copy(), (Handler*) 0);
+		}
+
+		ch->next_hop() = dst;
+		STORE4BYTE(&src, (dh->dh_3a));
+		ch->addr_type() = NS_AF_ILINK;
+		ch->direction() = hdr_cmn::DOWN;
+	}
+
+	uptarget_->recv(p, (Handler*) 0);
+}
+
+
+void
+Mac802_11::recvACK(Packet *p)
+{	
+	if(tx_state_ != MAC_SEND) {
+		discard(p, DROP_MAC_INVALID_STATE);
+		return;
+	}
+	assert(pktTx_);
+
+	mhSend_.stop();
+
+	/*
+	 * The successful reception of this ACK packet implies
+	 * that our DATA transmission was successful.  Hence,
+	 * we can reset the Short/Long Retry Count and the CW.
+	 *
+	 * need to check the size of the packet we sent that's being
+	 * ACK'd, not the size of the ACK packet.
+	 */
+	if((u_int32_t) HDR_CMN(pktTx_)->size() <= macmib_.getRTSThreshold())
+		ssrc_ = 0;
+	else
+		slrc_ = 0;
+	rst_cw();
+	Packet::free(pktTx_); 
+	pktTx_ = 0;
+	
+	/*
+	 * Backoff before sending again.
+	 */
+	assert(mhBackoff_.busy() == 0);
+	mhBackoff_.start(cw_, is_idle());
+
+	tx_resume();
+
+	mac_log(p);
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/mac/mac.h ns-2.30/mac/mac.h
--- ns-2.30-pure/mac/mac.h	2006-09-24 22:11:19.000000000 -0700
+++ ns-2.30/mac/mac.h	2006-12-30 17:22:28.000000000 -0800
@@ -177,7 +177,10 @@
 	virtual void sendUp(Packet *p);
 
 	virtual void resume(Packet* p = 0);
-	virtual void installTap(Tap *t) { tap_ = t; }
+	virtual void installTap(Tap *t,bool filterown = false) {
+		tap_ = t;
+		tap_filterown_ = filterown;
+	}
 	
 	inline double txtime(int bytes) {
 		return (8. * bytes / bandwidth_);
@@ -231,6 +234,7 @@
         
 	Phy *netif_;            // network interface
         Tap *tap_;              // tap agent
+	bool tap_filterown_;    // filter tap packets destined for use anyhow
 	LL *ll_;             	// LL this MAC is connected to
 	Channel *channel_;	// channel this MAC is connected to
 
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/mac/phy.cc ns-2.30/mac/phy.cc
--- ns-2.30-pure/mac/phy.cc	2006-09-24 22:11:19.000000000 -0700
+++ ns-2.30/mac/phy.cc	2006-12-30 17:22:28.000000000 -0800
@@ -68,6 +68,16 @@
 			tcl.resultf("%d", index_);
 			return TCL_OK;
 		}
+		
+		if (strcmp(argv[1],"getchannel") == 0) {
+			if (channel_) {
+				tcl.resultf("%s",channel_->name());
+			}
+			else {
+				tcl.resultf("%s","");
+			}
+			return TCL_OK;
+		}
 	}
 
 	else if(argc == 3) {
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/mac/wireless-phy.cc ns-2.30/mac/wireless-phy.cc
--- ns-2.30-pure/mac/wireless-phy.cc	2006-09-24 22:11:19.000000000 -0700
+++ ns-2.30/mac/wireless-phy.cc	2006-12-30 17:22:28.000000000 -0800
@@ -134,6 +134,7 @@
 WirelessPhy::command(int argc, const char*const* argv)
 {
 	TclObject *obj; 
+	Tcl& tcl = Tcl::instance();
 
 	if (argc==2) {
 		if (strcasecmp(argv[1], "NodeOn") == 0) {
@@ -156,7 +157,11 @@
 				update_energy_time_ = NOW;
 			}
 			return TCL_OK;
+		} else if (strcasecmp(argv[1], "getantenna") == 0) {
+			tcl.result(ant_->name());
+			return TCL_OK;
 		}
+
 	} else if(argc == 3) {
 		if (strcasecmp(argv[1], "setTxPower") == 0) {
 			Pt_consume_ = atof(argv[2]);
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/mobile/pattern-antenna.cc ns-2.30/mobile/pattern-antenna.cc
--- ns-2.30-pure/mobile/pattern-antenna.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/mobile/pattern-antenna.cc	2006-12-30 17:22:59.000000000 -0800
@@ -0,0 +1,238 @@
+
+/*
+ * Copyright (c) 2003 University of Colorado, Boulder
+ * All rights reserved.
+ *
+ */
+
+#include <antenna.h>
+#include <pattern-antenna.h> 
+#include <math.h>
+#include <iostream>
+#include <fstream>
+#include <string>
+
+static class PatternAntennaClass : public TclClass {
+public:
+  PatternAntennaClass() : TclClass("Antenna/PatternAntenna") {}
+  TclObject* create(int, const char*const*) {
+    return (new PatternAntenna);
+  }
+} class_PatternAntenna;
+
+PatternAntenna::PatternAntenna() {
+  Dir_ = 0.0;
+  bind("Dir_", &Dir_);
+}
+
+double
+PatternAntenna::normalize(double deg) {
+  while (360.0 <= deg) {
+    deg -= 360.0;
+  }
+
+  while (0.0 > deg) {
+    deg += 360.0;
+  }
+
+  return deg;
+}
+
+double
+PatternAntenna::get_angle(double dX, double dY) {
+  double angle;
+
+  // First take care of dX or both == 0
+  if ((0.0 == dY) && (0.0 == dX)) {
+    angle = 0.0;
+  }
+  else if (0.0 == dX) {
+    angle = M_PI/2.0;
+  }
+  else {
+    angle = atan2(dY,dX);
+    if (0.0 > angle) {
+      angle += 2*M_PI;
+    }
+  }
+
+  angle = (180.0/M_PI) * angle;
+
+  return angle;
+}
+
+PatternAntenna::gain_pattern::gain_pattern() {
+  samplecount_ = 0;
+  samples_ = 0;
+}
+
+PatternAntenna::gain_pattern::~gain_pattern() {
+  if (samples_) {
+    free(samples_);
+    samples_ = 0;
+  }
+}
+
+void
+PatternAntenna::gain_pattern::set_gain_pattern(int samplecount,double* samples)
+{
+  if (samples_) {
+    free(samples_);
+    samples_ = 0;
+    samplecount = 0;
+  }
+  samples_ = (double*)malloc(samplecount*sizeof(double));
+  samplecount_ = samplecount;
+  sample_quantum_ = 360.0/samplecount_;
+  memcpy(samples_,samples,samplecount*sizeof(double));
+}
+
+double
+PatternAntenna::gain_pattern::get_gain(double angle) {
+  // Find closest sample to angle.
+  // XXX Maybe interpolate between samples at some point?
+  int whichsamp = ( (int)((angle/sample_quantum_) + 0.5) ) % samplecount_;
+  return samples_[whichsamp];
+}
+
+void
+PatternAntenna::gain_pattern::copy_pattern(gain_pattern& pat) {
+  set_gain_pattern(pat.samplecount_,pat.samples_);
+}
+
+// return the gain for a signal to a node at vector dX, dY, dZ
+// from the transmitter at wavelength lambda  
+double
+PatternAntenna::getTxGain(double dX, double dY, double dZ, double l) {
+  double angle = get_angle(dX,dY);
+  return horiz_tx_gain_.get_gain(angle);
+}
+
+// return the gain for a signal from a node at vector dX, dY, dZ
+// from the receiver at wavelength lambda
+double
+PatternAntenna::getRxGain(double dX, double dY, double dZ, double l) {
+  double angle = get_angle(dX,dY);
+  return horiz_rx_gain_.get_gain(angle);
+}
+
+void
+PatternAntenna::setHorizRxGainPattern(int samplecount, double* samples) {
+  horiz_rx_gain_.set_gain_pattern(samplecount,samples);
+}
+
+
+void
+PatternAntenna::setHorizTxGainPattern(int samplecount, double* samples) {
+  horiz_tx_gain_.set_gain_pattern(samplecount,samples);
+}
+
+
+// return a pointer to a copy of this antenna that will return the 
+// same thing for get{Rx,Tx}Gain that this one would at this point
+// in time.  This is needed b/c if a pkt is sent with a directable
+// antenna, this antenna may be have been redirected by the time we
+// call getTxGain on the copy to determine if the pkt is received.  
+Antenna*
+PatternAntenna::copy() {
+  PatternAntenna* antcopy =
+    (PatternAntenna*)TclObject::New("Antenna/PatternAntenna");
+  antcopy->horiz_rx_gain_.copy_pattern(horiz_rx_gain_);
+  antcopy->horiz_tx_gain_.copy_pattern(horiz_tx_gain_);
+  return antcopy;
+}
+
+void
+PatternAntenna::release() {
+  TclObject::Delete((TclObject*)this);
+}
+
+int
+PatternAntenna::read_pattern_from_msi(const char* msifile) {
+  // XXX This code is by no means great. It is simplistic
+  // and fragile, but I think it'll work well enough for the
+  // simplistic kinds of tasks we'll give it.
+  double gain;
+  double* hpoints = 0;
+  int hpointcount = 0;
+  string units;
+  string nxttok;
+  int i = 0;
+  int result = 0;
+  int finalresult = 0;
+  ifstream msistrm(msifile);
+  // MSI uses 0 deg as due north, we have 0 deg as due east (and 90 as N).
+  // Add 90 deg to MSI numbers to fix this.
+  int hoffset = 90;
+  // MSI can use either dBd or dBi. I believe that ns-2 uses dBi.
+  // We'll set this appropriately when we get the units.
+  double gainoffset = 0.0;
+
+  if (!msistrm) {
+    return -1;
+  }
+
+  while (!msistrm.eof()) {
+    msistrm >> nxttok;
+
+    if (msistrm.eof()) {
+      continue;
+    }
+    else if ("GAIN" == nxttok) {
+      msistrm >> gain;
+      msistrm >> units;
+      //cout << "GAIN " << gain  << " " << units << endl;
+      gainoffset = 0.0;
+      if ("dBd" == units) {
+	gainoffset = 2.15;
+      }
+    }
+    else if ("HORIZONTAL" == nxttok) {
+      msistrm >> hpointcount;
+      //cout << "Horizontal pointcount: " << hpointcount << endl;
+      hpoints = (double*) malloc(hpointcount*sizeof(double));
+      for (i=0;i<hpointcount;i++) {
+	double index = 0;
+	double curpoint = 0;
+	msistrm >> index;
+	msistrm >> curpoint;
+	//cout << "POINTS: " << index << " " << curpoint << endl;
+	int hindx = (i + hoffset) % 360;
+	if (0 > hindx) hindx += 360;
+	hpoints[hindx] = gain - curpoint + gainoffset;
+      }
+    }
+  }
+
+  if (hpoints) {
+    if (hpointcount) {
+      // Assume same gain for Tx and Rx
+      setHorizRxGainPattern(hpointcount,hpoints);
+      setHorizTxGainPattern(hpointcount,hpoints);
+    }
+    free(hpoints);
+    hpoints = 0;
+    hpointcount = 0;
+  }
+  return finalresult;
+}
+
+int
+PatternAntenna::command(int argc, const char*const* argv)
+{
+  Tcl& tcl = Tcl::instance();
+  if (2 == argc) {
+  }
+  else if (3 == argc) {
+    if(strcmp(argv[1], "loadmsi") == 0) {
+      int result = read_pattern_from_msi(argv[2]);
+      tcl.resultf("%d",result);
+      return TCL_OK;
+    }
+  }
+  else if (4 == argc) {
+  } else if (argc == 5) {
+  }
+
+  return Antenna::command(argc, argv);
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/mobile/pattern-antenna.h ns-2.30/mobile/pattern-antenna.h
--- ns-2.30-pure/mobile/pattern-antenna.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/mobile/pattern-antenna.h	2006-12-30 17:22:59.000000000 -0800
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2003 University of Colorado, Boulder
+ * All rights reserved.
+ *
+ */
+
+#ifndef ns_patternantenna_h
+#define ns_patternantenna_h
+
+#include <antenna.h>
+
+class PatternAntenna : public Antenna {
+
+public:
+  PatternAntenna();
+  virtual int command(int argc, const char*const* argv);
+  // return the gain for a signal to a node at vector dX, dY, dZ
+  // from the transmitter at wavelength lambda  
+  virtual double getTxGain(double, double, double, double);
+
+  // return the gain for a signal from a node at vector dX, dY, dZ
+  // from the receiver at wavelength lambda
+  virtual double getRxGain(double, double, double, double);
+
+  // return a pointer to a copy of this antenna that will return the 
+  // same thing for get{Rx,Tx}Gain that this one would at this point
+  // in time.  This is needed b/c if a pkt is sent with a directable
+  // antenna, this antenna may be have been redirected by the time we
+  // call getTxGain on the copy to determine if the pkt is received.  
+  virtual Antenna* copy();
+  virtual void release();
+
+  void setDir(double newdir) { Dir_ = newdir; }
+  double getDir() { return Dir_; }
+
+  void setHorizRxGainPattern(int samplecount, double* samples);
+  void setHorizTxGainPattern(int samplecount, double* samples);
+
+  static double get_angle(double dX, double dY);
+  static double normalize(double deg);
+
+  int read_pattern_from_msi(const char* msifile);
+
+protected:
+  double Dir_;
+  typedef class gain_pattern {
+  public:
+    gain_pattern();
+    ~gain_pattern();
+    void set_gain_pattern(int samplecount, double* samples);
+    double get_gain(double angle);
+    void copy_pattern(gain_pattern& pat);
+
+  protected:
+    int samplecount_;
+    double* samples_;
+    double sample_quantum_;
+  };
+
+  gain_pattern horiz_tx_gain_;
+  gain_pattern horiz_rx_gain_;
+};
+
+
+#endif // ns_uniantenna_h
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/mobile/uni-antenna.cc ns-2.30/mobile/uni-antenna.cc
--- ns-2.30-pure/mobile/uni-antenna.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/mobile/uni-antenna.cc	2006-12-30 17:22:59.000000000 -0800
@@ -0,0 +1,197 @@
+
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Daedalus Research
+ *	Group at the University of California Berkeley.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+
+ * Ported from CMU/Monarch's code, nov'98 -Padma.
+   omni-antenna.cc
+   */
+
+#include <antenna.h>
+#include <uni-antenna.h> 
+#include <math.h>
+
+static class UniAntennaClass : public TclClass {
+public:
+  UniAntennaClass() : TclClass("Antenna/UniAntenna") {}
+  TclObject* create(int, const char*const*) {
+    return (new UniAntenna);
+  }
+} class_UniAntenna;
+
+UniAntenna::UniAntenna() : is_copy_(false) {
+  Gt_ = 1.0;
+  Gr_ = 1.0;
+  GtOmni_ = 0.0;
+  GrOmni_ = 0.0;
+  Dir_ = 0.0;
+  Width_ = 360.0;
+  bind("Gt_", &Gt_);
+  bind("Gr_", &Gr_);
+  bind("GtOmni_", &GtOmni_);
+  bind("GrOmni_", &GrOmni_);
+  bind("Dir_", &Dir_);
+  bind("Width_", &Width_);
+}
+
+double
+UniAntenna::normalize(double deg) {
+  while (360.0 <= deg) {
+    deg -= 360.0;
+  }
+
+  while (0.0 > deg) {
+    deg += 360.0;
+  }
+
+  return deg;
+}
+
+double
+UniAntenna::get_angle(double dX, double dY) {
+  double angle;
+
+  // First take care of dX or both == 0
+  if ((0.0 == dY) && (0.0 == dX)) {
+    angle = 0.0;
+  }
+  else if (0.0 == dX) {
+    angle = M_PI/2.0;
+  }
+  else {
+    angle = atan2(dY,dX);
+    if (0.0 > angle) {
+      angle += 2*M_PI;
+    }
+  }
+
+  angle = (180.0/M_PI) * angle;
+
+  return angle;
+}
+
+void
+UniAntenna::get_cone(double& lb, double& ub) {
+  lb = Dir_ - (Width_/2.0);
+  ub = Dir_ + (Width_/2.0);
+  lb = normalize(lb);
+  ub = normalize(ub);
+}
+
+bool
+UniAntenna::is_in_cone(double dX, double dY) {
+  bool result = false;
+  double angle = get_angle(dX,dY);
+  double lb, ub;
+  get_cone(lb,ub);
+
+  // If lb and ub are swapped, we had a wraparound. In this
+  // case, the specified range is the inverse of the cone
+  // we want to check for.
+  if (lb > ub) {
+    result = ! ((ub <= angle) && (angle <= lb));
+  }
+  else if (lb == ub) {
+    result = true;
+  }
+  else {
+    result = (lb <= angle) && (angle <= ub);
+  }
+
+  return result;
+}
+
+// return the gain for a signal to a node at vector dX, dY, dZ
+// from the transmitter at wavelength lambda  
+double
+UniAntenna::getTxGain(double dX, double dY, double dZ, double l) {
+  // XXX for now ignore dZ, just do 2 dimensions, and ignore lambda, too
+  double gain = Gt_;
+
+  // XXX very stupid model. Gt_ gain within cone, GtOmni_ outside.
+  // Hopefully good enough for what we need initially...
+  if (is_in_cone(dX,dY)) {
+    gain = Gt_;
+  }
+  else {
+    gain = GtOmni_;
+  }
+  
+  return gain;
+}
+
+// return the gain for a signal from a node at vector dX, dY, dZ
+// from the receiver at wavelength lambda
+double
+UniAntenna::getRxGain(double dX, double dY, double dZ, double l) {
+  // XXX for now ignore dZ, just do 2 dimensions, and ignore lambda, too.
+  double gain = Gr_;
+
+  // XXX very stupid model. Gr_ gain within cone, GrOmni_ outside.
+  // Hopefully good enough for what we need initially...
+  if (is_in_cone(dX,dY)) {
+    gain = Gr_;
+  }
+  else {
+    gain = GrOmni_;
+  }
+
+  return gain;
+}
+
+// return a pointer to a copy of this antenna that will return the 
+// same thing for get{Rx,Tx}Gain that this one would at this point
+// in time.  This is needed b/c if a pkt is sent with a directable
+// antenna, this antenna may be have been redirected by the time we
+// call getTxGain on the copy to determine if the pkt is received.  
+Antenna*
+UniAntenna::copy() {
+  UniAntenna* antcopy = (UniAntenna*)TclObject::New("Antenna/UniAntenna");
+  antcopy->X_ = X_;
+  antcopy->Y_ = Y_;
+  antcopy->Z_ = Z_;
+  antcopy->Gt_ = Gt_;
+  antcopy->Gr_ = Gr_;
+  antcopy->Dir_ = Dir_;
+  antcopy->Width_ = Width_;
+  antcopy->is_copy_ = true;
+  return antcopy;
+}
+
+void
+UniAntenna::release() {
+  if (is_copy_) {
+    TclObject::Delete((TclObject*)this);
+  }
+}
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/mobile/uni-antenna.h ns-2.30/mobile/uni-antenna.h
--- ns-2.30-pure/mobile/uni-antenna.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/mobile/uni-antenna.h	2006-12-30 17:22:59.000000000 -0800
@@ -0,0 +1,82 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+/* Ported from CMU/Monarch's code, nov'98 -Padma.
+   omni-antenna.h
+   omni-directional antenna
+
+*/
+
+#ifndef ns_uniantenna_h
+#define ns_uniantenna_h
+
+#include <antenna.h>
+
+class UniAntenna : public Antenna {
+
+public:
+  UniAntenna();
+
+  // return the gain for a signal to a node at vector dX, dY, dZ
+  // from the transmitter at wavelength lambda  
+  virtual double getTxGain(double, double, double, double);
+
+  // return the gain for a signal from a node at vector dX, dY, dZ
+  // from the receiver at wavelength lambda
+  virtual double getRxGain(double, double, double, double);
+
+  // return a pointer to a copy of this antenna that will return the 
+  // same thing for get{Rx,Tx}Gain that this one would at this point
+  // in time.  This is needed b/c if a pkt is sent with a directable
+  // antenna, this antenna may be have been redirected by the time we
+  // call getTxGain on the copy to determine if the pkt is received.  
+  virtual Antenna* copy();
+  virtual void release();
+
+  static double get_angle(double dX, double dY);
+  static double normalize(double deg);
+  bool is_in_cone(double dX, double dY);
+  void get_cone(double& lb,double& ub);
+
+protected:
+  double Gt_;			// gain of transmitter (db)
+  double Gr_;			// gain of receiver (db)
+  double GtOmni_;               // Tx gain outside of cone
+  double GrOmni_;               // Rx gain outside of cone
+  double Dir_;
+  double Width_;
+  bool is_copy_;
+};
+
+
+#endif // ns_uniantenna_h
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/queue/clickqueue.cc ns-2.30/queue/clickqueue.cc
--- ns-2.30-pure/queue/clickqueue.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/queue/clickqueue.cc	2006-12-30 17:23:06.000000000 -0800
@@ -0,0 +1,147 @@
+/*
+ * clickqueue.cc
+ * Special queue which runs the external Click router when it unblocks
+ *
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#include <stdlib.h>
+#include <ctype.h>
+#include <sys/time.h>
+#include <unistd.h>
+//#include <stl.h>
+//#include <hash_map.h>
+#include <map>
+#include <math.h>
+#include <string>
+#include <click/simclick.h>
+#include "packet.h"
+#include "extrouter.h"
+#include "classifier.h"
+#include "classifier-ext.h"
+#include "classifier-click.h"
+#include "clickqueue.h"
+
+static class ClickQueueClass : public TclClass {
+public:
+	ClickQueueClass() : TclClass("Queue/ClickQueue") {}
+	TclObject* create(int, const char*const*) {
+		return (new ClickQueue);
+	}
+} class_click_queue;
+
+int 
+ClickQueue::command(int argc, const char*const* argv) {
+	if (3 == argc) {
+		if (!strcmp(argv[1],"setclickclassifier")) {
+			cc_ = (ClickClassifier*)TclObject::lookup(argv[2]);
+			return TCL_OK;
+		}
+	}
+	return Queue::command(argc, argv);
+}
+/*
+ * drop-tail
+ */
+ClickQueue::ClickQueue() { 
+	pq_ = new PacketQueue; 
+	qlim_ = 1;
+	cc_ = 0;
+}
+
+ClickQueue::~ClickQueue() {
+	delete pq_;
+}
+
+int
+ClickQueue::is_full() {
+	return (pq_->length() >= qlim_);
+}
+
+int
+ClickQueue::ready() {
+	return (!is_full() && !blocked());
+}
+
+void ClickQueue::enque(Packet* p)
+{
+	pq_->enque(p);
+	if (pq_->length() > qlim_) {
+		fprintf(stderr,"Hey!!! IFQ Overflow!!!\n");
+		Packet *pp = pq_->deque();
+		drop(pp);
+	}
+}
+
+Packet* ClickQueue::deque()
+{
+	Packet* retval = pq_->deque();
+	return retval;
+}
+
+void ClickQueue::on_unblock() {
+	//
+	// Queue has space - run the external router 
+	// and give it a chance to fill things up.
+	//
+	if (cc_) {
+		simclick_click clickinst = cc_->GetClickinst();
+		Scheduler& s = Scheduler::instance();
+		double dcurtime = s.clock();
+		simclick_simstate curstate;
+		memset(&curstate,0,sizeof(curstate));
+		double fracp, intp;
+		fracp = modf(dcurtime,&intp);
+		curstate.curtime.tv_sec = intp;
+		curstate.curtime.tv_usec = (fracp*1.0e6+0.5);
+		simclick_click_run(clickinst,&curstate);
+	}
+}
+
+#if 0
+void ClickQueue::runclick() {
+	if (is_full()) {
+		return;
+	}
+	//
+	// Queue has space - run the external router 
+	// and give it a chance to fill things up.
+	//
+	if (cc_) {
+		simclick_click clickinst = cc_->GetClickinst();
+		Scheduler& s = Scheduler::instance();
+		double dcurtime = s.clock();
+		simclick_simstate curstate;
+		memset(&curstate,0,sizeof(curstate));
+		double fracp, intp;
+		fracp = modf(dcurtime,&intp);
+		curstate.curtime.tv_sec = intp;
+		curstate.curtime.tv_usec = (fracp*1.0e6+0.5);
+		simclick_click_run(clickinst,&curstate);
+	}
+}
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/queue/clickqueue.h ns-2.30/queue/clickqueue.h
--- ns-2.30-pure/queue/clickqueue.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/queue/clickqueue.h	2006-12-30 17:23:06.000000000 -0800
@@ -0,0 +1,61 @@
+/*
+ * clickqueue.h
+ * Special queue which runs the external Click router when it unblocks
+ *
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#ifndef ns_clickqueue_h
+#define ns_clickqueue_h
+
+#include <string.h>
+#include "queue.h"
+#include "config.h"
+
+/*
+ * A degenerate queue designed to work with Click routers. Should only
+ * have 1 packet ever sitting in it since the queueing should be handled
+ * by Click. Also makes sure that simclick gets run whenever the queue
+ * empties and unblocks so that the polling simulated network driver
+ * will insert packets when it has them.
+ */
+class ClickQueue : public Queue {
+  public:
+	ClickQueue();
+	~ClickQueue();
+	void enque(Packet*);
+	Packet* deque();
+
+	int is_full();
+	int ready();
+  protected:
+	int command(int argc, const char*const* argv); 
+	ClickClassifier* cc_;
+	virtual void on_unblock();
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/queue/queue.cc ns-2.30/queue/queue.cc
--- ns-2.30-pure/queue/queue.cc	2006-09-24 22:11:19.000000000 -0700
+++ ns-2.30/queue/queue.cc	2006-12-30 17:23:06.000000000 -0800
@@ -218,6 +218,7 @@
 			utilUpdate(last_change_, now, blocked_);
 			last_change_ = now;
 			blocked_ = 0;
+			on_unblock();
 		}
 		else {
 			utilUpdate(last_change_, now, blocked_);
@@ -227,6 +228,10 @@
 	}
 }
 
+void Queue::on_unblock() {
+	// Do nothing in base class
+}
+
 void Queue::reset()
 {
 	Packet* p;
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/queue/queue.h ns-2.30/queue/queue.h
--- ns-2.30-pure/queue/queue.h	2006-09-24 22:11:19.000000000 -0700
+++ ns-2.30/queue/queue.h	2006-12-30 17:23:06.000000000 -0800
@@ -145,6 +145,7 @@
 protected:
 	Queue();
 	void reset();
+	virtual void on_unblock();
 	int qlim_;		/* maximum allowed pkts in queue */
 	int blocked_;		/* blocked now? */
 	int unblock_on_resume_;	/* unblock q on idle? */
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/routing/extclickrouter.cc ns-2.30/routing/extclickrouter.cc
--- ns-2.30-pure/routing/extclickrouter.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/routing/extclickrouter.cc	2006-12-30 17:23:06.000000000 -0800
@@ -0,0 +1,20 @@
+/*
+ * XXX Insert CU copyright stuff here...
+ *
+ */
+
+#include "packet.h"
+#include "extrouter.h"
+#include "extclickrouter.h"
+
+ExtClickRouter::ExtClickRouter() {
+}
+
+ExtClickRouter::~ExtClickRouter() {
+}
+
+int ExtClickRouter::recv(Packet* p) {
+  int result = 0;
+
+  return result;
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/routing/extclickrouter.h ns-2.30/routing/extclickrouter.h
--- ns-2.30-pure/routing/extclickrouter.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/routing/extclickrouter.h	2006-12-30 17:23:06.000000000 -0800
@@ -0,0 +1,27 @@
+/*
+ * XXX Insert CU copyright stuff here...
+ * 
+ * This defines the interface used by all external raw packet routing
+ * modules bolted on to ns.
+ *
+ */
+
+#ifndef __ns_extclickrouter_h__
+#define __ns_extclickrouter_h__
+
+class ExtClickRouter
+{
+
+ public:
+  ExtClickRouter();
+  virtual ~ExtClickRouter();
+  virtual int recv(Packet* p);
+
+  void* SetClickRouterPtr(void* crtptr);
+
+ private:
+  void* clickrouter_;
+  
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/routing/extrouter.cc ns-2.30/routing/extrouter.cc
--- ns-2.30-pure/routing/extrouter.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/routing/extrouter.cc	2006-12-30 17:23:06.000000000 -0800
@@ -0,0 +1,15 @@
+/*
+ * XXX Insert CU copyright stuff here...
+ * 
+ * This defines the interface used by all external raw packet routing
+ * modules bolted on to ns.
+ *
+ */
+
+#include "packet.h"
+#include "extrouter.h"
+
+// Just here so we get virtual destructors
+ExtRouter::~ExtRouter() {
+}
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/routing/extrouter.h ns-2.30/routing/extrouter.h
--- ns-2.30-pure/routing/extrouter.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/routing/extrouter.h	2006-12-30 17:23:06.000000000 -0800
@@ -0,0 +1,29 @@
+/*
+ * XXX Insert CU copyright stuff here...
+ * 
+ * This defines the interface used by all external raw packet routing
+ * modules bolted on to ns.
+ *
+ */
+
+#ifndef __ns_extrouter_h__
+#define __ns_extrouter_h__
+
+class ExtRouter
+{
+
+public:
+  enum {
+    IFID_NONE = -1,
+    IFID_KERNELTAP = 0,
+    IFID_FIRSTIF = 1,
+    IFID_LASTIF = 32,
+    IFID_FIRSTIFDROP = 33,
+    IFID_LASTIFDROP = 64
+  };
+  virtual ~ExtRouter();
+  virtual int route(Packet* p) = 0;
+  
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/routing/rtmodule.cc ns-2.30/routing/rtmodule.cc
--- ns-2.30-pure/routing/rtmodule.cc	2006-09-24 22:11:18.000000000 -0700
+++ ns-2.30/routing/rtmodule.cc	2006-12-30 17:23:06.000000000 -0800
@@ -137,6 +137,14 @@
         }
 } class_lms_routing_module;
 
+static class ClickRoutingModuleClass : public TclClass {
+public:
+        ClickRoutingModuleClass() : TclClass("RtModule/Click") {}
+        TclObject* create(int, const char*const*) {
+                return (new ClickRoutingModule);
+        }
+} class_click_routing_module;
+
 RoutingModule::RoutingModule() : 
 	next_rtm_(NULL), n_(NULL), classifier_(NULL) {
 	bind("classifier_", (TclObject**)&classifier_);
@@ -508,4 +516,3 @@
 	if (next_rtm_ != NULL)
 		next_rtm_->add_route(dst, target); 
 }
-
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/routing/rtmodule.h ns-2.30/routing/rtmodule.h
--- ns-2.30-pure/routing/rtmodule.h	2006-09-24 22:11:18.000000000 -0700
+++ ns-2.30/routing/rtmodule.h	2006-12-30 17:23:06.000000000 -0800
@@ -178,4 +178,10 @@
 	virtual void add_route(char *dst, NsObject *target){}
 };
 
+class ClickRoutingModule : public RoutingModule {
+public:
+        ClickRoutingModule() : RoutingModule() {}
+        virtual const char* module_name() const { return "Click"; }
+};
+
 #endif //  ns_rtmodule_h
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/sctp/sctp.h.orig ns-2.30/sctp/sctp.h.orig
--- ns-2.30-pure/sctp/sctp.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/sctp/sctp.h.orig	2006-09-24 22:11:17.000000000 -0700
@@ -0,0 +1,882 @@
+/*
+ * Copyright (c) 2001-2004 by the Protocol Engineering Lab, U of Delaware
+ * All rights reserved.
+ *
+ * Armando L. Caro Jr. <acaro@@cis,udel,edu>
+ * Janardhan Iyengar   <iyengar@@cis,udel,edu>
+ * Keyur Shah          <shah@@cis,udel,edu>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) $Header: /home/kohler/click-cvsroot-copy/release/one/etc/ns-2.30-patch,v 1.1 2006/12/31 01:54:25 eddietwo Exp $ (UD/PEL)
+ */
+
+#ifndef ns_sctp_h
+#define ns_sctp_h
+
+#include "agent.h"
+#include "node.h"
+#include "packet.h"
+
+/* The SCTP Common header is 12 bytes.
+ */
+#define SCTP_HDR_SIZE         12
+
+#define MAX_RWND_SIZE         0xffffffff
+#define MAX_DATA_CHUNK_SIZE   0xffffffff
+#define MIN_DATA_CHUNK_SIZE   16
+#define MAX_NUM_STREAMS       0x0000ffff
+
+#define DELAYED_SACK_TRIGGER  2      // sack for every 2 data packets
+
+#define RTO_ALPHA             0.125  // RTO.alpha is 1/8
+#define RTO_BETA              0.25   // RTO.Beta is 1/4
+
+#define MAX_BURST             4
+typedef enum MaxBurstUsage_E
+{
+  MAX_BURST_USAGE_OFF,      // 0
+  MAX_BURST_USAGE_ON        // 1
+};
+
+/* Let us use OUR typedef'd enum for FALSE and TRUE. It's much better this way.
+ * ...why? because NOW all boolean variables can be explicitly declared as
+ * such. There is no longer any ambiguity between a regular int variable and a
+ * boolean variable.  
+ */
+#undef FALSE
+#undef TRUE
+typedef enum Boolean_E
+{
+  FALSE,
+  TRUE
+};
+
+/* Each time the sender retransmits marked chunks, how many can be sent? Well,
+ * immediately after a timeout or when the 4 missing report is received, only
+ * one packet of retransmits may be sent. Later, the number of packets is gated
+ * by cwnd
+ */
+typedef enum SctpRtxLimit_E
+{
+  RTX_LIMIT_ONE_PACKET,
+  RTX_LIMIT_CWND,
+  RTX_LIMIT_ZERO
+};
+
+typedef enum MarkedForRtx_E
+{
+  NO_RTX,
+  FAST_RTX,
+  TIMEOUT_RTX
+};
+
+typedef enum RtxToAlt_E
+{
+  RTX_TO_ALT_OFF,
+  RTX_TO_ALT_ON,
+  RTX_TO_ALT_TIMEOUTS_ONLY
+};
+
+/* What behavior is used during dormant state (ie, all destinations have
+ * failed) when timeouts persist?
+ */
+typedef enum DormantAction_E
+{
+  DORMANT_HOP,        // keep hopping to another destination
+  DORMANT_PRIMARY,    // goto primary and stay there
+  DORMANT_LASTDEST    // stay at the last destination used before dormant state
+};
+
+/* Who controls the data sending, app layer or the transport layer 
+ * (as in the case of infinite data)
+ */
+typedef enum DataSource_E
+{
+  DATA_SOURCE_APPLICATION,
+  DATA_SOURCE_INFINITE
+};
+
+/* SCTP chunk types 
+ */
+typedef enum SctpChunkType_E
+{
+  SCTP_CHUNK_DATA,
+  SCTP_CHUNK_INIT,
+  SCTP_CHUNK_INIT_ACK,
+  SCTP_CHUNK_SACK,
+  SCTP_CHUNK_HB,
+  SCTP_CHUNK_HB_ACK,
+  SCTP_CHUNK_ABORT,
+  SCTP_CHUNK_SHUTDOWN,
+  SCTP_CHUNK_SHUTDOWN_ACK,
+  SCTP_CHUNK_ERROR,
+  SCTP_CHUNK_COOKIE_ECHO,
+  SCTP_CHUNK_COOKIE_ACK,
+  SCTP_CHUNK_ECNE,                  // reserved in rfc2960
+  SCTP_CHUNK_CWR,                   // reserved in rfc2960
+  SCTP_CHUNK_SHUTDOWN_COMPLETE,
+
+  /* RFC2960 leaves room for later defined chunks */
+
+  /* for U-SCTP/PR-SCTP
+   */
+  SCTP_CHUNK_FORWARD_TSN,    // should be 192, but this is a simulation! :-)
+
+  /* for timestamp option (sctp-timestamp.cc)
+   */
+  SCTP_CHUNK_TIMESTAMP
+};
+
+typedef struct AppData_S 
+{
+  /* Parameters needed for establishing an association 
+   */
+  u_short usNumStreams;     // Number of streams to associate
+  u_short usNumUnreliable;  // first usNumUnreliable streams will be unreliable
+
+  /* Parameters needed for app data messages 
+   */
+  u_short    usStreamId;     // Which stream does this message go on?
+  u_short    usReliability;  // What level of relability does this message have
+  Boolean_E  eUnordered;     // Is this an unordered message?
+  u_int      uiNumBytes;     // Number of databytes in message
+};
+
+/* ns specific header fields used for tracing SCTP traffic
+ * (This was done so that the 'trace' module wouldn't have to look into the
+ * payload of SCTP packets)
+ */
+typedef struct SctpTrace_S
+{
+  SctpChunkType_E  eType;
+  u_int            uiTsn;    // (cum ack for sacks, -1 for other control chunks)
+  u_short          usStreamId;     // -1 for control chunks
+  u_short          usStreamSeqNum; // -1 for control chunks
+};
+
+struct hdr_sctp
+{
+  /* ns required header fields/methods 
+   */
+  static int offset_;	// offset for this header
+  inline static int& offset() { return offset_; }
+  inline static hdr_sctp* access(Packet* p) 
+  {
+    return (hdr_sctp*) p->access(offset_);
+  }
+
+  /* ns specific header fields used for tracing SCTP traffic
+   * (This was done so that the 'trace' module wouldn't have to look into the
+   * payload of SCTP packets)
+   */
+  u_int         uiNumChunks;
+  SctpTrace_S  *spSctpTrace;
+
+  u_int&        NumChunks() { return uiNumChunks; }
+  SctpTrace_S*& SctpTrace() { return spSctpTrace; }
+};
+
+typedef struct SctpChunkHdr_S
+{
+  u_char  ucType;
+  u_char  ucFlags;
+  u_short usLength;
+};
+
+/* INIT paramater types
+ */
+#define SCTP_INIT_PARAM_UNREL  0xC000
+typedef struct SctpUnrelStreamsParam_S
+{
+  u_short  usType;
+  u_short  usLength;
+
+  /* unreliable stream start-end pairs are appended dynamically
+   */
+};
+
+typedef struct SctpUnrelStreamPair_S
+{
+  u_short  usStart;
+  u_short  usEnd;
+};
+
+typedef struct SctpInitChunk_S  // this is used for init ack, too 
+{
+  SctpChunkHdr_S  sHdr;
+  u_int           uiInitTag;		 // tag of mine (not used)
+  u_int           uiArwnd; 	         // referred to as a_rwnd in rfc2960
+  u_short         usNumOutboundStreams;	 // referred to as OS in rfc2960
+  u_short         usMaxInboundStreams;   // referred to as MIS in rfc2960
+  u_int           uiInitialTsn;          
+
+  SctpUnrelStreamsParam_S  sUnrelStream;	
+};
+typedef SctpInitChunk_S SctpInitAckChunk_S;
+
+typedef struct SctpCookieEchoChunk_S
+{
+  SctpChunkHdr_S  sHdr;
+	
+  /* cookie would go here, but we aren't implementing this at the moment */
+};
+typedef SctpCookieEchoChunk_S SctpCookieAckChunk_S;
+
+typedef struct SctpDataChunkHdr_S
+{
+  SctpChunkHdr_S  sHdr;
+  u_int           uiTsn;
+  u_short         usStreamId;
+  u_short         usStreamSeqNum;
+  u_int           uiPayloadType;     // not used
+
+  /* user data must be appended dynamically when filling packets */
+};
+
+/* Data Chunk Specific Flags
+ */
+#define SCTP_DATA_FLAG_END        0x01  // indicates last fragment
+#define SCTP_DATA_FLAG_BEGINNING  0x02  // indicates first fragment
+#define SCTP_DATA_FLAG_UNORDERED  0x04  // indicates unordered DATA chunk
+
+/* SACK has the following structure and following it will be some number of
+ * gap acks and duplicate tsns.
+ */
+typedef struct SctpSackChunk_S
+{
+  SctpChunkHdr_S  sHdr;
+  u_int           uiCumAck;
+  u_int           uiArwnd;
+  u_short         usNumGapAckBlocks;
+  u_short         usNumDupTsns;
+
+  /* Gap Ack Blocks and Duplicate TSNs are appended dynamically
+   */
+};
+
+typedef struct SctpGapAckBlock_S
+{
+  u_short  usStartOffset;
+  u_short  usEndOffset;
+};
+
+typedef struct SctpDupTsn_S
+{
+  u_int  uiTsn;
+};
+
+#define SCTP_CHUNK_FORWARD_TSN_LENGTH  8
+typedef struct SctpForwardTsnChunk_S
+{
+  SctpChunkHdr_S  sHdr;
+  u_int           uiNewCum;
+};
+
+typedef struct SctpDest_S;
+#define SCTP_CHUNK_HEARTBEAT_LENGTH  24
+typedef struct SctpHeartbeatChunk_S
+{
+  SctpChunkHdr_S  sHdr;
+  u_short         usInfoType;      // filled in, but not really used
+  u_short         usInfoLength;    // filled in, but not really used
+  double          dTimestamp;
+  SctpDest_S     *spDest;
+};
+typedef SctpHeartbeatChunk_S SctpHeartbeatAckChunk_S;
+
+/* SCTP state defines for internal state machine */
+typedef enum SctpState_E
+{
+  SCTP_STATE_UNINITIALIZED,
+  SCTP_STATE_CLOSED,
+  SCTP_STATE_ESTABLISHED,
+  SCTP_STATE_COOKIE_WAIT,
+  SCTP_STATE_COOKIE_ECHOED,
+  SCTP_STATE_SHUTDOWN_SENT,        // not currently used
+  SCTP_STATE_SHUTDOWN_RECEIVED,    // not currently used
+  SCTP_STATE_SHUTDOWN_ACK_SENT,    // not currently used
+  SCTP_STATE_SHUTDOWN_PENDING      // not currently used
+};
+
+class SctpAgent;
+
+class T1InitTimer : public TimerHandler 
+{
+public:
+  T1InitTimer(SctpAgent *a) : TimerHandler(), opAgent(a) { }
+	
+protected:
+  virtual void expire(Event *);
+  SctpAgent *opAgent;
+};
+
+class T1CookieTimer : public TimerHandler 
+{
+public:
+  T1CookieTimer(SctpAgent *a) : TimerHandler(), opAgent(a) { }
+	
+protected:
+  virtual void expire(Event *);
+  SctpAgent *opAgent;
+};
+
+class T3RtxTimer : public TimerHandler 
+{
+public:
+  T3RtxTimer(SctpAgent *a, SctpDest_S *d) 
+    : TimerHandler(), opAgent(a) {spDest = d;}
+	
+protected:
+  virtual void expire(Event *);
+  SctpAgent  *opAgent;
+  SctpDest_S *spDest;  // destination this timer corresponds to
+};
+
+class CwndDegradeTimer : public TimerHandler 
+{
+public:
+  CwndDegradeTimer(SctpAgent *a, SctpDest_S *d) 
+    : TimerHandler(), opAgent(a) {spDest = d;}
+	
+protected:
+  virtual void expire(Event *);
+  SctpAgent  *opAgent;
+  SctpDest_S *spDest;  // destination this timer corresponds to
+};
+
+class HeartbeatGenTimer : public TimerHandler 
+{
+public:
+  HeartbeatGenTimer(SctpAgent *a, SctpDest_S *d) 
+    : TimerHandler(), opAgent(a) {spDest = d;}
+
+  double      dStartTime; // timestamp of when timer started
+	
+protected:
+  virtual void expire(Event *);
+  SctpAgent  *opAgent;
+  SctpDest_S *spDest;     // destination this timer corresponds to
+};
+
+class HeartbeatTimeoutTimer : public TimerHandler 
+{
+public:
+  HeartbeatTimeoutTimer(SctpAgent *a, SctpDest_S *d) 
+    : TimerHandler(), opAgent(a) {spDest = d;}
+	
+  SctpDest_S *spDest;  // destination this timer corresponds to
+
+protected:
+  virtual void expire(Event *);
+  SctpAgent  *opAgent;
+};
+
+/* This timer simulates the route lifetime in the routing tables of
+ * reactive routing protocols for MANETs, etc. When this timer expires,
+ * the route is flushed and any future data sent to this dest will cause a 
+ * route calculation.
+ *
+ * Note: This timer is not normally used. It's only for our simulated reactive
+ * routing overheads for MANETs, etc. 
+ */
+class RouteCacheFlushTimer : public TimerHandler 
+{
+public:
+  RouteCacheFlushTimer(SctpAgent *a, SctpDest_S *d) 
+    : TimerHandler(), opAgent(a) {spDest = d;}
+	
+protected:
+  virtual void expire(Event *);
+  SctpAgent  *opAgent;
+  SctpDest_S *spDest;  // destination this timer corresponds to
+};
+
+/* This timer simulates the time it takes to calculate a route in
+ * reactive routing protocols for MANETs, etc. 
+ *
+ * Note: This timer is not normally used. It's only for our simulated reactive
+ * routing overheads for MANETs, etc. 
+ */
+class RouteCalcDelayTimer : public TimerHandler 
+{
+public:
+  RouteCalcDelayTimer(SctpAgent *a, SctpDest_S *d) 
+    : TimerHandler(), opAgent(a) {spDest = d;}
+	
+protected:
+  virtual void expire(Event *);
+  SctpAgent  *opAgent;
+  SctpDest_S *spDest;  // destination this timer corresponds to
+};
+
+typedef struct SctpInterface_S
+{
+  int        iNsAddr;
+  int        iNsPort;
+  NsObject  *opTarget;
+  NsObject  *opLink;
+};
+
+typedef enum SctpDestStatus_E
+{
+  SCTP_DEST_STATUS_INACTIVE,
+  SCTP_DEST_STATUS_POSSIBLY_FAILED,
+  SCTP_DEST_STATUS_ACTIVE
+};
+
+typedef enum NodeType_E
+{
+  NODE_TYPE_STREAM_BUFFER,
+  NODE_TYPE_RECV_TSN_BLOCK,
+  NODE_TYPE_DUP_TSN,
+  NODE_TYPE_SEND_BUFFER,
+  NODE_TYPE_APP_LAYER_BUFFER,
+  NODE_TYPE_INTERFACE_LIST,
+  NODE_TYPE_DESTINATION_LIST,
+  NODE_TYPE_PACKET_BUFFER
+};
+
+typedef struct Node_S
+{
+  NodeType_E  eType;
+  void       *vpData;   // u can put any data type into the node
+  Node_S     *spNext;
+  Node_S     *spPrev;
+};
+
+typedef struct List_S
+{
+  u_int    uiLength;
+  Node_S  *spHead;
+  Node_S  *spTail;
+};
+
+/* PN 01/20/2006
+ * In CMT-PF, a dest in PF state, could have sent data/HBs and
+ * be in one of the following sub-states.
+ * These sub-states are used for correct processing after receipt
+ * of hb ack/ data ack
+ */
+typedef enum CmtPFSubState_E
+{
+        NOT_PF,
+        NOTHING_SENT,
+        SENT_HB_ONLY,
+        SENT_DATA_ONLY,
+        SENT_HB_AND_DATA
+};
+
+typedef struct SctpSendBufferNode_S;
+typedef struct SctpDest_S
+{
+  int        iNsAddr;  // ns "IP address"
+  int        iNsPort;  // ns "port"
+
+  /* Packet is simply used for determing src addr. The header stores dest addr,
+   * which makes it easy to determine src target using
+   * Connector->find(Packet *). Then with the target, we can determine src 
+   * addr.
+   */
+  Packet    *opRoutingAssistPacket;
+
+  int           iCwnd;                // current congestion window
+  int           iSsthresh;            // current ssthresh value
+  Boolean_E     eFirstRttMeasurement; // is this our first RTT measurement?
+  double        dRto;                 // current retransmission timeout value
+  double        dSrtt;                // current smoothed round trip time
+  double        dRttVar;              // current RTT variance
+  int           iPmtu;                // current known path MTU (not used)
+  Boolean_E     eRtxTimerIsRunning;   // is there a timer running already?
+  T3RtxTimer   *opT3RtxTimer;         // retransmission timer
+  Boolean_E     eRtoPending;          // DATA chunk being used to measure RTT?
+
+  int  iPartialBytesAcked; // helps to modify cwnd in congestion avoidance mode
+  int  iOutstandingBytes;  // outstanding bytes still in flight (unacked)
+
+  int                     iTimeoutCount;           // total number of timeouts
+  int                     iErrorCount;             // destination error counter
+  SctpDestStatus_E        eStatus;                 // active/inactive
+  CwndDegradeTimer       *opCwndDegradeTimer;      // timer to degrade cwnd
+  double                  dIdleSince;              // timestamp since idle
+  HeartbeatGenTimer      *opHeartbeatGenTimer;     // to trigger a heartbeat
+  HeartbeatTimeoutTimer  *opHeartbeatTimeoutTimer; // heartbeat timeout timer
+
+  float fLossrate;          // Set from tcl, in SetLossrate(). Allows an
+			    // Oracle to tell sender a given destination's
+			    // lossrate. Used in CMT's RTX_LOSSRATE rtx
+			    // policy.
+
+  /* these are temporary variables needed per destination and they should
+   * be cleared for each usage.
+   */
+  Boolean_E              eCcApplied;          // cong control already applied?
+  SctpSendBufferNode_S  *spFirstOutstanding;  // first outstanding on this dest
+  int                    iNumNewlyAckedBytes; // newly ack'd bytes in a sack
+
+  /* These variables are generally not used. They are only for our
+   * simulated reactive routing overheads for MANETs, etc. 
+   */
+  int                    iRcdCount;     // total count of route calc delays
+  Boolean_E              eRouteCached;  // route cache hit or miss?
+  RouteCacheFlushTimer  *opRouteCacheFlushTimer;
+  RouteCalcDelayTimer   *opRouteCalcDelayTimer;  
+  List_S                 sBufferedPackets;
+
+  /* CMT variables follow. These are used only when CMT is used. 
+   */
+  Boolean_E  eSawNewAck;                // was this destination acked 
+                                        // in the current SACK?
+  u_int uiHighestTsnInSackForDest;      // highest TSN newly acked sent to this 
+                                        // destination in SACK
+  u_int      uiExpectedPseudoCum;       // expected pseudo cumack for this dest
+  Boolean_E  eNewPseudoCum;             // is there a new pseudo cum for dest?
+  Boolean_E  eFindExpectedPseudoCum;    // find a new expected pseudo cumack?
+  u_int      uiExpectedRtxPseudoCum;    // expected rtx pseudo cum for dest
+  Boolean_E  eFindExpectedRtxPseudoCum; // find a new expected rtx pseudo cum?
+  u_int uiLowestTsnInSackForDest;       // lowest TSN newly acked sent to this 
+                                        // destination in SACK
+
+  u_int iNumPacketsSent;    // for the one packet limit during rtx. With 
+                            // independent bottlenecks, apply limit per path.
+  u_int uiBurstLength;      // tracks sending burst per SACK per dest
+  Boolean_E eMarkedChunksPending;  // added global var per dest
+  u_int uiRecover;                 // To enable newreno recovery per dest
+  SctpRtxLimit_E eRtxLimit; // Which destination should use RTX_ONE_PACKET_LIMIT
+                            // when calling rtxmarkedchunks()
+
+  u_int uiNumTimeouts;      // track number of timeouts for this dest
+
+  CmtPFSubState_E eCmtPFSubState; // Possible CMT-PF sub-state, for correct 
+                                  // processing on receipt of hb ack/data ack.
+
+  /* End of CMT variables
+   */
+  
+};
+
+typedef struct SctpRecvTsnBlock_S
+{
+  u_int  uiStartTsn;
+  u_int  uiEndTsn;
+};
+
+typedef struct SctpSendBufferNode_S
+{
+  SctpDataChunkHdr_S  *spChunk;
+  Boolean_E            eAdvancedAcked;     // acked via rtx expiration (u-sctp)
+  Boolean_E            eGapAcked;          // acked via a Gap Ack Block
+  Boolean_E            eAddedToPartialBytesAcked; // already accounted for?
+  int                  iNumMissingReports; // # times reported missing
+  int                  iUnrelRtxLimit;     // limit on # of unreliable rtx's
+  MarkedForRtx_E       eMarkedForRtx;      // has it been marked for rtx?
+  Boolean_E            eIneligibleForFastRtx; // ineligible for fast rtx??
+  int                  iNumTxs;            // # of times transmitted (orig+rtx)
+  double               dTxTimestamp;  
+  SctpDest_S          *spDest;             // destination last sent to
+
+  /* variables used for extensions
+   */
+  u_int                uiFastRtxRecover;   // sctp-multipleFastRtxs.cc uses this
+
+  Boolean_E eMeasuringRtt;  // Maintain which TSN is being used for RTT
+			    // measurement, so that all TSNs can have
+			    // their timestamp. This timestamp can be used
+			    // for different things, and is used by CMT
+			    // for the RTT heuristic to determine whether
+			    // a TSN should be rtxd or not.  If now <=
+			    // timestamp + srtt, then no rtx.
+};
+
+typedef struct SctpStreamBufferNode_S
+{
+  SctpDataChunkHdr_S  *spChunk;
+};
+
+typedef enum SctpStreamMode_E
+{
+  SCTP_STREAM_RELIABLE,
+  SCTP_STREAM_UNRELIABLE
+};
+
+typedef struct SctpInStream_S
+{
+  SctpStreamMode_E  eMode;
+  u_short           usNextStreamSeqNum;
+  List_S            sBufferedChunkList;
+};
+
+typedef struct SctpOutStream_S
+{
+  SctpStreamMode_E  eMode;
+  u_short           usNextStreamSeqNum;	
+};
+
+class SackGenTimer : public TimerHandler 
+{
+public:
+  SackGenTimer(SctpAgent *a) : TimerHandler(), opAgent(a) { }
+	
+protected:
+  virtual void expire(Event *);
+  SctpAgent *opAgent;
+};
+
+class SctpAgent : public Agent 
+{
+public:
+  SctpAgent();
+  ~SctpAgent();
+	
+  virtual void  recv(Packet *pkt, Handler*);
+  virtual void  sendmsg(int nbytes, const char *flags = 0);
+  virtual int   command(int argc, const char*const* argv);
+	
+  void          T1InitTimerExpiration();
+  void          T1CookieTimerExpiration();
+  virtual void  Timeout(SctpChunkType_E, SctpDest_S *);
+  virtual void  CwndDegradeTimerExpiration(SctpDest_S *);
+  virtual void  HeartbeatGenTimerExpiration(double, SctpDest_S *);
+  void          SackGenTimerExpiration();
+  void          RouteCacheFlushTimerExpiration(SctpDest_S *);
+  void          RouteCalcDelayTimerExpiration(SctpDest_S *);
+
+protected:
+  virtual void  delay_bind_init_all();
+  virtual int   delay_bind_dispatch(const char *varName, const char *localName,
+				    TclObject *tracer);
+
+  /* initialization stuff
+   */
+  void           SetDebugOutFile();
+  virtual void   Reset();
+  virtual void   OptionReset();
+  virtual u_int  ControlChunkReservation();
+
+  /* tracing functions
+   */
+  virtual void  TraceVar(const char*);
+  virtual void  TraceAll();
+  void          trace(TracedVar*);
+
+  /* generic list functions
+   */
+  void       InsertNode(List_S *, Node_S *, Node_S *, Node_S *);
+  void       DeleteNode(List_S *, Node_S *);
+  void       ClearList(List_S *);
+
+  /* multihome functions
+   */
+  void       AddInterface(int, int, NsObject *, NsObject *);
+  void       AddDestination(int, int);
+  int        SetPrimary(int);
+  int        ForceSource(int);
+  int        SetLossrate(int, float); // Oracle tells sender lossrate to
+				      // dest. Called by handling of tcl
+				      // set-destination-lossrate command
+
+  /* chunk generation functions
+   */
+  virtual int  GenChunk(SctpChunkType_E, u_char *);
+  u_int        GetNextDataChunkSize();
+  int          GenOneDataChunk(u_char *);
+  virtual int  GenMultipleDataChunks(u_char *, int);
+  virtual int  BundleControlChunks(u_char *);
+
+  /* sending functions
+   */
+  void          StartT3RtxTimer(SctpDest_S *);
+  void          StopT3RtxTimer(SctpDest_S *);
+  virtual void  AddToSendBuffer(SctpDataChunkHdr_S *, int, u_int, SctpDest_S *);
+  void          RttUpdate(double, SctpDest_S *);
+  virtual void  SendBufferDequeueUpTo(u_int);
+  virtual void  AdjustCwnd(SctpDest_S *);
+  void          AdvancePeerAckPoint();
+  virtual u_int GetHighestOutstandingTsn();
+  virtual void  FastRtx();
+  void          TimeoutRtx(SctpDest_S *);
+  void          MarkChunkForRtx(SctpSendBufferNode_S *, MarkedForRtx_E);
+  Boolean_E     AnyMarkedChunks();
+  virtual void  RtxMarkedChunks(SctpRtxLimit_E);
+  void          SendHeartbeat(SctpDest_S *);
+  SctpDest_S   *GetNextDest(SctpDest_S *);
+  double        CalcHeartbeatTime(double);
+  void          SetSource(SctpDest_S *);
+  void          SetDestination(SctpDest_S *);
+  void          SendPacket(u_char *, int, SctpDest_S *);
+  SctpDest_S   *GetReplyDestination(hdr_ip *);
+  u_int         TotalOutstanding();
+  virtual void  SendMuch();
+
+  /* receiving functions
+   */
+  Boolean_E  UpdateHighestTsn(u_int);
+  Boolean_E  IsDuplicateChunk(u_int);
+  void       InsertDuplicateTsn(u_int);
+  void       UpdateCumAck();
+  void       UpdateRecvTsnBlocks(u_int);
+  void       PassToUpperLayer(SctpDataChunkHdr_S *);
+  void       InsertInStreamBuffer(List_S *, SctpDataChunkHdr_S *);
+  void       PassToStream(SctpDataChunkHdr_S *);
+  void       UpdateAllStreams();
+
+  /* processing functions
+   */
+  void               ProcessInitChunk(u_char *);
+  void               ProcessInitAckChunk(u_char *);
+  void               ProcessCookieEchoChunk(SctpCookieEchoChunk_S *);
+  void               ProcessCookieAckChunk(SctpCookieAckChunk_S *);
+  void               ProcessDataChunk(SctpDataChunkHdr_S *);
+  virtual Boolean_E  ProcessGapAckBlocks(u_char *, Boolean_E);
+  virtual void       ProcessSackChunk(u_char *);
+  void               ProcessForwardTsnChunk(SctpForwardTsnChunk_S *);  
+  void               ProcessHeartbeatAckChunk(SctpHeartbeatChunk_S *);  
+  virtual void       ProcessOptionChunk(u_char *);
+  virtual int        ProcessChunk(u_char *, u_char **);
+  void               NextChunk(u_char **, int *);
+
+  /* misc functions
+   */
+  void       Close();
+
+  /* debugging functions
+   */
+  void DumpSendBuffer();
+
+  /* sctp association state variable
+   */
+  SctpState_E     eState;
+
+  /* App Layer buffer
+   */
+  List_S          sAppLayerBuffer;
+
+  /* multihome variables
+   */
+  Classifier         *opCoreTarget;
+  List_S              sInterfaceList;
+  List_S              sDestList;
+  SctpDest_S         *spPrimaryDest;       // primary destination
+  SctpDest_S         *spNewTxDest;         // destination for new transmissions
+  SctpDest_S         *spReplyDest; // reply with sacks or control chunk replies
+  Boolean_E           eForceSource;
+  int                 iAssocErrorCount;  // total error counter for the assoc
+
+  /* heartbeat variables
+   */
+  HeartbeatGenTimer      *opHeartbeatGenTimer;      // to trigger a heartbeat
+  HeartbeatTimeoutTimer  *opHeartbeatTimeoutTimer;  // heartbeat timeout timer
+
+  /* sending variables
+   */
+  T1InitTimer       *opT1InitTimer;    // T1-init timer
+  T1CookieTimer     *opT1CookieTimer;  // T1-cookie timer
+  int                iInitTryCount;    // # of unsuccessful INIT attempts
+  u_int              uiNextTsn;
+  u_short            usNextStreamId; // used to round-robin the streams
+  SctpOutStream_S   *spOutStreams;
+  u_int              uiPeerRwnd;
+  u_int              uiCumAckPoint;  
+  u_int              uiAdvancedPeerAckPoint;
+  u_int              uiHighestTsnNewlyAcked; // global for HTNA
+  u_int              uiRecover;
+  List_S             sSendBuffer;
+  Boolean_E          eForwardTsnNeeded;  // is a FORWARD TSN chunk needed?
+  Boolean_E          eSendNewDataChunks; // should we send new data chunks too?
+  Boolean_E          eMarkedChunksPending; // chunks waiting to be rtx'd?
+  Boolean_E          eApplyMaxBurst; 
+  DataSource_E       eDataSource;
+  u_int              uiBurstLength;  // tracks sending burst per SACK
+
+  /* receiving variables
+   */
+  u_int            uiMyRwnd;
+  u_int            uiCumAck;       
+  u_int            uiHighestRecvTsn; // higest tsn recv'd of entire assoc
+  List_S           sRecvTsnBlockList;
+  List_S           sDupTsnList;
+  int              iNumInStreams;
+  SctpInStream_S  *spInStreams;
+  Boolean_E        eStartOfPacket;             // for delayed sack triggering
+  int              iDataPktCountSinceLastSack; // for delayed sack triggering
+  Boolean_E        eSackChunkNeeded; // do we need to transmit a sack chunk?
+  SackGenTimer    *opSackGenTimer;    // sack generation timer
+
+  /* tcl bindable variables
+   */
+  u_int            uiDebugMask;     // 32 bits for fine level debugging
+  int              iDebugFileIndex; // 1 debug output file per agent 
+  u_int            uiPathMaxRetrans;
+  u_int            uiChangePrimaryThresh;
+  u_int            uiAssociationMaxRetrans;
+  u_int            uiMaxInitRetransmits;
+  Boolean_E        eOneHeartbeatTimer;  // one heartbeat timer for all dests?
+  u_int            uiHeartbeatInterval;
+  u_int            uiMtu;
+  u_int            uiInitialRwnd;
+  int              iInitialSsthresh;
+  u_int            uiIpHeaderSize;
+  u_int            uiDataChunkSize;
+  u_int            uiNumOutStreams;
+  Boolean_E        eUseDelayedSacks; // are we using delayed sacks?
+  double           dSackDelay;
+  MaxBurstUsage_E  eUseMaxBurst;
+  int              iInitialCwnd;
+  double           dInitialRto;
+  double           dMinRto;
+  double           dMaxRto;
+  int              iFastRtxTrigger;
+  u_int            uiNumUnrelStreams;
+  u_int            uiReliability; // k-rtx on all chunks & all unrel streams
+  Boolean_E        eUnordered;    // sets for all chunks on all streams :-(
+  RtxToAlt_E       eRtxToAlt;     // rtxs to alternate destination?
+  DormantAction_E  eDormantAction;// behavior during dormant state
+  double           dRouteCacheLifetime; 
+  double           dRouteCalcDelay; 
+  Boolean_E        eTraceAll;     // trace all variables on one line?
+  TracedInt        tiCwnd;        // trace cwnd for all destinations
+  TracedInt        tiRwnd;        // trace rwnd
+  TracedDouble     tdRto;         // trace rto for all destinations
+  TracedInt        tiErrorCount;  // trace error count for all destinations
+  TracedInt        tiFrCount;     // trace each time a fast rtx gets triggered
+  TracedInt        tiTimeoutCount;// trace each time a timeout occurs
+  TracedInt        tiRcdCount;    // trace each time a route calc delay occurs
+
+  /* globally used non-tcl bindable variables, but rely on the tcl bindable
+   */
+  u_int           uiMaxPayloadSize; // we don't want this to be tcl bindable
+  u_int           uiMaxDataSize; // max payload size - reserved control bytes
+  FILE           *fhpDebugFile; 	   // file pointer for debugging output
+
+  /* tracing variables that will be copied into hdr_sctp
+   */
+  u_int           uiNumChunks;
+  SctpTrace_S    *spSctpTrace;  
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/tcl/ex/nsclick-simple-bridge.click ns-2.30/tcl/ex/nsclick-simple-bridge.click
--- ns-2.30-pure/tcl/ex/nsclick-simple-bridge.click	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/tcl/ex/nsclick-simple-bridge.click	2006-12-30 17:23:06.000000000 -0800
@@ -0,0 +1,40 @@
+//
+//  Copyright 2002, Univerity of Colorado at Boulder.                        
+//                                                                            
+//                         All Rights Reserved                                
+//                                                                            
+//  Permission to use, copy, modify, and distribute this software and its    
+//  documentation for any purpose other than its incorporation into a        
+//  commercial product is hereby granted without fee, provided that the      
+//  above copyright notice appear in all copies and that both that           
+//  copyright notice and this permission notice appear in supporting         
+//  documentation, and that the name of the University not be used in        
+//  advertising or publicity pertaining to distribution of the software      
+//  without specific, written prior permission.                              
+//                                                                            
+//  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+//  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+//  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+//  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+//  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+//  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+//  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+//  PERFORMANCE OF THIS SOFTWARE.                                            
+//
+
+// nsclick-simple-bridge.click
+//
+// This is a simple and stupid network "bridge." Packets coming
+// in off of eth0 are pumped out on eth1, and packets coming
+// in off of eth1 are pumped out on eth0.
+//
+
+FromSimDevice(eth0,4096)
+	-> Queue
+	-> ToSimDevice(eth1);
+	
+FromSimDevice(eth1,4096)
+	-> Queue
+	-> ToSimDevice(eth0);
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/tcl/ex/nsclick-simple-hybrid.tcl ns-2.30/tcl/ex/nsclick-simple-hybrid.tcl
--- ns-2.30-pure/tcl/ex/nsclick-simple-hybrid.tcl	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/tcl/ex/nsclick-simple-hybrid.tcl	2006-12-30 17:23:06.000000000 -0800
@@ -0,0 +1,390 @@
+#
+#  Copyright 2002, Univerity of Colorado at Boulder.                        
+#                                                                            
+#                         All Rights Reserved                                
+#                                                                            
+#  Permission to use, copy, modify, and distribute this software and its    
+#  documentation for any purpose other than its incorporation into a        
+#  commercial product is hereby granted without fee, provided that the      
+#  above copyright notice appear in all copies and that both that           
+#  copyright notice and this permission notice appear in supporting         
+#  documentation, and that the name of the University not be used in        
+#  advertising or publicity pertaining to distribution of the software      
+#  without specific, written prior permission.                              
+#                                                                            
+#  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+#  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+#  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+#  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+#  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+#  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+#  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+#  PERFORMANCE OF THIS SOFTWARE.                                            
+#
+# nsclick-simple-hybrid.tcl
+#
+# A sample nsclick script simulating a small hybrid wired/wireless
+#
+
+#
+# Set some general simulation parameters
+#
+
+#
+# Unity gain, omnidirectional antennas, centered 1.5m above each node.
+# These values are lifted from the ns-2 sample files.
+#
+Antenna/OmniAntenna set X_ 0
+Antenna/OmniAntenna set Y_ 0
+Antenna/OmniAntenna set Z_ 1.5
+Antenna/OmniAntenna set Gt_ 1.0
+Antenna/OmniAntenna set Gr_ 1.0
+
+#
+# Initialize the SharedMedia interface with parameters to make
+# it work like the 914MHz Lucent WaveLAN DSSS radio interface
+# These are taken directly from the ns-2 sample files.
+#
+Phy/WirelessPhy set CPThresh_ 10.0
+Phy/WirelessPhy set CSThresh_ 1.559e-11
+Phy/WirelessPhy set RXThresh_ 3.652e-10
+Phy/WirelessPhy set Rb_ 2*1e6
+Phy/WirelessPhy set Pt_ 0.2818
+Phy/WirelessPhy set freq_ 914e+6 
+Phy/WirelessPhy set L_ 1.0
+
+# 
+# Set the size of the playing field and the topography.
+#
+set xsize 100
+set ysize 100
+set wtopo	[new Topography]
+$wtopo load_flatgrid $xsize $ysize
+
+#
+# The network channel, physical layer, MAC, propagation model,
+# and antenna model are all standard ns-2.
+#  
+set wirelesschan Channel/WirelessChannel
+set wiredchan Channel
+
+set wirelessphy Phy/WirelessPhy
+set wiredphy Phy/WiredPhy
+
+set wirelessmac Mac/802_11
+set wiredmac Mac/802_3
+
+set netprop Propagation/TwoRayGround
+set antenna Antenna/OmniAntenna
+
+#
+# We have to use a special queue and link layer. This is so that
+# Click can have control over the network interface packet queue,
+# which is vital if we want to play with, e.g. QoS algorithms.
+#
+set netifq	Queue/ClickQueue
+set netll	LL/Ext
+LL set delay_			1ms
+
+#
+# These are pretty self-explanatory, just the number of nodes
+# and when we'll stop.
+#
+set wirednodecount 3
+set wirelessnodecount 3
+set bridgenodecount 1
+set nodecount   7
+set stoptime	10.0
+
+#
+# With nsclick, we have to worry about details like which network
+# port to use for communication. This sets the default ports to 5000.
+#
+Agent/Null set sport_		5000
+Agent/Null set dport_		5000
+
+Agent/CBR set sport_		5000
+Agent/CBR set dport_		5000
+
+#
+# Standard ns-2 stuff here - create the simulator object.
+#
+set ns_		[new Simulator]
+
+#
+# Create and activate trace files.
+#
+set tracefd	[open "nsclick-simple-hybrid.tr" w]
+set namtrace    [open "nsclick-simple-hybrid.nam" w]
+$ns_ trace-all $tracefd
+$ns_ namtrace-all-wireless $namtrace $xsize $ysize
+$ns_ use-newtrace
+
+
+#
+# Create the "god" object. This is another artifact of using
+# the mobile node type. We have to have this even though
+# we never use it.
+#
+set god_ [create-god $nodecount]
+
+#
+# Tell the simulator to create Click nodes.
+#
+Simulator set node_factory_ Node/MobileNode/ClickNode
+
+#
+# Create a network Channel for the nodes to use. One channel
+# per LAN. Also set the propagation model to be used.
+#
+set wired_chan_ [new $wiredchan]
+set wireless_chan_ [new $wirelesschan]
+set prop_ [new $netprop]
+
+#
+# In nsclick we have to worry about assigning IP and MAC addresses
+# to out network interfaces. Here we generate a list of IP and MAC
+# addresses, one per node since we've only got one network interface
+# per node in this case. Also note that this scheme only works for
+# fewer than 255 nodes, and we aren't worrying about subnet masks.
+#
+set iptemplate "192.168.1.%d"
+set mactemplate "00:03:47:70:89:%0x"
+for {set i 0} {$i < $wirednodecount} {incr i} {
+    set wired_node_ip($i) [format $iptemplate [expr $i+1]]
+    set wired_node_mac($i) [format $mactemplate [expr $i+1]]
+}
+
+set iptemplate "192.168.2.%d"
+set mactemplate "00:03:47:70:8A:%0x"
+for {set i 0} {$i < $wirelessnodecount} {incr i} {
+    set wireless_node_ip($i) [format $iptemplate [expr $i+1]]
+    set wireless_node_mac($i) [format $mactemplate [expr $i+1]]
+}
+
+
+#
+# We set the routing protocol to "Empty" so that ns-2 doesn't do
+# any packet routing. All of the routing will be done by the
+# Click script.
+#
+$ns_ rtproto Empty
+
+#
+# Here is where we actually create all of the nodes.
+# We'll create the wired, wireless, and the bridge node
+# separately.
+#
+
+#
+# Start with the wireless nodes
+#
+for {set i 0} {$i < $wirelessnodecount } {incr i} {
+    set wireless_node_($i) [$ns_ node]
+
+    #
+    # After creating the node, we add one wireless network interface to
+    # it. By default, this interface will be named "eth0". If we
+    # added a second interface it would be named "eth1", a third
+    # "eth2" and so on.
+    #
+    $wireless_node_($i) add-interface $wireless_chan_ $prop_ $netll \
+	    $wirelessmac $netifq 1 $wirelessphy $antenna $wtopo
+
+    #
+    # Now configure the interface eth0
+    #
+    $wireless_node_($i) setip "eth0" $wireless_node_ip($i)
+    $wireless_node_($i) setmac "eth0" $wireless_node_mac($i)
+
+    #
+    # Set some node properties
+    #
+    $wireless_node_($i) random-motion 0
+    $wireless_node_($i) topography $wtopo
+    $wireless_node_($i) nodetrace $tracefd
+
+    #
+    # The node name is used by Click to distinguish information
+    # coming from different nodes. For example, a "Print" element
+    # prepends this to the printed string so it's clear exactly
+    # which node is doing the printing.
+    #
+    [$wireless_node_($i) set classifier_] setnodename "wirelessnode$i-hybrid"
+    
+    #
+    # Load the appropriate Click router script for the node.
+    #
+    [$wireless_node_($i) entry] loadclick "nsclick-simple-lan.click"
+}
+
+#
+# Now create the wired nodes
+#
+for {set i 0} {$i < $wirednodecount } {incr i} {
+    set wired_node_($i) [$ns_ node]
+
+    #
+    # After creating the node, we add one wired network interface to
+    # it. By default, this interface will be named "eth0". If we
+    # added a second interface it would be named "eth1", a third
+    # "eth2" and so on.
+    #
+    $wired_node_($i) add-wired-interface $wired_chan_ $netll $wiredmac \
+	$netifq 1 $wiredphy
+
+    #
+    # Now configure the interface eth0
+    #
+    $wired_node_($i) setip "eth0" $wired_node_ip($i)
+    $wired_node_($i) setmac "eth0" $wired_node_mac($i)
+
+    #
+    # Set some node properties
+    #
+    $wired_node_($i) random-motion 0
+    $wired_node_($i) topography $wtopo
+    $wired_node_($i) nodetrace $tracefd
+
+    #
+    # The node name is used by Click to distinguish information
+    # coming from different nodes. For example, a "Print" element
+    # prepends this to the printed string so it's clear exactly
+    # which node is doing the printing.
+    #
+    [$wired_node_($i) set classifier_] setnodename "wirednode$i-hybrid"
+    
+    #
+    # Load the appropriate Click router script for the node.
+    # All nodes in this simulation are using the same script,
+    # but there's no reason why each node couldn't use a different
+    # script.
+    #
+    [$wired_node_($i) entry] loadclick "nsclick-simple-lan.click"
+}
+
+#
+# Finally make the bridge node
+#
+set bridge_node_ [$ns_ node]
+$bridge_node_ add-wired-interface $wired_chan_ $netll $wiredmac \
+	$netifq 1 $wiredphy
+$bridge_node_ add-interface $wireless_chan_ $prop_ $netll \
+	    $wirelessmac $netifq 1 $wirelessphy $antenna $wtopo
+
+$bridge_node_ random-motion 0
+$bridge_node_ topography $wtopo
+$bridge_node_ nodetrace $tracefd
+
+[$bridge_node_ entry] loadclick "nsclick-simple-bridge.click"
+[$bridge_node_ set classifier_] setnodename "bridgenode-hybrid"
+
+# 
+# Define node network traffic. There isn't a whole lot going on
+# in this simple test case, we're just going to have the first wireless node
+# send packets to the first wired node, starting at 1 second, and ending at 10.
+# There are Perl scripts available to automatically generate network
+# traffic.
+#
+
+
+#
+# Start transmitting at $startxmittime, $xmitrate packets per second.
+#
+set startxmittime 1
+set xmitrate 4
+set xmitinterval 0.25
+set packetsize 64
+
+#
+# We use the "raw" packet type, which sends real packet data
+# down the pipe.
+#
+set raw_(0) [new Agent/Raw]
+$ns_ attach-agent $wireless_node_(0) $raw_(0)
+
+set null_(0) [new Agent/Null]
+$ns_ attach-agent $wired_node_(0) $null_(0)
+
+#
+# The CBR object is just the default ns-2 CBR object, so
+# no change in the meaning of the parameters.
+#
+set cbr_(0) [new Application/Traffic/CBR]
+$cbr_(0) set packetSize_ $packetsize
+$cbr_(0) set interval_ $xmitinterval
+$cbr_(0) set random_ 0
+$cbr_(0) set maxpkts_ [expr ($stoptime - $startxmittime)*$xmitrate]
+$cbr_(0) attach-agent $raw_(0)
+
+#
+# The Raw agent creates real UDP packets, so it has to know
+# the source and destination IP addresses and port numberes.
+#
+$raw_(0) set-srcip [$wireless_node_(0) getip eth0]
+$raw_(0) set-srcport 5000
+$raw_(0) set-destport 5000
+$raw_(0) set-destip [$wired_node_(0) getip eth0]
+
+$ns_ at $startxmittime "$cbr_(0) start"
+
+
+$wireless_node_(0) set X_ 10
+$wireless_node_(0) set Y_ 50
+$wireless_node_(0) set Z_ 0
+
+$wireless_node_(1) set X_ 50
+$wireless_node_(1) set Y_ 50
+$wireless_node_(1) set Z_ 0
+
+$wireless_node_(2) set X_ 90
+$wireless_node_(2) set Y_ 50
+$wireless_node_(2) set Z_ 0
+
+$bridge_node_ set X_ 50
+$bridge_node_ set Y_ 10
+$bridge_node_ set Z_ 0
+
+$wired_node_(0) set X_ 10
+$wired_node_(0) set Y_ 0
+$wired_node_(0) set Z_ 0
+
+$wired_node_(1) set X_ 50
+$wired_node_(1) set Y_ 0
+$wired_node_(1) set Z_ 0
+
+$wired_node_(2) set X_ 90
+$wired_node_(2) set Y_ 0
+$wired_node_(2) set Z_ 0
+#
+# This sizes the nodes for use in nam.
+#
+for {set i 0} {$i < $wirelessnodecount} {incr i} {
+    $ns_ initial_node_pos $wireless_node_($i) 10
+    [$wireless_node_($i) entry] runclick
+}
+
+for {set i 0} {$i < $wirednodecount} {incr i} {
+    $ns_ initial_node_pos $wired_node_($i) 10
+    [$wired_node_($i) entry] runclick
+}
+
+$ns_ initial_node_pos $bridge_node_ 10
+
+#
+# Stop the simulation
+#
+$ns_ at  $stoptime.000000001 "puts \"NS EXITING...\" ; $ns_ halt"
+
+#
+# Let nam know that the simulation is done.
+#
+$ns_ at  $stoptime	"$ns_ nam-end-wireless $stoptime"
+
+
+puts "Starting Simulation..."
+$ns_ run
+
+
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/tcl/ex/nsclick-simple-lan.click ns-2.30/tcl/ex/nsclick-simple-lan.click
--- ns-2.30-pure/tcl/ex/nsclick-simple-lan.click	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/tcl/ex/nsclick-simple-lan.click	2006-12-30 17:23:06.000000000 -0800
@@ -0,0 +1,97 @@
+//
+//  Copyright 2002, Univerity of Colorado at Boulder.                        
+//                                                                            
+//                         All Rights Reserved                                
+//                                                                            
+//  Permission to use, copy, modify, and distribute this software and its    
+//  documentation for any purpose other than its incorporation into a        
+//  commercial product is hereby granted without fee, provided that the      
+//  above copyright notice appear in all copies and that both that           
+//  copyright notice and this permission notice appear in supporting         
+//  documentation, and that the name of the University not be used in        
+//  advertising or publicity pertaining to distribution of the software      
+//  without specific, written prior permission.                              
+//                                                                            
+//  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+//  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+//  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+//  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+//  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+//  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+//  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+//  PERFORMANCE OF THIS SOFTWARE.                                            
+//
+
+// nsclick-simple-lan.click
+//
+// This is a simple and stupid flat routing mechanism.
+// It broadcasts ARP requests if it wants to find a destination
+// address, and it responds to ARP requests made for it.
+
+elementclass DumbRouter {
+  $myaddr, $myaddr_ethernet |
+
+  class :: Classifier(12/0806 20/0001,12/0806 20/0002, -);
+  mypackets :: IPClassifier(dst host $myaddr,-);
+  myarpquerier :: ARPQuerier($myaddr,$myaddr_ethernet);
+  myarpresponder :: ARPResponder($myaddr $myaddr_ethernet);
+  ethout :: Queue -> ToSimDevice(eth0);
+
+  FromSimDevice(eth0,4096)
+	-> Print(eth0,64)
+	-> ToDump(in_eth0,PER_NODE 1)
+	-> HostEtherFilter($myaddr_ethernet)
+	-> class;
+	
+  // ARP queries from other nodes go to the ARP responder module
+  class[0] -> myarpresponder;
+
+  // ARP responses go to our query module
+  class[1] -> [1]myarpquerier;
+
+  // All other packets get checked to see if they're meant for us
+  class[2]				
+	-> Strip(14)
+	-> CheckIPHeader
+	-> MarkIPHeader
+	-> GetIPAddress(16)
+	-> mypackets; 
+
+  // Packets for us go to "tap0" which sends them to the kernel
+  mypackets[0]
+	-> IPPrint(tokernel) 
+	-> ToDump(tokernel,2000,IP,PER_NODE 1) 
+	-> ToSimDevice(tap0,IP);
+
+  // Packets for other folks or broadcast packets get discarded
+  mypackets[1]
+	-> Print(discard,64)
+	-> ToDump(discard,2000,PER_NODE 1)
+	-> Discard;
+
+  // Packets sent out by the "kernel" get pushed into the ARP query module
+  FromSimDevice(tap0,4096)
+	-> CheckIPHeader 
+	-> IPPrint(fromkernel) 
+	-> ToDump(fromkernel,2000,IP,PER_NODE 1)
+	-> GetIPAddress(16)
+	-> myarpquerier;
+
+  // Both the ARP query and response modules send data out to
+  // the simulated network device, eth0.
+  myarpquerier
+	-> Print(fromarpquery,64)
+	-> ToDump(out_arpquery,PER_NODE 1)
+	-> ethout;
+
+  myarpresponder
+	-> Print(arpresponse,64)
+	-> ToDump(out_arprespond,PER_NODE 1)
+	-> ethout;
+}
+
+
+u :: DumbRouter(eth0,eth0);
+
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/tcl/ex/nsclick-simple-lan.tcl ns-2.30/tcl/ex/nsclick-simple-lan.tcl
--- ns-2.30-pure/tcl/ex/nsclick-simple-lan.tcl	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/tcl/ex/nsclick-simple-lan.tcl	2006-12-30 17:23:06.000000000 -0800
@@ -0,0 +1,271 @@
+#
+#  Copyright 2002, Univerity of Colorado at Boulder.                        
+#                                                                            
+#                         All Rights Reserved                                
+#                                                                            
+#  Permission to use, copy, modify, and distribute this software and its    
+#  documentation for any purpose other than its incorporation into a        
+#  commercial product is hereby granted without fee, provided that the      
+#  above copyright notice appear in all copies and that both that           
+#  copyright notice and this permission notice appear in supporting         
+#  documentation, and that the name of the University not be used in        
+#  advertising or publicity pertaining to distribution of the software      
+#  without specific, written prior permission.                              
+#                                                                            
+#  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+#  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+#  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+#  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+#  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+#  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+#  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+#  PERFORMANCE OF THIS SOFTWARE.                                            
+#
+# nsclick-simple-lan.tcl
+#
+# A sample nsclick script simulating a small LAN
+#
+
+#
+# Set some general simulation parameters
+#
+
+# 
+# Even though this is a wired simulation with non-moving nodes, nsclick
+# uses the mobile node type. This means we have to set the size of the
+# playing field and the topography even though it won't matter.
+#
+set xsize 100
+set ysize 100
+set wtopo	[new Topography]
+$wtopo load_flatgrid $xsize $ysize
+
+#
+# The network channel, physical layer, and MAC are all standard ns-2.
+#  
+set netchan	Channel
+set netphy	Phy/WiredPhy
+set netmac	Mac/802_3
+
+#
+# We have to use a special queue and link layer. This is so that
+# Click can have control over the network interface packet queue,
+# which is vital if we want to play with, e.g. QoS algorithms.
+#
+set netifq	Queue/ClickQueue
+set netll	LL/Ext
+LL set delay_			1ms
+
+#
+# These are pretty self-explanatory, just the number of nodes
+# and when we'll stop.
+#
+set nodecount   4
+set stoptime	10.0
+
+#
+# With nsclick, we have to worry about details like which network
+# port to use for communication. This sets the default ports to 5000.
+#
+Agent/Null set sport_		5000
+Agent/Null set dport_		5001
+
+Agent/CBR set sport_		5002
+Agent/CBR set dport_		5003
+
+#
+# Standard ns-2 stuff here - create the simulator object.
+#
+Simulator set MacTrace_ ON
+set ns_		[new Simulator]
+
+#
+# Create and activate trace files.
+#
+set tracefd	[open "nsclick-simple-lan.tr" w]
+set namtrace    [open "nsclick-simple-lan.nam" w]
+$ns_ trace-all $tracefd
+$ns_ namtrace-all-wireless $namtrace $xsize $ysize
+$ns_ use-newtrace
+
+
+#
+# Create the "god" object. This is another artifact of using
+# the mobile node type. We have to have this even though
+# we never use it.
+#
+set god_ [create-god $nodecount]
+
+#
+# Tell the simulator to create Click nodes.
+#
+Simulator set node_factory_ Node/MobileNode/ClickNode
+
+#
+# Create a network Channel for the nodes to use. One channel
+# per LAN.
+#
+set chan_1_ [new $netchan]
+
+#
+# In nsclick we have to worry about assigning IP and MAC addresses
+# to out network interfaces. Here we generate a list of IP and MAC
+# addresses, one per node since we've only got one network interface
+# per node in this case. Also note that this scheme only works for
+# fewer than 255 nodes, and we aren't worrying about subnet masks.
+#
+set iptemplate "192.168.1.%d"
+set mactemplate "00:03:47:70:89:%0x"
+for {set i 0} {$i < $nodecount} {incr i} {
+    set node_ip($i) [format $iptemplate [expr $i+1]]
+    set node_mac($i) [format $mactemplate [expr $i+1]]
+}
+
+#
+# We set the routing protocol to "Empty" so that ns-2 doesn't do
+# any packet routing. All of the routing will be done by the
+# Click script.
+#
+$ns_ rtproto Empty
+
+#
+# Here is where we actually create all of the nodes.
+#
+for {set i 0} {$i < $nodecount } {incr i} {
+    set node_($i) [$ns_ node]
+
+    #
+    # After creating the node, we add one wired network interface to
+    # it. By default, this interface will be named "eth0". If we
+    # added a second interface it would be named "eth1", a third
+    # "eth2" and so on.
+    #
+    $node_($i) add-wired-interface $chan_1_ $netll $netmac \
+	$netifq 1 $netphy
+
+    #
+    # Now configure the interface eth0
+    #
+    $node_($i) setip "eth0" $node_ip($i)
+    $node_($i) setmac "eth0" $node_mac($i)
+
+    #
+    # Set some node properties
+    #
+    $node_($i) random-motion 0
+    $node_($i) topography $wtopo
+    $node_($i) nodetrace $tracefd
+
+    #
+    # The node name is used by Click to distinguish information
+    # coming from different nodes. For example, a "Print" element
+    # prepends this to the printed string so it's clear exactly
+    # which node is doing the printing.
+    #
+    [$node_($i) set classifier_] setnodename "node$i-simplelan"
+    
+    #
+    # Load the appropriate Click router script for the node.
+    # All nodes in this simulation are using the same script,
+    # but there's no reason why each node couldn't use a different
+    # script.
+    #
+    [$node_($i) entry] loadclick "nsclick-simple-lan.click"
+}
+
+
+# 
+# Define node network traffic. There isn't a whole lot going on
+# in this simple test case, we're just going to have the first node
+# send packets to the last node, starting at 1 second, and ending at 10.
+# There are Perl scripts available to automatically generate network
+# traffic.
+#
+
+
+#
+# Start transmitting at $startxmittime, $xmitrate packets per second.
+#
+set startxmittime 1
+set xmitrate 4
+set xmitinterval 0.25
+set packetsize 64
+
+#
+# We use the "raw" packet type, which sends real packet data
+# down the pipe.
+#
+set raw_(0) [new Agent/Raw]
+$ns_ attach-agent $node_(0) $raw_(0)
+
+set lastnode [expr $nodecount-1]
+set null_(0) [new Agent/Null]
+$ns_ attach-agent $node_($lastnode) $null_(0)
+
+#
+# The CBR object is just the default ns-2 CBR object, so
+# no change in the meaning of the parameters.
+#
+set cbr_(0) [new Application/Traffic/CBR]
+$cbr_(0) set packetSize_ $packetsize
+$cbr_(0) set interval_ $xmitinterval
+$cbr_(0) set random_ 0
+$cbr_(0) set maxpkts_ [expr ($stoptime - $startxmittime)*$xmitrate]
+$cbr_(0) attach-agent $raw_(0)
+
+#
+# The Raw agent creates real UDP packets, so it has to know
+# the source and destination IP addresses and port numberes.
+#
+$raw_(0) set-srcip [$node_(0) getip eth0]
+$raw_(0) set-srcport 5000
+$raw_(0) set-destport 5001
+$raw_(0) set-destip [$node_($lastnode) getip eth0]
+
+$ns_ at $startxmittime "$cbr_(0) start"
+
+#
+# Set node positions. For wired networks, these are only used
+# when looking at nam traces.
+#
+$node_(0) set X_ 10
+$node_(0) set Y_ 50
+$node_(0) set Z_ 0
+
+$node_(1) set X_ 50
+$node_(1) set Y_ 50
+$node_(1) set Z_ 0
+
+$node_(2) set X_ 90
+$node_(2) set Y_ 50
+$node_(2) set Z_ 0
+
+$node_(3) set X_ 50
+$node_(3) set Y_ 10
+$node_(3) set Z_ 0
+
+#
+# This sizes the nodes for use in nam.
+#
+for {set i 0} {$i < $nodecount} {incr i} {
+    $ns_ initial_node_pos $node_($i) 20
+    [$node_($i) entry] runclick
+}
+
+#
+# Stop the simulation
+#
+$ns_ at  $stoptime.000000001 "puts \"NS EXITING...\" ; $ns_ halt"
+
+#
+# Let nam know that the simulation is done.
+#
+$ns_ at  $stoptime	"$ns_ nam-end-wireless $stoptime"
+
+
+puts "Starting Simulation..."
+$ns_ run
+
+
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/tcl/ex/nsclick-simple-wlan.tcl ns-2.30/tcl/ex/nsclick-simple-wlan.tcl
--- ns-2.30-pure/tcl/ex/nsclick-simple-wlan.tcl	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/tcl/ex/nsclick-simple-wlan.tcl	2006-12-30 17:23:06.000000000 -0800
@@ -0,0 +1,295 @@
+#
+#  Copyright 2002, Univerity of Colorado at Boulder.                        
+#                                                                            
+#                         All Rights Reserved                                
+#                                                                            
+#  Permission to use, copy, modify, and distribute this software and its    
+#  documentation for any purpose other than its incorporation into a        
+#  commercial product is hereby granted without fee, provided that the      
+#  above copyright notice appear in all copies and that both that           
+#  copyright notice and this permission notice appear in supporting         
+#  documentation, and that the name of the University not be used in        
+#  advertising or publicity pertaining to distribution of the software      
+#  without specific, written prior permission.                              
+#                                                                            
+#  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+#  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+#  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+#  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+#  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+#  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+#  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+#  PERFORMANCE OF THIS SOFTWARE.                                            
+#
+# nsclick-simple-lan.tcl
+#
+# A sample nsclick script simulating a small LAN
+#
+
+#
+# Set some general simulation parameters
+#
+
+#
+# Unity gain, omnidirectional antennas, centered 1.5m above each node.
+# These values are lifted from the ns-2 sample files.
+#
+Antenna/OmniAntenna set X_ 0
+Antenna/OmniAntenna set Y_ 0
+Antenna/OmniAntenna set Z_ 1.5
+Antenna/OmniAntenna set Gt_ 1.0
+Antenna/OmniAntenna set Gr_ 1.0
+
+#
+# Initialize the SharedMedia interface with parameters to make
+# it work like the 914MHz Lucent WaveLAN DSSS radio interface
+# These are taken directly from the ns-2 sample files.
+#
+Phy/WirelessPhy set CPThresh_ 10.0
+Phy/WirelessPhy set CSThresh_ 1.559e-11
+Phy/WirelessPhy set RXThresh_ 3.652e-10
+Phy/WirelessPhy set Rb_ 2*1e6
+Phy/WirelessPhy set Pt_ 0.2818
+Phy/WirelessPhy set freq_ 914e+6 
+Phy/WirelessPhy set L_ 1.0
+
+# 
+# Set the size of the playing field and the topography.
+#
+set xsize 100
+set ysize 100
+set wtopo	[new Topography]
+$wtopo load_flatgrid $xsize $ysize
+
+#
+# The network channel, physical layer, MAC, propagation model,
+# and antenna model are all standard ns-2.
+#  
+set netchan	Channel/WirelessChannel
+set netphy	Phy/WirelessPhy
+set netmac	Mac/802_11
+set netprop     Propagation/TwoRayGround
+set antenna     Antenna/OmniAntenna
+
+#
+# We have to use a special queue and link layer. This is so that
+# Click can have control over the network interface packet queue,
+# which is vital if we want to play with, e.g. QoS algorithms.
+#
+set netifq	Queue/ClickQueue
+set netll	LL/Ext
+LL set delay_			1ms
+
+#
+# These are pretty self-explanatory, just the number of nodes
+# and when we'll stop.
+#
+set nodecount   4
+set stoptime	10.0
+
+#
+# With nsclick, we have to worry about details like which network
+# port to use for communication. This sets the default ports to 5000.
+#
+Agent/Null set sport_		5000
+Agent/Null set dport_		5000
+
+Agent/CBR set sport_		5000
+Agent/CBR set dport_		5000
+
+#
+# Standard ns-2 stuff here - create the simulator object.
+#
+Simulator set MacTrace_ ON
+set ns_		[new Simulator]
+
+#
+# Create and activate trace files.
+#
+set tracefd	[open "nsclick-simple-wlan.tr" w]
+set namtrace    [open "nsclick-simple-wlan.nam" w]
+$ns_ trace-all $tracefd
+$ns_ namtrace-all-wireless $namtrace $xsize $ysize
+$ns_ use-newtrace
+
+
+#
+# Create the "god" object. This is another artifact of using
+# the mobile node type. We have to have this even though
+# we never use it.
+#
+set god_ [create-god $nodecount]
+
+#
+# Tell the simulator to create Click nodes.
+#
+Simulator set node_factory_ Node/MobileNode/ClickNode
+
+#
+# Create a network Channel for the nodes to use. One channel
+# per LAN. Also set the propagation model to be used.
+#
+set chan_1_ [new $netchan]
+set prop_ [new $netprop]
+
+#
+# In nsclick we have to worry about assigning IP and MAC addresses
+# to out network interfaces. Here we generate a list of IP and MAC
+# addresses, one per node since we've only got one network interface
+# per node in this case. Also note that this scheme only works for
+# fewer than 255 nodes, and we aren't worrying about subnet masks.
+#
+set iptemplate "192.168.1.%d"
+set mactemplate "00:03:47:70:89:%0x"
+for {set i 0} {$i < $nodecount} {incr i} {
+    set node_ip($i) [format $iptemplate [expr $i+1]]
+    set node_mac($i) [format $mactemplate [expr $i+1]]
+}
+
+#
+# We set the routing protocol to "Empty" so that ns-2 doesn't do
+# any packet routing. All of the routing will be done by the
+# Click script.
+#
+$ns_ rtproto Empty
+
+#
+# Here is where we actually create all of the nodes.
+#
+for {set i 0} {$i < $nodecount } {incr i} {
+    set node_($i) [$ns_ node]
+
+    #
+    # After creating the node, we add one wireless network interface to
+    # it. By default, this interface will be named "eth0". If we
+    # added a second interface it would be named "eth1", a third
+    # "eth2" and so on.
+    #
+    $node_($i) add-interface $chan_1_ $prop_ $netll $netmac \
+	$netifq 1 $netphy $antenna $wtopo
+
+    #
+    # Now configure the interface eth0
+    #
+    $node_($i) setip "eth0" $node_ip($i)
+    $node_($i) setmac "eth0" $node_mac($i)
+
+    #
+    # Set some node properties
+    #
+    $node_($i) random-motion 0
+    $node_($i) topography $wtopo
+    $node_($i) nodetrace $tracefd
+
+    #
+    # The node name is used by Click to distinguish information
+    # coming from different nodes. For example, a "Print" element
+    # prepends this to the printed string so it's clear exactly
+    # which node is doing the printing.
+    #
+    [$node_($i) set classifier_] setnodename "node$i-simplelan"
+    
+    #
+    # Load the appropriate Click router script for the node.
+    # All nodes in this simulation are using the same script,
+    # but there's no reason why each node couldn't use a different
+    # script.
+    #
+    [$node_($i) entry] loadclick "nsclick-simple-lan.click"
+}
+
+
+# 
+# Define node network traffic. There isn't a whole lot going on
+# in this simple test case, we're just going to have the first node
+# send packets to the last node, starting at 1 second, and ending at 10.
+# There are Perl scripts available to automatically generate network
+# traffic.
+#
+
+
+#
+# Start transmitting at $startxmittime, $xmitrate packets per second.
+#
+set startxmittime 1
+set xmitrate 4
+set xmitinterval 0.25
+set packetsize 64
+
+#
+# We use the "raw" packet type, which sends real packet data
+# down the pipe.
+#
+set raw_(0) [new Agent/Raw]
+$ns_ attach-agent $node_(0) $raw_(0)
+
+set lastnode [expr $nodecount-1]
+set null_(0) [new Agent/Null]
+$ns_ attach-agent $node_($lastnode) $null_(0)
+
+#
+# The CBR object is just the default ns-2 CBR object, so
+# no change in the meaning of the parameters.
+#
+set cbr_(0) [new Application/Traffic/CBR]
+$cbr_(0) set packetSize_ $packetsize
+$cbr_(0) set interval_ $xmitinterval
+$cbr_(0) set random_ 0
+$cbr_(0) set maxpkts_ [expr ($stoptime - $startxmittime)*$xmitrate]
+$cbr_(0) attach-agent $raw_(0)
+
+#
+# The Raw agent creates real UDP packets, so it has to know
+# the source and destination IP addresses and port numberes.
+#
+$raw_(0) set-srcip [$node_(0) getip eth0]
+$raw_(0) set-srcport 5000
+$raw_(0) set-destport 5000
+$raw_(0) set-destip [$node_($lastnode) getip eth0]
+
+$ns_ at $startxmittime "$cbr_(0) start"
+
+
+$node_(0) set X_ 10
+$node_(0) set Y_ 50
+$node_(0) set Z_ 0
+
+$node_(1) set X_ 50
+$node_(1) set Y_ 50
+$node_(1) set Z_ 0
+
+$node_(2) set X_ 90
+$node_(2) set Y_ 50
+$node_(2) set Z_ 0
+
+$node_(3) set X_ 50
+$node_(3) set Y_ 10
+$node_(3) set Z_ 0
+
+
+#
+# This sizes the nodes for use in nam. Currently, the trace files
+# produced by nsclick don't really work in nam.
+#
+for {set i 0} {$i < $nodecount} {incr i} {
+    $ns_ initial_node_pos $node_($i) 20
+    [$node_($i) entry] runclick
+}
+
+#
+# Stop the simulation
+#
+$ns_ at  $stoptime.000000001 "puts \"NS EXITING...\" ; $ns_ halt"
+
+#
+# Let nam know that the simulation is done.
+#
+$ns_ at  $stoptime	"$ns_ nam-end-wireless $stoptime"
+
+
+puts "Starting Simulation..."
+$ns_ run
+
+
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/tcl/lib/ns-clicknode.tcl ns-2.30/tcl/lib/ns-clicknode.tcl
--- ns-2.30-pure/tcl/lib/ns-clicknode.tcl	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/tcl/lib/ns-clicknode.tcl	2006-12-30 17:23:06.000000000 -0800
@@ -0,0 +1,352 @@
+#
+#  Copyright 2002, Univerity of Colorado at Boulder.                        
+#                                                                            
+#                         All Rights Reserved                                
+#                                                                            
+#  Permission to use, copy, modify, and distribute this software and its    
+#  documentation for any purpose other than its incorporation into a        
+#  commercial product is hereby granted without fee, provided that the      
+#  above copyright notice appear in all copies and that both that           
+#  copyright notice and this permission notice appear in supporting         
+#  documentation, and that the name of the University not be used in        
+#  advertising or publicity pertaining to distribution of the software      
+#  without specific, written prior permission.                              
+#                                                                            
+#  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+#  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+#  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+#  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+#  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+#  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+#  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+#  PERFORMANCE OF THIS SOFTWARE.                                            
+#
+#
+
+Class ClickNode -superclass Node/MobileNode
+
+Node/MobileNode/ClickNode instproc init args {
+    $self instvar nifs_ netif_ mac_ ifq_ ll_ dmux_
+    set ns [Simulator instance]
+    eval $self next $args
+    set nifs_ 0
+    $self register-module [new RtModule/Click]
+
+    #
+    # This Trace Target is used to log changes in direction
+    # and velocity for the mobile node.
+    #
+    set tracefd [$ns get-ns-traceall]
+    if {$tracefd != "" } {
+	$self nodetrace $tracefd
+	#$self agenttrace $tracefd
+    }
+
+    set namtracefd [$ns get-nam-traceall]
+    if {$namtracefd != "" } {
+	$self namattach $namtracefd
+    }
+
+}
+
+Node/MobileNode/ClickNode instproc getip { ifname } {
+    [$self entry] getip $ifname
+}
+
+Node/MobileNode/ClickNode instproc getmac { ifname } {
+    [$self entry] getmac $ifname
+}
+
+Node/MobileNode/ClickNode instproc setip { ifname ipaddr } {
+    [$self entry] setip $ifname $ipaddr
+}
+
+Node/MobileNode/ClickNode instproc setmac { ifname macaddr } {
+    [$self entry] setmac $ifname $macaddr
+}
+
+Node/MobileNode/ClickNode instproc add-route { dst target } {
+    #puts "ClickNode does routing via Click - not ns."
+}
+
+Node/MobileNode/ClickNode instproc delete-route args {
+    #puts "ClickNode does routing via Click - not ns."
+}
+
+Node/MobileNode/ClickNode instproc route-notify { module } {
+    #puts "ClickNode does routing via Click - not ns."
+}
+
+#
+# The following setups up link layer, mac layer, network interface
+# and physical layer structures for the click node. Stolen from
+# the MobileNode code, and then modified a bit, e.g. the ARP
+# stuff got removed.
+#
+Node/MobileNode/ClickNode instproc add-interface { channel pmodel lltype mactype \
+					    qtype qlen iftype anttype topo} {
+
+    $self instvar nifs_ netif_ mac_ ifq_ ll_
+    set ns [Simulator instance]
+    set t $nifs_
+    incr nifs_
+
+    set netif_($t)	[new $iftype]		;# interface
+    set mac_($t)	[new $mactype]		;# mac layer
+    set ifq_($t)	[new $qtype]		;# interface queue
+    set ll_($t)	[new $lltype]		;# link layer
+    set ant_($t)    [new $anttype]
+
+    set namfp [$ns get-nam-traceall]
+
+    #
+    # Local Variables
+    #
+    set nullAgent_ [$ns set nullAgent_]
+    set netif $netif_($t)
+    set mac $mac_($t)
+    set ifq $ifq_($t)
+    set ll $ll_($t)
+
+    #
+    # Link Layer
+    #
+    $ll mac $mac
+    $ll down-target $ifq
+    $ll up-target [$self entry]
+    # Stuff the link layer into the next available classifier slot, and
+    # use that slot number as the network id
+    $ll setid [[$self entry] installNext $ll]
+    # Set the associated MAC layer address
+    $ll set macDA_ [$mac id]
+
+    #
+    # Interface Queue
+    #
+    $ifq target $mac
+    $ifq set limit_ $qlen
+    set drpT [cmu-trace Drop "IFQ" $self]
+    $ifq drop-target $drpT
+    if { $namfp != "" } {
+	$drpT namattach $namfp
+    }
+    if {$qtype == "Queue/ClickQueue"} {
+	$ifq setclickclassifier [$self entry]
+	$ll ifq $ifq
+    }
+
+    #
+    # Mac Layer
+    #
+    $mac netif $netif
+    $mac up-target $ll
+    $mac down-target $netif
+    set god_ [God instance]
+    if {$mactype == "Mac/802_11"} {
+	# XXX this is a hack to handle multiple interfaces per node.
+	$mac nodes [expr 4*[$god_ num_nodes]]
+    }
+    #
+    # Network Interface
+    #
+    $netif channel $channel
+    $netif up-target $mac
+    $netif propagation $pmodel	;# Propagation Model
+    $netif node $self		;# Bind node <---> interface
+    $netif antenna $ant_($t)
+    #
+    # Physical Channel
+    #
+    $channel addif $netif
+
+        # List-based improvement
+	# For nodes talking to multiple channels this should
+	# be called multiple times for each channel
+	$channel add-node $self		
+
+	# let topo keep handle of channel
+	$topo channel $channel	
+
+    
+    # ============================================================
+    
+    if { [Simulator set MacTrace_] == "ON" } {
+	#
+	# Trace RTS/CTS/ACK Packets
+	#
+	set rcvT [cmu-trace Recv "MAC" $self]
+	$mac log-target $rcvT
+	if { $namfp != "" } {
+	    $rcvT namattach $namfp
+	}
+	#
+	# Trace Sent Packets
+	#
+	set sndT [cmu-trace Send "MAC" $self]
+	$sndT target [$mac down-target]
+	$mac down-target $sndT
+	if { $namfp != "" } {
+	    $sndT namattach $namfp
+	}
+	#
+	# Trace Received Packets
+	#
+	set rcvT [cmu-trace Recv "MAC" $self]
+	$rcvT target [$mac up-target]
+	$mac up-target $rcvT
+	if { $namfp != "" } {
+	    $rcvT namattach $namfp
+	}
+	#
+	# Trace Dropped Packets
+	#
+	set drpT [cmu-trace Drop "MAC" $self]
+	$mac drop-target $drpT
+	if { $namfp != "" } {
+	    $drpT namattach $namfp
+	}
+    } else {
+	$mac log-target [$ns set nullAgent_]
+	$mac drop-target [$ns set nullAgent_]
+    }
+    
+    # ============================================================
+    
+    $self addif $netif
+}
+
+
+#
+# The following setups up link layer, mac layer, network interface
+# and physical layer structures for the click node. Stolen from
+# the MobileNode code, and then modified a bit, e.g. the ARP
+# stuff got removed.
+#
+Node/MobileNode/ClickNode instproc add-wired-interface { channel lltype mactype qtype qlen iftype} {
+
+    $self instvar nifs_ netif_ mac_ ifq_ ll_
+    set ns [Simulator instance]
+    set t $nifs_
+    incr nifs_
+
+    set netif_($t)	[new $iftype]		;# interface
+    set mac_($t)	[new $mactype]		;# mac layer
+    set ifq_($t)	[new $qtype]		;# interface queue
+    set ll_($t)	[new $lltype]		;# link layer
+
+
+    set namfp [$ns get-nam-traceall]
+
+    #
+    # Local Variables
+    #
+    set nullAgent_ [$ns set nullAgent_]
+    set netif $netif_($t)
+    set mac $mac_($t)
+    set ifq $ifq_($t)
+    set ll $ll_($t)
+
+    #
+    # Link Layer
+    #
+    $ll mac $mac
+    $ll down-target $ifq
+     $ll up-target [$self entry]
+    # Stuff the link layer into the next available classifier slot, and
+    # use that slot number as the network id
+    $ll setid [[$self entry] installNext $ll]
+    # Set the associated MAC layer address
+    $ll set macDA_ [$mac id]
+
+    #
+    # Interface Queue
+    #
+    $ifq target $mac
+    $ifq set limit_ $qlen
+    set drpT [cmu-trace Drop "IFQ" $self]
+    $ifq drop-target $drpT
+    if { $namfp != "" } {
+	$drpT namattach $namfp
+    }
+    if {$qtype == "Queue/ClickQueue"} {
+	$ifq setclickclassifier [$self entry]
+	$ll ifq $ifq
+    }
+
+    #
+    # Mac Layer
+    #
+    $mac netif $netif
+    $mac up-target $ll
+    $mac down-target $netif
+    set god_ [God instance]
+    if {$mactype == "Mac/802_11"} {
+	$mac nodes [$god_ num_nodes]
+    }
+    #
+    # Network Interface
+    #
+    $netif channel $channel
+    $netif up-target $mac
+    $netif node $self		;# Bind node <---> interface
+    #
+    # Physical Channel
+    #
+    $channel addif $netif
+    
+    # ============================================================
+    
+    if { [Simulator set MacTrace_] == "ON" } {
+	#
+	# Trace RTS/CTS/ACK Packets
+	#
+	set rcvT [cmu-trace Recv "MAC" $self]
+	$mac log-target $rcvT
+	if { $namfp != "" } {
+	    $rcvT namattach $namfp
+	}
+	#
+	# Trace Sent Packets
+	#
+	set sndT [cmu-trace Send "MAC" $self]
+	$sndT target [$mac down-target]
+	$mac down-target $sndT
+	if { $namfp != "" } {
+	    $sndT namattach $namfp
+	}
+	#
+	# Trace Received Packets
+	#
+	set rcvT [cmu-trace Recv "MAC" $self]
+	$rcvT target [$mac up-target]
+	$mac up-target $rcvT
+	if { $namfp != "" } {
+	    $rcvT namattach $namfp
+	}
+	#
+	# Trace Dropped Packets
+	#
+	set drpT [cmu-trace Drop "MAC" $self]
+	$mac drop-target $drpT
+	if { $namfp != "" } {
+	    $drpT namattach $namfp
+	}
+    } else {
+	$mac log-target [$ns set nullAgent_]
+	$mac drop-target [$ns set nullAgent_]
+    }
+    
+    # ============================================================
+    
+    $self addif $netif
+}
+
+Node/MobileNode/ClickNode instproc setpromiscuous { whichif ispromisc } {
+    $self instvar ll_
+    set thell $ll_($whichif)
+    $thell setpromiscuous $ispromisc
+}
+
+Node/MobileNode/ClickNode instproc dump-namconfig {} {
+# Do nothing
+}
\ No newline at end of file
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/tcl/lib/ns-lib.tcl ns-2.30/tcl/lib/ns-lib.tcl
--- ns-2.30-pure/tcl/lib/ns-lib.tcl	2006-09-24 22:11:03.000000000 -0700
+++ ns-2.30/tcl/lib/ns-lib.tcl	2006-12-30 17:23:06.000000000 -0800
@@ -208,6 +208,8 @@
 source ns-default.tcl
 source ../emulate/ns-emulate.tcl
 
+source ns-clicknode.tcl
+
 #pushback
 source ns-pushback.tcl
 
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/tcl/lib/ns-mobilenode.tcl ns-2.30/tcl/lib/ns-mobilenode.tcl
--- ns-2.30-pure/tcl/lib/ns-mobilenode.tcl	2006-09-24 22:11:03.000000000 -0700
+++ ns-2.30/tcl/lib/ns-mobilenode.tcl	2006-12-30 17:23:06.000000000 -0800
@@ -660,6 +660,7 @@
 
 
 
+
 Node/MobileNode instproc mobility-trace { ttype atype } {
 	set ns [Simulator instance]
         set tracefd [$ns get-ns-traceall]
@@ -788,6 +789,21 @@
 }
 # </zheng: add>
 
+# change interface channel
+Node/MobileNode instproc changechannel { whichif newchan } {
+	$self instvar netif_
+	[$netif_($whichif) getchannel] delif $netif_(0)
+	$netif_($whichif) channel $newchan
+	$newchan addif $netif_($whichif)
+}
+
+# aim a steerable antenna
+Node/MobileNode instproc aimantenna { whichif newdir } {
+	$self instvar netif_
+	set theant [$netif_($whichif) getantenna]
+	$theant set Dir_ $newdir
+}
+
 Class SRNodeNew -superclass Node/MobileNode
 
 SRNodeNew instproc init args {
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/tcl/lib/ns-packet.tcl ns-2.30/tcl/lib/ns-packet.tcl
--- ns-2.30-pure/tcl/lib/ns-packet.tcl	2006-09-24 22:11:03.000000000 -0700
+++ ns-2.30/tcl/lib/ns-packet.tcl	2006-12-30 17:23:06.000000000 -0800
@@ -115,6 +115,7 @@
 	Common 
 	Flags
 	IP 	# IP
+	Raw	# nsclick: raw packet type
 # Routing Protocols:
 	NV 	# NixVector classifier for stateless routing 
 	rtProtoDV 	# distance vector routing protocol
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/tcl/lib/ns-rtmodule.tcl ns-2.30/tcl/lib/ns-rtmodule.tcl
--- ns-2.30-pure/tcl/lib/ns-rtmodule.tcl	2006-09-24 22:11:03.000000000 -0700
+++ ns-2.30/tcl/lib/ns-rtmodule.tcl	2006-12-30 17:23:06.000000000 -0800
@@ -340,6 +340,43 @@
 RtModule/VC instproc add-route { dst target } {
 }
 
+
+#
+# Click routing module. Intended to subvert the normal routing process
+# and defer to Click.
+#
+RtModule/Click instproc init {} {
+        $self next
+}
+
+RtModule/Click instproc register { node } {
+        $self next $node
+        $self make-classifier
+}
+
+RtModule/Click instproc make-classifier {} {
+        $self instvar classifier_
+        set classifier_ [new Classifier/Ext/Click]
+        [$self node] install-entry $self $classifier_
+        $classifier_ setnodename [format "node%d" [[$self node] set id_]]
+        $classifier_ setnodeaddr [[$self node] set address_]
+        [$self node] set dmux_ [new Classifier/Port]
+
+        # Always stick the kernel tap interface into slot 0
+        $classifier_ install 0 [[$self node] set dmux_]
+}
+
+RtModule/Click instproc attach { agent port } {
+        # Send target
+        $agent target [[$self node] entry]
+        # Recv target
+        [[$self node] demux] install $port $agent
+}
+
+RtModule/Click instproc detach { agent nullagent } {
+        # Empty method
+}
+
 Classifier/Virtual instproc find dst {
 	$self instvar node_
 	if {[$node_ id] == $dst} {
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/tcl/rtglib/route-proto.tcl ns-2.30/tcl/rtglib/route-proto.tcl
--- ns-2.30-pure/tcl/rtglib/route-proto.tcl	2006-09-24 22:11:04.000000000 -0700
+++ ns-2.30/tcl/rtglib/route-proto.tcl	2006-12-30 17:23:06.000000000 -0800
@@ -739,6 +739,15 @@
 Agent/rtProto/Manual proc init-all args {
     # The user will do all routing.
 }
+#
+# Empty. Does NOTHING - even less than the Manual routing.
+#
+Class Agent/rtProto/Empty -superclass Agent/rtProto
+
+Agent/rtProto/Empty proc init-all args {
+    # Do nothing
+}
+
 
 ### Local Variables:
 ### mode: tcl
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/tools/random.cc ns-2.30/tools/random.cc
--- ns-2.30-pure/tools/random.cc	2006-09-24 22:11:00.000000000 -0700
+++ ns-2.30/tools/random.cc	2006-12-30 17:23:07.000000000 -0800
@@ -34,7 +34,7 @@
  * "@(#) $Header: /home/kohler/click-cvsroot-copy/release/one/etc/ns-2.30-patch,v 1.1 2006/12/31 01:54:25 eddietwo Exp $ (LBL)";
  */
 
-#ifndef WIN32
+#if !defined(WIN32) && !defined(ALLOW_RANDOM)
 
 #include <sys/time.h>
 #include "config.h"
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/tools/random.cc.orig ns-2.30/tools/random.cc.orig
--- ns-2.30-pure/tools/random.cc.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/tools/random.cc.orig	2006-09-24 22:11:00.000000000 -0700
@@ -0,0 +1,57 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1995 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * "@(#) $Header: /home/kohler/click-cvsroot-copy/release/one/etc/ns-2.30-patch,v 1.1 2006/12/31 01:54:25 eddietwo Exp $ (LBL)";
+ */
+
+#ifndef WIN32
+
+#include <sys/time.h>
+#include "config.h"
+#include "random.h"
+
+/* __THROW is new with gcc 2.8.x and egcs (in redhat 7.0beta) */
+#if defined(__GNUC__) && defined(__THROW)
+#define GCC_THROW __THROW
+#else
+#define GCC_THROW
+#endif
+
+RANDOM_RETURN_TYPE
+random() GCC_THROW
+{
+	printf("The C library random() has been called in ns.\nThis library function is not portable (it produces different streams\non different computers), please use ns's Random::uniform() instead.\n");
+	abort();
+}
+
+#endif /* !WIN32 */
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/trace/cmu-trace.cc ns-2.30/trace/cmu-trace.cc
--- ns-2.30-pure/trace/cmu-trace.cc	2006-09-24 22:10:59.000000000 -0700
+++ ns-2.30/trace/cmu-trace.cc	2006-12-30 17:23:07.000000000 -0800
@@ -53,6 +53,7 @@
 #include <aodv/aodv_packet.h> //AODV
 #include <cmu-trace.h>
 #include <mobilenode.h>
+#include <rawpacket.h>
 #include <simulator.h>
 //<zheng: add for 802.15.4>
 #include "wpan/p802_15_4pkt.h"
@@ -886,6 +887,20 @@
         }
 }
 
+// XXX Fix this
+void
+CMUTrace::format_raw(Packet *p, int offset)
+{
+        struct hdr_cmn *ch = HDR_CMN(p);
+        struct hdr_tcp *th = HDR_TCP(p);
+        
+        if( newtrace_ ) {
+                sprintf(pt_->buffer() + offset,"raw ");
+        } else {
+                sprintf(pt_->buffer() + offset,"raw ");
+        }
+}
+
 void
 CMUTrace::nam_format(Packet *p, int offset)
 {
@@ -1128,6 +1143,12 @@
 	hdr_cmn *ch = HDR_CMN(p);
 	int offset = 0;
 
+	int israw = (PT_RAW == ch->ptype());
+ 	hdr_raw* rhdr = hdr_raw::access(p);	
+	if (israw) {
+	    ch->ptype() = (packet_t) rhdr->ns_type;
+	}
+
 	/*
 	 * Log the MAC Header
 	 */
@@ -1136,6 +1157,8 @@
 	if (pt_->namchannel()) 
 		nam_format(p, offset);
 	offset = strlen(pt_->buffer());
+
+
 	switch(ch->ptype()) {
 	case PT_MAC:
 	case PT_SMAC:
@@ -1147,6 +1170,9 @@
 		format_ip(p, offset);
 		offset = strlen(pt_->buffer());
 		switch(ch->ptype()) {
+		case PT_RAW:
+			format_raw(p, offset);
+			break;
 		case PT_AODV:
 			format_aodv(p, offset);
 			break;
@@ -1189,6 +1215,9 @@
 			break;		//zheng: add
 		}
 	}
+	if (israw) {
+	    ch->ptype() = PT_RAW;
+	}
 }
 
 int
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/trace/cmu-trace.cc.orig ns-2.30/trace/cmu-trace.cc.orig
--- ns-2.30-pure/trace/cmu-trace.cc.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.30/trace/cmu-trace.cc.orig	2006-09-24 22:10:59.000000000 -0700
@@ -0,0 +1,1325 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Ported from CMU/Monarch's code, appropriate copyright applies.
+ * nov'98 -Padma.
+ *
+ * $Header: /home/kohler/click-cvsroot-copy/release/one/etc/ns-2.30-patch,v 1.1 2006/12/31 01:54:25 eddietwo Exp $
+ */
+
+#include <packet.h>
+#include <ip.h>
+#include <tcp.h>
+#include <sctp.h>
+#include <rtp.h>
+#include <arp.h>
+#include <dsr/hdr_sr.h>	// DSR
+#include <mac.h>
+#include <mac-802_11.h>
+#include <smac.h>
+#include <address.h>
+#include <tora/tora_packet.h> //TORA
+#include <imep/imep_spec.h>         // IMEP
+#include <aodv/aodv_packet.h> //AODV
+#include <cmu-trace.h>
+#include <mobilenode.h>
+#include <simulator.h>
+//<zheng: add for 802.15.4>
+#include "wpan/p802_15_4pkt.h"
+#include "wpan/p802_15_4trace.h"
+#include "wpan/p802_15_4nam.h"
+//</zheng: add for 802.15.4>
+
+#include "diffusion/diff_header.h" // DIFFUSION -- Chalermek
+
+
+//#define LOG_POSITION
+
+//extern char* pt_names[];
+
+static class CMUTraceClass : public TclClass {
+public:
+	CMUTraceClass() : TclClass("CMUTrace") { }
+	TclObject* create(int, const char*const* argv) {
+		return (new CMUTrace(argv[4], *argv[5]));
+	}
+} cmutrace_class;
+
+
+//<zheng: ns 2.27 removed the following part, but we need it to control the broadcast radius>
+double CMUTrace::bradius = 0.0;
+double CMUTrace::radius_scaling_factor_ = 0.0;
+double CMUTrace::duration_scaling_factor_ = 0.0;
+//</zheng>
+
+CMUTrace::CMUTrace(const char *s, char t) : Trace(t)
+{
+	bzero(tracename, sizeof(tracename));
+	strncpy(tracename, s, MAX_ID_LEN);
+
+        if(strcmp(tracename, "RTR") == 0) {
+                tracetype = TR_ROUTER;
+        }
+	else if(strcmp(tracename, "TRP") == 0) {
+                tracetype = TR_ROUTER;
+        }
+        else if(strcmp(tracename, "MAC") == 0) {
+                tracetype = TR_MAC;
+        }
+        else if(strcmp(tracename, "IFQ") == 0) {
+                tracetype = TR_IFQ;
+        }
+        else if(strcmp(tracename, "AGT") == 0) {
+                tracetype = TR_AGENT;
+        }
+        else {
+                fprintf(stderr, "CMU Trace Initialized with invalid type\n");
+                exit(1);
+        }
+// change wrt Mike's code
+//	assert(type_ == DROP || type_ == SEND || type_ == RECV);
+	assert(type_ == DROP || type_ == SEND || type_ == RECV
+               || ((type_ == EOT) && (tracetype == TR_MAC)));
+
+
+
+	newtrace_ = 0;
+	for (int i=0 ; i < MAX_NODE ; i++) 
+		nodeColor[i] = 3 ;
+        node_ = 0;
+}
+
+void
+CMUTrace::format_mac_common(Packet *p, const char *why, int offset)
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_ip *ih = HDR_IP(p);
+	struct hdr_mac802_11 *mh;
+	struct hdr_smac *sh;
+	char mactype[SMALL_LEN];
+
+	strcpy(mactype, Simulator::instance().macType());
+	if (strcmp (mactype, "Mac/SMAC") == 0)
+		sh = HDR_SMAC(p);
+	else
+		mh = HDR_MAC802_11(p);
+	
+	double x = 0.0, y = 0.0, z = 0.0;
+       
+	char op = (char) type_;
+	Node* thisnode = Node::get_node_by_address(src_);
+	double energy = -1;
+	if (thisnode) {
+	    if (thisnode->energy_model()) {
+		    energy = thisnode->energy_model()->energy();
+	    }
+	}
+
+	// hack the IP address to convert pkt format to hostid format
+	// for now until port ids are removed from IP address. -Padma.
+
+	int src = Address::instance().get_nodeaddr(ih->saddr());
+
+	if(tracetype == TR_ROUTER && type_ == SEND) {
+		if(src_ != src)
+			op = FWRD;
+	}
+
+	// use tagged format if appropriate
+	if (pt_->tagged()) {
+		int next_hop = -1 ;
+		Node* nextnode = Node::get_node_by_address(ch->next_hop_);
+        	if (nextnode) next_hop = nextnode->nodeid(); 
+
+		node_->getLoc(&x, &y, &z);
+
+		if (op == DROP) op = 'd';
+		if (op == SEND) op = '+';
+		if (op == FWRD) op = 'h';
+
+		sprintf(pt_->buffer() + offset,
+			"%c "TIME_FORMAT" -s %d -d %d -p %s -k %3s -i %d "
+			"-N:loc {%.2f %.2f %.2f} -N:en %f ",
+			
+			op,				// event type
+			Scheduler::instance().clock(),	// time
+			src_,				// this node
+			next_hop,			// next hop
+			packet_info.name(ch->ptype()),	// packet type
+			tracename,			// trace level
+			ch->uid(),			// event id
+			x, y, z,			// location
+			energy);				// energy
+
+		offset = strlen(pt_->buffer());
+		if (strcmp (mactype, "Mac/SMAC") == 0) {
+			format_smac(p, offset);
+		} else {
+			format_mac(p, offset);
+		}
+		return;
+	}
+
+
+	// Use new ns trace format to replace the old cmu trace format)
+	if (newtrace_) {
+	    
+	    node_->getLoc(&x, &y, &z);
+	    // consistence
+	    if ( op == DROP ) { op = 'd';}
+
+	        // basic trace infomation + basic exenstion
+
+	    sprintf(pt_->buffer() + offset,
+		   "%c -t %.9f -Hs %d -Hd %d -Ni %d -Nx %.2f -Ny %.2f -Nz %.2f -Ne %f -Nl %3s -Nw %s ",
+		    op,                       // event type
+		    Scheduler::instance().clock(),  // time
+		    src_,                           // this node
+                    ch->next_hop_,                  // next hop
+		    src_,                           // this node
+		    x,                              // x coordinate
+		    y,                              // y coordinate
+		    z,                              // z coordinate
+		    energy,                         // energy, -1 = not existing
+		    tracename,                      // trace level
+                    why);                            // reason
+
+	    // mac layer extension
+
+	    offset = strlen(pt_->buffer());
+	    if (strcmp(mactype, "Mac/SMAC") == 0) {
+		    format_smac(p, offset);
+	    } else {
+		    format_mac(p, offset);
+	    }
+	    return;
+	}
+
+
+#ifdef LOG_POSITION
+        x = 0.0, y = 0.0, z = 0.0;
+        node_->getLoc(&x, &y, &z);
+#endif
+
+	sprintf(pt_->buffer() + offset,
+#ifdef LOG_POSITION
+		"%c %.9f %d (%6.2f %6.2f) %3s %4s %d %s %d ",
+#else
+		"%c %.9f _%d_ %3s %4s %d %s %d",
+#endif
+		op,
+		Scheduler::instance().clock(),
+                src_,                           // this node
+#ifdef LOG_POSITION
+                x,
+                y,
+#endif
+		tracename,
+		why,
+		
+                ch->uid(),                      // identifier for this event
+		
+		((ch->ptype() == PT_MAC) ? (
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_RTS) ? "RTS"  :
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_CTS) ? "CTS"  :
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_ACK) ? "ACK"  :
+		  //<zheng: add for 802.15.4>
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Beacon) ? "BCN"  :		//Beacon
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_AssoReq) ? "CM1"  :	//CMD: Association request
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_AssoRsp) ? "CM2"  :	//CMD: Association response
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_DAssNtf) ? "CM3"  :	//CMD: Disassociation notification
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_DataReq) ? "CM4"  :	//CMD: Data request
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_PIDCNtf) ? "CM5"  :	//CMD: PAN ID conflict notification
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_OrphNtf) ? "CM6"  :	//CMD: Orphan notification
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_BconReq) ? "CM7"  :	//CMD: Beacon request
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_CoorRea) ? "CM8"  :	//CMD: Coordinator realignment
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_GTSReq) ? "CM9"  :	//CMD: GTS request
+		  //</zheng: add for 802.15.4>
+		  "UNKN") :
+		 (ch->ptype() == PT_SMAC) ? (
+		  (sh->type == RTS_PKT) ? "RTS" :
+		  (sh->type == CTS_PKT) ? "CTS" :
+		  (sh->type == ACK_PKT) ? "ACK" :
+		  (sh->type == SYNC_PKT) ? "SYNC" :
+		  "UNKN") : 
+		 packet_info.name(ch->ptype())),
+		ch->size());
+	
+	offset = strlen(pt_->buffer());
+
+	if (strncmp (mactype, "Mac/SMAC", 8) == 0) {
+		format_smac(p, offset);
+	} else {
+		format_mac(p, offset);
+        }
+	
+	offset = strlen(pt_->buffer());
+
+	if (thisnode) {
+		if (thisnode->energy_model()) {
+			// log detailed energy consumption
+			// total energy and breakdown in idle, sleep, transmit and receive modes
+			sprintf(pt_->buffer() + offset,
+				"[energy %f ei %.3f es %.3f et %.3f er %.3f] ",
+				thisnode->energy_model()->energy(),
+				thisnode->energy_model()->ei(),
+				thisnode->energy_model()->es(),				
+				thisnode->energy_model()->et(),
+				thisnode->energy_model()->er());				
+		}
+        }
+}
+
+void
+CMUTrace::format_mac(Packet *p, int offset)
+{
+	struct hdr_mac802_11 *mh = HDR_MAC802_11(p);
+	
+	if (pt_->tagged()) {
+		sprintf(pt_->buffer() + offset,
+			"-M:dur %x -M:s %x -M:d %x -M:t %x ",
+			mh->dh_duration,		// MAC: duration
+			
+			// change wrt Mike's code
+			//ETHER_ADDR(mh->dh_da),		// MAC: source
+			//ETHER_ADDR(mh->dh_sa),		// MAC: destination
+			ETHER_ADDR(mh->dh_ra),          // MAC: source
+                       ETHER_ADDR(mh->dh_ta),          // MAC: destination
+
+
+			GET_ETHER_TYPE(mh->dh_body));	// MAC: type
+	} else if (newtrace_) {
+		sprintf(pt_->buffer() + offset, 
+			"-Ma %x -Md %x -Ms %x -Mt %x ",
+			mh->dh_duration,
+			
+			// change wrt Mike's code
+			//ETHER_ADDR(mh->dh_da),
+			//ETHER_ADDR(mh->dh_sa),
+
+	   		ETHER_ADDR(mh->dh_ra),
+	                   ETHER_ADDR(mh->dh_ta),
+
+			GET_ETHER_TYPE(mh->dh_body));
+	} else {
+		sprintf(pt_->buffer() + offset,
+			" [%x %x %x %x] ",
+			//*((u_int16_t*) &mh->dh_fc),
+			mh->dh_duration,
+			
+			// change wrt Mike's code
+			//ETHER_ADDR(mh->dh_da),
+			//ETHER_ADDR(mh->dh_sa),
+			ETHER_ADDR(mh->dh_ra),
+                        ETHER_ADDR(mh->dh_ta),
+
+
+			GET_ETHER_TYPE(mh->dh_body));
+	}
+}
+
+void
+CMUTrace::format_smac(Packet *p, int offset)
+{
+	struct hdr_smac *sh = HDR_SMAC(p);
+	sprintf(pt_->buffer() + offset,
+		" [%.2f %d %d] ",
+		sh->duration,
+		sh->dstAddr,
+		sh->srcAddr);
+}
+	
+
+void
+CMUTrace::format_ip(Packet *p, int offset)
+{
+        struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_ip *ih = HDR_IP(p);
+	
+	// hack the IP address to convert pkt format to hostid format
+	// for now until port ids are removed from IP address. -Padma.
+	int src = Address::instance().get_nodeaddr(ih->saddr());
+	int dst = Address::instance().get_nodeaddr(ih->daddr());
+
+	if (pt_->tagged()) {
+		sprintf(pt_->buffer() + offset,
+			"-IP:s %d -IP:sp %d -IP:d %d -IP:dp %d -p %s -e %d "
+			"-c %d -i %d -IP:ttl %d ",
+			src,                           // packet src
+			ih->sport(),                   // src port
+			dst,                           // packet dest
+			ih->dport(),                   // dst port
+			packet_info.name(ch->ptype()), // packet type
+			ch->size(),                    // packet size
+			ih->flowid(),                  // flow id
+			ch->uid(),                     // unique id
+			ih->ttl_                       // ttl
+			);
+	} else if (newtrace_) {
+	    sprintf(pt_->buffer() + offset,
+		    "-Is %d.%d -Id %d.%d -It %s -Il %d -If %d -Ii %d -Iv %d ",
+		    src,                           // packet src
+		    ih->sport(),                   // src port
+		    dst,                           // packet dest
+		    ih->dport(),                   // dst port
+		    packet_info.name(ch->ptype()),  // packet type
+		    ch->size(),                     // packet size
+		    ih->flowid(),                   // flow id
+		    ch->uid(),                      // unique id
+		    ih->ttl_);                      // ttl
+	} else {
+	    sprintf(pt_->buffer() + offset, "------- [%d:%d %d:%d %d %d] ",
+		src, ih->sport(),
+		dst, ih->dport(),
+		ih->ttl_, (ch->next_hop_ < 0) ? 0 : ch->next_hop_);
+	}
+}
+
+// Note:  HDLC format (format_hdlc()) has moved to satellite tracing
+
+void
+CMUTrace::format_arp(Packet *p, int offset)
+{
+	struct hdr_arp *ah = HDR_ARP(p);
+
+	if (pt_->tagged()) {
+	    sprintf(pt_->buffer() + offset,
+		    "-arp:op %s -arp:ms %d -arp:s %d -arp:md %d -arp:d %d ",
+		    ah->arp_op == ARPOP_REQUEST ?  "REQUEST" : "REPLY",
+		    ah->arp_sha,
+		    ah->arp_spa,
+		    ah->arp_tha,
+		    ah->arp_tpa);
+	} else if (newtrace_) {
+	    sprintf(pt_->buffer() + offset,
+		    "-P arp -Po %s -Pms %d -Ps %d -Pmd %d -Pd %d ",
+		    ah->arp_op == ARPOP_REQUEST ?  "REQUEST" : "REPLY",
+		    ah->arp_sha,
+		    ah->arp_spa,
+		    ah->arp_tha,
+		    ah->arp_tpa);
+	} else {
+
+	    sprintf(pt_->buffer() + offset,
+		"------- [%s %d/%d %d/%d]",
+		ah->arp_op == ARPOP_REQUEST ?  "REQUEST" : "REPLY",
+		ah->arp_sha,
+		ah->arp_spa,
+		ah->arp_tha,
+		ah->arp_tpa);
+	}
+}
+
+void
+CMUTrace::format_dsr(Packet *p, int offset)
+{
+	hdr_sr *srh = hdr_sr::access(p);
+
+	if (pt_->tagged()) {
+	    sprintf(pt_->buffer() + offset,
+		    "-dsr:h %d -dsr:q %d -dsr:s %d -dsr:p %d -dsr:n %d "
+		    "-dsr:l %d -dsr:e {%d %d} -dsr:w %d -dsr:m %d -dsr:c %d "
+		    "-dsr:b {%d %d} ",
+		    srh->num_addrs(),
+		    srh->route_request(),
+		    srh->rtreq_seq(),
+		    srh->route_reply(),
+		    srh->rtreq_seq(),
+		    srh->route_reply_len(),
+		    srh->reply_addrs()[0].addr,
+		    srh->reply_addrs()[srh->route_reply_len()-1].addr,
+		    srh->route_error(),
+		    srh->num_route_errors(),
+		    srh->down_links()[srh->num_route_errors() - 1].tell_addr,
+		    srh->down_links()[srh->num_route_errors() - 1].from_addr,
+		    srh->down_links()[srh->num_route_errors() - 1].to_addr);
+	    return;
+	} else if (newtrace_) {
+	    sprintf(pt_->buffer() + offset, 
+		"-P dsr -Ph %d -Pq %d -Ps %d -Pp %d -Pn %d -Pl %d -Pe %d->%d -Pw %d -Pm %d -Pc %d -Pb %d->%d ",
+		    srh->num_addrs(),                   // how many nodes travered
+
+		srh->route_request(),
+		srh->rtreq_seq(),
+
+		srh->route_reply(),
+		srh->rtreq_seq(),
+		srh->route_reply_len(),
+		// the dest of the src route
+		srh->reply_addrs()[0].addr,
+		srh->reply_addrs()[srh->route_reply_len()-1].addr,
+
+		srh->route_error(),
+		srh->num_route_errors(),
+		srh->down_links()[srh->num_route_errors() - 1].tell_addr,
+		srh->down_links()[srh->num_route_errors() - 1].from_addr,
+		srh->down_links()[srh->num_route_errors() - 1].to_addr);
+
+	   return;
+	}
+	sprintf(pt_->buffer() + offset, 
+		"%d [%d %d] [%d %d %d %d->%d] [%d %d %d %d->%d]",
+		srh->num_addrs(),
+
+		srh->route_request(),
+		srh->rtreq_seq(),
+
+		srh->route_reply(),
+		srh->rtreq_seq(),
+		srh->route_reply_len(),
+		// the dest of the src route
+		srh->reply_addrs()[0].addr,
+		srh->reply_addrs()[srh->route_reply_len()-1].addr,
+
+		srh->route_error(),
+		srh->num_route_errors(),
+		srh->down_links()[srh->num_route_errors() - 1].tell_addr,
+		srh->down_links()[srh->num_route_errors() - 1].from_addr,
+		srh->down_links()[srh->num_route_errors() - 1].to_addr);
+}
+
+void
+CMUTrace::format_msg(Packet *, int)
+{
+}
+
+void
+CMUTrace::format_tcp(Packet *p, int offset)
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_tcp *th = HDR_TCP(p);
+	
+	if (pt_->tagged()) {
+	    sprintf(pt_->buffer() + offset,
+		    "-tcp:s %d -tcp:a %d -tcp:f %d -tcp:o %d ",
+		    th->seqno_,
+		    th->ackno_,
+		    ch->num_forwards(),
+		    ch->opt_num_forwards());
+	} else if (newtrace_) {
+	    sprintf(pt_->buffer() + offset,
+		"-Pn tcp -Ps %d -Pa %d -Pf %d -Po %d ",
+		th->seqno_,
+		th->ackno_,
+		ch->num_forwards(),
+		ch->opt_num_forwards());
+
+	} else {
+	    sprintf(pt_->buffer() + offset,
+		"[%d %d] %d %d",
+		th->seqno_,
+		th->ackno_,
+		ch->num_forwards(),
+		ch->opt_num_forwards());
+	}
+}
+
+/* Armando L. Caro Jr. <acaro@@cis,udel,edu> 6/5/2002
+ * (with help from Florina Almenrez <florina@@it,uc3m,es>)
+ */
+void
+CMUTrace::format_sctp(Packet* p,int offset)
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_sctp *sh = HDR_SCTP(p);
+	//struct hdr_ip *ih = HDR_IP(p);
+	char cChunkType;
+  
+	for(u_int i = 0; i < sh->NumChunks(); i++) {
+		switch(sh->SctpTrace()[i].eType) {
+		case SCTP_CHUNK_INIT:
+		case SCTP_CHUNK_INIT_ACK:
+		case SCTP_CHUNK_COOKIE_ECHO:
+		case SCTP_CHUNK_COOKIE_ACK:
+			cChunkType = 'I';       // connection initialization
+			break;
+      
+		case SCTP_CHUNK_DATA:
+			cChunkType = 'D';
+			break;
+      
+		case SCTP_CHUNK_SACK:
+			cChunkType = 'S';
+			break;
+      
+		case SCTP_CHUNK_FORWARD_TSN:
+			cChunkType = 'R';
+			break;
+
+		case SCTP_CHUNK_HB:
+			cChunkType = 'H';
+			break;
+			
+		case SCTP_CHUNK_HB_ACK:
+			cChunkType = 'B';
+			break;
+		default:
+			// quiet compiler
+			cChunkType = ' ';
+			assert (false);
+			break;
+		}
+    
+		if( newtrace_ ) {
+			sprintf(pt_->buffer() + offset,
+				"-Pn sctp -Pnc %d -Pct %c "
+				"-Ptsn %d -Psid %d -Pssn %d "
+				"-Pf %d -Po %d ",
+				sh->NumChunks(),
+				cChunkType,
+				sh->SctpTrace()[i].uiTsn,
+				sh->SctpTrace()[i].usStreamId,
+				sh->SctpTrace()[i].usStreamSeqNum,
+				ch->num_forwards(),
+				ch->opt_num_forwards());
+		}
+		else {
+			sprintf(pt_->buffer() + offset,
+				"[%d %c %d %d %d] %d %d",
+				sh->NumChunks(),
+				cChunkType,
+				sh->SctpTrace()[i].uiTsn,
+				sh->SctpTrace()[i].usStreamId,
+				sh->SctpTrace()[i].usStreamSeqNum,
+				ch->num_forwards(),
+				ch->opt_num_forwards());
+		}
+	}
+}
+
+void
+CMUTrace::format_rtp(Packet *p, int offset)
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_rtp *rh = HDR_RTP(p);
+	struct hdr_ip *ih = HDR_IP(p);
+        Node* thisnode = Node::get_node_by_address(src_);
+
+	//hacking, needs to change later, 
+        int dst = Address::instance().get_nodeaddr(ih->daddr());
+	
+	if (dst == src_){
+		// I just received a cbr data packet
+		if (thisnode->energy_model() && 
+		    thisnode->energy_model()->powersavingflag()) {
+			thisnode->energy_model()->set_node_state(EnergyModel::INROUTE);
+		}
+        }
+
+	if (pt_->tagged()) {
+		sprintf(pt_->buffer() + offset,
+			"-cbr:s %d -cbr:f %d -cbr:o %d ",
+			rh->seqno_,
+			ch->num_forwards(),
+			ch->opt_num_forwards());
+	} else if (newtrace_) {
+		sprintf(pt_->buffer() + offset,
+			"-Pn cbr -Pi %d -Pf %d -Po %d ",
+			rh->seqno_,
+			ch->num_forwards(),
+			ch->opt_num_forwards());
+	} else {
+		sprintf(pt_->buffer() + offset,
+			"[%d] %d %d",
+			rh->seqno_,
+			ch->num_forwards(),
+			ch->opt_num_forwards());
+	}
+}
+
+void
+CMUTrace::format_imep(Packet *p, int offset)
+{
+        struct hdr_imep *im = HDR_IMEP(p);
+
+#define U_INT16_T(x)    *((u_int16_t*) &(x))
+
+	if (pt_->tagged()) {
+	    sprintf(pt_->buffer() + offset,
+		    "-imep:a %c -imep:h %c -imep:o %c -imep:l %04x ",
+		    (im->imep_block_flags & BLOCK_FLAG_ACK) ? 'A' : '-',
+                    (im->imep_block_flags & BLOCK_FLAG_HELLO) ? 'H' : '-',
+                    (im->imep_block_flags & BLOCK_FLAG_OBJECT) ? 'O' : '-',
+                    U_INT16_T(im->imep_length));
+	} else if (newtrace_) {
+	    sprintf(pt_->buffer() + offset,
+                "-P imep -Pa %c -Ph %c -Po %c -Pl 0x%04x ] ",
+                (im->imep_block_flags & BLOCK_FLAG_ACK) ? 'A' : '-',
+                (im->imep_block_flags & BLOCK_FLAG_HELLO) ? 'H' : '-',
+                (im->imep_block_flags & BLOCK_FLAG_OBJECT) ? 'O' : '-',
+                U_INT16_T(im->imep_length));
+	} else {
+            sprintf(pt_->buffer() + offset,
+                "[%c %c %c 0x%04x] ",
+                (im->imep_block_flags & BLOCK_FLAG_ACK) ? 'A' : '-',
+                (im->imep_block_flags & BLOCK_FLAG_HELLO) ? 'H' : '-',
+                (im->imep_block_flags & BLOCK_FLAG_OBJECT) ? 'O' : '-',
+                U_INT16_T(im->imep_length));
+	}
+#undef U_INT16_T
+}
+
+
+void
+CMUTrace::format_tora(Packet *p, int offset)
+{
+        struct hdr_tora *th = HDR_TORA(p);
+        struct hdr_tora_qry *qh = HDR_TORA_QRY(p);
+        struct hdr_tora_upd *uh = HDR_TORA_UPD(p);
+        struct hdr_tora_clr *ch = HDR_TORA_CLR(p);
+
+        switch(th->th_type) {
+
+        case TORATYPE_QRY:
+
+		if (pt_->tagged()) {
+		    sprintf(pt_->buffer() + offset,
+			    "-tora:t %x -tora:d %d -tora:c QUERY",
+			    qh->tq_type, qh->tq_dst);
+		} else if (newtrace_) {
+		    sprintf(pt_->buffer() + offset,
+			"-P tora -Pt 0x%x -Pd %d -Pc QUERY ",
+                        qh->tq_type, qh->tq_dst);
+			
+                } else {
+
+                    sprintf(pt_->buffer() + offset, "[0x%x %d] (QUERY)",
+                        qh->tq_type, qh->tq_dst);
+		}
+                break;
+
+        case TORATYPE_UPD:
+
+		if (pt_->tagged()) {
+		    sprintf(pt_->buffer() + offset,
+			    "-tora:t %x -tora:d %d -tora:a %f -tora:o %d "
+			    "-tora:r %d -tora:e %d -tora:i %d -tora:c UPDATE",
+			    uh->tu_type,
+                            uh->tu_dst,
+                            uh->tu_tau,
+                            uh->tu_oid,
+                            uh->tu_r,
+                            uh->tu_delta,
+                            uh->tu_id);
+		} else if (newtrace_) {
+		    sprintf(pt_->buffer() + offset,
+                        "-P tora -Pt 0x%x -Pd %d (%f %d %d %d %d) -Pc UPDATE ",
+                        uh->tu_type,
+                        uh->tu_dst,
+                        uh->tu_tau,
+                        uh->tu_oid,
+                        uh->tu_r,
+                        uh->tu_delta,
+                        uh->tu_id);
+		} else {
+                    sprintf(pt_->buffer() + offset,
+                        "-Pt 0x%x -Pd %d -Pa %f -Po %d -Pr %d -Pe %d -Pi %d -Pc UPDATE ",
+                        uh->tu_type,
+                        uh->tu_dst,
+                        uh->tu_tau,
+                        uh->tu_oid,
+                        uh->tu_r,
+                        uh->tu_delta,
+                        uh->tu_id);
+		}
+                break;
+
+        case TORATYPE_CLR:
+		if (pt_->tagged()) {
+		    sprintf(pt_->buffer() + offset,
+			    "-tora:t %x -tora:d %d -tora:a %f -tora:o %d "
+			    "-tora:c CLEAR ",
+			    ch->tc_type,
+                            ch->tc_dst,
+                            ch->tc_tau,
+                            ch->tc_oid);
+		} else if (newtrace_) {
+		    sprintf(pt_->buffer() + offset, 
+			"-P tora -Pt 0x%x -Pd %d -Pa %f -Po %d -Pc CLEAR ",
+                        ch->tc_type,
+                        ch->tc_dst,
+                        ch->tc_tau,
+                        ch->tc_oid);
+		} else {
+                    sprintf(pt_->buffer() + offset, "[0x%x %d %f %d] (CLEAR)",
+                        ch->tc_type,
+                        ch->tc_dst,
+                        ch->tc_tau,
+                        ch->tc_oid);
+		}
+                break;
+        }
+}
+
+void
+CMUTrace::format_aodv(Packet *p, int offset)
+{
+        struct hdr_aodv *ah = HDR_AODV(p);
+        struct hdr_aodv_request *rq = HDR_AODV_REQUEST(p);
+        struct hdr_aodv_reply *rp = HDR_AODV_REPLY(p);
+
+
+        switch(ah->ah_type) {
+        case AODVTYPE_RREQ:
+
+		if (pt_->tagged()) {
+		    sprintf(pt_->buffer() + offset,
+			    "-aodv:t %x -aodv:h %d -aodv:b %d -aodv:d %d "
+			    "-aodv:ds %d -aodv:s %d -aodv:ss %d "
+			    "-aodv:c REQUEST ",
+			    rq->rq_type,
+                            rq->rq_hop_count,
+                            rq->rq_bcast_id,
+                            rq->rq_dst,
+                            rq->rq_dst_seqno,
+                            rq->rq_src,
+                            rq->rq_src_seqno);
+		} else if (newtrace_) {
+
+		    sprintf(pt_->buffer() + offset,
+			"-P aodv -Pt 0x%x -Ph %d -Pb %d -Pd %d -Pds %d -Ps %d -Pss %d -Pc REQUEST ",
+			rq->rq_type,
+                        rq->rq_hop_count,
+                        rq->rq_bcast_id,
+                        rq->rq_dst,
+                        rq->rq_dst_seqno,
+                        rq->rq_src,
+                        rq->rq_src_seqno);
+
+
+		} else {
+
+		    sprintf(pt_->buffer() + offset,
+			"[0x%x %d %d [%d %d] [%d %d]] (REQUEST)",
+			rq->rq_type,
+                        rq->rq_hop_count,
+                        rq->rq_bcast_id,
+                        rq->rq_dst,
+                        rq->rq_dst_seqno,
+                        rq->rq_src,
+                        rq->rq_src_seqno);
+		}
+                break;
+
+        case AODVTYPE_RREP:
+        case AODVTYPE_HELLO:
+	case AODVTYPE_RERR:
+		
+		if (pt_->tagged()) {
+		    sprintf(pt_->buffer() + offset,
+			    "-aodv:t %x -aodv:h %d -aodv:d %d -adov:ds %d "
+			    "-aodv:l %f -aodv:c %s ",
+			    rp->rp_type,
+			    rp->rp_hop_count,
+			    rp->rp_dst,
+			    rp->rp_dst_seqno,
+			    rp->rp_lifetime,
+			    rp->rp_type == AODVTYPE_RREP ? "REPLY" :
+			    (rp->rp_type == AODVTYPE_RERR ? "ERROR" :
+			     "HELLO"));
+		} else if (newtrace_) {
+			
+			sprintf(pt_->buffer() + offset,
+			    "-P aodv -Pt 0x%x -Ph %d -Pd %d -Pds %d -Pl %f -Pc %s ",
+				rp->rp_type,
+				rp->rp_hop_count,
+				rp->rp_dst,
+				rp->rp_dst_seqno,
+				rp->rp_lifetime,
+				rp->rp_type == AODVTYPE_RREP ? "REPLY" :
+				(rp->rp_type == AODVTYPE_RERR ? "ERROR" :
+				 "HELLO"));
+	        } else {
+			
+			sprintf(pt_->buffer() + offset,
+				"[0x%x %d [%d %d] %f] (%s)",
+				rp->rp_type,
+				rp->rp_hop_count,
+				rp->rp_dst,
+				rp->rp_dst_seqno,
+				rp->rp_lifetime,
+				rp->rp_type == AODVTYPE_RREP ? "REPLY" :
+				(rp->rp_type == AODVTYPE_RERR ? "ERROR" :
+				 "HELLO"));
+		}
+                break;
+		
+        default:
+#ifdef WIN32
+                fprintf(stderr,
+		        "CMUTrace::format_aodv: invalid AODV packet type\n");
+#else
+		fprintf(stderr,
+		        "%s: invalid AODV packet type\n", __FUNCTION__);
+#endif
+                abort();
+        }
+}
+
+void
+CMUTrace::nam_format(Packet *p, int offset)
+{
+	Node* srcnode = 0 ;
+	Node* dstnode = 0 ;
+	Node* nextnode = 0 ;
+        struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_ip *ih = HDR_IP(p);
+	char op = (char) type_;
+	char colors[32];
+	int next_hop = -1 ;
+
+// change wrt Mike's code
+	assert(type_ != EOT);
+
+
+
+	//<zheng: add for 802.15.4>
+
+	//Actually we only need to handle MAC layer for nam (but should display dropping for other layers)
+	//if (strcmp(tracename,"MAC") != 0)
+	//if ((op != 'D')&&(op != 'd'))
+	//	return;
+
+	struct hdr_mac802_11 *mh = HDR_MAC802_11(p);
+	char ptype[11];
+	strcpy(ptype,
+	((ch->ptype() == PT_MAC) ? (
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_RTS) ? "RTS"  :
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_CTS) ? "CTS"  :
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_ACK) ? "ACK"  :
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Beacon) ? "BCN"  :		//Beacon
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_AssoReq) ? "CM1"  :	//CMD: Association request
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_AssoRsp) ? "CM2"  :	//CMD: Association response
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_DAssNtf) ? "CM3"  :	//CMD: Disassociation notification
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_DataReq) ? "CM4"  :	//CMD: Data request
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_PIDCNtf) ? "CM5"  :	//CMD: PAN ID conflict notification
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_OrphNtf) ? "CM6"  :	//CMD: Orphan notification
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_BconReq) ? "CM7"  :	//CMD: Beacon request
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_CoorRea) ? "CM8"  :	//CMD: Coordinator realignment
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_GTSReq) ? "CM9"  :	//CMD: GTS request
+	  "UNKN"
+	  ) : packet_info.name(ch->ptype())));
+	//</zheng: add for 802.15.4>
+        int dst = Address::instance().get_nodeaddr(ih->daddr());
+
+	nextnode = Node::get_node_by_address(ch->next_hop_);
+        if (nextnode) next_hop = nextnode->nodeid(); 
+
+	srcnode = Node::get_node_by_address(src_);
+	dstnode = Node::get_node_by_address(ch->next_hop_);
+
+	double distance = 0;
+
+        if ((srcnode) && (dstnode)) {
+	   MobileNode* tmnode = (MobileNode*)srcnode;
+	   MobileNode* rmnode = (MobileNode*)dstnode;
+
+	   distance = tmnode->propdelay(rmnode) * 300000000 ;
+	}
+
+	double energy = -1;
+	double initenergy = -1;
+
+	//default value for changing node color with respect to energy depletion
+	double l1 = 0.5; 
+	double l2 = 0.2;
+	
+	if (srcnode) {
+	    if (srcnode->energy_model()) {
+		    energy = srcnode->energy_model()->energy();
+		    initenergy = srcnode->energy_model()->initialenergy();
+		    l1 = srcnode->energy_model()->level1();
+		    l2 = srcnode->energy_model()->level2();
+	    }
+	}
+
+        int energyLevel = 0 ;
+        double energyLeft = (double)(energy/initenergy) ;
+
+        if ((energyLeft <= 1 ) && (energyLeft >= l1 )) energyLevel = 3;	
+        if ((energyLeft >= l2 ) && (energyLeft < l1 )) energyLevel = 2;	
+        if ((energyLeft > 0 ) && (energyLeft < l2 )) energyLevel = 1;	
+
+	if (energyLevel == 0) 
+		strcpy(colors,"-c black -o red");
+        else if (energyLevel == 1) 
+		strcpy(colors,"-c red -o yellow");
+        else if (energyLevel == 2) 
+		strcpy(colors,"-c yellow -o green");
+        else if (energyLevel == 3) 
+		strcpy(colors,"-c green -o black");
+
+	// A simple hack for scadds demo (fernandez's visit) -- Chalermek
+	int pkt_color = 0;
+	if (ch->ptype()==PT_DIFF) {
+		hdr_cdiff *dfh= HDR_CDIFF(p);
+		if (dfh->mess_type != DATA) {
+			pkt_color = 1;
+		}
+	}
+
+	//<zheng: add for 802.15.4>
+	if (Nam802_15_4::Nam_Status)
+	{
+		ATTRIBUTELINK *attr;
+		int t_src,t_dst;
+		if (ch->ptype() == PT_MAC)
+		{
+			t_src = p802_15_4macSA(p);
+			t_dst = p802_15_4macDA(p);;
+		}
+		else
+		{
+			t_src = HDR_IP(p)->saddr();
+			t_dst = HDR_IP(p)->daddr();
+		}
+		attr = findAttrLink(HDR_CMN(p)->ptype(),t_src,t_dst);
+		if (attr == NULL)
+			attr = findAttrLink(HDR_CMN(p)->ptype());
+		if (attr != NULL)
+			HDR_LRWPAN(p)->attribute = attr->attribute;
+		else
+			HDR_LRWPAN(p)->attribute = 0;
+		if (HDR_LRWPAN(p)->attribute >= 32)
+			pkt_color = HDR_LRWPAN(p)->attribute;
+	}
+	//</zheng: add for 802.15.4>
+
+	// convert to nam format 
+	if (op == 's') op = 'h' ;
+	if (op == 'D') op = 'd' ;
+	if (op == 'h') {
+		sprintf(pt_->nbuffer(),
+			"+ -t %.9f -s %d -d %d -p %s -e %d -c 2 -a %d -i %d -k %3s ",
+			Scheduler::instance().clock(),
+			src_,                           // this node
+			next_hop,
+			ptype,			//<zheng: modify for 802.15.4>packet_info.name(ch->ptype()),
+			ch->size(),
+			pkt_color,   
+			ch->uid(),
+			tracename);
+
+		offset = strlen(pt_->nbuffer());
+		pt_->namdump();
+		sprintf(pt_->nbuffer() ,
+			"- -t %.9f -s %d -d %d -p %s -e %d -c 2 -a %d -i %d -k %3s",
+			Scheduler::instance().clock(),
+			src_,                           // this node
+			next_hop,
+			ptype,			//<zheng: modify for 802.15.4>packet_info.name(ch->ptype()),
+			ch->size(),
+			pkt_color,
+			ch->uid(),
+			tracename);
+		
+		offset = strlen(pt_->nbuffer());
+		pt_->namdump();
+	}
+
+        // if nodes are too far from each other
+	// nam won't dump SEND event 'cuz it's
+	// gonna be dropped later anyway
+	// this value 250 is pre-calculated by using 
+	// two-ray ground refelction model with fixed
+	// transmission power 3.652e-10
+//	if ((type_ == SEND)  && (distance > 250 )) return ;
+
+	if(tracetype == TR_ROUTER && type_ == RECV && dst != -1 ) return ;
+	if(type_ == RECV && dst == -1 )dst = src_ ; //broadcasting event
+
+        if (energy != -1) { //energy model being turned on
+	   if (src_ >= MAX_NODE) {
+		   fprintf (stderr, "node id must be < %d\n",
+			    MAX_NODE);
+	       exit(0);
+	   }
+	   if (nodeColor[src_] != energyLevel ) { //only dump it when node  
+	       sprintf(pt_->nbuffer() ,                    //color change
+	          "n -t %.9f -s %d -S COLOR %s",
+	           Scheduler::instance().clock(),
+	           src_,                           // this node
+	           colors);
+               offset = strlen(pt_->nbuffer());
+               pt_->namdump();
+	       nodeColor[src_] = energyLevel ;
+	    }   
+        }
+
+	sprintf(pt_->nbuffer() ,
+		"%c -t %.9f -s %d -d %d -p %s -e %d -c 2 -a %d -i %d -k %3s",
+		op,
+		Scheduler::instance().clock(),
+		src_,                           // this node
+		next_hop,
+		ptype,			//<zheng: modify for 802.15.4>packet_info.name(ch->ptype()),
+		ch->size(),
+		pkt_color,
+		ch->uid(),
+		tracename);
+
+//<zheng: ns 2.27 removed the following part, but we need it to control the broadcast radius>
+if (Nam802_15_4::Nam_Status)
+{
+	if ((strcmp(tracename, "AGT") != 0) || ((u_int32_t)(ih->daddr()) == IP_BROADCAST))		//<zheng: add: next_hop info not available at agent level>
+											//(doesn't really matter -- seems agent level has no effect on nam)
+	if (next_hop == -1 && op == 'h') {
+		// print extra fields for broadcast packets
+
+		// bradius is calculated assuming 2-ray ground reflectlon
+		// model using default settings of Phy/WirelessPhy and
+		// Antenna/OmniAntenna
+		if (bradius == 0.0) calculate_broadcast_parameters();
+
+		double radius = bradius*radius_scaling_factor_; 
+
+		// duration is calculated based on the radius and
+		// the speed of light (299792458 m/s)
+		double duration = (bradius/299792458.0)*duration_scaling_factor_;
+		//<zheng: add -- the duration in 802.15.4 could be very small and rounded to 0.0>
+		if (Nam802_15_4::Nam_Status)
+		if (duration < 0.000000001)
+			duration = 0.000000001;
+		//</zheng: add>
+		sprintf(pt_->nbuffer() + strlen(pt_->nbuffer()),
+			" -R %.2f -D %.2f",
+			radius,
+			duration);
+	}
+}
+//</zheng>
+
+	offset = strlen(pt_->nbuffer());
+	pt_->namdump();
+}
+
+void CMUTrace::format(Packet* p, const char *why)
+{
+	hdr_cmn *ch = HDR_CMN(p);
+	int offset = 0;
+
+	/*
+	 * Log the MAC Header
+	 */
+	format_mac_common(p, why, offset);
+
+	if (pt_->namchannel()) 
+		nam_format(p, offset);
+	offset = strlen(pt_->buffer());
+	switch(ch->ptype()) {
+	case PT_MAC:
+	case PT_SMAC:
+		break;
+	case PT_ARP:
+		format_arp(p, offset);
+		break;
+	default:
+		format_ip(p, offset);
+		offset = strlen(pt_->buffer());
+		switch(ch->ptype()) {
+		case PT_AODV:
+			format_aodv(p, offset);
+			break;
+		case PT_TORA:
+                        format_tora(p, offset);
+                        break;
+                case PT_IMEP:
+                        format_imep(p, offset);
+                        break;
+		case PT_DSR:
+			format_dsr(p, offset);
+			break;
+		case PT_MESSAGE:
+		case PT_UDP:
+			format_msg(p, offset);
+			break;
+		case PT_TCP:
+		case PT_ACK:
+			format_tcp(p, offset);
+			break;
+		case PT_SCTP:
+			/* Armando L. Caro Jr. <acaro@@cis,udel,edu> 6/5/2002
+			 */
+			format_sctp(p, offset);
+			break;
+		case PT_CBR:
+			format_rtp(p, offset);
+			break;
+	        case PT_DIFF:
+			break;
+		case PT_GAF:
+		case PT_PING:
+			break;
+		default:
+		/*<zheng: del -- there are many more new packet types added, like PT_EXP (poisson traffic belongs to this type)>
+			fprintf(stderr, "%s - invalid packet type (%s).\n",
+				__PRETTY_FUNCTION__, packet_info.name(ch->ptype()));
+			exit(1);
+		</zheng: del>*/
+			break;		//zheng: add
+		}
+	}
+}
+
+int
+CMUTrace::command(int argc, const char*const* argv)
+{
+	
+        if(argc == 3) {
+                if(strcmp(argv[1], "node") == 0) {
+                        node_ = (MobileNode*) TclObject::lookup(argv[2]);
+                        if(node_ == 0)
+                                return TCL_ERROR;
+                        return TCL_OK;
+                }
+		if (strcmp(argv[1], "newtrace") == 0) {
+			newtrace_ = atoi(argv[2]);
+		        return TCL_OK;
+		}
+        }
+	return Trace::command(argc, argv);
+}
+
+/*ARGSUSED*/
+void
+CMUTrace::recv(Packet *p, Handler *h)
+{
+	if (!node_energy()) {
+		Packet::free(p);
+		return;
+	}
+        assert(initialized());
+        /*
+         * Agent Trace "stamp" the packet with the optimal route on
+         * sending.
+         */
+        if (tracetype == TR_AGENT && type_ == SEND) {
+                God::instance()->stampPacket(p);
+        }
+#if 0
+        /*
+         * When the originator of a packet drops the packet, it may or may
+         * not have been stamped by GOD.  Stamp it before logging the
+         * information.
+         */
+        if(src_ == src && type_ == DROP) {
+                God::instance()->stampPacket(p);
+        }
+#endif
+	format(p, "---");
+	pt_->dump();
+	//namdump();
+	if(target_ == 0)
+		Packet::free(p);
+	else
+		send(p, h);
+}
+
+void
+CMUTrace::recv(Packet *p, const char* why)
+{
+        assert(initialized() && type_ == DROP);
+	if (!node_energy()) {
+		Packet::free(p);
+		return;
+	}
+#if 0
+        /*
+         * When the originator of a packet drops the packet, it may or may
+         * not have been stamped by GOD.  Stamp it before logging the
+         * information.
+         */
+        if(src_ == ih->saddr()) {
+                God::instance()->stampPacket(p);
+        }
+#endif
+	format(p, why);
+	pt_->dump();
+	//namdump();
+	Packet::free(p);
+}
+
+int CMUTrace::node_energy()
+{
+	Node* thisnode = Node::get_node_by_address(src_);
+	double energy = 1;
+	if (thisnode) {
+		if (thisnode->energy_model()) {
+			energy = thisnode->energy_model()->energy();
+		}
+	} 
+	if (energy > 0) return 1;
+	return 0;
+}
+
+//<zheng: ns 2.27 removed the following part, but we need it to control the broadcast radius>
+void CMUTrace::calculate_broadcast_parameters() {
+	// Calculate the maximum distance at which a packet can be received
+	// based on the two-ray reflection model using the current default
+	// values for Phy/WirelessPhy and Antenna/OmniAntenna.
+
+	double P_t, P_r, G_t, G_r, h, L;
+	Tcl& tcl = Tcl::instance();
+
+	tcl.evalc("Phy/WirelessPhy set Pt_");
+	P_t = atof(tcl.result());
+	tcl.evalc("Phy/WirelessPhy set RXThresh_");
+	P_r = atof(tcl.result());
+	tcl.evalc("Phy/WirelessPhy set L_");
+	L = atof(tcl.result());
+	tcl.evalc("Antenna/OmniAntenna set Gt_");
+	G_t = atof(tcl.result());
+	tcl.evalc("Antenna/OmniAntenna set Gr_");
+	G_r = atof(tcl.result());
+	tcl.evalc("Antenna/OmniAntenna set Z_");
+	h = atof(tcl.result());
+	bradius = pow(P_t*G_r*G_t*pow(h,4.0)/(P_r*L), 0.25);
+	//<zheng: add for 802.15.4>
+	//the above calculation is not accurate for short distance
+	double PI,freq,lambda,crossover_dist;
+	PI = 3.14159265359;
+	tcl.evalc("Phy/WirelessPhy set freq_");
+	freq = atof(tcl.result());
+	lambda = 3.0e8/freq;
+	crossover_dist = (4 * PI * h * h) / lambda;
+	if (bradius < crossover_dist)	//need re-calculation
+		bradius = pow(P_t * G_r * G_t * pow(lambda, 2.0)/(P_r * L), 0.5)/(4 * PI);
+	//</zheng: add for 802.15.4>
+
+	// Also get the scaling factors
+	tcl.evalc("CMUTrace set radius_scaling_factor_");
+	radius_scaling_factor_ = atof(tcl.result());
+	tcl.evalc("CMUTrace set duration_scaling_factor_");
+	duration_scaling_factor_ = atof(tcl.result());
+}
+//</zheng>
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.30-pure/trace/cmu-trace.h ns-2.30/trace/cmu-trace.h
--- ns-2.30-pure/trace/cmu-trace.h	2006-09-24 22:10:59.000000000 -0700
+++ ns-2.30/trace/cmu-trace.h	2006-12-30 17:23:07.000000000 -0800
@@ -133,6 +133,7 @@
 	void	format_tora(Packet *p, int offset);
         void    format_imep(Packet *p, int offset);
         void    format_aodv(Packet *p, int offset);
+	void    format_raw(Packet *p, int offset);
 };
 
 #endif /* __cmu_trace__ */
