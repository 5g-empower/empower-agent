diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/Makefile.in ns-2.34/Makefile.in
--- ns-2.34-pure/Makefile.in	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/Makefile.in	2010-02-28 09:31:39.000000000 -0800
@@ -59,7 +59,7 @@
 LDFLAGS	= @LDFLAGS@ 
 LDOUT	= -o $(BLANK)
 
-DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test
+DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test -DALLOW_RANDOM
 
 INCLUDES = \
 	-I. @V_INCLUDE_X11@ \
@@ -163,7 +163,7 @@
 
 OBJ_CC = \
 	tools/random.o tools/rng.o tools/ranvar.o common/misc.o common/timer-handler.o \
-	common/scheduler.o common/object.o common/packet.o \
+	common/scheduler.o common/object.o common/packet.o common/rawpacket.o \
 	common/ip.o routing/route.o common/connector.o common/ttl.o \
 	trace/trace.o trace/trace-ip.o \
 	classifier/classifier.o classifier/classifier-addr.o \
@@ -175,6 +175,7 @@
 	classifier/classifier-mac.o \
 	classifier/classifier-qs.o \
 	classifier/classifier-port.o src_rtg/classifier-sr.o \
+	classifier/classifier-ext.o classifier/classifier-click.o \
         src_rtg/sragent.o src_rtg/hdr_src.o adc/ump.o \
 	qs/qsagent.o qs/hdr_qs.o \
 	apps/app.o apps/telnet.o tcp/tcplib-telnet.o \
@@ -215,7 +216,7 @@
 	sctp/sctpDebug.o \
 	tools/integrator.o tools/queue-monitor.o \
 	tools/flowmon.o tools/loss-monitor.o \
-	queue/queue.o queue/drop-tail.o \
+	queue/queue.o queue/drop-tail.o queue/clickqueue.o \
 	adc/simple-intserv-sched.o queue/red.o \
 	queue/semantic-packetqueue.o queue/semantic-red.o \
 	tcp/ack-recons.o \
@@ -243,16 +244,17 @@
 	common/pkt-counter.o \
 	common/Decapsulator.o common/Encapsulator.o \
 	common/encap.o \
-	mac/channel.o mac/mac.o mac/ll.o mac/mac-802_11.o \
+	mac/channel.o mac/mac.o mac/ll.o mac/ll-ext.o mac/mac-802_11.o \
 	mac/mac-802_11Ext.o \
 	mac/mac-802_3.o mac/mac-tdma.o mac/smac.o \
 	mobile/mip.o mobile/mip-reg.o mobile/gridkeeper.o \
 	mobile/propagation.o mobile/tworayground.o \
 	mobile/nakagami.o \
-	mobile/antenna.o mobile/omni-antenna.o \
+	mobile/antenna.o mobile/omni-antenna.o mobile/uni-antenna.o \
+	mobile/pattern-antenna.o \
 	mobile/shadowing.o mobile/shadowing-vis.o mobile/dumb-agent.o \
 	common/bi-connector.o common/node.o \
-	common/mobilenode.o \
+	common/mobilenode.o common/clicknode.o \
 	mac/arp.o mobile/god.o mobile/dem.o \
 	mobile/topography.o mobile/modulation.o \
 	queue/priqueue.o queue/dsr-priqueue.o \
@@ -319,6 +321,7 @@
 	pgm/classifier-pgm.o pgm/pgm-agent.o pgm/pgm-sender.o \
 	pgm/pgm-receiver.o mcast/rcvbuf.o \
 	mcast/classifier-lms.o mcast/lms-agent.o mcast/lms-receiver.o \
+	routing/extrouter.o routing/extclickrouter.o \
 	mcast/lms-sender.o \
 	queue/delayer.o \
 	xcp/xcpq.o xcp/xcp.o xcp/xcp-end-sys.o \
@@ -512,6 +515,7 @@
 	tcl/lib/ns-srcrt.tcl \
 	tcl/mcast/ns-lms.tcl \
 	tcl/lib/ns-qsnode.tcl \
+	tcl/lib/ns-clicknode.tcl \
 	@V_NS_TCL_LIB_STL@
 
 $(GEN_DIR)ns_tcl.cc: $(NS_TCL_LIB)
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/Makefile.in.orig ns-2.34/Makefile.in.orig
--- ns-2.34-pure/Makefile.in.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/Makefile.in.orig	2009-06-14 10:35:44.000000000 -0700
@@ -0,0 +1,610 @@
+#  Copyright (c) 1994, 1995, 1996
+# 	The Regents of the University of California.  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that: (1) source code distributions
+#  retain the above copyright notice and this paragraph in its entirety, (2)
+#  distributions including binary code include the above copyright notice and
+#  this paragraph in its entirety in the documentation or other materials
+#  provided with the distribution, and (3) all advertising materials mentioning
+#  features or use of this software display the following acknowledgement:
+#  ``This product includes software developed by the University of California,
+#  Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+#  the University nor the names of its contributors may be used to endorse
+#  or promote products derived from this software without specific prior
+#  written permission.
+#  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+#  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+#
+# @(#) $Header: 2002/10/09 15:34:11
+
+#
+# Various configurable paths (remember to edit Makefile.in, not Makefile)
+#
+
+# Top level hierarchy
+prefix	= @prefix@
+# Pathname of directory to install the binary
+BINDEST	= @prefix@/bin
+# Pathname of directory to install the man page
+MANDEST	= @prefix@/man
+
+BLANK	= # make a blank space.  DO NOT add anything to this line
+
+# The following will be redefined under Windows (see WIN32 lable below)
+CC	= @CC@
+CPP	= @CXX@
+LINK	= $(CPP)
+LINK_SHLIB = @SHLIB_LD@
+MKDEP	= ./conf/mkdep
+TCLSH	= @V_TCLSH@
+TCL2C	= @V_TCL2CPP@
+AR	= ar rc $(BLANK)
+
+RANLIB	= @V_RANLIB@
+INSTALL	= @INSTALL@
+LN	= ln
+TEST	= test
+RM	= rm -f
+MV      = mv
+PERL	= @PERL@
+
+# for diffusion
+#DIFF_INCLUDES = "./diffusion3/main ./diffusion3/lib ./diffusion3/nr ./diffusion3/ns"
+
+CCOPT	= @V_CCOPT@ 
+STATIC	= @V_STATIC@
+#LDFLAGS	= $(STATIC)
+LDFLAGS	= @LDFLAGS@ 
+LDOUT	= -o $(BLANK)
+
+DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test
+
+INCLUDES = \
+	-I. @V_INCLUDE_X11@ \
+	-I. \
+	@V_INCLUDES@ \
+	-I./tcp -I./sctp -I./common -I./link -I./queue \
+	-I./adc -I./apps -I./mac -I./mobile -I./trace \
+	-I./routing -I./tools -I./classifier -I./mcast \
+	-I./diffusion3/lib/main -I./diffusion3/lib \
+	-I./diffusion3/lib/nr -I./diffusion3/ns \
+	-I./diffusion3/filter_core -I./asim/ -I./qs \
+	-I./diffserv -I./satellite \
+	-I./wpan
+
+
+LIB	= \
+	@V_LIBS@ \
+	@V_LIB_X11@ \
+	@V_LIB@ \
+	-lm @LIBS@
+#	-L@libdir@ \
+
+CFLAGS	+= $(CCOPT) $(DEFINE) 
+
+# Explicitly define compilation rules since SunOS 4's make doesn't like gcc.
+# Also, gcc does not remove the .o before forking 'as', which can be a
+# problem if you don't own the file but can write to the directory.
+.SUFFIXES: .cc	# $(.SUFFIXES)
+
+.cc.o:
+	@rm -f $@
+	$(CPP) -c $(CFLAGS) $(INCLUDES) -o $@ $*.cc
+
+.c.o:
+	@rm -f $@
+	$(CC) -c $(CFLAGS) $(INCLUDES) -o $@ $*.c
+
+
+GEN_DIR	= gen/
+LIB_DIR	= lib/
+NS	= ns
+NSLIB   = @NSLIB@
+NSX	= nsx
+NSE	= nse
+NSTK = nstk
+
+# To allow conf/makefile.win overwrite this macro
+# We will set these two macros to empty in conf/makefile.win since VC6.0
+# does not seem to support the STL in gcc 2.8 and up. 
+OBJ_STL = diffusion3/lib/nr/nr.o diffusion3/lib/dr.o \
+	diffusion3/filters/diffusion/one_phase_pull.o \
+	diffusion3/filters/diffusion/two_phase_pull.o \
+	diffusion3/lib/diffapp.o \
+	diffusion3/ns/diffagent.o diffusion3/ns/diffrtg.o \
+	diffusion3/ns/difftimer.o \
+	diffusion3/filter_core/filter_core.o \
+	diffusion3/filter_core/iolog.o \
+	diffusion3/filter_core/iostats.o \
+	diffusion3/lib/main/attrs.o \
+	diffusion3/lib/main/events.o \
+	diffusion3/lib/main/iodev.o \
+	diffusion3/lib/main/iohook.o \
+	diffusion3/lib/main/timers.o \
+	diffusion3/lib/main/message.o \
+	diffusion3/lib/main/tools.o \
+	diffusion3/apps/gear_examples/gear_common.o \
+	diffusion3/apps/gear_examples/gear_receiver.o \
+	diffusion3/apps/gear_examples/gear_sender.o \
+	diffusion3/apps/rmst_examples/rmst_sink.o \
+	diffusion3/apps/rmst_examples/rmst_source.o \
+	diffusion3/apps/ping/1pp_ping_sender.o \
+	diffusion3/apps/ping/1pp_ping_receiver.o \
+	diffusion3/apps/ping/2pp_ping_sender.o \
+	diffusion3/apps/ping/2pp_ping_receiver.o \
+	diffusion3/apps/ping/ping_common.o \
+	diffusion3/apps/ping/push_receiver.o \
+	diffusion3/apps/ping/push_sender.o \
+	diffusion3/filters/gear/gear_attr.o \
+	diffusion3/filters/gear/gear.o \
+	diffusion3/filters/gear/gear_tools.o \
+	diffusion3/filters/misc/log.o \
+	diffusion3/filters/misc/srcrt.o \
+	diffusion3/filters/misc/tag.o \
+	diffusion3/filters/rmst/rmst.o \
+	diffusion3/filters/rmst/rmst_filter.o \
+	delaybox/delaybox.o \
+	packmime/packmime_HTTP.o packmime/packmime_HTTP_rng.o \
+	packmime/packmime_OL.o packmime/packmime_OL_ranvar.o\
+	packmime/packmime_ranvar.o \
+	tmix/tmix.o tmix/tmix_delaybox.o
+
+NS_TCL_LIB_STL = tcl/lib/ns-diffusion.tcl \
+	tcl/delaybox/delaybox.tcl \
+	tcl/packmime/packmime.tcl \
+	tcl/tmix/tmix.tcl \
+	tcl/tmix/tmix_delaybox.tcl
+
+
+# WIN32: uncomment the following line to include specific make for VC++
+# !include <conf/makefile.win>
+
+OBJ_CC = \
+	tools/random.o tools/rng.o tools/ranvar.o common/misc.o common/timer-handler.o \
+	common/scheduler.o common/object.o common/packet.o \
+	common/ip.o routing/route.o common/connector.o common/ttl.o \
+	trace/trace.o trace/trace-ip.o \
+	classifier/classifier.o classifier/classifier-addr.o \
+	classifier/classifier-hash.o \
+	classifier/classifier-virtual.o \
+	classifier/classifier-mcast.o \
+	classifier/classifier-bst.o \
+	classifier/classifier-mpath.o mcast/replicator.o \
+	classifier/classifier-mac.o \
+	classifier/classifier-qs.o \
+	classifier/classifier-port.o src_rtg/classifier-sr.o \
+        src_rtg/sragent.o src_rtg/hdr_src.o adc/ump.o \
+	qs/qsagent.o qs/hdr_qs.o \
+	apps/app.o apps/telnet.o tcp/tcplib-telnet.o \
+	tools/trafgen.o trace/traffictrace.o tools/pareto.o \
+	tools/expoo.o tools/cbr_traffic.o \
+	adc/tbf.o adc/resv.o adc/sa.o tcp/saack.o \
+	tools/measuremod.o adc/estimator.o adc/adc.o adc/ms-adc.o \
+	adc/timewindow-est.o adc/acto-adc.o \
+        adc/pointsample-est.o adc/salink.o adc/actp-adc.o \
+	adc/hb-adc.o adc/expavg-est.o\
+	adc/param-adc.o adc/null-estimator.o \
+	adc/adaptive-receiver.o apps/vatrcvr.o adc/consrcvr.o \
+	common/agent.o common/message.o apps/udp.o \
+	common/session-rtp.o apps/rtp.o tcp/rtcp.o \
+	common/ivs.o \
+	common/messpass.o common/tp.o common/tpm.o apps/worm.o \
+	tcp/tcp.o tcp/tcp-sink.o tcp/tcp-reno.o \
+	tcp/tcp-newreno.o \
+	tcp/tcp-vegas.o tcp/tcp-rbp.o tcp/tcp-full.o tcp/rq.o \
+	baytcp/tcp-full-bay.o baytcp/ftpc.o baytcp/ftps.o \
+	tcp/scoreboard.o tcp/scoreboard-rq.o tcp/tcp-sack1.o tcp/tcp-fack.o \
+	tcp/linux/tcp_naivereno.o\
+	tcp/linux/src/tcp_cong.o\
+	tcp/linux/src/tcp_highspeed.o tcp/linux/src/tcp_bic.o tcp/linux/src/tcp_htcp.o tcp/linux/src/tcp_scalable.o tcp/linux/src/tcp_cubic.o\
+	tcp/linux/src/tcp_westwood.o tcp/linux/src/tcp_vegas.o tcp/linux/src/tcp_hybla.o\
+	tcp/linux/src/tcp_illinois.o tcp/linux/src/tcp_yeah.o \
+	tcp/linux/src/tcp_veno.o tcp/linux/src/tcp_compound.o tcp/linux/src/tcp_lp.o\
+	tcp/scoreboard1.o tcp/tcp-linux.o tcp/linux/ns-linux-util.o tcp/linux/ns-linux-c.o tcp/linux/ns-linux-param.o\
+	tcp/tcp-asym.o tcp/tcp-asym-sink.o tcp/tcp-fs.o \
+	tcp/tcp-asym-fs.o \
+	tcp/tcp-int.o tcp/chost.o tcp/tcp-session.o \
+	tcp/nilist.o \
+	sctp/sctp.o apps/sctp_app1.o\
+	sctp/sctp-timestamp.o sctp/sctp-hbAfterRto.o \
+	sctp/sctp-multipleFastRtx.o sctp/sctp-mfrHbAfterRto.o \
+	sctp/sctp-mfrTimestamp.o \
+	sctp/sctp-cmt.o \
+	sctp/sctpDebug.o \
+	tools/integrator.o tools/queue-monitor.o \
+	tools/flowmon.o tools/loss-monitor.o \
+	queue/queue.o queue/drop-tail.o \
+	adc/simple-intserv-sched.o queue/red.o \
+	queue/semantic-packetqueue.o queue/semantic-red.o \
+	tcp/ack-recons.o \
+	queue/sfq.o queue/fq.o queue/drr.o queue/srr.o queue/cbq.o \
+	queue/jobs.o queue/marker.o queue/demarker.o \
+	link/hackloss.o queue/errmodel.o queue/fec.o\
+	link/delay.o tcp/snoop.o \
+	gaf/gaf.o \
+	link/dynalink.o routing/rtProtoDV.o common/net-interface.o \
+	mcast/ctrMcast.o mcast/mcast_ctrl.o mcast/srm.o \
+	common/sessionhelper.o queue/delaymodel.o \
+	mcast/srm-ssm.o mcast/srm-topo.o \
+	routing/alloc-address.o routing/address.o \
+	$(LIB_DIR)int.Vec.o $(LIB_DIR)int.RVec.o \
+	$(LIB_DIR)dmalloc_support.o \
+	webcache/http.o webcache/tcp-simple.o webcache/pagepool.o \
+	webcache/inval-agent.o webcache/tcpapp.o webcache/http-aux.o \
+	webcache/mcache.o webcache/webtraf.o \
+	webcache/webserver.o \
+	webcache/logweb.o \
+	empweb/empweb.o \
+	empweb/empftp.o \
+	realaudio/realaudio.o \
+	mac/lanRouter.o classifier/filter.o \
+	common/pkt-counter.o \
+	common/Decapsulator.o common/Encapsulator.o \
+	common/encap.o \
+	mac/channel.o mac/mac.o mac/ll.o mac/mac-802_11.o \
+	mac/mac-802_11Ext.o \
+	mac/mac-802_3.o mac/mac-tdma.o mac/smac.o \
+	mobile/mip.o mobile/mip-reg.o mobile/gridkeeper.o \
+	mobile/propagation.o mobile/tworayground.o \
+	mobile/nakagami.o \
+	mobile/antenna.o mobile/omni-antenna.o \
+	mobile/shadowing.o mobile/shadowing-vis.o mobile/dumb-agent.o \
+	common/bi-connector.o common/node.o \
+	common/mobilenode.o \
+	mac/arp.o mobile/god.o mobile/dem.o \
+	mobile/topography.o mobile/modulation.o \
+	queue/priqueue.o queue/dsr-priqueue.o \
+	mac/phy.o mac/wired-phy.o mac/wireless-phy.o \
+	mac/wireless-phyExt.o \
+	mac/mac-timers.o trace/cmu-trace.o mac/varp.o \
+	mac/mac-simple.o \
+	satellite/sat-hdlc.o \
+	dsdv/dsdv.o dsdv/rtable.o queue/rtqueue.o \
+	routing/rttable.o \
+	imep/imep.o imep/dest_queue.o imep/imep_api.o \
+	imep/imep_rt.o imep/rxmit_queue.o imep/imep_timers.o \
+	imep/imep_util.o imep/imep_io.o \
+	tora/tora.o tora/tora_api.o tora/tora_dest.o \
+	tora/tora_io.o tora/tora_logs.o tora/tora_neighbor.o \
+	dsr/dsragent.o dsr/hdr_sr.o dsr/mobicache.o dsr/path.o \
+	dsr/requesttable.o dsr/routecache.o dsr/add_sr.o \
+	dsr/dsr_proto.o dsr/flowstruct.o dsr/linkcache.o \
+	dsr/simplecache.o dsr/sr_forwarder.o \
+	aodv/aodv_logs.o aodv/aodv.o \
+	aodv/aodv_rtable.o aodv/aodv_rqueue.o \
+	aomdv/aomdv_logs.o aomdv/aomdv.o \
+	aomdv/aomdv_rtable.o aomdv/aomdv_rqueue.o \
+	common/ns-process.o \
+	satellite/satgeometry.o satellite/sathandoff.o \
+	satellite/satlink.o satellite/satnode.o \
+	satellite/satposition.o satellite/satroute.o \
+	satellite/sattrace.o \
+	rap/raplist.o rap/rap.o rap/media-app.o rap/utilities.o \
+	common/fsm.o tcp/tcp-abs.o \
+	diffusion/diffusion.o diffusion/diff_rate.o diffusion/diff_prob.o \
+	diffusion/diff_sink.o diffusion/flooding.o diffusion/omni_mcast.o \
+	diffusion/hash_table.o diffusion/routing_table.o diffusion/iflist.o \
+	tcp/tfrc.o tcp/tfrc-sink.o mobile/energy-model.o apps/ping.o tcp/tcp-rfc793edu.o \
+	queue/rio.o queue/semantic-rio.o tcp/tcp-sack-rh.o tcp/scoreboard-rh.o \
+	plm/loss-monitor-plm.o plm/cbr-traffic-PP.o \
+	linkstate/hdr-ls.o \
+	mpls/classifier-addr-mpls.o mpls/ldp.o mpls/mpls-module.o \
+	routing/rtmodule.o classifier/classifier-hier.o \
+	routing/addr-params.o \
+         nix/hdr_nv.o nix/classifier-nix.o \
+         nix/nixnode.o \
+         routealgo/rnode.o \
+         routealgo/bfs.o \
+         routealgo/rbitmap.o \
+         routealgo/rlookup.o \
+         routealgo/routealgo.o \
+         nix/nixvec.o \
+	nix/nixroute.o \
+	diffserv/dsred.o diffserv/dsredq.o \
+	diffserv/dsEdge.o diffserv/dsCore.o \
+	diffserv/dsPolicy.o diffserv/ew.o diffserv/dewp.o \
+	queue/red-pd.o queue/pi.o queue/vq.o queue/rem.o \
+	queue/gk.o \
+	pushback/rate-limit.o pushback/rate-limit-strategy.o \
+	pushback/ident-tree.o pushback/agg-spec.o \
+	pushback/logging-data-struct.o \
+	pushback/rate-estimator.o \
+	pushback/pushback-queue.o pushback/pushback.o \
+	common/parentnode.o trace/basetrace.o \
+	common/simulator.o asim/asim.o \
+	common/scheduler-map.o common/splay-scheduler.o \
+	linkstate/ls.o linkstate/rtProtoLS.o \
+	pgm/classifier-pgm.o pgm/pgm-agent.o pgm/pgm-sender.o \
+	pgm/pgm-receiver.o mcast/rcvbuf.o \
+	mcast/classifier-lms.o mcast/lms-agent.o mcast/lms-receiver.o \
+	mcast/lms-sender.o \
+	queue/delayer.o \
+	xcp/xcpq.o xcp/xcp.o xcp/xcp-end-sys.o \
+	wpan/p802_15_4csmaca.o wpan/p802_15_4fail.o \
+	wpan/p802_15_4hlist.o wpan/p802_15_4mac.o \
+	wpan/p802_15_4nam.o wpan/p802_15_4phy.o \
+	wpan/p802_15_4sscs.o wpan/p802_15_4timer.o \
+	wpan/p802_15_4trace.o wpan/p802_15_4transac.o \
+	apps/pbc.o \
+	@V_STLOBJ@
+
+
+# don't allow comments to follow continuation lines
+
+#  mac-csma.o mac-multihop.o\
+#	sensor-nets/landmark.o mac-simple-wireless.o \
+#	sensor-nets/tags.o sensor-nets/sensor-query.o \
+#	sensor-nets/flood-agent.o \
+
+# what was here before is now in emulate/
+OBJ_C =
+
+OBJ_COMPAT = $(OBJ_GETOPT) common/win32.o
+#XXX compat/win32x.o compat/tkConsole.o
+
+OBJ_EMULATE_CC = \
+	emulate/net-ip.o \
+	emulate/net.o \
+	emulate/tap.o \
+	emulate/ether.o \
+	emulate/internet.o \
+	emulate/ping_responder.o \
+	emulate/arp.o \
+	emulate/icmp.o \
+	emulate/net-pcap.o \
+	emulate/nat.o  \
+	emulate/iptap.o \
+	emulate/tcptap.o
+
+OBJ_EMULATE_C = \
+	emulate/inet.o
+
+OBJ_GEN = $(GEN_DIR)version.o $(GEN_DIR)ns_tcl.o $(GEN_DIR)ptypes.o
+
+SRC =	$(OBJ_C:.o=.c) $(OBJ_CC:.o=.cc) \
+	$(OBJ_EMULATE_C:.o=.c) $(OBJ_EMULATE_CC:.o=.cc) \
+	common/tclAppInit.cc common/tkAppInit.cc 
+
+OBJ =	$(OBJ_C) $(OBJ_CC) $(OBJ_GEN) $(OBJ_COMPAT)
+
+CLEANFILES = ns nse nsx ns.dyn $(OBJ) $(OBJ_EMULATE_CC) \
+	$(OBJ_EMULATE_C) common/tclAppInit.o \
+	common/tkAppInit.o nstk \
+	$(GEN_DIR)* $(NS).core core core.$(NS) core.$(NSX) core.$(NSE) \
+	common/ptypes2tcl common/ptypes2tcl.o 
+
+SUBDIRS=\
+	indep-utils/cmu-scen-gen/setdest \
+	indep-utils/webtrace-conv/dec \
+	indep-utils/webtrace-conv/epa \
+	indep-utils/webtrace-conv/nlanr \
+	indep-utils/webtrace-conv/ucb
+
+BUILD_NSE = @build_nse@
+
+all: $(NS) $(BUILD_NSE) $(NSTK) all-recursive Makefile
+
+
+all-recursive:
+	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) all; ) done
+
+
+
+
+ifeq ($(NSLIB),libns.dll)
+
+# This is for cygwin
+
+NS_CPPFLAGS = -DNSLIBNAME=\"$(NSLIB)\" 
+NS_LIBS =  @DL_LIBS@
+
+$(NSLIB): $(OBJ) common/tclAppInit.o 
+	$(LINK) -shared $(LDFLAGS) \
+		$(LDOUT)$@  \
+		-Wl,--export-all-symbols \
+		-Wl,--enable-auto-import \
+		-Wl,--out-implib=$@.a \
+		-Wl,--whole-archive $^ \
+		-Wl,--no-whole-archive @V_IMPORT_LIBS@ 
+
+$(NS): $(NSLIB) common/main-modular.cc 
+	$(LINK) $(NS_CPPFLAGS) $(LDFLAGS) $(LDOUT)$@ common/main-modular.cc $(NS_LIBS)
+
+else 
+
+# default for all systems but cygwin
+
+$(NS): $(OBJ) common/tclAppInit.o common/main-monolithic.o
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB)
+
+endif 
+
+
+
+Makefile: Makefile.in
+	@echo "Makefile.in is newer than Makefile."
+	@echo "You need to re-run configure."
+	false
+
+$(NSE): $(OBJ) common/tclAppInit.o common/main-monolithic.o $(OBJ_EMULATE_CC) $(OBJ_EMULATE_C)
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB) 
+
+$(NSTK): $(OBJ) common/tkAppInit.o 
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB)
+
+ns.dyn: $(OBJ) common/tclAppInit.o common/main-monolithic.o 
+	$(LINK) $(LDFLAGS) -o $@ $^ $(LIB)
+
+PURIFY	= purify -cache-dir=/tmp
+ns-pure: $(OBJ) common/tclAppInit.o common/main-monolithic.o 
+	$(PURIFY) $(LINK) $(LDFLAGS) -o $@ $^ $(LIB)
+
+NS_TCL_LIB = \
+	tcl/lib/ns-compat.tcl \
+	tcl/lib/ns-default.tcl \
+	tcl/lib/ns-errmodel.tcl \
+	tcl/lib/ns-lib.tcl \
+	tcl/lib/ns-link.tcl \
+	tcl/lib/ns-mobilenode.tcl \
+	tcl/lib/ns-sat.tcl \
+	tcl/lib/ns-cmutrace.tcl \
+	tcl/lib/ns-node.tcl \
+	tcl/lib/ns-rtmodule.tcl \
+	tcl/lib/ns-hiernode.tcl \
+	tcl/lib/ns-packet.tcl \
+	tcl/lib/ns-queue.tcl \
+	tcl/lib/ns-source.tcl \
+	tcl/lib/ns-nam.tcl \
+	tcl/lib/ns-trace.tcl \
+	tcl/lib/ns-agent.tcl \
+	tcl/lib/ns-random.tcl \
+	tcl/lib/ns-namsupp.tcl \
+	tcl/lib/ns-address.tcl \
+	tcl/lib/ns-intserv.tcl \
+	tcl/lib/ns-autoconf.tcl \
+	tcl/rtp/session-rtp.tcl \
+	tcl/lib/ns-mip.tcl \
+	tcl/rtglib/dynamics.tcl \
+	tcl/rtglib/route-proto.tcl \
+	tcl/rtglib/algo-route-proto.tcl \
+	tcl/rtglib/ns-rtProtoLS.tcl \
+        tcl/interface/ns-iface.tcl \
+	tcl/mcast/BST.tcl \
+        tcl/mcast/ns-mcast.tcl \
+        tcl/mcast/McastProto.tcl \
+        tcl/mcast/DM.tcl \
+	tcl/mcast/srm.tcl \
+	tcl/mcast/srm-adaptive.tcl \
+	tcl/mcast/srm-ssm.tcl \
+	tcl/mcast/timer.tcl \
+	tcl/mcast/McastMonitor.tcl \
+	tcl/mobility/dsdv.tcl \
+	tcl/mobility/dsr.tcl \
+        tcl/ctr-mcast/CtrMcast.tcl \
+        tcl/ctr-mcast/CtrMcastComp.tcl \
+        tcl/ctr-mcast/CtrRPComp.tcl \
+	tcl/rlm/rlm.tcl \
+	tcl/rlm/rlm-ns.tcl \
+	tcl/session/session.tcl \
+	tcl/lib/ns-route.tcl \
+	tcl/emulate/ns-emulate.tcl \
+	tcl/lan/vlan.tcl \
+	tcl/lan/abslan.tcl \
+	tcl/lan/ns-ll.tcl \
+	tcl/lan/ns-mac.tcl \
+	tcl/webcache/http-agent.tcl \
+	tcl/webcache/http-server.tcl \
+	tcl/webcache/http-cache.tcl \
+	tcl/webcache/http-mcache.tcl \
+	tcl/webcache/webtraf.tcl \
+	tcl/webcache/empweb.tcl \
+	tcl/webcache/empftp.tcl \
+	tcl/plm/plm.tcl \
+	tcl/plm/plm-ns.tcl \
+	tcl/plm/plm-topo.tcl \
+	tcl/mpls/ns-mpls-classifier.tcl \
+	tcl/mpls/ns-mpls-ldpagent.tcl \
+	tcl/mpls/ns-mpls-node.tcl \
+	tcl/mpls/ns-mpls-simulator.tcl \
+	tcl/lib/ns-pushback.tcl \
+	tcl/lib/ns-srcrt.tcl \
+	tcl/mcast/ns-lms.tcl \
+	tcl/lib/ns-qsnode.tcl \
+	@V_NS_TCL_LIB_STL@
+
+$(GEN_DIR)ns_tcl.cc: $(NS_TCL_LIB)
+	$(TCLSH) bin/tcl-expand.tcl tcl/lib/ns-lib.tcl @V_NS_TCL_LIB_STL@ | $(TCL2C) et_ns_lib > $@
+
+$(GEN_DIR)version.c: VERSION
+	$(RM) $@
+	$(TCLSH) bin/string2c.tcl version_string < VERSION > $@
+
+$(GEN_DIR)ptypes.cc: common/ptypes2tcl common/packet.h
+	./common/ptypes2tcl > $@
+
+common/ptypes2tcl: common/ptypes2tcl.o
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ common/ptypes2tcl.o
+
+common/ptypes2tcl.o: common/ptypes2tcl.cc common/packet.h
+
+dirs:
+	for d in $(DESTDIR)$(MANDEST)/man1; do \
+		if [ ! -d $$d ]; then \
+			mkdir -p $$d ;\
+		fi;\
+	done
+
+
+install: dirs force install-ns install-man
+
+install-ns: force
+	$(INSTALL) -m 755 ns $(DESTDIR)$(BINDEST)
+
+install-man: force
+	$(INSTALL) -m 644 ns.1 $(DESTDIR)$(MANDEST)/man1
+
+install-recursive: force
+	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) install; ) done
+
+clean:
+	$(RM) $(CLEANFILES)
+
+AUTOCONF_GEN = tcl/lib/ns-autoconf.tcl
+distclean: distclean-recursive
+	$(RM) $(CLEANFILES) Makefile config.cache config.log config.status \
+	    autoconf.h gnuc.h os-proto.h $(AUTOCONF_GEN); \
+	$(MV) .configure .configure- ;\
+	echo "Moved .configure to .configure-"
+
+distclean-recursive:
+	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) clean; $(RM) Makefile; ) done
+
+tags:	force
+	ctags -wtd *.cc *.h webcache/*.cc webcache/*.h dsdv/*.cc dsdv/*.h \
+	dsr/*.cc dsr/*.h webcache/*.cc webcache/*.h lib/*.cc lib/*.h \
+	../Tcl/*.cc ../Tcl/*.h 
+
+TAGS:	force
+	etags *.cc *.h webcache/*.cc webcache/*.h dsdv/*.cc dsdv/*.h \
+	dsr/*.cc dsr/*.h webcache/*.cc webcache/*.h lib/*.cc lib/*.h \
+	../Tcl/*.cc ../Tcl/*.h
+
+tcl/lib/TAGS:	force
+	( \
+		cd tcl/lib; \
+		$(TCLSH) ../../bin/tcl-expand.tcl ns-lib.tcl | grep '^### tcl-expand.tcl: begin' | awk '{print $$5}' >.tcl_files; \
+		etags --lang=none -r '/^[ \t]*proc[ \t]+\([^ \t]+\)/\1/' `cat .tcl_files`; \
+		etags --append --lang=none -r '/^\([A-Z][^ \t]+\)[ \t]+\(instproc\|proc\)[ \t]+\([^ \t]+\)[ \t]+/\1::\3/' `cat .tcl_files`; \
+	)
+
+depend: $(SRC)
+	$(MKDEP) $(CFLAGS) $(INCLUDES) -- $(SRC) 2>&1 > /dev/null
+
+srctar:
+	@cwd=`pwd` ; dir=`basename $$cwd` ; \
+	    name=ns-`cat VERSION | tr A-Z a-z` ; \
+	    tar=ns-src-`cat VERSION`.tar.gz ; \
+	    list="" ; \
+	    for i in `cat FILES` ; do list="$$list $$name/$$i" ; done; \
+	    echo \
+	    "(rm -f $$tar; cd .. ; ln -s $$dir $$name)" ; \
+	     (rm -f $$tar; cd .. ; ln -s $$dir $$name) ; \
+	    echo \
+	    "(cd .. ; tar cfhz $$tar [lots of files])" ; \
+	     (cd .. ; tar cfhz - $$list) > $$tar ; \
+	    echo \
+	    "rm ../$$name; chmod 444 $$tar" ;  \
+	     rm ../$$name; chmod 444 $$tar
+
+force:
+
+test:	force
+	./validate
+
+# Create makefile.vc for Win32 development by replacing:
+# "# !include ..." 	-> 	"!include ..."
+makefile.vc:	Makefile.in
+	$(PERL) bin/gen-vcmake.pl < Makefile.in > makefile.vc
+#	$(PERL) -pe 's/^# (\!include)/\!include/o' < Makefile.in > makefile.vc
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/apps/udp.cc ns-2.34/apps/udp.cc
--- ns-2.34-pure/apps/udp.cc	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/apps/udp.cc	2010-02-28 09:31:39.000000000 -0800
@@ -104,7 +104,8 @@
 		if (flags && (0 ==strcmp(flags, "NEW_BURST")))
 			rh->flags() |= RTP_M;
 		p->setdata(data);
-		target_->recv(p);
+		//target_->recv(p);
+		Agent::send(p,0);
 	}
 	n = nbytes % size_;
 	if (n > 0) {
@@ -119,7 +120,8 @@
 		if (flags && (0 == strcmp(flags, "NEW_BURST")))
 			rh->flags() |= RTP_M;
 		p->setdata(data);
-		target_->recv(p);
+		//target_->recv(p);
+		Agent::send(p,0);
 	}
 	idle();
 }
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/classifier/classifier-click.cc ns-2.34/classifier/classifier-click.cc
--- ns-2.34-pure/classifier/classifier-click.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/classifier/classifier-click.cc	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,730 @@
+/*
+ * classifier-click classifier file for nsclick
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+/*
+ *	Modified by Nicolas Letor to support wifi elements.
+ * 	Performance Analysis of Telecommunication Systems (PATS) research group,
+ * 	Interdisciplinary Institute for Broadband Technology (IBBT) & Universiteit Antwerpen.
+ */
+#include "config.h"
+#include <stdlib.h>
+#include <ctype.h>
+#include <sys/time.h>
+#include <unistd.h>
+//#include <stl.h>
+//#include <hash_map.h>
+#include <map>
+#include <string>
+#include <stdarg.h>
+
+#include "agent.h"
+#include "packet.h"
+#include "rawpacket.h"
+#include "ip.h"
+#include "extrouter.h"
+#include "classifier.h"
+#include "classifier-ext.h"
+#include "mobilenode.h"
+#include "clicknode.h"
+#include "address.h"
+#include <click/simclick.h>
+#include "scheduler.h"
+#include "classifier-click.h"
+#include "ll-ext.h"
+#include "clickqueue.h"
+
+#include "packet_anno.h"
+
+static class ClickClassifierClass : public TclClass {
+public:
+  ClickClassifierClass() : TclClass("Classifier/Ext/Click") {}
+  TclObject* create(int, const char*const*) {
+    return (new ClickClassifier());
+  }
+} class_click_classifier;
+
+
+void
+ClickEventHandler::handle(Event* event) {
+    // XXX dangerous downcast - should use RTTI
+    // XXX multithreading!
+    ClickEvent* cevent = (ClickEvent*) event;
+    cevent->simnode_->curtime = cevent->when_;
+    //fprintf(stderr,"Should be calling simclick_click_run: %lf\n",event->time_);
+    simclick_click_run(cevent->simnode_);
+    delete cevent;
+}
+
+map<MACAddr,int> ClickClassifier::global_mactonodemap_;
+map<MACAddr,int> ClickClassifier::global_mactonsmacmap_;
+map<u_int32_t,int> ClickClassifier::global_ipmap_;
+
+ClickClassifier::ClickClassifier() {
+  extrouter_ = this;
+  click_initialized_ = false;
+}
+
+int
+ClickClassifier::command(int argc, const char*const* argv)
+{
+  Tcl& tcl = Tcl::instance();
+  if (2 == argc) {
+    if (strcmp(argv[1], "getnodename") == 0) {
+      // getnodename
+      tcl.resultf(nodename_.c_str());
+      return TCL_OK;
+    }
+    if (strcmp(argv[1], "runclick") == 0) {
+      // runclick
+      if (click_initialized_) {
+	  simclick_node_t::curtime = GetSimTime();
+	  simclick_click_run(this);
+      }
+      return TCL_OK;
+    }
+  }
+  else if (3 == argc) {
+    if(strcmp(argv[1], "loadclick") == 0) {
+	simclick_node_t::curtime = GetSimTime();
+	if (simclick_click_create(this, argv[2]) >= 0) {
+	    click_initialized_ = true;
+	    simclick_click_run(this);
+	}
+
+      return TCL_OK;
+    }
+    if (strcmp(argv[1], "getip") == 0) {
+      // getip <ifname>
+      int theif = GetIFID(argv[2]);
+      //fprintf(stderr,"get ipaddr is %s\n",ifipaddrs_[theif].c_str());
+      tcl.resultf(ifipaddrs_[theif].c_str());
+      return TCL_OK;
+    }
+    if (strcmp(argv[1], "getmac") == 0) {
+      // getmac <ifname>
+      int theif = GetIFID(argv[2]);
+      //fprintf(stderr,"get macaddr is %s\n",ifmacaddrs_[theif].c_str());
+      tcl.resultf(ifmacaddrs_[theif].c_str());
+      return TCL_OK;
+    }
+    if (strcmp(argv[1], "setnodename") == 0) {
+      // setnodename <ifname>
+      nodename_ = argv[2];
+      return TCL_OK;
+    }
+    if (strcmp(argv[1], "setnodeaddr") == 0) {
+      // setnodeaddr <nodeaddress>
+      nodeaddr_ =  Address::instance().str2addr(argv[2]);
+      return TCL_OK;
+    }
+    //mvhaen -- meant to set the trace file
+    if (strcmp(argv[1], "tracetarget") == 0) {
+      logtarget_ = ( CMUTrace* ) TclObject::lookup(argv[2]);
+      if (logtarget_ == 0)
+          return TCL_ERROR;
+      return TCL_OK;
+    }
+  }
+  else if (4 == argc) {
+    if(strcmp(argv[1], "setip") == 0) {
+      // setip <ifname> <ipaddr>
+      int theif = GetIFID(argv[2]);
+      ifipaddrs_[theif] = string(argv[3]);
+      //fprintf(stderr,"ipaddr is %s\n",ifipaddrs_[theif].c_str());
+      // Also save the binary form of this IP address in a static
+      // (i.e. simulator global) hash map of IP addresses to ns-2
+      // addresses. This lets us track map IP to ns-2 address when
+      // we might need it.
+      global_ipmap_[inet_addr(argv[3])] = nodeaddr_;
+      return TCL_OK;
+    }
+    else if(strcmp(argv[1], "setmac") == 0) {
+      // setmac <ifname> <macaddr>
+      int theif = GetIFID(argv[2]);
+      ifmacaddrs_[theif] = string(argv[3]);
+
+      //fprintf(stderr,"macaddr is %s\n",ifmacaddrs_[theif].c_str());
+
+      // Also save the binary form of this MAC address in a static
+      // (i.e. simulator global) hash map of MAC addresses to ns-2
+      // addresses. This lets us set the destination address in the
+      // ns-2 packet header.
+      MACAddr thismacaddr = MACAddr(string(argv[3]));
+      global_mactonodemap_[thismacaddr] = nodeaddr_;
+      LL* mylink = (LL*) slot_[theif];
+      global_mactonsmacmap_[thismacaddr] = mylink->macDA();
+      return TCL_OK;
+    }
+    else if (strcmp(argv[1], "readhandler") == 0) {
+      char* readreturn = 0;
+      simclick_node_t::curtime = GetSimTime();
+      readreturn = simclick_click_read_handler(this,argv[2],argv[3],0,0);
+      //fprintf(stderr, "readhandler: %s\n",clickretc);
+      if (readreturn) {
+	tcl.resultf("%s", readreturn);
+	free(readreturn);
+	readreturn = 0;
+      }
+      else {
+	tcl.resultf("");
+      }
+      return TCL_OK;
+    }
+  } else if (argc == 5) {
+    if (strcmp(argv[1], "writehandler") == 0) {
+      int clickret;
+      simclick_node_t::curtime = GetSimTime();
+      clickret = simclick_click_write_handler(this, argv[2], argv[3], argv[4]);
+      //fprintf(stderr, "writehandler: %i\n",clickret);
+      tcl.resultf("%i", clickret);
+      return TCL_OK;
+    }
+  }
+
+  return ExtClassifier::command(argc, argv);
+}
+
+
+ClickClassifier::~ClickClassifier() {
+}
+
+int
+ClickClassifier::route(Packet* p) {
+  int result = 0;
+  if (click_initialized_) {
+    unsigned char* data = NULL;
+    int len = ((PacketData*)(p->userdata()))->size();
+    simclick_simpacketinfo simpinfo;
+    hdr_cmn* chdr = HDR_CMN(p);
+    int ifid = chdr->iface_;
+    hdr_ip* iphdr = hdr_ip::access(p);
+    simpinfo.id = chdr->uid();
+    simpinfo.fid = iphdr->flowid();
+    hdr_raw* rhdr = hdr_raw::access(p);
+    int nssubtype = rhdr->subtype;
+    int clicktype = GetClickPacketType(nssubtype);
+    simpinfo.simtype = rhdr->ns_type;
+    unsigned char* pdat = p->accessdata();
+    data = new unsigned char[len];
+	memcpy(data,pdat,len);
+	
+    /*
+     * XXX Destroy packet for now. This may change if we wind
+     * up having to track and reuse ns packets after they've gone through
+     * click.
+     */
+    Packet::free(p);
+    p = NULL;
+
+    simclick_node_t::curtime = GetSimTime();
+    //fprintf(stderr,"Sending packet up to click...\n");
+    simclick_click_send(this,ifid,clicktype,data,len,&simpinfo);
+    delete[] data;
+    data = 0;
+  }
+  else {
+    fprintf(stderr,"No click upcall set!\n");
+  }
+  return result;
+}
+
+string
+ClickClassifier::GetIPAddr(int ifid) {
+  return ifipaddrs_[ifid];
+}
+
+string
+ClickClassifier::GetMACAddr(int ifid) {
+  return ifmacaddrs_[ifid];
+}
+
+string
+ClickClassifier::GetNodeName() {
+  return nodename_;
+}
+
+int
+ClickClassifier::GetNodeAddr()
+{
+  return nodeaddr_;
+}
+
+int
+ClickClassifier::GetIFID(const char *ifname) const
+{
+    int r = -1;
+
+    /*
+     * Provide a mapping between a textual interface name
+     * and the id numbers used. This is mostly for the
+     * benefit of click scripts, i.e. you can still refer to
+     * an interface as, say, /dev/eth0.
+     */
+    if (strstr(ifname, "tap") || strstr(ifname, "tun")) {
+	/*
+	 * A tapX or tunX interface goes to and from the kernel -
+	 * always IFID_KERNELTAP
+	 */
+	r = ExtRouter::IFID_KERNELTAP;
+    } else if (const char *devname = strstr(ifname, "eth")) {
+	/*
+	 * Anything with an "eth" followed by a number is
+	 * a regular interface. Add the number to IFID_FIRSTIF
+	 * to get the handle.
+	 */
+	while (*devname && !isdigit((unsigned char) *devname))
+	    devname++;
+	if (*devname)
+	    r = atoi(devname) + ExtRouter::IFID_FIRSTIF;
+    } else if (const char *devname = strstr(ifname, "drop")) {
+	/*
+	 * Anything with an "drop" followed by a number is
+	 * a special interface on which we place packets that
+	 * get dropped due to MAC layer feedback. Add the number to
+	 * IFID_FIRSTIFDROP to get the handle.
+	 */
+	while (*devname && !isdigit((unsigned char) *devname))
+	    devname++;
+	if (*devname)
+	    r = atoi(devname) + ExtRouter::IFID_FIRSTIFDROP;
+    }
+
+    return r;
+}
+
+/*
+ * Click service methods
+ */
+extern "C" {
+
+static int simstrlcpy(char *buf, int len, const string &s) {
+    if (len) {
+	len--;
+	if ((unsigned) len > s.length())
+	    len = s.length();
+	s.copy(buf, len);
+	buf[len] = '\0';
+    }
+    return 0;
+}
+
+int simclick_sim_command(simclick_node_t *simnode, int cmd, ...)
+{
+    ClickClassifier *cc = static_cast<ClickClassifier *>(simnode);
+    Tcl &tcl = Tcl::instance();
+    va_list val;
+    va_start(val, cmd);
+    int r;
+
+    switch (cmd) {
+	
+      case SIMCLICK_VERSION:
+	r = 0;
+	break;
+
+      case SIMCLICK_SUPPORTS: {
+	  int othercmd = va_arg(val, int);
+	  r = othercmd >= 0 && othercmd <= SIMCLICK_CHANGE_CHANNEL;
+	  break;
+      }
+
+      case SIMCLICK_IFID_FROM_NAME: {
+	  const char *ifname = va_arg(val, const char *);
+	  r = cc->GetIFID(ifname);
+	  break;
+      }
+
+      case SIMCLICK_IPADDR_FROM_NAME: {
+	  const char *ifname = va_arg(val, const char *);
+	  char *buf = va_arg(val, char *);
+	  int len = va_arg(val, int);
+	  int ifid = cc->GetIFID(ifname);
+	  r = simstrlcpy(buf, len, cc->GetIPAddr(ifid));
+	  break;
+      }
+
+      case SIMCLICK_MACADDR_FROM_NAME: {
+	  const char *ifname = va_arg(val, const char *);
+	  char *buf = va_arg(val, char *);
+	  int len = va_arg(val, int);
+	  int ifid = cc->GetIFID(ifname);
+	  r = simstrlcpy(buf, len, cc->GetMACAddr(ifid));
+	  break;
+      }
+
+      case SIMCLICK_SCHEDULE: {
+	  const struct timeval *when = va_arg(val, const struct timeval *);
+	  double simtime = when->tv_sec + (when->tv_usec / 1.0e6);
+	  double simdelay = simtime - Scheduler::instance().clock();
+	  ClickEvent *ev = new ClickEvent;
+	  ev->simnode_ = simnode;
+	  ev->when_ = *when;
+	  Scheduler::instance().schedule(&cc->cevhandler_, ev, simdelay);
+	  r = 0;
+	  break;
+      }
+
+      case SIMCLICK_GET_NODE_NAME: {
+	  char *buf = va_arg(val, char *);
+	  int len = va_arg(val, int);
+	  r = simstrlcpy(buf, len, cc->GetNodeName());
+	  break;
+      }
+
+      case SIMCLICK_IF_READY: {
+	  int ifid = va_arg(val, int);
+	  r = cc->IFReady(ifid);
+	  break;
+      }
+
+      case SIMCLICK_TRACE: {
+	  const char *event = va_arg(val, const char *);
+	  cc->trace("%s", event);
+	  r = 1;
+	  break;
+      }
+
+      case SIMCLICK_GET_NODE_ID:
+	r = cc->GetNodeAddr();
+	break;
+
+      case SIMCLICK_GET_NEXT_PKT_ID:
+	r = cc->GetNextPktID();
+	break;
+
+      case SIMCLICK_CHANGE_CHANNEL: {
+	  int ifid = va_arg(val, int);
+	  int channelid = va_arg(val, int);
+	  char work[128];
+	  sprintf(work, "SwitchChannel %i %i %i", cc->GetNodeAddr(), ifid, channelid);
+	  tcl.eval(work);
+	  r = 0;
+	  break;
+      }
+
+      default:
+	r = -1;
+	break;
+	
+    }
+    
+    va_end(val);
+    return r;
+}
+
+int
+simclick_sim_send(simclick_node_t *simnode,
+		  int ifid,int type, const unsigned char* data,int len,
+		  simclick_simpacketinfo* pinfo) {
+
+  if (NULL == simnode) {
+    return -1;
+  }
+
+  /*
+   * Bail out if we get a bad ifid
+   */
+  if (ExtRouter::IFID_LASTIF < ifid) {
+    return -1;
+  }
+  /*
+   * XXX should probably use RTTI typesafe casts if they are now
+   * reliably implemented across the compilers/platforms we want
+   * to run on.
+   */
+  ClickClassifier* theclassifier = static_cast<ClickClassifier*>(simnode);
+
+  return theclassifier->send_to_if(ifid,type,data,len,pinfo);
+}
+
+}
+
+int
+ClickClassifier::send_to_if(int ifid,int type,const unsigned char* data,
+			 int len,simclick_simpacketinfo* pinfo) {
+  int result = 0;
+
+  /*
+   * Package raw data into an ns-2 format raw packet, then send
+   * it on down the line.
+   */
+
+  Packet* pkt = MakeRawPacket(type,ifid,data,len,pinfo);
+  //fprintf(stderr,"simclickid == %d\n",simclickid);
+  recv(pkt,0);
+
+  return result;
+}
+
+int
+ClickClassifier::IFReady(int ifid) {
+  NsObject* target = NULL;
+  int ready = 0;
+
+  // XXX assumes direct ifid->slot mapping
+  if (ExtRouter::IFID_KERNELTAP == ifid) {
+    return 1;
+  }
+
+  target = slot_[ifid];
+  if (target) {
+    LLExt* llext = (LLExt*) target;
+    ready = llext->ready();
+  }
+  else {
+    ready = 0;
+    fprintf(stderr,"ERROR: network interface does not exist\n");
+  }
+
+  return ready;
+}
+
+int
+ClickClassifier::GetNSSubtype(int type) {
+  switch (type) {
+  case SIMCLICK_PTYPE_ETHER:
+    return hdr_raw::ETHERNET;
+
+  case SIMCLICK_PTYPE_IP:
+    return hdr_raw::IP;
+
+  default:
+    return hdr_raw::NONE;
+  }
+
+  return hdr_raw::NONE;
+}
+
+int
+ClickClassifier::GetClickPacketType(int nssubtype) {
+  switch (nssubtype) {
+  case hdr_raw::ETHERNET:
+    return SIMCLICK_PTYPE_ETHER;
+
+  case hdr_raw::IP:
+    return SIMCLICK_PTYPE_IP;
+
+  case hdr_raw::MADWIFI:
+    return SIMCLICK_PTYPE_ETHER;
+  
+  default:
+    return SIMCLICK_PTYPE_UNKNOWN;
+  }
+
+  return SIMCLICK_PTYPE_UNKNOWN;
+}
+
+// XXX 
+// Normally I'd bitterly complain about code like this. However,
+// I don't really want to worry about annoying differences
+// between IP header files across different platforms, and I
+// want to get this code up and running ASAP. So... I'm defining
+// a few things here to handle the minimal packet cracking I
+// need to do to create raw packets. If more complicated
+// packet munging is called for, something better should be created.
+#define NS_ETHER_OFFSET_DADDR 0
+#define NS_ETHER_OFFSET_SADDR 6
+#define NS_ETHER_HEADER_SIZE 14
+#define NS_80211_OFFSET_DADDR 4
+#define NS_80211_OFFSET_SADDR 10
+
+void
+ClickClassifier::LinkLayerFailedCallback(Packet* p, void* arg) {
+  // Hit the callback and then free the packet
+  ((ClickClassifier*)arg)->LinkLayerFailed(p);
+  Packet::free(p);
+}
+
+void
+ClickClassifier::LinkLayerFailed(Packet* p) {
+  //fprintf(stderr,"XXX Lost a packet!!!\n");
+  if (click_initialized_) {
+    unsigned char* data = NULL;
+    int len = ((PacketData*)(p->userdata()))->size();
+    simclick_simpacketinfo simpinfo;
+    hdr_cmn* chdr = HDR_CMN(p);
+    int ifid = chdr->iface_ + IFID_LASTIF;
+    hdr_ip* iphdr = hdr_ip::access(p);
+    simpinfo.id = chdr->uid();
+    simpinfo.fid = iphdr->flowid();
+    hdr_raw* rhdr = hdr_raw::access(p);
+    int nssubtype = rhdr->subtype;
+    int clicktype = GetClickPacketType(nssubtype);
+    unsigned char* pdat = p->accessdata();
+    data = new unsigned char[len];
+    memcpy(data,pdat,len);
+    simclick_node_t::curtime = GetSimTime();
+    //fprintf(stderr,"Sending packet up to click...\n");
+    simclick_click_send(this,ifid,clicktype,data,len,&simpinfo);
+    delete[] data;
+    data = 0;
+  }
+  else {
+    fprintf(stderr,"No click upcall set!\n");
+  }
+}
+
+Packet*
+ClickClassifier::MakeRawPacket(int type,int ifid,const unsigned char* data,
+			       int len,simclick_simpacketinfo* pinfo){
+  Packet* pkt = Packet::alloc(len);
+  /*
+   * Shovel raw data into packet
+   */
+  hdr_raw* rhdr = hdr_raw::access(pkt);
+  // nletor -- check if it is a wireless packet and threat it accordingly
+  click_wifi_extra *ceh = (click_wifi_extra *) data;
+  if (ceh->magic == WIFI_EXTRA_MAGIC) {
+	rhdr->subtype = hdr_raw::MADWIFI;  
+  } else {
+  rhdr->subtype = GetNSSubtype(type);
+  }
+  unsigned char* pdat = pkt->accessdata();
+  memcpy(pdat,data,len);
+
+  /*
+   * Set some of the packet header stuff ns-2 wants
+   */
+  struct hdr_cmn* chdr = HDR_CMN(pkt);
+  chdr->iface() = ifid;
+  chdr->ptype() = PT_RAW;
+  chdr->size() = len;
+  if (pinfo->id >= 0) {
+    chdr->uid() = pinfo->id;
+  }
+  else {
+    chdr->uid() = Agent::getnextuid();
+  }
+  rhdr->ns_type = (-1 == pinfo->simtype) ? PT_RAW : pinfo->simtype;
+  chdr->xmit_failure_ = LinkLayerFailedCallback;
+  chdr->xmit_failure_data_ = (void*)this;
+
+  hdr_ip* iphdr = hdr_ip::access(pkt);
+  iphdr->flowid() = 0;
+  if (pinfo->fid >= 0) {
+    iphdr->flowid() = pinfo->fid;
+  }
+
+  /*
+   * A packet coming in from click on the kernel tap device is
+   * considered to be going up into the node, on any other device
+   * going down out of it.
+   */
+  if (ExtRouter::IFID_KERNELTAP == ifid) {
+    chdr->direction() = hdr_cmn::UP;
+  }
+  else {
+    chdr->direction() = hdr_cmn::DOWN;
+    // Going out to a network adapter, and we're already 
+    // ethernet encapsulated. The ns-2 interface code will
+    // tack on ethernet header overhead as well, so we subtract
+    // it out of our simulated size here to avoid actual packet
+    // size inflation
+    if (hdr_raw::ETHERNET == rhdr->subtype) {
+      chdr->size() -= NS_ETHER_HEADER_SIZE;
+    } else if (hdr_raw::MADWIFI == rhdr->subtype) {	
+	  // nsmadwifi
+		chdr->size() -= sizeof(click_wifi_extra);
+		chdr->size() -= sizeof(click_wifi);
+    }
+  }
+
+  // If we've got ethernet encapsulation, translate mac address
+  // to ns address. Otherwise we're SOL.
+  struct hdr_mac* mhdr = HDR_MAC(pkt);
+  if (hdr_raw::ETHERNET == rhdr->subtype) {
+    MACAddr dmac(data + NS_ETHER_OFFSET_DADDR);
+    MACAddr smac(data + NS_ETHER_OFFSET_SADDR);
+    if (dmac.is_broadcast()) {
+      mhdr->macDA_ = MAC_BROADCAST;
+    }
+    else {
+      mhdr->macDA_ = global_mactonsmacmap_[dmac];
+      //fprintf(stderr,"XXX using real MAC: %s -> %d\n",dmac.to_string().c_str(),mhdr->macDA_);
+    }
+    mhdr->macSA_ = global_mactonsmacmap_[smac];
+    chdr->next_hop_ = global_mactonodemap_[dmac];
+    chdr->prev_hop_ = global_mactonodemap_[smac];
+  } else if (hdr_raw::MADWIFI == rhdr->subtype) {
+  	//TODO
+	MACAddr dmac(data + NS_ETHER_OFFSET_DADDR + sizeof(click_wifi_extra) + 4); // destination address (STA,AP whatever)
+    MACAddr smac(data + NS_ETHER_OFFSET_SADDR + sizeof(click_wifi_extra) + 4); // source address (STA,AP whatever)
+	if (dmac.is_broadcast()) {
+      mhdr->macDA_ = MAC_BROADCAST;
+    } else {
+      mhdr->macDA_ = global_mactonsmacmap_[dmac];
+    }
+    mhdr->macSA_ = global_mactonsmacmap_[smac];
+    chdr->next_hop_ = global_mactonodemap_[dmac];
+    chdr->prev_hop_ = global_mactonodemap_[smac];
+	  
+  } else {
+    //fprintf(stderr,"XXX using broadcast mac XXX\n");
+    mhdr->macDA_ = MAC_BROADCAST;
+  }
+
+  // Got an IP packet? Must have come from click, and therefore
+  // the next hop is us.
+  if ((ExtRouter::IFID_KERNELTAP == ifid) && (hdr_raw::IP == rhdr->subtype)) {
+    chdr->next_hop() = nodeaddr_;
+  }
+
+  return pkt;
+}
+
+struct timeval
+ClickClassifier::GetSimTime() {
+  struct timeval curtime;
+  double ns2time = Scheduler::instance().clock();
+  double fracp,intp;
+  fracp = modf(ns2time,&intp);
+  curtime.tv_sec = (long) intp;
+  curtime.tv_usec = (long) (fracp * 1.0e6 + 0.5); 
+  return curtime;
+}
+
+void
+ClickClassifier::trace(char* fmt, ...)
+{
+	va_list ap;
+
+	if ( !logtarget_ ) {
+		printf( "ClickClassifier: need to configure tracetarget\n" );
+		return ;
+	}
+	va_start( ap, fmt );
+	vsprintf( logtarget_->pt_->buffer(), fmt, ap );
+	logtarget_->pt_->dump();
+	va_end( ap );
+}
+
+int
+ClickClassifier::GetNextPktID()
+{
+	return Agent::getnextuid();
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/classifier/classifier-click.h ns-2.34/classifier/classifier-click.h
--- ns-2.34-pure/classifier/classifier-click.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/classifier/classifier-click.h	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,169 @@
+/*
+ *
+ * This might not seem like a regular classifier, and it isn't.
+ * It essentially has a fixed interface ID which it sends along
+ * with its packet to the ClickNode it lives on, the idea being
+ * that the Click subsystem will be the thing which actually
+ * does the classifying, not the classifier.
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#ifndef ns_classifier_click_h
+#define ns_classifier_click_h
+
+#include "object.h"
+#include "cmu-trace.h"
+
+class Packet;
+
+
+class ClickEvent : public Event {
+ public:
+  simclick_node_t *simnode_;
+  // Store an extra copy of the call time in sec/usec format.
+  // This is to sidestep some roundoff errors which occured
+  // when going back and forth between sec/usec and doubles.
+  struct timeval when_;
+};
+
+class ClickEventHandler : public Handler {
+ public:
+  virtual void handle(Event* event);
+};
+
+class MACAddr {
+ public:
+  MACAddr() {
+    memset(macaddr_,0,6);
+  }
+  explicit MACAddr(const string straddr) {
+      unsigned crap[6];
+      sscanf(straddr.c_str(), "%02X:%02X:%02X:%02X:%02X:%02X", &crap[0],
+	     &crap[1], &crap[2], &crap[3], &crap[4], &crap[5]);
+      for (int i = 0; i < 6; i++)
+	  macaddr_[i] = crap[i];
+  }  
+  explicit MACAddr(const unsigned char* rawaddr) {
+    memcpy(macaddr_,rawaddr,6);
+  }
+  bool operator==(const MACAddr& rhs) const {
+    return(0 == memcmp(macaddr_,rhs.macaddr_,6));
+  }
+
+  bool is_broadcast() {
+    for (int i=0;i<6;i++) {
+      if (macaddr_[i] != 0xff) {
+	return false;
+      }
+    }
+    return true;
+  }
+
+  string to_string() {
+    char tmp[64];
+    sprintf(tmp, "%02X:%02X:%02X:%02X:%02X:%02X", macaddr_[0],
+	   macaddr_[1], macaddr_[2], macaddr_[3], macaddr_[4],
+	   macaddr_[5]);
+
+    return string(tmp);
+  }
+  unsigned char macaddr_[6];
+};
+
+namespace std {
+template<>
+struct less<MACAddr> {
+  bool operator()(const MACAddr& l, const MACAddr& r) const {
+    // Treat MAC as a big old integer...
+    uint32_t leftu = *((uint32_t*)(l.macaddr_));
+    uint32_t rightu = *((uint32_t*)(r.macaddr_));
+    uint16_t leftl = *((uint16_t*)(l.macaddr_+4));
+    uint16_t rightl = *((uint16_t*)(r.macaddr_+4));
+    
+    // Check the upper bytes first, if those are equal check lower
+    if (leftu < rightu) {
+      return true;
+    }
+    else if (leftu == rightu) {
+      return (leftl < rightl);
+    }
+    return false;
+  }
+};
+}
+
+class ClickClassifier : public ExtClassifier, public ExtRouter,
+    public simclick_node_t {
+ public:
+  ClickClassifier();
+  virtual ~ClickClassifier();
+  virtual int command(int argc, const char*const* argv);
+  
+  /*
+   * Stuff to handle click requests
+   */
+ public:
+  virtual int send_to_if(int ifid,int type,const unsigned char* data,
+			 int len,simclick_simpacketinfo* pinfo);
+  ClickEventHandler cevhandler_;
+
+  // ExtRouter method
+  virtual int route(Packet* p);
+
+  string GetIPAddr(int ifid);
+  string GetMACAddr(int ifid);
+  string GetNodeName();
+  int GetNodeAddr(); /// ToNSTrace
+  int IFReady(int ifid);
+  static void LinkLayerFailedCallback(Packet* p, void* arg);
+  void LinkLayerFailed(Packet* p);
+  void trace(char* fmt, ...); /// ToNSTrace
+  int GetNextPktID(); /// ToNSTrace
+  int GetIFID(const char *) const;
+ protected:
+  int GetNSSubtype(int clicktype);
+  int GetClickPacketType(int nssubtype);
+  struct timeval GetSimTime();
+  Packet* MakeRawPacket(int type,int ifid,const unsigned char* data,int len,
+			simclick_simpacketinfo* pinfo);
+  typedef map<int,string> STRmap;
+  map<int,string> ifipaddrs_;
+  map<int,string> ifmacaddrs_;
+  static map<MACAddr,int> global_mactonodemap_;
+  static map<MACAddr,int> global_mactonsmacmap_;
+  static map<u_int32_t,int> global_ipmap_;
+  string nodename_;
+  int nodeaddr_;
+  bool click_initialized_;
+
+
+
+  //mvhaen -- meant to allow a click router to add to an ns2 trace file.
+  Trace *logtarget_;
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/classifier/classifier-ext.cc ns-2.34/classifier/classifier-ext.cc
--- ns-2.34-pure/classifier/classifier-ext.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/classifier/classifier-ext.cc	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,160 @@
+/*
+ * classifier-ext.cc
+ * Base external router classifier
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#include <stdlib.h>
+#include "config.h"
+#include "packet.h"
+#include "ip.h"
+#include "extrouter.h"
+#include "classifier.h"
+#include "classifier-hash.h"
+#include "classifier-ext.h"
+
+
+static class ExtClassifierClass : public TclClass {
+public:
+  ExtClassifierClass() : TclClass("Classifier/Ext") {}
+  TclObject* create(int, const char*const*) {
+    return (new ExtClassifier());
+  }
+} class_ext_classifier;
+
+
+ExtClassifier::ExtClassifier() {
+  extrouter_ = NULL;
+}
+
+ExtClassifier::~ExtClassifier() {
+}
+
+int ExtClassifier::command(int argc, const char*const* argv) {
+  int result = TCL_OK;
+  //Tcl& tcl = Tcl::instance();
+
+  result = Classifier::command(argc,argv);
+  return result;
+}
+
+void ExtClassifier::recv(Packet* p, Handler* h) {
+  /*
+   * Use the interface and direction to decide what to do. If the
+   * packet is going down and came from an agent, it needs to
+   * go to the external router for processing. If coming up
+   * from the external router it needs to be sent to the appropriate
+   * local agent for processing. Otherwise, it just goes either down
+   * to the ns network interface or up to the external router.
+   */
+  struct hdr_cmn* hdr = HDR_CMN(p);
+  int extid = hdr->iface();
+  if (hdr_cmn::DOWN == hdr->direction()) {
+    if (ExtRouter::IFID_KERNELTAP == extid) {
+      /*
+       * Packet came from an agent - needs to go to the external router
+       */
+      //fprintf(stderr,"To external router\n");
+      if (NULL != extrouter_) {
+	extrouter_->route(p);
+      }
+      else {
+	fprintf(stderr,"No external router set!\n");
+      }
+    }
+    else {
+      /*
+       * Packet came from the external router - needs to go to the net
+       */
+      int cl = classify(p);
+      if ((cl >= 0) && (cl <= maxslot_)) {
+	NsObject* target = NULL;
+	target = slot_[cl];
+	if (NULL == target) {
+	  /*
+	   * "Drop" the packet
+	   */
+	  //puts("Dropping the packet");
+	  Packet::free(p);
+	}
+	else {
+	  //puts("Sending packet out!!!");
+	  target->recv(p,h);
+	}
+      }
+      else {
+	fprintf(stderr,"Invalid slot: %d maxslot is %d\n",cl,maxslot_);
+      }
+    }
+  }
+  else if (hdr_cmn::UP == hdr->direction()) {
+    if (ExtRouter::IFID_KERNELTAP == extid) {
+      /*
+       * Packet came from the external router - needs to go to an agent.
+       */
+      NsObject* target = NULL;
+      target = slot_[0];
+      if (NULL == target) {
+	/*
+	 * "Drop" the packet
+	 */
+	//fprintf(stderr,"Dropping the packet\n");
+	Packet::free(p);
+      }
+      else {
+	//fprintf(stderr,"Packet going to agent\n");
+	target->recv(p,h);
+      }
+
+      //fprintf(stderr,"Hey! Send packets to agents!\n");
+    }
+    else {
+      /*
+       * Packet came from the net - needs to go to the external router
+       */
+      if (NULL != extrouter_) {
+	extrouter_->route(p);
+      }
+    }
+  }
+  else {
+    fprintf(stderr,"No packet direction set...");
+  }
+}
+
+int
+ExtClassifier::classify(Packet* p) {
+  struct hdr_cmn* hdr = HDR_CMN(p);
+  int extid = hdr->iface();
+
+  /*
+   * Simple  mapping between extid and slot number.
+   * No real reason to make things more complicated right now.
+   */
+  int slot = extid;
+  return slot;
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/classifier/classifier-ext.h ns-2.34/classifier/classifier-ext.h
--- ns-2.34-pure/classifier/classifier-ext.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/classifier/classifier-ext.h	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,57 @@
+/*
+ *
+ * This classifier is intended for use with external routers bolted
+ * on to ns-2, e.g. Click. It uses a combination of the packet direction
+ * and interface ID to decide where to send stuff.
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#ifndef ns_classifier_ext_h
+#define ns_classifier_ext_h
+
+#include "object.h"
+
+class Packet;
+
+class ExtClassifier : public Classifier {
+ public:
+	ExtClassifier();
+	virtual ~ExtClassifier();
+	
+	virtual void recv(Packet* p, Handler* h);
+
+	void setExtRouter(ExtRouter* ext) {extrouter_ = ext;}
+	ExtRouter* getExtRouter() {return extrouter_;}
+
+	virtual int classify(Packet*);
+
+ protected:
+	virtual int command(int argc, const char*const* argv);
+	ExtRouter* extrouter_;
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/classifier/packet_anno.h ns-2.34/classifier/packet_anno.h
--- ns-2.34-pure/classifier/packet_anno.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/classifier/packet_anno.h	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,17 @@
+#ifndef PACKET_ANNO_H
+#define PACKET_ANNO_H
+
+/* Define macros for declaring packed structures. */
+#ifdef __GNUC__
+#define CLICK_PACKED_STRUCTURE(open, close) open close __attribute__((packed))
+#define CLICK_SIZE_PACKED_STRUCTURE(open, close) open close __attribute__((packed))
+#define CLICK_SIZE_PACKED_ATTRIBUTE __attribute__((packed))
+#else
+#define CLICK_PACKED_STRUCTURE(open, close) _Cannot_pack_structure__Use_GCC
+#define CLICK_SIZE_PACKED_STRUCTURE(open, close) open close
+#define CLICK_SIZE_PACKED_ATTRIBUTE
+#endif
+
+#include <clicknet/wifi.h>
+
+#endif /* PACKET_ANNO_H */
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/common/agent.cc ns-2.34/common/agent.cc
--- ns-2.34-pure/common/agent.cc	2009-06-14 10:35:45.000000000 -0700
+++ ns-2.34/common/agent.cc	2010-02-28 09:31:39.000000000 -0800
@@ -43,6 +43,7 @@
 #include "config.h"
 #include "agent.h"
 #include "ip.h"
+#include "tcp.h"
 #include "flags.h"
 #include "address.h"
 #include "app.h"
@@ -51,7 +52,14 @@
 #include "nix/nixnode.h"
 #endif //HAVE_STL
 
+#include "rawpacket.h"
+#include "extrouter.h"
 
+#include <click/config.h>
+#include <click/confparse.hh>
+#include <clicknet/ip.h>
+#include <clicknet/tcp.h>
+#include <clicknet/udp.h>
 
 #ifndef min
 #define min(a, b) (((a) < (b)) ? (a) : (b))
@@ -70,7 +78,7 @@
 Agent::Agent(packet_t pkttype) : 
 	size_(0), type_(pkttype), 
 	channel_(0), traceName_(NULL),
-	oldValueList_(NULL), app_(0), et_(0)
+	oldValueList_(NULL), app_(0), rawcvt_(false), et_(0)
 {
 }
 
@@ -170,6 +178,24 @@
 		} else if (strcmp(argv[1], "set_pkttype") == 0) {
 			set_pkttype(packet_t(atoi(argv[2])));
 			return (TCL_OK);
+		} else if (strcmp(argv[1], "set-srcip") == 0) {
+			if (!Click::cp_ip_address(Click::String(argv[2]), (unsigned char *) &srcip_))
+				return TCL_ERROR;
+			return (TCL_OK);
+		} else if (strcmp(argv[1], "set-srcport") == 0) {
+			srcport_ = atoi(argv[2]);
+			return (TCL_OK);
+		}
+		else if (strcmp(argv[1], "set-destip") == 0) {
+			if (!Click::cp_ip_address(Click::String(argv[2]), (unsigned char *) &destip_))
+				return TCL_ERROR;
+			return (TCL_OK);
+		} else if (strcmp(argv[1], "set-destport") == 0) {
+			destport_ = atoi(argv[2]);
+			return (TCL_OK);
+		} else if (strcmp(argv[1],"rawconvert") == 0) {
+			rawcvt_ = atoi(argv[2]);
+			return(TCL_OK);
 		}
 	}
 	else if (argc == 4) {	
@@ -438,10 +464,140 @@
 {
 }
 
+bool
+Agent::toraw(Packet* p) {
+	// XXX What about AppData and other such junk? Need to
+	// figure out if anyone actually sends payloads.
+	// XXX What about TCP option headers? Won't work with SACK right now
+	bool result = false;
+	struct hdr_tcp* htcp = HDR_TCP(p);
+	struct hdr_ip* hip = HDR_IP(p);
+	struct hdr_cmn* hcmn = HDR_CMN(p);
+	struct hdr_raw* hraw = hdr_raw::access(p);
+	int packetlen = sizeof(click_ip) + hcmn->size_;
+	int paylen = hcmn->size_;
+	unsigned char* pdat = 0;
+
+	// build packet length
+	if (hcmn->ptype_ == PT_ACK || hcmn->ptype_ == PT_TCP)
+		packetlen += sizeof(click_tcp);
+	else if (hcmn->ptype_ == PT_CBR)
+		packetlen += sizeof(click_udp);
+	else
+		return false;
+
+	// build packet
+	p->allocdata(packetlen);
+	pdat = p->accessdata();
+	memset(pdat, 0, packetlen);
+
+	// build IP header
+	click_ip *ip = (click_ip *) pdat;
+	ip->ip_v = 4;
+	ip->ip_hl = sizeof(click_ip) >> 2;
+	ip->ip_len = htons(packetlen);
+	ip->ip_id = htons(ipseq_);
+	ip->ip_p = (hcmn->ptype_ == PT_CBR ? IP_PROTO_UDP : IP_PROTO_TCP);
+	ip->ip_src.s_addr = srcip_;
+	ip->ip_dst.s_addr = destip_;
+	ip->ip_tos = 0;
+	ip->ip_off = 0;
+	ip->ip_ttl = hip->ttl_;
+	ip->ip_sum = 0;
+#if HAVE_FAST_CHECKSUM
+	ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
+#else
+	ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
+#endif
+
+	// build TCP/UDP header and payload
+	if (paylen > 0)
+		memset(pdat + (packetlen - paylen), 'A', paylen);
+	
+	if (hcmn->ptype_ == PT_CBR) {
+		click_udp *udp = (click_udp *) (ip + 1);
+		udp->uh_sport = htons(srcport_);
+		udp->uh_dport = htons(destport_);
+		uint16_t len = packetlen - sizeof(click_ip);
+		udp->uh_ulen = htons(len); 
+		udp->uh_sum = 0;
+		unsigned csum = click_in_cksum((unsigned char *)udp, len);
+		udp->uh_sum = click_in_cksum_pseudohdr(csum, ip, len);
+	} else {
+		click_tcp *tcp = (click_tcp *) (ip + 1);
+		tcp->th_sport = htons(srcport_);
+		tcp->th_dport = htons(destport_);
+		tcp->th_seq = htonl(htcp->seqno_);
+		tcp->th_ack = htonl(htcp->ackno_);
+		tcp->th_flags2 = 0;
+		tcp->th_off = sizeof(click_tcp) >> 2;
+		tcp->th_flags = htcp->tcp_flags_;
+		if (hcmn->ptype_ == PT_ACK)
+			tcp->th_flags |= TH_ACK;
+		tcp->th_win = 0; /* XXX */
+		tcp->th_urp = 0;
+		tcp->th_sum = 0;
+		uint16_t len = packetlen - sizeof(click_ip);
+		unsigned csum = click_in_cksum((unsigned char *)tcp, len);
+		tcp->th_sum = click_in_cksum_pseudohdr(csum, ip, len);
+	}
+
+	hcmn->direction() = hdr_cmn::DOWN;
+	hcmn->iface() = ExtRouter::IFID_KERNELTAP;
+	hraw->subtype = hdr_raw::IP;
+	hraw->ns_type = hcmn->ptype();
+	hcmn->ptype() = PT_RAW;
+	hcmn->size() = packetlen;
+	ipseq_++;
+
+	return result;
+}
+
+bool
+Agent::fromraw(Packet* p) {
+	struct hdr_tcp* htcp = HDR_TCP(p);
+	//struct hdr_ip* hip = HDR_IP(p);
+	struct hdr_cmn* hcmn = HDR_CMN(p);
+	//struct hdr_flags* hflg = hdr_flags::access(p);
+	struct click_ip* ip = 0;
+	struct click_tcp* tcp = 0;
+	//struct click_udp* udp = 0;
+	unsigned char* pdat = 0;
+	bool result = false;
+
+	if (PT_RAW != hcmn->ptype()) return false;
+
+	pdat = p->accessdata();
+	ip = (click_ip*)pdat;
+
+	switch (ip->ip_p) {
+	case IPPROTO_TCP:
+		tcp = (click_tcp*)(pdat + (ip->ip_hl << 2));
+		htcp->seqno_ = ntohl(tcp->th_seq);
+		htcp->ackno_ = ntohl(tcp->th_ack);
+		htcp->tcp_flags_ = tcp->th_flags;
+		htcp->hlen_ = (ip->ip_hl << 2) + (tcp->th_off << 2);
+		hcmn->ptype_ = (tcp->th_flags & TH_ACK) ? PT_ACK : PT_TCP;
+		result = true;
+		break;
+	case IPPROTO_UDP:
+		hcmn->ptype_ = PT_CBR;
+		result = true;
+		break;
+	default:
+		result = false;
+		break;
+	}
+
+	return result;
+}
+
 void Agent::recv(Packet* p, Handler*)
 {
-	if (app_)
+	if (app_) {
+		if (rawcvt_) fromraw(p);
 		app_->recv(hdr_cmn::access(p)->size());
+	}
 	/*
 	 * didn't expect packet (or we're a null agent?)
 	 */
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/common/agent.h ns-2.34/common/agent.h
--- ns-2.34-pure/common/agent.h	2009-06-14 10:35:45.000000000 -0700
+++ ns-2.34/common/agent.h	2010-02-28 09:31:39.000000000 -0800
@@ -43,6 +43,7 @@
 #include "ns-process.h"
 #include "app.h"
 //#include "basetrace.h"
+
 #define TIME_FORMAT "%.15g"
 // TIME_FORMAT is in basetrace.h, but including that header leads to problems
 
@@ -77,7 +78,14 @@
 	//added for edrop tracing - ratul
 	void recvOnly(Packet *) {};
 
-	void send(Packet* p, Handler* h) { target_->recv(p, h); }
+	void send(Packet* p, Handler* h) { 
+	  if (rawcvt_) toraw(p);
+	  target_->recv(p, h);
+	}
+
+        bool toraw(Packet* p);
+	bool fromraw(Packet* p);
+
 	virtual void timeout(int tno);
 
 	virtual void sendmsg(int sz, AppData*, const char* flags = 0);
@@ -102,6 +110,7 @@
 	inline nsaddr_t& dport() { return dst_.port_; }
 	void set_pkttype(packet_t pkttype) { type_ = pkttype; }
 	inline packet_t get_pkttype() { return type_; }
+	static int getnextuid() { return uidcnt_++; }
 
  protected:
 	int command(int argc, const char*const* argv);
@@ -135,6 +144,18 @@
 	OldValue *oldValueList_; 
 
 	Application *app_;		// ptr to application for callback
+	
+	// If this is set to "true" convert packets to and from
+	// raw format as they go to and from attached applications.
+	bool rawcvt_;
+	
+	// We also need to keep src and dest ip and port addresses
+	// around if we're going to use raw packets.
+	u_int16_t ipseq_;
+	u_long srcip_;
+	u_short srcport_;
+	u_long destip_;
+	u_short destport_;
 
 	virtual void trace(TracedVar *v);
 	void deleteAgentTrace();
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/common/clicknode.cc ns-2.34/common/clicknode.cc
--- ns-2.34-pure/common/clicknode.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/common/clicknode.cc	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,132 @@
+/*
+ * clicknode.cc 
+ * Base class for nsclick nodes.
+ *
+ * XXX Should probably move a bunch of the functionality in this
+ * class to a superclass, i.e. something called ExtNode, since a lot
+ * of this should work with most Ext routing stuff, not just click.
+ *
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "connector.h"
+#include "delay.h"
+#include "packet.h"
+#include "agent.h"
+#include "rawpacket.h"
+#include "random.h"
+#include "trace.h"
+#include "address.h"
+
+#include "arp.h"
+#include "topography.h"
+#include "ll.h"
+#include "mac.h"
+#include "propagation.h"
+#include "mobilenode.h"
+#include "phy.h"
+#include "wired-phy.h"
+#include "god.h"
+#include "extrouter.h"
+#include "extclickrouter.h"
+#include <sys/time.h>
+#include <click/simclick.h>
+#include "clicknode.h"
+
+
+static class ClickNodeClass : public TclClass {
+public:
+  ClickNodeClass() : TclClass("Node/MobileNode/ClickNode") {}
+  TclObject* create(int, const char*const*) {
+    ClickNode* thenode = new ClickNode;
+    if (!thenode) {
+      return NULL;
+    }
+
+    /*
+     * Do post-constructor initialization.
+     */
+    int result = thenode->cinit();
+    if (0 > result) {
+      delete thenode;
+      thenode = NULL;
+    }
+
+    return thenode;
+  }
+} class_clicknode;
+
+
+ClickNode::ClickNode(void) {
+}
+
+int
+ClickNode::cinit() {
+  int result = 0;
+  return result;
+}
+
+int
+ClickNode::command(int argc, const char*const* argv)
+{
+  //Tcl& tcl = Tcl::instance();
+  if (2 == argc) {
+  }
+  else if (3 == argc) {
+    if(strcmp(argv[1], "addif") == 0) {
+      Phy* phyp = (Phy*)TclObject::lookup(argv[2]);
+      if(phyp == 0) {
+	return TCL_ERROR;
+      }
+      phyp->insertnode(&ifhead_);
+      phyp->setnode(this);
+      return TCL_OK;
+    }
+  }
+  else if (4 == argc) {
+  }
+  else if (5 == argc) {
+  }
+
+  return MobileNode::command(argc, argv);
+}
+
+
+/* ======================================================================
+   Other class functions
+   ====================================================================== */
+void
+ClickNode::dump(void) {
+  printf("Dumping a clicknode...\n");
+}
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/common/clicknode.h ns-2.34/common/clicknode.h
--- ns-2.34-pure/common/clicknode.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/common/clicknode.h	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,64 @@
+/*
+ * clicknode.h
+ *
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#ifndef __ns_clicknode_h__
+#define __ns_clicknode_h__
+
+#include "object.h"
+#include "trace.h"
+#include "lib/bsd-list.h"
+#include "node.h"
+
+class ClickNode : public MobileNode
+{
+
+public:
+  ClickNode();
+  virtual int cinit();
+  virtual int command(int argc, const char*const* argv);
+  inline ClickNode* nextnode() { return link_.le_next; }
+  
+  void dump(void);
+  
+private:
+
+  /*
+   * A global list of click nodes
+   */
+  LIST_ENTRY(ClickNode) link_;
+  
+  /*
+   * Trace Target
+   */
+  Trace* log_target_;
+
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/common/packet-stamp.h ns-2.34/common/packet-stamp.h
--- ns-2.34-pure/common/packet-stamp.h	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/common/packet-stamp.h	2010-02-28 09:31:39.000000000 -0800
@@ -22,7 +22,8 @@
 class PacketStamp {
 public:
 
-  PacketStamp() : ant(0), node(0), Pr(-1), lambda(-1) { }
+  PacketStamp() : ant(0), node(0), Pr(-1), lambda(-1),PrLevel(-1),rate(0) { }
+  void clear() { ant = 0; node = 0; Pr = -1; lambda = -1; PrLevel = -1; rate = 0;}
 
   void init(const PacketStamp *s) {
 	  Antenna* ant;
@@ -33,6 +34,8 @@
 	  
 	  //Antenna *ant = (s->ant) ? s->ant->copy(): 0;
 	  stamp(s->node, ant, s->Pr, s->lambda);
+	  PrLevel = s->PrLevel;
+	  rate = s->rate;
   }
 
   void stamp(MobileNode *n, Antenna *a, double xmitPr, double lam) {
@@ -45,7 +48,11 @@
   inline Antenna * getAntenna() {return ant;}
   inline MobileNode * getNode() {return node;}
   inline double getTxPr() {return Pr;}
+  inline void setPrLevel(int p){PrLevel = p;}
+  inline int getPrLevel(){return PrLevel;}
   inline double getLambda() {return lambda;}
+  inline void setRate(double r){rate =r;}
+  inline double getRate(){return rate;}
 
   /* WILD HACK: The following two variables are a wild hack.
      They will go away in the next release...
@@ -60,6 +67,8 @@
   MobileNode	*node;
   double        Pr;		// power pkt sent with
   double        lambda;         // wavelength of signal
+  int 			PrLevel;	// nletor -- madwifi powerlevel set by TxPower element
+  double		rate;	// nletor -- transmission rate of packet
 };
 
 #endif /* !_cmu_packetstamp_h_ */
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/common/packet.h ns-2.34/common/packet.h
--- ns-2.34-pure/common/packet.h	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/common/packet.h	2010-02-28 09:31:39.000000000 -0800
@@ -182,8 +182,11 @@
 	// AOMDV packet
 static const packet_t PT_AOMDV = 61;
 
+	// nsclick RAW packet
+	static const packet_t PT_RAW = 62;
+
         // insert new packet types here
-static packet_t       PT_NTYPE = 62; // This MUST be the LAST one
+static packet_t       PT_NTYPE = 63; // This MUST be the LAST one
 
 enum packetClass
 {
@@ -286,6 +289,7 @@
 		nPkt_ = PT_NTYPE+1;
 		
 
+		name_[PT_RAW] = "raw";
 		name_[PT_TCP]= "tcp";
 		name_[PT_UDP]= "udp";
 		name_[PT_CBR]= "cbr";
@@ -656,6 +660,7 @@
 inline void Packet::init(Packet* p)
 {
 	bzero(p->bits_, hdrlen_);
+	p->txinfo_.clear();
 }
 
 inline Packet* Packet::alloc()
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/common/packet.h.orig ns-2.34/common/packet.h.orig
--- ns-2.34-pure/common/packet.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/common/packet.h.orig	2009-06-14 10:35:44.000000000 -0700
@@ -0,0 +1,767 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) $Header: /cvsroot/nsnam/ns-2/common/packet.h,v 1.103 2009/01/15 06:23:49 tom_henderson Exp $ (LBL)
+ */
+
+#ifndef ns_packet_h
+#define ns_packet_h
+
+#include <string.h>
+#include <assert.h>
+
+#include "config.h"
+#include "scheduler.h"
+#include "object.h"
+#include "lib/bsd-list.h"
+#include "packet-stamp.h"
+#include "ns-process.h"
+
+// Used by wireless routing code to attach routing agent
+#define RT_PORT		255	/* port that all route msgs are sent to */
+
+#define HDR_CMN(p)      (hdr_cmn::access(p))
+#define HDR_ARP(p)      (hdr_arp::access(p))
+#define HDR_MAC(p)      (hdr_mac::access(p))
+#define HDR_MAC802_11(p) ((hdr_mac802_11 *)hdr_mac::access(p))
+#define HDR_MAC_TDMA(p) ((hdr_mac_tdma *)hdr_mac::access(p))
+#define HDR_SMAC(p)     ((hdr_smac *)hdr_mac::access(p))
+#define HDR_LL(p)       (hdr_ll::access(p))
+#define HDR_HDLC(p)     ((hdr_hdlc *)hdr_ll::access(p))
+#define HDR_IP(p)       (hdr_ip::access(p))
+#define HDR_RTP(p)      (hdr_rtp::access(p))
+#define HDR_TCP(p)      (hdr_tcp::access(p))
+#define HDR_SCTP(p)     (hdr_sctp::access(p))
+#define HDR_SR(p)       (hdr_sr::access(p))
+#define HDR_TFRC(p)     (hdr_tfrc::access(p))
+#define HDR_TORA(p)     (hdr_tora::access(p))
+#define HDR_IMEP(p)     (hdr_imep::access(p))
+#define HDR_CDIFF(p)    (hdr_cdiff::access(p))  /* chalermak's diffusion*/
+//#define HDR_DIFF(p)     (hdr_diff::access(p))  /* SCADD's diffusion ported into ns */
+#define HDR_LMS(p)		(hdr_lms::access(p))
+
+/* --------------------------------------------------------------------*/
+
+/*
+ * modified ns-2.33, adding support for dynamic libraries
+ * 
+ * packet_t is changed from enum to unsigned int in order to allow
+ * dynamic definition of  new packet types within dynamic libraries.
+ * Pre-defined packet types are implemented as static const.
+ * 
+ */
+
+typedef unsigned int packet_t;
+
+static const packet_t PT_TCP = 0;
+static const packet_t PT_UDP = 1;
+static const packet_t PT_CBR = 2;
+static const packet_t PT_AUDIO = 3;
+static const packet_t PT_VIDEO = 4;
+static const packet_t PT_ACK = 5;
+static const packet_t PT_START = 6;
+static const packet_t PT_STOP = 7;
+static const packet_t PT_PRUNE = 8;
+static const packet_t PT_GRAFT = 9;
+static const packet_t PT_GRAFTACK = 10;
+static const packet_t PT_JOIN = 11;
+static const packet_t PT_ASSERT = 12;
+static const packet_t PT_MESSAGE = 13;
+static const packet_t PT_RTCP = 14;
+static const packet_t PT_RTP = 15;
+static const packet_t PT_RTPROTO_DV = 16;
+static const packet_t PT_CtrMcast_Encap = 17;
+static const packet_t PT_CtrMcast_Decap = 18;
+static const packet_t PT_SRM = 19;
+        /* simple signalling messages */
+static const packet_t PT_REQUEST = 20;
+static const packet_t PT_ACCEPT = 21;
+static const packet_t PT_CONFIRM = 22;
+static const packet_t PT_TEARDOWN = 23;
+static const packet_t PT_LIVE = 24;   // packet from live network
+static const packet_t PT_REJECT = 25;
+
+static const packet_t PT_TELNET = 26; // not needed: telnet use TCP
+static const packet_t PT_FTP = 27;
+static const packet_t PT_PARETO = 28;
+static const packet_t PT_EXP = 29;
+static const packet_t PT_INVAL = 30;
+static const packet_t PT_HTTP = 31;
+
+        /* new encapsulator */
+static const packet_t PT_ENCAPSULATED = 32;
+static const packet_t PT_MFTP = 33;
+
+        /* CMU/Monarch's extnsions */
+static const packet_t PT_ARP = 34;
+static const packet_t PT_MAC = 35;
+static const packet_t PT_TORA = 36;
+static const packet_t PT_DSR = 37;
+static const packet_t PT_AODV = 38;
+static const packet_t PT_IMEP = 39;
+        
+        // RAP packets
+static const packet_t PT_RAP_DATA = 40;
+static const packet_t PT_RAP_ACK = 41;
+  
+static const packet_t PT_TFRC = 42;
+static const packet_t PT_TFRC_ACK = 43;
+static const packet_t PT_PING = 44;
+        
+static const packet_t PT_PBC = 45;
+        // Diffusion packets - Chalermek
+static const packet_t PT_DIFF = 46;
+        
+        // LinkState routing update packets
+static const packet_t PT_RTPROTO_LS = 47;
+        
+        // MPLS LDP header
+static const packet_t PT_LDP = 48;
+        
+        // GAF packet
+static const packet_t PT_GAF = 49;
+        
+        // ReadAudio traffic
+static const packet_t PT_REALAUDIO = 50;
+        
+        // Pushback Messages
+static const packet_t PT_PUSHBACK = 51;
+  
+  #ifdef HAVE_STL
+        // Pragmatic General Multicast
+static const packet_t PT_PGM = 52;
+  #endif //STL
+        // LMS packets
+static const packet_t PT_LMS = 53;
+static const packet_t PT_LMS_SETUP = 54;
+
+static const packet_t PT_SCTP = 55;
+static const packet_t PT_SCTP_APP1 = 56;
+
+        // SMAC packet
+static const packet_t PT_SMAC = 57;
+        // XCP packet
+static const packet_t PT_XCP = 58;
+
+        // HDLC packet
+static const packet_t PT_HDLC = 59;
+
+        // Bell Labs Traffic Trace Type (PackMime OL)
+static const packet_t PT_BLTRACE = 60;
+
+	// AOMDV packet
+static const packet_t PT_AOMDV = 61;
+
+        // insert new packet types here
+static packet_t       PT_NTYPE = 62; // This MUST be the LAST one
+
+enum packetClass
+{
+	UNCLASSIFIED,
+	ROUTING,
+	DATApkt
+  };
+
+
+/*
+ * ns-2.33 adding support for dynamic libraries
+ * 
+ * The PacketClassifier class is needed to make
+ * p_info::data_packet(packet_t) work also with dynamically defined
+ * packet types.
+ * 
+ */
+class PacketClassifier
+{
+	public:
+		PacketClassifier(): next_(0){}
+		virtual ~PacketClassifier() {}
+		void setNext(PacketClassifier *next){next_ = next;}
+		PacketClassifier *getNext(){return next_;}
+		packetClass classify(packet_t type) 
+		{
+		        packetClass c = getClass(type);
+		        if(c == UNCLASSIFIED && next_)
+		                c = next_->classify(type);
+		        return c;
+		}
+
+	protected:
+		//return 0 if the packet is unknown
+		virtual packetClass getClass(packet_t type) = 0;        
+		PacketClassifier *next_;
+};
+
+class p_info {
+public:
+	p_info()
+	{
+		initName();
+	}
+	const char* name(packet_t p) const { 
+		if ( p <= p_info::nPkt_ ) return name_[p];
+		return 0;
+	}
+	static bool data_packet(packet_t type) {
+		return ( (type) == PT_TCP || \
+		         (type) == PT_TELNET || \
+		         (type) == PT_CBR || \
+		         (type) == PT_AUDIO || \
+		         (type) == PT_VIDEO || \
+		         (type) == PT_ACK || \
+		         (type) == PT_SCTP || \
+		         (type) == PT_SCTP_APP1 || \
+		         (type) == PT_HDLC \
+		        );
+	}
+	static packetClass classify(packet_t type) {		
+		if (type == PT_DSR || 
+		    type == PT_MESSAGE || 
+		    type == PT_TORA || 
+		    type == PT_AODV)
+			return ROUTING;		
+		if (type == PT_TCP || 
+		    type == PT_TELNET || 
+		    type == PT_CBR || 
+		    type == PT_AUDIO || 
+		    type == PT_VIDEO || 
+		    type == PT_ACK || 
+		    type == PT_SCTP || 
+		    type == PT_SCTP_APP1 || 
+		    type == PT_HDLC)
+			return DATApkt;
+		if (pc_)
+			return pc_->classify(type);
+		return UNCLASSIFIED;
+	}
+	static void addPacketClassifier(PacketClassifier *pc)
+	{
+		if(!pc)
+		        return;
+		pc->setNext(pc_);
+		pc_ = pc;
+	}       
+	static void initName()
+	{
+		if(nPkt_ >= PT_NTYPE+1)
+		        return;
+		char **nameNew = new char*[PT_NTYPE+1];
+		for(unsigned int i = (unsigned int)PT_SMAC+1; i < nPkt_; i++)
+		{
+		        nameNew[i] = name_[i];
+		}
+		if(!nPkt_)
+		        delete [] name_;
+		name_ = nameNew;
+		nPkt_ = PT_NTYPE+1;
+		
+
+		name_[PT_TCP]= "tcp";
+		name_[PT_UDP]= "udp";
+		name_[PT_CBR]= "cbr";
+		name_[PT_AUDIO]= "audio";
+		name_[PT_VIDEO]= "video";
+		name_[PT_ACK]= "ack";
+		name_[PT_START]= "start";
+		name_[PT_STOP]= "stop";
+		name_[PT_PRUNE]= "prune";
+		name_[PT_GRAFT]= "graft";
+		name_[PT_GRAFTACK]= "graftAck";
+		name_[PT_JOIN]= "join";
+		name_[PT_ASSERT]= "assert";
+		name_[PT_MESSAGE]= "message";
+		name_[PT_RTCP]= "rtcp";
+		name_[PT_RTP]= "rtp";
+		name_[PT_RTPROTO_DV]= "rtProtoDV";
+		name_[PT_CtrMcast_Encap]= "CtrMcast_Encap";
+		name_[PT_CtrMcast_Decap]= "CtrMcast_Decap";
+		name_[PT_SRM]= "SRM";
+	
+		name_[PT_REQUEST]= "sa_req";	
+		name_[PT_ACCEPT]= "sa_accept";
+		name_[PT_CONFIRM]= "sa_conf";
+		name_[PT_TEARDOWN]= "sa_teardown";
+		name_[PT_LIVE]= "live"; 
+		name_[PT_REJECT]= "sa_reject";
+	
+		name_[PT_TELNET]= "telnet";
+		name_[PT_FTP]= "ftp";
+		name_[PT_PARETO]= "pareto";
+		name_[PT_EXP]= "exp";
+		name_[PT_INVAL]= "httpInval";
+		name_[PT_HTTP]= "http";
+		name_[PT_ENCAPSULATED]= "encap";
+		name_[PT_MFTP]= "mftp";
+		name_[PT_ARP]= "ARP";
+		name_[PT_MAC]= "MAC";
+		name_[PT_TORA]= "TORA";
+		name_[PT_DSR]= "DSR";
+		name_[PT_AODV]= "AODV";
+		name_[PT_IMEP]= "IMEP";
+
+		name_[PT_RAP_DATA] = "rap_data";
+		name_[PT_RAP_ACK] = "rap_ack";
+
+ 		name_[PT_TFRC]= "tcpFriend";
+		name_[PT_TFRC_ACK]= "tcpFriendCtl";
+		name_[PT_PING]="ping";
+	
+		name_[PT_PBC] = "PBC";
+
+	 	/* For diffusion : Chalermek */
+ 		name_[PT_DIFF] = "diffusion";
+
+		// Link state routing updates
+		name_[PT_RTPROTO_LS] = "rtProtoLS";
+
+		// MPLS LDP packets
+		name_[PT_LDP] = "LDP";
+
+		// for GAF
+                name_[PT_GAF] = "gaf";      
+
+		// RealAudio packets
+		name_[PT_REALAUDIO] = "ra";
+
+		//pushback 
+		name_[PT_PUSHBACK] = "pushback";
+
+#ifdef HAVE_STL
+		// for PGM
+		name_[PT_PGM] = "PGM";
+#endif //STL
+
+		// LMS entries
+		name_[PT_LMS]="LMS";
+		name_[PT_LMS_SETUP]="LMS_SETUP";
+
+		name_[PT_SCTP]= "sctp";
+ 		name_[PT_SCTP_APP1] = "sctp_app1";
+		
+		// smac
+		name_[PT_SMAC]="smac";
+
+		// HDLC
+		name_[PT_HDLC]="HDLC";
+
+		// XCP
+		name_[PT_XCP]="xcp";
+
+		// Bell Labs (PackMime OL)
+		name_[PT_BLTRACE]="BellLabsTrace";
+		
+		// AOMDV patch
+		name_[PT_AOMDV]= "AOMDV";
+
+		name_[PT_NTYPE]= "undefined";
+	}
+	static int addPacket(char *name);
+	static packet_t getType(const char *name)
+	{
+		for(unsigned int i = 0; i < nPkt_; i++)
+		{
+		        if(strcmp(name, name_[i]) == 0)
+		                return i;
+		}
+		return PT_NTYPE;
+
+	}
+private:
+	static char** name_;
+	static unsigned int nPkt_;
+	static PacketClassifier *pc_;
+};
+extern p_info packet_info; /* map PT_* to string name */
+//extern char* p_info::name_[];
+
+#define DATA_PACKET(type) ( (type) == PT_TCP || \
+                            (type) == PT_TELNET || \
+                            (type) == PT_CBR || \
+                            (type) == PT_AUDIO || \
+                            (type) == PT_VIDEO || \
+                            (type) == PT_ACK || \
+                            (type) == PT_SCTP || \
+                            (type) == PT_SCTP_APP1 \
+                            )
+
+//#define OFFSET(type, field)	((long) &((type *)0)->field)
+#define OFFSET(type, field) ( (char *)&( ((type *)256)->field )  - (char *)256)
+
+class PacketData : public AppData {
+public:
+	PacketData(int sz) : AppData(PACKET_DATA) {
+		datalen_ = sz;
+		if (datalen_ > 0)
+			data_ = new unsigned char[datalen_];
+		else
+			data_ = NULL;
+	}
+	PacketData(PacketData& d) : AppData(d) {
+		datalen_ = d.datalen_;
+		if (datalen_ > 0) {
+			data_ = new unsigned char[datalen_];
+			memcpy(data_, d.data_, datalen_);
+		} else
+			data_ = NULL;
+	}
+	virtual ~PacketData() { 
+		if (data_ != NULL) 
+			delete []data_; 
+	}
+	unsigned char* data() { return data_; }
+
+	virtual int size() const { return datalen_; }
+	virtual AppData* copy() { return new PacketData(*this); }
+private:
+	unsigned char* data_;
+	int datalen_;
+};
+
+//Monarch ext
+typedef void (*FailureCallback)(Packet *,void *);
+
+class Packet : public Event {
+private:
+	unsigned char* bits_;	// header bits
+//	unsigned char* data_;	// variable size buffer for 'data'
+//  	unsigned int datalen_;	// length of variable size buffer
+	AppData* data_;		// variable size buffer for 'data'
+	static void init(Packet*);     // initialize pkt hdr 
+	bool fflag_;
+protected:
+	static Packet* free_;	// packet free list
+	int	ref_count_;	// free the pkt until count to 0
+public:
+	Packet* next_;		// for queues and the free list
+	static int hdrlen_;
+
+	Packet() : bits_(0), data_(0), ref_count_(0), next_(0) { }
+	inline unsigned char* const bits() { return (bits_); }
+	inline Packet* copy() const;
+	inline Packet* refcopy() { ++ref_count_; return this; }
+	inline int& ref_count() { return (ref_count_); }
+	static inline Packet* alloc();
+	static inline Packet* alloc(int);
+	inline void allocdata(int);
+	// dirty hack for diffusion data
+	inline void initdata() { data_  = 0;}
+	static inline void free(Packet*);
+	inline unsigned char* access(int off) const {
+		if (off < 0)
+			abort();
+		return (&bits_[off]);
+	}
+	// This is used for backward compatibility, i.e., assuming user data
+	// is PacketData and return its pointer.
+	inline unsigned char* accessdata() const { 
+		if (data_ == 0)
+			return 0;
+		assert(data_->type() == PACKET_DATA);
+		return (((PacketData*)data_)->data()); 
+	}
+	// This is used to access application-specific data, not limited 
+	// to PacketData.
+	inline AppData* userdata() const {
+		return data_;
+	}
+	inline void setdata(AppData* d) { 
+		if (data_ != NULL)
+			delete data_;
+		data_ = d; 
+	}
+	inline int datalen() const { return data_ ? data_->size() : 0; }
+
+	// Monarch extn
+
+	static void dump_header(Packet *p, int offset, int length);
+
+	// the pkt stamp carries all info about how/where the pkt
+        // was sent needed for a receiver to determine if it correctly
+        // receives the pkt
+        PacketStamp	txinfo_;  
+
+	/*
+         * According to cmu code:
+	 * This flag is set by the MAC layer on an incoming packet
+         * and is cleared by the link layer.  It is an ugly hack, but
+         * there's really no other way because NS always calls
+         * the recv() function of an object.
+	 * 
+         */
+        u_int8_t        incoming;
+
+	//monarch extns end;
+};
+
+/* 
+ * static constant associations between interface special (negative) 
+ * values and their c-string representations that are used from tcl
+ */
+class iface_literal {
+public:
+	enum iface_constant { 
+		UNKN_IFACE= -1, /* 
+				 * iface value for locally originated packets 
+				 */
+		ANY_IFACE= -2   /* 
+				 * hashnode with iif == ANY_IFACE_   
+				 * matches any pkt iface (imported from TCL);
+				 * this value should be different from 
+				 * hdr_cmn::UNKN_IFACE (packet.h)
+				 */ 
+	};
+	iface_literal(const iface_constant i, const char * const n) : 
+		value_(i), name_(n) {}
+	inline int value() const { return value_; }
+	inline const char * const name() const { return name_; }
+private:
+	const iface_constant value_;
+	/* strings used in TCL to access those special values */
+	const char * const name_; 
+};
+
+static const iface_literal UNKN_IFACE(iface_literal::UNKN_IFACE, "?");
+static const iface_literal ANY_IFACE(iface_literal::ANY_IFACE, "*");
+
+/*
+ * Note that NS_AF_* doesn't necessarily correspond with
+ * the constants used in your system (because many
+ * systems don't have NONE or ILINK).
+ */
+enum ns_af_enum { NS_AF_NONE, NS_AF_ILINK, NS_AF_INET };
+
+enum ModulationScheme {BPSK = 0, QPSK = 1, QAM16 = 2, QAM64 = 3};
+
+struct hdr_cmn {
+	enum dir_t { DOWN= -1, NONE= 0, UP= 1 };
+	packet_t ptype_;	// packet type (see above)
+	int	size_;		// simulated packet size
+	int	uid_;		// unique id
+	int	error_;		// error flag
+	int     errbitcnt_;     // # of corrupted bits jahn
+	int     fecsize_;
+	double	ts_;		// timestamp: for q-delay measurement
+	int	iface_;		// receiving interface (label)
+	dir_t	direction_;	// direction: 0=none, 1=up, -1=down
+	// source routing 
+        char src_rt_valid;
+	double ts_arr_; // Required by Marker of JOBS 
+
+	//Monarch extn begins
+	nsaddr_t prev_hop_;     // IP addr of forwarding hop
+	nsaddr_t next_hop_;	// next hop for this packet
+	int      addr_type_;    // type of next_hop_ addr
+	nsaddr_t last_hop_;     // for tracing on multi-user channels
+	
+	// AOMDV patch
+	int aomdv_salvage_count_;
+	
+        // called if pkt can't obtain media or isn't ack'd. not called if
+        // droped by a queue
+        FailureCallback xmit_failure_; 
+        void *xmit_failure_data_;
+
+        /*
+         * MONARCH wants to know if the MAC layer is passing this back because
+         * it could not get the RTS through or because it did not receive
+         * an ACK.
+         */
+        int     xmit_reason_;
+#define XMIT_REASON_RTS 0x01
+#define XMIT_REASON_ACK 0x02
+
+        // filled in by GOD on first transmission, used for trace analysis
+        int num_forwards_;	// how many times this pkt was forwarded
+        int opt_num_forwards_;   // optimal #forwards
+	// Monarch extn ends;
+
+	// tx time for this packet in sec
+	double txtime_;
+	inline double& txtime() { return(txtime_); }
+
+	static int offset_;	// offset for this header
+	inline static int& offset() { return offset_; }
+	inline static hdr_cmn* access(const Packet* p) {
+		return (hdr_cmn*) p->access(offset_);
+	}
+	
+        /* per-field member functions */
+	inline packet_t& ptype() { return (ptype_); }
+	inline int& size() { return (size_); }
+	inline int& uid() { return (uid_); }
+	inline int& error() { return error_; }
+	inline int& errbitcnt() {return errbitcnt_; }
+	inline int& fecsize() {return fecsize_; }
+	inline double& timestamp() { return (ts_); }
+	inline int& iface() { return (iface_); }
+	inline dir_t& direction() { return (direction_); }
+	// monarch_begin
+	inline nsaddr_t& next_hop() { return (next_hop_); }
+	inline int& addr_type() { return (addr_type_); }
+	inline int& num_forwards() { return (num_forwards_); }
+	inline int& opt_num_forwards() { return (opt_num_forwards_); }
+        //monarch_end
+
+	ModulationScheme mod_scheme_;
+	inline ModulationScheme& mod_scheme() { return (mod_scheme_); }
+};
+
+
+class PacketHeaderClass : public TclClass {
+protected:
+	PacketHeaderClass(const char* classname, int hdrsize);
+	virtual int method(int argc, const char*const* argv);
+	void field_offset(const char* fieldname, int offset);
+	inline void bind_offset(int* off) { offset_ = off; }
+	inline void offset(int* off) {offset_= off;}
+	int hdrlen_;		// # of bytes for this header
+	int* offset_;		// offset for this header
+public:
+	virtual void bind();
+	virtual void export_offsets();
+	TclObject* create(int argc, const char*const* argv);
+};
+
+
+inline void Packet::init(Packet* p)
+{
+	bzero(p->bits_, hdrlen_);
+}
+
+inline Packet* Packet::alloc()
+{
+	Packet* p = free_;
+	if (p != 0) {
+		assert(p->fflag_ == FALSE);
+		free_ = p->next_;
+		assert(p->data_ == 0);
+		p->uid_ = 0;
+		p->time_ = 0;
+	} else {
+		p = new Packet;
+		p->bits_ = new unsigned char[hdrlen_];
+		if (p == 0 || p->bits_ == 0)
+			abort();
+	}
+	init(p); // Initialize bits_[]
+	(HDR_CMN(p))->next_hop_ = -2; // -1 reserved for IP_BROADCAST
+	(HDR_CMN(p))->last_hop_ = -2; // -1 reserved for IP_BROADCAST
+	p->fflag_ = TRUE;
+	(HDR_CMN(p))->direction() = hdr_cmn::DOWN;
+	/* setting all direction of pkts to be downward as default; 
+	   until channel changes it to +1 (upward) */
+	p->next_ = 0;
+	return (p);
+}
+
+/* 
+ * Allocate an n byte data buffer to an existing packet 
+ * 
+ * To set application-specific AppData, use Packet::setdata()
+ */
+inline void Packet::allocdata(int n)
+{
+	assert(data_ == 0);
+	data_ = new PacketData(n);
+	if (data_ == 0)
+		abort();
+}
+
+/* allocate a packet with an n byte data buffer */
+inline Packet* Packet::alloc(int n)
+{
+	Packet* p = alloc();
+	if (n > 0) 
+		p->allocdata(n);
+	return (p);
+}
+
+
+inline void Packet::free(Packet* p)
+{
+	if (p->fflag_) {
+		if (p->ref_count_ == 0) {
+			/*
+			 * A packet's uid may be < 0 (out of a event queue), or
+			 * == 0 (newed but never gets into the event queue.
+			 */
+			assert(p->uid_ <= 0);
+			// Delete user data because we won't need it any more.
+			if (p->data_ != 0) {
+				delete p->data_;
+				p->data_ = 0;
+			}
+			init(p);
+			p->next_ = free_;
+			free_ = p;
+			p->fflag_ = FALSE;
+		} else {
+			--p->ref_count_;
+		}
+	}
+}
+
+inline Packet* Packet::copy() const
+{
+	
+	Packet* p = alloc();
+	memcpy(p->bits(), bits_, hdrlen_);
+	if (data_) 
+		p->data_ = data_->copy();
+	p->txinfo_.init(&txinfo_);
+ 
+	return (p);
+}
+
+inline void
+Packet::dump_header(Packet *p, int offset, int length)
+{
+        assert(offset + length <= p->hdrlen_);
+        struct hdr_cmn *ch = HDR_CMN(p);
+
+        fprintf(stderr, "\nPacket ID: %d\n", ch->uid());
+
+        for(int i = 0; i < length ; i+=16) {
+                fprintf(stderr, "%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+                        p->bits_[offset + i],     p->bits_[offset + i + 1],
+                        p->bits_[offset + i + 2], p->bits_[offset + i + 3],
+                        p->bits_[offset + i + 4], p->bits_[offset + i + 5],
+                        p->bits_[offset + i + 6], p->bits_[offset + i + 7],
+                        p->bits_[offset + i + 8], p->bits_[offset + i + 9],
+                        p->bits_[offset + i + 10], p->bits_[offset + i + 11],
+                        p->bits_[offset + i + 12], p->bits_[offset + i + 13],
+                        p->bits_[offset + i + 14], p->bits_[offset + i + 15]);
+        }
+}
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/common/rawpacket.cc ns-2.34/common/rawpacket.cc
--- ns-2.34-pure/common/rawpacket.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/common/rawpacket.cc	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,205 @@
+/*
+ * rawpacket.cc
+ * Main file for the raw packet type
+ *
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#include <stdio.h>
+#include "agent.h"
+#include "packet.h"
+#include "rawpacket.h"
+#include "extrouter.h"
+
+#include <click/config.h>
+#include <click/confparse.hh>
+#include <clicknet/ip.h>
+#include <clicknet/udp.h>
+
+int hdr_raw::offset_;
+
+/*
+ * RawHeaderClass based on the ping example in the ns-2 tutorial.
+ */
+static class RawHeaderClass : public PacketHeaderClass {
+public:
+  RawHeaderClass() : PacketHeaderClass("PacketHeader/Raw",sizeof(hdr_raw)){
+    bind_offset(&hdr_raw::offset_);
+  }
+} class_rawhdr;
+
+static class RawClass : public TclClass {
+public:
+  RawClass() : TclClass("Agent/Raw") {}
+  TclObject* create(int,const char*const*) {
+    return (new RawAgent());
+  }
+} class_raw;
+  
+
+RawAgent::RawAgent() : Agent(PT_RAW) {
+  ipseq_ = 0;
+}
+
+int RawAgent::command(int argc,const char*const* argv) {
+  if (argc == 2) {
+    if (strcmp(argv[1], "send") == 0) {
+      char* testmsg = "Howdy Howdy Howdy\n";
+      send_udp_str(srcip_,srcport_,destip_,destport_,testmsg);
+      return (TCL_OK);
+    }
+  }
+  else if (argc == 3) {
+    if (strcmp(argv[1], "send") == 0) {
+      const char* testmsg = argv[2];
+      send_udp_str(srcip_,srcport_,destip_,destport_,testmsg);
+      return (TCL_OK);
+    }
+    if (strcmp(argv[1], "set-srcip") == 0) {
+	if (!Click::cp_ip_address(Click::String(argv[2]), (unsigned char *) &srcip_))
+	    return TCL_ERROR;
+	return (TCL_OK);
+    }
+    if (strcmp(argv[1], "set-srcport") == 0) {
+      srcport_ = atoi(argv[2]);
+      return (TCL_OK);
+    }
+    if (strcmp(argv[1], "set-destip") == 0) {
+	if (!Click::cp_ip_address(Click::String(argv[2]), (unsigned char *) &destip_))
+	    return TCL_ERROR;
+	return (TCL_OK);
+    }
+    if (strcmp(argv[1], "set-destport") == 0) {
+      destport_ = atoi(argv[2]);
+      return (TCL_OK);
+    }
+  }
+  else if (argc == 7) {
+    if (strcmp(argv[1],"send-udp") == 0) {
+      // saddr,sport,daddr,dport,payload
+      // For right now only text strings can be sent
+      // as payload.
+	u_long saddr, daddr;
+	if (!Click::cp_ip_address(Click::String(argv[2]), (unsigned char *) &saddr)
+	    || !Click::cp_ip_address(Click::String(argv[4]), (unsigned char *) &daddr))
+	    return TCL_ERROR;
+      u_short sport = atoi(argv[3]);
+      u_short dport = atoi(argv[5]);
+      send_udp_str(saddr,sport,daddr,dport,argv[6]);
+      // return TCL_OK, so the calling function knows that the
+      // command has been processed
+      return (TCL_OK);
+    }
+  }
+
+  // If the command hasn't been processed by RawAgent()::command,
+  // call the command() function for the base class
+  return (Agent::command(argc, argv));
+}
+
+void
+RawAgent::sendmsg(int nbytes, const char *flags) {
+  // Make a string full of 'A's and use it for the payload
+  char* stuff = new char[nbytes];
+  memset(stuff,'A',nbytes);
+  send_udp(srcip_,srcport_,destip_,destport_,stuff,nbytes);
+  delete[] stuff;
+  stuff = 0;
+}
+
+void
+RawAgent::send_udp_str(u_long saddr,u_short sport,u_long daddr,u_short dport,
+		       const char* payload) {
+  send_udp(saddr,sport,daddr,dport,payload,strlen(payload));
+}
+
+void
+RawAgent::send_udp(u_long saddr,u_short sport,u_long daddr,u_short dport,
+		   const char* payload,int paylen) {
+    int packetlen = paylen + sizeof(click_ip) + sizeof(click_udp);
+    Packet* pkt = allocpkt(packetlen);
+    hdr_cmn* hcmn = HDR_CMN(pkt);
+    hcmn->direction() = hdr_cmn::DOWN;
+    hcmn->iface() = ExtRouter::IFID_KERNELTAP;
+    hcmn->ptype() = PT_RAW;
+    hcmn->size() = packetlen;
+    // Access the raw header for the new packet:
+    hdr_raw* hdr = hdr_raw::access(pkt);
+    hdr->subtype = hdr_raw::IP;
+    hdr->ns_type = PT_RAW;
+    unsigned char* pdat = pkt->accessdata();
+    memset(pdat,0,packetlen);
+
+    click_ip *ip = reinterpret_cast<click_ip *>(pdat);
+    click_udp *udp = reinterpret_cast<click_udp *>(ip + 1);
+
+    // set up IP header
+    ip->ip_v = 4;
+    ip->ip_hl = sizeof(click_ip) >> 2;
+    ip->ip_len = htons(packetlen);
+    ip->ip_id = htons(ipseq_);
+    ip->ip_p = IP_PROTO_UDP;
+    ip->ip_src.s_addr = saddr;
+    ip->ip_dst.s_addr = daddr;
+    ip->ip_tos = 0;
+    ip->ip_off = 0;
+    ip->ip_ttl = 255;
+
+    ip->ip_sum = 0;
+#if HAVE_FAST_CHECKSUM
+    ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
+#else
+    ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
+#endif
+    
+    // set up UDP header
+    udp->uh_sport = htons(sport);
+    udp->uh_dport = htons(dport);
+    uint16_t len = packetlen - sizeof(click_ip);
+    udp->uh_ulen = htons(len);
+    udp->uh_sum = 0;
+    unsigned csum = click_in_cksum((unsigned char *)udp, len);
+    udp->uh_sum = click_in_cksum_pseudohdr(csum, ip, len);
+  
+    // Send the packet
+    send(pkt, 0);
+    ipseq_++;
+}
+
+void RawAgent::recv(Packet* pkt, Handler*)
+{
+  // Access the raw header for the received packet
+  hdr_raw* hdr = hdr_raw::access(pkt);
+
+  if (hdr_raw::PSTRING == hdr->subtype) {
+    unsigned char* pdat = pkt->accessdata();
+    unsigned int len = pdat[0];
+
+    // Shovel the string to the screen...
+    fwrite(pdat+1,sizeof(char),len,stdout);
+  }
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/common/rawpacket.h ns-2.34/common/rawpacket.h
--- ns-2.34-pure/common/rawpacket.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/common/rawpacket.h	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,91 @@
+/*
+ * rawpacket.h
+ *
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+/*
+ * Raw packet type. 
+ */
+struct hdr_raw {
+  /*
+   * This indicates the actual type of the stuff in the
+   * packet. The actual packet stuff is pointed to by 
+   * the data thing.
+   */
+  int subtype;
+
+  /*
+   * Not many raw subtypes defined so far.
+   */
+  enum {
+    NONE,
+    PSTRING,
+    IP,
+    ETHERNET,
+    MADWIFI
+  };
+
+  /*
+   * This is the equivalent packet type in ns-2. Sometimes we
+   * want to maintain the raw packet data _and_ the ns-2 headers
+   * for that particular type in parallel, e.g. so we can use
+   * the existing ns-2 trace printing routines. However, we
+   * still want to keep the packet type as PT_RAW, so we store
+   * the ns-2 type in this field.
+   */
+  int ns_type;
+ 
+  /* Packet header access functions */
+  static int offset_;
+  inline static int& offset() { return offset_; }
+  inline static hdr_raw* access(const Packet* p) {
+    return (hdr_raw*) p->access(offset_);
+  }
+};
+
+/*
+ * The base RawAgent class
+ */
+class RawAgent : public Agent {
+ public:
+  RawAgent();
+  int command(int argc,const char*const* argv);
+  void recv(Packet*, Handler*);
+  virtual void sendmsg(int nbytes, const char *flags = 0);
+ protected:
+  void send_udp_str(u_long saddr,u_short sport,u_long daddr,u_short dport,
+		    const char* payload);
+  void send_udp(u_long saddr,u_short sport,u_long daddr,u_short dport,
+		const char* payload,int paylen);
+
+  u_int16_t ipseq_;
+  u_long srcip_;
+  u_short srcport_;
+  u_long destip_;
+  u_short destport_;
+};
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/conf/configure.in.click ns-2.34/conf/configure.in.click
--- ns-2.34-pure/conf/configure.in.click	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/conf/configure.in.click	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,29 @@
+dnl autoconf rules to find click - copied from dmalloc example
+
+AC_ARG_WITH(click,	--with-click=path specify a pathname for the click modular router, d="$withval", d="")
+
+CLICK_VERS=1.3
+
+CLICK_PATH="$PWD/../click \
+	$PWD/../../click \
+	$PWD/../click-$CLICK_VERS \
+	$PWD/../../click-$CLICK_VERS \
+	$PWD/../click/include \
+	$PWD/../../click/include \
+	$PWD/../click-$CLICK_VERS/include \
+	$PWD/../../click-$CLICK_VERS/include \
+	$PWD/../click/ns \
+	$PWD/../../click/ns \
+	$PWD/../click-$CLICK_VERS/ns \
+	$PWD/../../click-$CLICK_VERS/ns \
+	"
+CLICK_PATH_D="$d \
+	$d/lib \
+	$d/include \
+	"
+
+NS_BEGIN_PACKAGE(click)
+NS_CHECK_HEADER_PATH(click/simclick.h,$CLICK_PATH,$d,$CLICK_PATH_D,V_HEADER_CLICK,click)
+NS_CHECK_LIB_PATH(nsclick,$CLICK_PATH,$d,$CLICK_PATH_D,V_LIB_CLICK,click)
+V_DEFINES="-DCLICK_NS $V_DEFINES"
+NS_END_PACKAGE(click,yes)
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/configure ns-2.34/configure
--- ns-2.34-pure/configure	2009-06-14 10:35:07.000000000 -0700
+++ ns-2.34/configure	2010-02-28 09:31:39.000000000 -0800
@@ -1428,6 +1428,7 @@
 --with-tclcl=path	specify a pathname for TclCL (the ex-libTcl)
 --with-tcldebug=path specify a pathname for the tcl debugger (path=no disables the debugger)
 --with-dmalloc=path specify a pathname for the dmalloc debugger (path=no disables the dmalloc)
+--with-click=path specify a pathname for the click modular router
 --with-perl=path specify a pathname for perl
 
 Some influential environment variables:
@@ -1500,7 +1501,7 @@
     else
       $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi || ac_status=$?
-    cd "$ac_pwd" || { ac_status=$?; break; }
+    cd $ac_pwd || { ac_status=$?; break; }
   done
 fi
 
@@ -8525,6 +8526,207 @@
 
 
 
+
+
+# Check whether --with-click or --without-click was given.
+if test "${with_click+set}" = set; then
+  withval="$with_click"
+  d="$withval"
+else
+  d=""
+fi;
+
+CLICK_VERS=1.3
+
+CLICK_PATH="$PWD/../click \
+	$PWD/../../click \
+	$PWD/../click-$CLICK_VERS \
+	$PWD/../../click-$CLICK_VERS \
+	$PWD/../click/include \
+	$PWD/../../click/include \
+	$PWD/../click-$CLICK_VERS/include \
+	$PWD/../../click-$CLICK_VERS/include \
+	$PWD/../click/ns \
+	$PWD/../../click/ns \
+	$PWD/../click-$CLICK_VERS/ns \
+	$PWD/../../click-$CLICK_VERS/ns \
+	"
+CLICK_PATH_D="$d \
+	$d/lib \
+	$d/include \
+	"
+
+
+NS_PACKAGE_click_UNDERWAY=false
+NS_PACKAGE_click_COMPLETE=true
+
+
+echo "$as_me:$LINENO: checking for click/simclick.h" >&5
+echo $ECHO_N "checking for click/simclick.h... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable header
+	V_HEADER_CLICK=FAIL
+
+NS_PACKAGE_click_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$CLICK_PATH"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$CLICK_PATH_D"
+	fi
+
+	V_HEADER_CLICK=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/click/simclick.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_HEADER_CLICK="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_click_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+
+				  ac_tr_hdr=HAVE_`echo click/simclick.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_HEADER_CLICK $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_click_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_HEADER_CLICK" >&5
+echo "${ECHO_T}$V_HEADER_CLICK" >&6
+	fi
+fi
+
+
+echo "$as_me:$LINENO: checking for libnsclick" >&5
+echo $ECHO_N "checking for libnsclick... $ECHO_C" >&6
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_CLICK=FAIL
+
+NS_PACKAGE_click_COMPLETE=false
+
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+else
+	places="$CLICK_PATH"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { echo "$as_me:$LINENO: error: $d is not a directory" >&5
+echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$CLICK_PATH_D"
+	fi
+
+	V_LIB_CLICK=""
+		full_lib_name="nsclick"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_CLICK="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_CLICK" = "FAIL" ; then
+
+NS_PACKAGE_click_COMPLETE=false
+
+		echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	else
+		if test "$solaris"; then
+			V_LIB_CLICK="-R$dir $V_LIB_CLICK"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo nsclick | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_CLICK $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_click_UNDERWAY=true
+
+		echo "$as_me:$LINENO: result: $V_LIB_CLICK" >&5
+echo "${ECHO_T}$V_LIB_CLICK" >&6
+	fi
+fi
+
+V_DEFINES="-DCLICK_NS $V_DEFINES"
+
+NS_PACKAGE_click_VALID=false
+if $NS_PACKAGE_click_UNDERWAY; then
+	if $NS_PACKAGE_click_COMPLETE; then
+		: All components of click found.
+		NS_PACKAGE_click_VALID=true
+	else
+		{ { echo "$as_me:$LINENO: error: Installation of click seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where click is
+using the argument --with-click=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-click=no." >&5
+echo "$as_me: error: Installation of click seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where click is
+using the argument --with-click=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-click=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xyes" = xyes; then
+	if $NS_PACKAGE_click_VALID; then
+		:
+	else
+		{ { echo "$as_me:$LINENO: error: click is required but could not be completely found.
+Please correct the problem by telling configure where click is
+using the argument --with-click=/path/to/package,
+or the package is not required, disable it with --with-click=no." >&5
+echo "$as_me: error: click is required but could not be completely found.
+Please correct the problem by telling configure where click is
+using the argument --with-click=/path/to/package,
+or the package is not required, disable it with --with-click=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+
 default_classinstvar=yes
 
 
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/configure.in ns-2.34/configure.in
--- ns-2.34-pure/configure.in	2009-06-14 10:35:07.000000000 -0700
+++ ns-2.34/configure.in	2010-02-28 09:31:39.000000000 -0800
@@ -26,6 +26,7 @@
 builtin(include, ./conf/configure.in.x11)
 builtin(include, ./conf/configure.in.tcldebug)
 builtin(include, ./conf/configure.in.dmalloc)
+builtin(include, ./conf/configure.in.click)
 default_classinstvar=yes
 builtin(include, ./conf/configure.in.debugopts)
 
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/configure.in.orig ns-2.34/configure.in.orig
--- ns-2.34-pure/configure.in.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/configure.in.orig	2009-06-14 10:35:07.000000000 -0700
@@ -0,0 +1,98 @@
+dnl Process this file with autoconf to produce a configure script.
+dnl
+
+AC_INIT(ns_tclsh.cc)
+
+AC_GNU_SOURCE
+
+AC_CONFIG_HEADER(autoconf.h)
+
+V_PROG="ns"
+V_LIB=""
+V_SHELL=""
+
+builtin(include, ./conf/configure.in.fns)
+
+dnl default to non-static
+enable_static=no
+
+builtin(include, ./conf/configure.in.head)
+builtin(include, ./conf/configure.in.stl)
+builtin(include, ./conf/configure.in.tcl)
+builtin(include, ./conf/configure.in.tk)
+builtin(include, ./conf/configure.in.otcl)
+builtin(include, ./conf/configure.in.TclCL)
+builtin(include, ./conf/configure.in.misc)
+builtin(include, ./conf/configure.in.x11)
+builtin(include, ./conf/configure.in.tcldebug)
+builtin(include, ./conf/configure.in.dmalloc)
+default_classinstvar=yes
+builtin(include, ./conf/configure.in.debugopts)
+
+PERL_OPTIONAL=true
+builtin(include, ./conf/configure.in.perl)
+if test "x$PERL" = x
+then
+	AC_MSG_WARN([Perl5 not found; test scripts will not run succesfully.])
+fi
+
+AC_HEADER_STDC
+
+dnl AC_CHECK_FUNCS will place -D's in @DEFS@
+AC_CHECK_HEADERS(arpa/inet.h fenv.h netinet/in.h string.h strings.h time.h unistd.h net/ethernet.h)
+dnl check for libm is needed for subseq checks
+AC_CHECK_LIB(m, main, , AC_MSG_ERROR(Could not find math library, cannot continue.))
+AC_CHECK_FUNCS(bcopy bzero fesetprecision feenableexcept getrusage sbrk snprintf)
+
+dnl
+dnl figure out random return type
+dnl
+AC_MSG_CHECKING(return type of random)
+touch confdefs.h
+AC_TRY_RUN([#include <stdlib.h>
+#include "confdefs.h"
+long random() { return 1; }
+main() { exit(0); }
+],
+AC_MSG_RESULT(long)
+AC_DEFINE(RANDOM_RETURN_TYPE,long)
+,
+AC_MSG_RESULT(int)
+AC_DEFINE(RANDOM_RETURN_TYPE,int)
+,
+AC_MSG_RESULT(cross compiling--guessing int)
+AC_DEFINE(RANDOM_RETURN_TYPE,int)
+)
+
+dnl
+dnl check some types
+dnl
+AC_CHECK_TYPE(int8_t,signed char)
+AC_CHECK_TYPE(int16_t,short)
+AC_CHECK_TYPE(int32_t,int)
+AC_CHECK_TYPE(u_int8_t,unsigned char)
+AC_CHECK_TYPE(u_int16_t,unsigned short)
+AC_CHECK_TYPE(u_int32_t,unsigned int)
+AC_CHECK_TYPE(u_char, unsigned char)
+AC_CHECK_TYPE(u_int, unsigned int)
+
+builtin(include, ./conf/configure.in.int64_t)
+
+
+dnl dynamic library support
+builtin(include, ./conf/configure.in.dynamic)
+AC_CHECK_HEADER([dlfcn.h], , [ AC_MSG_ERROR([cannot find dlfcn.h]) ])
+AC_MSG_CHECKING([for ns library name])
+NSLIB=libns${SHLIB_SUFFIX}
+AC_MSG_RESULT([$NSLIB])
+AC_SUBST(NSLIB)
+
+
+
+
+dnl Look for emulation specific stuff
+builtin(include, ./conf/configure.in.nse)
+
+NS_FNS_TAIL
+define(AcOutputFiles,Makefile tcl/lib/ns-autoconf.tcl indep-utils/webtrace-conv/ucb/Makefile indep-utils/webtrace-conv/dec/Makefile indep-utils/webtrace-conv/nlanr/Makefile indep-utils/webtrace-conv/epa/Makefile indep-utils/cmu-scen-gen/setdest/Makefile)
+builtin(include, ./conf/configure.in.tail)
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/configure.orig ns-2.34/configure.orig
--- ns-2.34-pure/configure.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/configure.orig	2009-06-14 10:35:07.000000000 -0700
@@ -0,0 +1,14135 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.63.
+#
+# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+# 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+
+
+# PATH needs CR
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+if (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  { (exit 1); exit 1; }
+fi
+
+# Work around bugs in pre-3.0 UWIN ksh.
+for as_var in ENV MAIL MAILPATH
+do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# CDPATH.
+$as_unset CDPATH
+
+
+if test "x$CONFIG_SHELL" = x; then
+  if (eval ":") 2>/dev/null; then
+  as_have_required=yes
+else
+  as_have_required=no
+fi
+
+  if test $as_have_required = yes &&	 (eval ":
+(as_func_return () {
+  (exit \$1)
+}
+as_func_success () {
+  as_func_return 0
+}
+as_func_failure () {
+  as_func_return 1
+}
+as_func_ret_success () {
+  return 0
+}
+as_func_ret_failure () {
+  return 1
+}
+
+exitcode=0
+if as_func_success; then
+  :
+else
+  exitcode=1
+  echo as_func_success failed.
+fi
+
+if as_func_failure; then
+  exitcode=1
+  echo as_func_failure succeeded.
+fi
+
+if as_func_ret_success; then
+  :
+else
+  exitcode=1
+  echo as_func_ret_success failed.
+fi
+
+if as_func_ret_failure; then
+  exitcode=1
+  echo as_func_ret_failure succeeded.
+fi
+
+if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
+  :
+else
+  exitcode=1
+  echo positional parameters were not saved.
+fi
+
+test \$exitcode = 0) || { (exit 1); exit 1; }
+
+(
+  as_lineno_1=\$LINENO
+  as_lineno_2=\$LINENO
+  test \"x\$as_lineno_1\" != \"x\$as_lineno_2\" &&
+  test \"x\`expr \$as_lineno_1 + 1\`\" = \"x\$as_lineno_2\") || { (exit 1); exit 1; }
+") 2> /dev/null; then
+  :
+else
+  as_candidate_shells=
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  case $as_dir in
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     as_candidate_shells="$as_candidate_shells $as_dir/$as_base"
+	   done;;
+       esac
+done
+IFS=$as_save_IFS
+
+
+      for as_shell in $as_candidate_shells $SHELL; do
+	 # Try only shells that exist, to save several forks.
+	 if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		{ ("$as_shell") 2> /dev/null <<\_ASEOF
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+:
+_ASEOF
+}; then
+  CONFIG_SHELL=$as_shell
+	       as_have_required=yes
+	       if { "$as_shell" 2> /dev/null <<\_ASEOF
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+:
+(as_func_return () {
+  (exit $1)
+}
+as_func_success () {
+  as_func_return 0
+}
+as_func_failure () {
+  as_func_return 1
+}
+as_func_ret_success () {
+  return 0
+}
+as_func_ret_failure () {
+  return 1
+}
+
+exitcode=0
+if as_func_success; then
+  :
+else
+  exitcode=1
+  echo as_func_success failed.
+fi
+
+if as_func_failure; then
+  exitcode=1
+  echo as_func_failure succeeded.
+fi
+
+if as_func_ret_success; then
+  :
+else
+  exitcode=1
+  echo as_func_ret_success failed.
+fi
+
+if as_func_ret_failure; then
+  exitcode=1
+  echo as_func_ret_failure succeeded.
+fi
+
+if ( set x; as_func_ret_success y && test x = "$1" ); then
+  :
+else
+  exitcode=1
+  echo positional parameters were not saved.
+fi
+
+test $exitcode = 0) || { (exit 1); exit 1; }
+
+(
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2") || { (exit 1); exit 1; }
+
+_ASEOF
+}; then
+  break
+fi
+
+fi
+
+      done
+
+      if test "x$CONFIG_SHELL" != x; then
+  for as_var in BASH_ENV ENV
+	do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+	done
+	export CONFIG_SHELL
+	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
+fi
+
+
+    if test $as_have_required = no; then
+  echo This script requires a shell more modern than all the
+      echo shells that I found on your system.  Please install a
+      echo modern shell, or manually run the script under such a
+      echo shell if you do have one.
+      { (exit 1); exit 1; }
+fi
+
+
+fi
+
+fi
+
+
+
+(eval "as_func_return () {
+  (exit \$1)
+}
+as_func_success () {
+  as_func_return 0
+}
+as_func_failure () {
+  as_func_return 1
+}
+as_func_ret_success () {
+  return 0
+}
+as_func_ret_failure () {
+  return 1
+}
+
+exitcode=0
+if as_func_success; then
+  :
+else
+  exitcode=1
+  echo as_func_success failed.
+fi
+
+if as_func_failure; then
+  exitcode=1
+  echo as_func_failure succeeded.
+fi
+
+if as_func_ret_success; then
+  :
+else
+  exitcode=1
+  echo as_func_ret_success failed.
+fi
+
+if as_func_ret_failure; then
+  exitcode=1
+  echo as_func_ret_failure succeeded.
+fi
+
+if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
+  :
+else
+  exitcode=1
+  echo positional parameters were not saved.
+fi
+
+test \$exitcode = 0") || {
+  echo No shell found that supports shell functions.
+  echo Please tell bug-autoconf@gnu.org about your system,
+  echo including any error possibly output before this message.
+  echo This can help us improve future autoconf versions.
+  echo Configuration will now proceed without shell functions.
+}
+
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line after each line using $LINENO; the second 'sed'
+  # does the real work.  The second script uses 'N' to pair each
+  # line-number line with the line containing $LINENO, and appends
+  # trailing '-' during substitution so that $LINENO is not a special
+  # case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # scripts with optimization help from Paolo Bonzini.  Blame Lee
+  # E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in
+-n*)
+  case `echo 'x\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  *)   ECHO_C='\c';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+
+exec 7<&0 </dev/null 6>&1
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+
+ac_unique_file="ns_tclsh.cc"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_STRING_H
+# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='LTLIBOBJS
+LIBOBJS
+INSTALL_DATA
+INSTALL_SCRIPT
+INSTALL_PROGRAM
+V_LSSCRIPT
+V_NS_TCL_LIB_STL
+V_STLOBJ
+V_AR
+V_RANLIB
+V_OBJ_CRYPT
+V_BROKEN_OBJ
+V_OBJ
+V_INCLUDE
+V_TARCMD
+V_SHELL
+V_SIGRET
+V_DEFINE
+V_LIB
+V_TAR_EXTRA
+V_CCOPT
+V_ALL
+V_LIB_TK
+V_LIB_TCL
+V_LIB_OTCL
+V_LIB_TCLCL
+V_TAR_TARGET
+V_STATIC
+V_DEFINES
+V_LIBS
+V_INCLUDES
+build_nse
+NSLIB
+PKG_SHLIB_CFLAGS
+SHLIB_SUFFIX
+SHLIB_LD_LIBS
+SHLIB_LD
+SHLIB_CFLAGS
+DL_LD_SEARCH_FLAGS
+DL_LD_FLAGS
+DL_LIBS
+V_IMPORT_LIBS
+PERL
+V_LIB_X11
+V_INCLUDE_X11
+V_TCL2CPP
+V_LIBRARY_TK
+V_TKDOSNAMES
+V_LIBRARY_TCL
+V_TCLSH
+V_TCL_LIBRARY_FILES
+CPP_NAMESPACE
+ac_ct_CXX
+CXXFLAGS
+CXX
+target_os
+target_vendor
+target_cpu
+target
+host_os
+host_vendor
+host_cpu
+host
+build_os
+build_vendor
+build_cpu
+build
+EGREP
+GREP
+CPP
+OBJEXT
+EXEEXT
+ac_ct_CC
+CPPFLAGS
+LDFLAGS
+CFLAGS
+CC
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
+ac_subst_files=''
+ac_user_opts='
+enable_option_checking
+with_defaultoptions
+enable_release
+enable_debug
+enable_devel
+enable_static
+enable_stl
+with_tcl
+with_tcl_ver
+with_tk
+with_tk_ver
+with_otcl
+with_Tcl
+with_tclcl
+with_tcldebug
+with_dmalloc
+enable_tclcl_classinstvar
+with_perl
+enable_shlib
+'
+      ac_precious_vars='build_alias
+host_alias
+target_alias
+CC
+CFLAGS
+LDFLAGS
+LIBS
+CPPFLAGS
+CPP
+CXX
+CXXFLAGS
+CCC'
+
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+ac_unrecognized_opts=
+ac_unrecognized_sep=
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+# (The list follows the same order as the GNU Coding Standards.)
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datarootdir='${prefix}/share'
+datadir='${datarootdir}'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+docdir='${datarootdir}/doc/${PACKAGE}'
+infodir='${datarootdir}/info'
+htmldir='${docdir}'
+dvidir='${docdir}'
+pdfdir='${docdir}'
+psdir='${docdir}'
+libdir='${exec_prefix}/lib'
+localedir='${datarootdir}/locale'
+mandir='${datarootdir}/man'
+
+ac_prev=
+ac_dashdash=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval $ac_prev=\$ac_option
+    ac_prev=
+    continue
+  fi
+
+  case $ac_option in
+  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *)	ac_optarg=yes ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_dashdash$ac_option in
+  --)
+    ac_dashdash=yes ;;
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+    datadir=$ac_optarg ;;
+
+  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
+  | --dataroo | --dataro | --datar)
+    ac_prev=datarootdir ;;
+  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
+  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
+    datarootdir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid feature name: $ac_useropt" >&2
+   { (exit 1); exit 1; }; }
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=no ;;
+
+  -docdir | --docdir | --docdi | --doc | --do)
+    ac_prev=docdir ;;
+  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
+    docdir=$ac_optarg ;;
+
+  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
+    ac_prev=dvidir ;;
+  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
+    dvidir=$ac_optarg ;;
+
+  -enable-* | --enable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid feature name: $ac_useropt" >&2
+   { (exit 1); exit 1; }; }
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=\$ac_optarg ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
+    ac_prev=htmldir ;;
+  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
+  | --ht=*)
+    htmldir=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localedir | --localedir | --localedi | --localed | --locale)
+    ac_prev=localedir ;;
+  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
+    localedir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst | --locals)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
+    ac_prev=pdfdir ;;
+  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
+    pdfdir=$ac_optarg ;;
+
+  -psdir | --psdir | --psdi | --psd | --ps)
+    ac_prev=psdir ;;
+  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
+    psdir=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid package name: $ac_useropt" >&2
+   { (exit 1); exit 1; }; }
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=\$ac_optarg ;;
+
+  -without-* | --without-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid package name: $ac_useropt" >&2
+   { (exit 1); exit 1; }; }
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=no ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { $as_echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { $as_echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    eval $ac_envvar=\$ac_optarg
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { $as_echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+if test -n "$ac_unrecognized_opts"; then
+  case $enable_option_checking in
+    no) ;;
+    fatal) { $as_echo "$as_me: error: unrecognized options: $ac_unrecognized_opts" >&2
+   { (exit 1); exit 1; }; } ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+  esac
+fi
+
+# Check all directory arguments for consistency.
+for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
+		datadir sysconfdir sharedstatedir localstatedir includedir \
+		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
+		libdir localedir mandir
+do
+  eval ac_val=\$$ac_var
+  # Remove trailing slashes.
+  case $ac_val in
+    */ )
+      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
+      eval $ac_var=\$ac_val;;
+  esac
+  # Be sure to have absolute directory names.
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* )  continue;;
+    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+  esac
+  { $as_echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; }
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+ac_pwd=`pwd` && test -n "$ac_pwd" &&
+ac_ls_di=`ls -di .` &&
+ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
+  { $as_echo "$as_me: error: working directory cannot be determined" >&2
+   { (exit 1); exit 1; }; }
+test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
+  { $as_echo "$as_me: error: pwd does not report name of working directory" >&2
+   { (exit 1); exit 1; }; }
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then the parent directory.
+  ac_confdir=`$as_dirname -- "$as_myself" ||
+$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_myself" : 'X\(//\)[^/]' \| \
+	 X"$as_myself" : 'X\(//\)$' \| \
+	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_myself" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r "$srcdir/$ac_unique_file"; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r "$srcdir/$ac_unique_file"; then
+  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
+  { $as_echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+fi
+ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
+ac_abs_confdir=`(
+	cd "$srcdir" && test -r "./$ac_unique_file" || { $as_echo "$as_me: error: $ac_msg" >&2
+   { (exit 1); exit 1; }; }
+	pwd)`
+# When building in place, set srcdir=.
+if test "$ac_abs_confdir" = "$ac_pwd"; then
+  srcdir=.
+fi
+# Remove unnecessary trailing slashes from srcdir.
+# Double slashes in file names in object file debugging info
+# mess up M-x gdb in Emacs.
+case $srcdir in
+*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
+esac
+for ac_var in $ac_precious_vars; do
+  eval ac_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_env_${ac_var}_value=\$${ac_var}
+  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_cv_env_${ac_var}_value=\$${ac_var}
+done
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR            user executables [EPREFIX/bin]
+  --sbindir=DIR           system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR        program executables [EPREFIX/libexec]
+  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --libdir=DIR            object code libraries [EPREFIX/lib]
+  --includedir=DIR        C header files [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
+  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
+  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
+  --infodir=DIR           info documentation [DATAROOTDIR/info]
+  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
+  --mandir=DIR            man documentation [DATAROOTDIR/man]
+  --docdir=DIR            documentation root [DATAROOTDIR/doc/PACKAGE]
+  --htmldir=DIR           html documentation [DOCDIR]
+  --dvidir=DIR            dvi documentation [DOCDIR]
+  --pdfdir=DIR            pdf documentation [DOCDIR]
+  --psdir=DIR             ps documentation [DOCDIR]
+_ACEOF
+
+  cat <<\_ACEOF
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-option-checking  ignore unrecognized --enable/--with options
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+--enable-release	do a release build
+--enable-debug		build with debugging enabled
+--enable-devel		do a development build
+--enable-static	enable/disable static building
+--enable-stl		include code that needs the Standard Template Library
+--enable-tclcl-classinstvar	assume classinstvars are present in tclcl
+--enable-shlib          enable Makefile targets for mash shared libraries
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+-with-defaultoptions=filename	use <filename> as default options file
+--with-tcl=path	specify a pathname for tcl
+--with-tcl-ver=path specify the version of tcl/tk
+--with-tk=path	specify a pathname for tk
+--with-tk-ver=path specify the version of tcl/tk
+--with-otcl=path	specify a pathname for otcl
+--with-Tcl: old command now replaced by --with-tclcl
+--with-tclcl=path	specify a pathname for TclCL (the ex-libTcl)
+--with-tcldebug=path specify a pathname for the tcl debugger (path=no disables the debugger)
+--with-dmalloc=path specify a pathname for the dmalloc debugger (path=no disables the dmalloc)
+--with-perl=path specify a pathname for perl
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  LIBS        libraries to pass to the linker, e.g. -l<library>
+  CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
+              you have headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+  CXX         C++ compiler command
+  CXXFLAGS    C++ compiler flags
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+_ACEOF
+ac_status=$?
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d "$ac_dir" ||
+      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
+      continue
+    ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+    cd "$ac_dir" || { ac_status=$?; continue; }
+    # Check for guested configure.
+    if test -f "$ac_srcdir/configure.gnu"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
+    elif test -f "$ac_srcdir/configure"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure" --help=recursive
+    else
+      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi || ac_status=$?
+    cd "$ac_pwd" || { ac_status=$?; break; }
+  done
+fi
+
+test -n "$ac_init_help" && exit $ac_status
+if $ac_init_version; then
+  cat <<\_ACEOF
+configure
+generated by GNU Autoconf 2.63
+
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit
+fi
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.63.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  $as_echo "PATH: $as_dir"
+done
+IFS=$as_save_IFS
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args="$ac_configure_args '$ac_arg'"
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) $as_unset $ac_var ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      $as_echo "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------------- ##
+## File substitutions. ##
+## ------------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	$as_echo "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      $as_echo "$as_me: caught signal $ac_signal"
+    $as_echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer an explicitly selected file to automatically selected ones.
+ac_site_file1=NONE
+ac_site_file2=NONE
+if test -n "$CONFIG_SITE"; then
+  ac_site_file1=$CONFIG_SITE
+elif test "x$prefix" != xNONE; then
+  ac_site_file1=$prefix/share/config.site
+  ac_site_file2=$prefix/etc/config.site
+else
+  ac_site_file1=$ac_default_prefix/share/config.site
+  ac_site_file2=$ac_default_prefix/etc/config.site
+fi
+for ac_site_file in "$ac_site_file1" "$ac_site_file2"
+do
+  test "x$ac_site_file" = xNONE && continue
+  if test -r "$ac_site_file"; then
+    { $as_echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+$as_echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { $as_echo "$as_me:$LINENO: loading cache $cache_file" >&5
+$as_echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { $as_echo "$as_me:$LINENO: creating cache $cache_file" >&5
+$as_echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { $as_echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { $as_echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { $as_echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	  ac_cache_corrupted=:
+	else
+	  { $as_echo "$as_me:$LINENO: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ $as_echo "$as_me:$LINENO:   former value:  \`$ac_old_val'" >&5
+$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ $as_echo "$as_me:$LINENO:   current value: \`$ac_new_val'" >&5
+$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+  { $as_echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { $as_echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+$as_echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }; }
+
+# Provide some information about the compiler.
+$as_echo "$as_me:$LINENO: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+{ (ac_try="$ac_compiler --version >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler --version >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -v >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -v >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -V >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -V >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+{ $as_echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
+$as_echo_n "checking for C compiler default output file name... " >&6; }
+ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+
+# The possible output files:
+ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
+
+ac_rmfiles=
+for ac_file in $ac_files
+do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
+  esac
+done
+rm -f $ac_rmfiles
+
+if { (ac_try="$ac_link_default"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link_default") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
+# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
+# in a Makefile.  We should not override ac_cv_exeext if it was cached,
+# so that the user can short-circuit this test for compilers unknown to
+# Autoconf.
+for ac_file in $ac_files ''
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+        if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	then :; else
+	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	fi
+	# We set ac_cv_exeext here because the later test for it is not
+	# safe: cross compilers may not add the suffix if given an `-o'
+	# argument, so we may need to know it at that point already.
+	# Even if this section looks crufty: it has the advantage of
+	# actually working.
+	break;;
+    * )
+	break;;
+  esac
+done
+test "$ac_cv_exeext" = no && ac_cv_exeext=
+
+else
+  ac_file=''
+fi
+
+{ $as_echo "$as_me:$LINENO: result: $ac_file" >&5
+$as_echo "$ac_file" >&6; }
+if test -z "$ac_file"; then
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: C compiler cannot create executables
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: C compiler cannot create executables
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }; }
+fi
+
+ac_exeext=$ac_cv_exeext
+
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ $as_echo "$as_me:$LINENO: checking whether the C compiler works" >&5
+$as_echo_n "checking whether the C compiler works... " >&6; }
+# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
+# If not cross compiling, check that we can run a simple program.
+if test "$cross_compiling" != yes; then
+  if { ac_try='./$ac_file'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }; }
+    fi
+  fi
+fi
+{ $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+
+rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ $as_echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+$as_echo_n "checking whether we are cross compiling... " >&6; }
+{ $as_echo "$as_me:$LINENO: result: $cross_compiling" >&5
+$as_echo "$cross_compiling" >&6; }
+
+{ $as_echo "$as_me:$LINENO: checking for suffix of executables" >&5
+$as_echo_n "checking for suffix of executables... " >&6; }
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }; }
+fi
+
+rm -f conftest$ac_cv_exeext
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+$as_echo "$ac_cv_exeext" >&6; }
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+{ $as_echo "$as_me:$LINENO: checking for suffix of object files" >&5
+$as_echo_n "checking for suffix of object files... " >&6; }
+if test "${ac_cv_objext+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  for ac_file in conftest.o conftest.obj conftest.*; do
+  test -f "$ac_file" || continue;
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }; }
+fi
+
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+$as_echo "$ac_cv_objext" >&6; }
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+{ $as_echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+if test "${ac_cv_c_compiler_gnu+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_compiler_gnu=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_compiler_gnu=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if test "${ac_cv_prog_cc_g+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_g=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	CFLAGS=""
+      cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_g=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ $as_echo "$as_me:$LINENO: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+if test "${ac_cv_prog_cc_c89+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_c89=$ac_arg
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { $as_echo "$as_me:$LINENO: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
+  xno)
+    { $as_echo "$as_me:$LINENO: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+$as_echo_n "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  # Broken: success on invalid input.
+continue
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+{ $as_echo "$as_me:$LINENO: result: $CPP" >&5
+$as_echo "$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  # Broken: success on invalid input.
+continue
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+{ $as_echo "$as_me:$LINENO: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+if test "${ac_cv_path_GREP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$GREP"; then
+  ac_path_GREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_prog in grep ggrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+# Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    ac_count=`expr $ac_count + 1`
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_GREP_found && break 3
+    done
+  done
+done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_GREP"; then
+    { { $as_echo "$as_me:$LINENO: error: no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
+$as_echo "$as_me: error: no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+else
+  ac_cv_path_GREP=$GREP
+fi
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_GREP" >&5
+$as_echo "$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
+
+
+{ $as_echo "$as_me:$LINENO: checking for egrep" >&5
+$as_echo_n "checking for egrep... " >&6; }
+if test "${ac_cv_path_EGREP+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
+   else
+     if test -z "$EGREP"; then
+  ac_path_EGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_prog in egrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+# Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    ac_count=`expr $ac_count + 1`
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_EGREP_found && break 3
+    done
+  done
+done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_EGREP"; then
+    { { $as_echo "$as_me:$LINENO: error: no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
+$as_echo "$as_me: error: no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+else
+  ac_cv_path_EGREP=$EGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_EGREP" >&5
+$as_echo "$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
+
+
+{ $as_echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if test "${ac_cv_header_stdc+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_header_stdc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_header_stdc=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+
+
+
+
+
+
+
+
+
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  eval "$as_ac_Header=yes"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_Header=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+  if test "${ac_cv_header_minix_config_h+set}" = set; then
+  { $as_echo "$as_me:$LINENO: checking for minix/config.h" >&5
+$as_echo_n "checking for minix/config.h... " >&6; }
+if test "${ac_cv_header_minix_config_h+set}" = set; then
+  $as_echo_n "(cached) " >&6
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_minix_config_h" >&5
+$as_echo "$ac_cv_header_minix_config_h" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:$LINENO: checking minix/config.h usability" >&5
+$as_echo_n "checking minix/config.h usability... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <minix/config.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:$LINENO: checking minix/config.h presence" >&5
+$as_echo_n "checking minix/config.h presence... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <minix/config.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: minix/config.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: minix/config.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: minix/config.h: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: minix/config.h:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: minix/config.h: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: minix/config.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h: proceeding with the preprocessor's result" >&5
+$as_echo "$as_me: WARNING: minix/config.h: proceeding with the preprocessor's result" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: minix/config.h: in the future, the compiler will take precedence" >&5
+$as_echo "$as_me: WARNING: minix/config.h: in the future, the compiler will take precedence" >&2;}
+
+    ;;
+esac
+{ $as_echo "$as_me:$LINENO: checking for minix/config.h" >&5
+$as_echo_n "checking for minix/config.h... " >&6; }
+if test "${ac_cv_header_minix_config_h+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_header_minix_config_h=$ac_header_preproc
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_minix_config_h" >&5
+$as_echo "$ac_cv_header_minix_config_h" >&6; }
+
+fi
+if test "x$ac_cv_header_minix_config_h" = x""yes; then
+  MINIX=yes
+else
+  MINIX=
+fi
+
+
+  if test "$MINIX" = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define _POSIX_SOURCE 1
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define _POSIX_1_SOURCE 2
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define _MINIX 1
+_ACEOF
+
+  fi
+
+
+
+  { $as_echo "$as_me:$LINENO: checking whether it is safe to define __EXTENSIONS__" >&5
+$as_echo_n "checking whether it is safe to define __EXTENSIONS__... " >&6; }
+if test "${ac_cv_safe_to_define___extensions__+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#	  define __EXTENSIONS__ 1
+	  $ac_includes_default
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_safe_to_define___extensions__=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_safe_to_define___extensions__=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_safe_to_define___extensions__" >&5
+$as_echo "$ac_cv_safe_to_define___extensions__" >&6; }
+  test $ac_cv_safe_to_define___extensions__ = yes &&
+    cat >>confdefs.h <<\_ACEOF
+#define __EXTENSIONS__ 1
+_ACEOF
+
+  cat >>confdefs.h <<\_ACEOF
+#define _ALL_SOURCE 1
+_ACEOF
+
+  cat >>confdefs.h <<\_ACEOF
+#define _GNU_SOURCE 1
+_ACEOF
+
+  cat >>confdefs.h <<\_ACEOF
+#define _POSIX_PTHREAD_SEMANTICS 1
+_ACEOF
+
+  cat >>confdefs.h <<\_ACEOF
+#define _TANDEM_SOURCE 1
+_ACEOF
+
+
+
+ac_config_headers="$ac_config_headers autoconf.h"
+
+
+V_PROG="ns"
+V_LIB=""
+V_SHELL=""
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+enable_static=no
+
+
+
+
+# Check whether --with-defaultoptions was given.
+if test "${with_defaultoptions+set}" = set; then
+  withval=$with_defaultoptions;
+else
+  with_defaultoptions=".configure"
+fi
+
+
+if test "$with_defaultoptions" = "yes" ; then
+	with_defaultoptions=".configure"
+elif test "$with_defaultoptions" = "no" ; then
+	with_defaultoptions=""
+fi
+
+if test -n "$with_defaultoptions" ; then
+	if test -f "$with_defaultoptions" ; then
+		read arglist < $with_defaultoptions
+
+		if test -n "$arglist" ; then
+			arguments="$0 $arglist $* --without-defaultoptions"
+			echo "Restarting: $arguments"
+			exec $arguments
+		fi
+	else
+		if test "$with_defaultoptions" = ".configure" ; then
+			echo No .configure file found in current directory
+			echo Continuing with default options...
+		else
+			echo Cannot find file $with_defaultoptions
+			echo Aborting configure...
+			exit 1
+		fi
+	fi
+fi
+
+
+ac_aux_dir=
+for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { $as_echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&5
+$as_echo "$as_me: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+# Make sure we can run config.sub.
+$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
+  { { $as_echo "$as_me:$LINENO: error: cannot run $SHELL $ac_aux_dir/config.sub" >&5
+$as_echo "$as_me: error: cannot run $SHELL $ac_aux_dir/config.sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+{ $as_echo "$as_me:$LINENO: checking build system type" >&5
+$as_echo_n "checking build system type... " >&6; }
+if test "${ac_cv_build+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+test "x$ac_build_alias" = x &&
+  { { $as_echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+$as_echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
+  { { $as_echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&5
+$as_echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+$as_echo "$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) { { $as_echo "$as_me:$LINENO: error: invalid value of canonical build" >&5
+$as_echo "$as_me: error: invalid value of canonical build" >&2;}
+   { (exit 1); exit 1; }; };;
+esac
+build=$ac_cv_build
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_build
+shift
+build_cpu=$1
+build_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+build_os=$*
+IFS=$ac_save_IFS
+case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:$LINENO: checking host system type" >&5
+$as_echo_n "checking host system type... " >&6; }
+if test "${ac_cv_host+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$host_alias" = x; then
+  ac_cv_host=$ac_cv_build
+else
+  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
+    { { $as_echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&5
+$as_echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+$as_echo "$ac_cv_host" >&6; }
+case $ac_cv_host in
+*-*-*) ;;
+*) { { $as_echo "$as_me:$LINENO: error: invalid value of canonical host" >&5
+$as_echo "$as_me: error: invalid value of canonical host" >&2;}
+   { (exit 1); exit 1; }; };;
+esac
+host=$ac_cv_host
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_host
+shift
+host_cpu=$1
+host_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+host_os=$*
+IFS=$ac_save_IFS
+case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:$LINENO: checking target system type" >&5
+$as_echo_n "checking target system type... " >&6; }
+if test "${ac_cv_target+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$target_alias" = x; then
+  ac_cv_target=$ac_cv_host
+else
+  ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
+    { { $as_echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&5
+$as_echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+$as_echo "$ac_cv_target" >&6; }
+case $ac_cv_target in
+*-*-*) ;;
+*) { { $as_echo "$as_me:$LINENO: error: invalid value of canonical target" >&5
+$as_echo "$as_me: error: invalid value of canonical target" >&2;}
+   { (exit 1); exit 1; }; };;
+esac
+target=$ac_cv_target
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_target
+shift
+target_cpu=$1
+target_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+target_os=$*
+IFS=$ac_save_IFS
+case $target_os in *\ *) target_os=`echo "$target_os" | sed 's/ /-/g'`;; esac
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }; }
+
+# Provide some information about the compiler.
+$as_echo "$as_me:$LINENO: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+{ (ac_try="$ac_compiler --version >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler --version >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -v >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -v >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -V >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -V >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+{ $as_echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+if test "${ac_cv_c_compiler_gnu+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_compiler_gnu=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_compiler_gnu=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if test "${ac_cv_prog_cc_g+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_g=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	CFLAGS=""
+      cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_g=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ $as_echo "$as_me:$LINENO: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+if test "${ac_cv_prog_cc_c89+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cc_c89=$ac_arg
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { $as_echo "$as_me:$LINENO: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
+  xno)
+    { $as_echo "$as_me:$LINENO: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+if test -z "$CXX"; then
+  if test -n "$CCC"; then
+    CXX=$CCC
+  else
+    if test -n "$ac_tool_prefix"; then
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CXX+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CXX"; then
+  ac_cv_prog_CXX="$CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+CXX=$ac_cv_prog_CXX
+if test -n "$CXX"; then
+  { $as_echo "$as_me:$LINENO: result: $CXX" >&5
+$as_echo "$CXX" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CXX" && break
+  done
+fi
+if test -z "$CXX"; then
+  ac_ct_CXX=$CXX
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CXX+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CXX"; then
+  ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CXX="$ac_prog"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
+if test -n "$ac_ct_CXX"; then
+  { $as_echo "$as_me:$LINENO: result: $ac_ct_CXX" >&5
+$as_echo "$ac_ct_CXX" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CXX" && break
+done
+
+  if test "x$ac_ct_CXX" = x; then
+    CXX="g++"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CXX=$ac_ct_CXX
+  fi
+fi
+
+  fi
+fi
+# Provide some information about the compiler.
+$as_echo "$as_me:$LINENO: checking for C++ compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+{ (ac_try="$ac_compiler --version >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler --version >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -v >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -v >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (ac_try="$ac_compiler -V >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compiler -V >&5") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+{ $as_echo "$as_me:$LINENO: checking whether we are using the GNU C++ compiler" >&5
+$as_echo_n "checking whether we are using the GNU C++ compiler... " >&6; }
+if test "${ac_cv_cxx_compiler_gnu+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_compiler_gnu=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_compiler_gnu=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_cxx_compiler_gnu" >&5
+$as_echo "$ac_cv_cxx_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GXX=yes
+else
+  GXX=
+fi
+ac_test_CXXFLAGS=${CXXFLAGS+set}
+ac_save_CXXFLAGS=$CXXFLAGS
+{ $as_echo "$as_me:$LINENO: checking whether $CXX accepts -g" >&5
+$as_echo_n "checking whether $CXX accepts -g... " >&6; }
+if test "${ac_cv_prog_cxx_g+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_cxx_werror_flag=$ac_cxx_werror_flag
+   ac_cxx_werror_flag=yes
+   ac_cv_prog_cxx_g=no
+   CXXFLAGS="-g"
+   cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cxx_g=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	CXXFLAGS=""
+      cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+	 CXXFLAGS="-g"
+	 cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_prog_cxx_g=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cxx_g" >&5
+$as_echo "$ac_cv_prog_cxx_g" >&6; }
+if test "$ac_test_CXXFLAGS" = set; then
+  CXXFLAGS=$ac_save_CXXFLAGS
+elif test $ac_cv_prog_cxx_g = yes; then
+  if test "$GXX" = yes; then
+    CXXFLAGS="-g -O2"
+  else
+    CXXFLAGS="-g"
+  fi
+else
+  if test "$GXX" = yes; then
+    CXXFLAGS="-O2"
+  else
+    CXXFLAGS=
+  fi
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+{ $as_echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if test "${ac_cv_header_stdc+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_header_stdc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_header_stdc=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+
+for ac_header in string.h
+do
+as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
+$as_echo_n "checking $ac_header usability... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
+$as_echo_n "checking $ac_header presence... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+
+    ;;
+esac
+{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+
+fi
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+V_INCLUDE=""
+V_LIB=""
+V_OBJ=""
+V_BROKEN_OBJ="strtol.o strtoul.o"
+
+V_SHELL=""
+V_TARCMD="tar cfh"
+V_SIGRET="void"
+
+{ $as_echo "$as_me:$LINENO: checking for main in -lXbsd" >&5
+$as_echo_n "checking for main in -lXbsd... " >&6; }
+if test "${ac_cv_lib_Xbsd_main+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lXbsd  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+return main ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_Xbsd_main=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_Xbsd_main=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xbsd_main" >&5
+$as_echo "$ac_cv_lib_Xbsd_main" >&6; }
+if test "x$ac_cv_lib_Xbsd_main" = x""yes; then
+  V_LIB="$V_LIB -lXbsd"
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for socket in -lsocket" >&5
+$as_echo_n "checking for socket in -lsocket... " >&6; }
+if test "${ac_cv_lib_socket_socket+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsocket  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char socket ();
+int
+main ()
+{
+return socket ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_socket_socket=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_socket_socket=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_socket_socket" >&5
+$as_echo "$ac_cv_lib_socket_socket" >&6; }
+if test "x$ac_cv_lib_socket_socket" = x""yes; then
+  V_LIB="$V_LIB -lsocket"
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for gethostbyname in -lnsl" >&5
+$as_echo_n "checking for gethostbyname in -lnsl... " >&6; }
+if test "${ac_cv_lib_nsl_gethostbyname+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gethostbyname ();
+int
+main ()
+{
+return gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_nsl_gethostbyname=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_nsl_gethostbyname=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
+$as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
+if test "x$ac_cv_lib_nsl_gethostbyname" = x""yes; then
+  V_LIB="$V_LIB -lnsl"
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for dcgettext in -lintl" >&5
+$as_echo_n "checking for dcgettext in -lintl... " >&6; }
+if test "${ac_cv_lib_intl_dcgettext+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lintl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dcgettext ();
+int
+main ()
+{
+return dcgettext ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_intl_dcgettext=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_intl_dcgettext=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_intl_dcgettext" >&5
+$as_echo "$ac_cv_lib_intl_dcgettext" >&6; }
+if test "x$ac_cv_lib_intl_dcgettext" = x""yes; then
+  V_LIB="$V_LIB -lintl"
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for getnodebyname in -ldnet_stub" >&5
+$as_echo_n "checking for getnodebyname in -ldnet_stub... " >&6; }
+if test "${ac_cv_lib_dnet_stub_getnodebyname+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldnet_stub  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char getnodebyname ();
+int
+main ()
+{
+return getnodebyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_dnet_stub_getnodebyname=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_dnet_stub_getnodebyname=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dnet_stub_getnodebyname" >&5
+$as_echo "$ac_cv_lib_dnet_stub_getnodebyname" >&6; }
+if test "x$ac_cv_lib_dnet_stub_getnodebyname" = x""yes; then
+  V_LIB="$V_LIB -ldnet_stub"
+fi
+
+
+V_TAR_EXTRA=""
+V_DEFINE=""
+
+V_RANLIB=ranlib
+V_AR="ar cr"
+
+#XXX
+V_SHM="-DUSE_SHM"
+
+# Check whether --enable-release was given.
+if test "${enable_release+set}" = set; then
+  enableval=$enable_release;
+else
+  enable_release="no"
+fi
+
+# Check whether --enable-debug was given.
+if test "${enable_debug+set}" = set; then
+  enableval=$enable_debug;
+else
+  enable_debug="no"
+fi
+
+# Check whether --enable-devel was given.
+if test "${enable_devel+set}" = set; then
+  enableval=$enable_devel;
+else
+  enable_devel="no"
+fi
+
+
+if test "$enable_devel" = "yes" ; then
+	enable_debug="yes"
+fi
+
+if test -f .devel -o "$enable_devel" = "yes"; then
+	OonS=""
+else
+    if test "$CC" = gcc ; then
+	    { $as_echo "$as_me:$LINENO: checking that $CXX can handle -O2" >&5
+$as_echo_n "checking that $CXX can handle -O2... " >&6; }
+	    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#if __GNUC__ < 2  || __GNUC_MINOR__ < 8
+		/* gcc */
+		error
+		#endif
+		#if __GNUC_MINOR__ < 92
+		/* egcs */
+		int error;
+		#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+	    OonS="-O2"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	# Optimize on Steroids
+	    { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    fi
+fi
+
+if test "$enable_debug" = "yes" ; then
+	V_CCOPT="-g"
+	if test "$CC" = gcc ; then
+		V_CCOPT="$V_CCOPT -Wall -Wno-write-strings -Wno-parentheses -Werror"
+		V_DEFINE="$V_DEFINE -fsigned-char -fno-inline"
+	fi
+else
+	V_CCOPT="$OonS"
+	V_DEFINE="$V_DEFINE -DNDEBUG"
+	if test "$CC" = gcc ; then
+		V_CCOPT="$V_CCOPT -Wall -Wno-write-strings"
+	fi
+fi
+
+# XXX Some stupid sh on solaris does not set PWD correctly, i.e.,
+# after chdir $PWD remains at the parent directory. :(
+# We'll just do this every time. Doesn't hurt anyway.
+PWD=`pwd`
+
+solaris=""
+if test `echo "$target_os" | sed 's/\..*//'` = solaris2 ; then
+	solaris="yes"
+fi
+
+#places="Tcl \
+#	/usr/src/local/Tcl \
+#	../../Tcl \
+#	../Tcl"
+#for d in $places; do
+#	if test -f $d/tclcl.h ; then
+#		V_LIB="$V_LIB $d/libTcl.a"
+#		V_INCLUDE="$V_INCLUDE -I$d"
+#    		break
+#	fi
+#done
+
+
+# we now default to non-static linking, although if the "magic" file
+# .devel exists in the current directory, we try for a static link
+# under the assumption we are trying to produce re-distributable
+# binaries.
+#
+# Yatin: Moved this code here from configure.in.tail, since the mash
+# configure.in file needs to set this variable appropriately before invoking
+# configure.in.tail and the presence of the .devel file can mess things up for
+# the linux release build
+#
+# Check whether --enable-static was given.
+if test "${enable_static+set}" = set; then
+  enableval=$enable_static;
+else
+  enable_static=""
+fi
+
+
+if test -f .devel -o "$enable_devel" = "yes"; then
+	echo -n "Development version: considering static"
+		if test "$enable_static" != no; then
+		echo ", and static enabled"
+		V_STATIC="-static"
+	else
+		echo ", but static disabled anyway"
+	fi
+else
+	V_STATIC=""
+fi
+
+
+# This can be extended to support compilation-time module selection
+V_STLOBJ=""
+V_LSSCRIPT=""
+
+# This is required by configure.in.tcl to provide absolute pathnames for
+# tclsh, and configure.in.tail to absolutize V_INCLUDES and V_LIBS.
+absolutize() {
+    case $1 in
+    -L*) p=`echo $1 | sed 's/^-L//'` ;;
+    -I*) p=`echo $1 | sed 's/^-I//'` ;;
+    *) p=$1 ;;
+    esac
+    d=`dirname $p`
+    f=`basename $p`
+    ad=`(
+	cd $d
+	pwd
+    )`
+    case $1 in
+    -L*) echo -L$ad/$f ;;
+    -I*) echo -I$ad/$f ;;
+    *) echo $ad/$f ;;
+    esac
+}
+
+
+
+
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+
+cpp_namespace=no
+stl_namespace=no
+
+if test x$cpp_namespace = xno
+then
+	{ $as_echo "$as_me:$LINENO: checking if C++ libraries work without any namespace" >&5
+$as_echo_n "checking if C++ libraries work without any namespace... " >&6; }
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <iostream>
+
+int
+main ()
+{
+cout.fail();
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+		cpp_namespace="none"
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+if test x$cpp_namespace = xno
+then
+	{ $as_echo "$as_me:$LINENO: checking if C++ libraries work with namespace std" >&5
+$as_echo_n "checking if C++ libraries work with namespace std... " >&6; }
+	cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <iostream>
+	using namespace std;
+
+int
+main ()
+{
+cout.fail();
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+		cpp_namespace=std
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+if test x$stl_namespace = xno
+then
+	{ $as_echo "$as_me:$LINENO: checking if STL works without any namespace" >&5
+$as_echo_n "checking if STL works without any namespace... " >&6; }
+	cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <list>
+
+int
+main ()
+{
+list<int> test;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+		stl_namespace="none"
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+if test x$stl_namespace = xno
+then
+	{ $as_echo "$as_me:$LINENO: checking if STL works with namespace std" >&5
+$as_echo_n "checking if STL works with namespace std... " >&6; }
+	cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <list>
+	using namespace std;
+
+int
+main ()
+{
+list<int> test;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+		stl_namespace=std
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+if test x$stl_namespace = xno
+then
+	{ $as_echo "$as_me:$LINENO: checking if STL works with namespace stl" >&5
+$as_echo_n "checking if STL works with namespace stl... " >&6; }
+	cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <list>
+	using namespace stl;
+
+int
+main ()
+{
+list<int> test;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+		stl_namespace=stl
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+{ $as_echo "$as_me:$LINENO: checking should use STL" >&5
+$as_echo_n "checking should use STL... " >&6; }
+# Check whether --enable-stl was given.
+if test "${enable_stl+set}" = set; then
+  enableval=$enable_stl;
+	enable_stl=$enableval
+	{ $as_echo "$as_me:$LINENO: result: user specified $enable_stl" >&5
+$as_echo "user specified $enable_stl" >&6; }
+
+else
+
+if test x$stl_namespace = xno
+then
+	enable_stl=no
+	{ $as_echo "$as_me:$LINENO: result: no, couldn't find STL" >&5
+$as_echo "no, couldn't find STL" >&6; }
+else
+	if test x$stl_namespace != x$cpp_namespace
+	then
+						enable_stl=no
+		{ $as_echo "$as_me:$LINENO: result: std/STL namespaces are too hard for your system, abandoning STL" >&5
+$as_echo "std/STL namespaces are too hard for your system, abandoning STL" >&6; }
+	else
+		enable_stl=yes
+		{ $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+	fi
+fi
+
+fi
+
+
+
+if test x$enable_stl = xno
+then
+	V_STLOBJ=""
+	V_NS_TCL_LIB_STL=""
+else
+	V_STLOBJ='$(OBJ_STL)'
+	V_NS_TCL_LIB_STL='$(NS_TCL_LIB_STL)'
+	cat >>confdefs.h <<\_ACEOF
+#define HAVE_STL 1
+_ACEOF
+
+fi
+if test x$cpp_namespace != xnone
+then
+	cat >>confdefs.h <<\_ACEOF
+#define CPP_REQUIRES_NAMESPACE 1
+_ACEOF
+
+fi
+CPP_NAMESPACE=$cpp_namespace
+
+
+
+
+
+
+
+
+# Check whether --with-tcl was given.
+if test "${with_tcl+set}" = set; then
+  withval=$with_tcl; d=$withval
+else
+  d=""
+fi
+
+
+
+# Check whether --with-tcl-ver was given.
+if test "${with_tcl_ver+set}" = set; then
+  withval=$with_tcl_ver; TCL_VERS=$withval
+else
+  TCL_VERS=8.4.18
+fi
+
+
+
+TCL_HI_VERS=`echo $TCL_VERS | sed 's/^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1.\2/'`
+TCL_MAJOR_VERS=`echo $TCL_VERS | sed 's/^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1/'`
+TCL_ALT_VERS=`echo $TCL_HI_VERS | sed 's/\.//'`
+
+TCL_OLD_VERS=8.3.5
+TCL_OLD_ALT_VERS=`echo $TCL_OLD_VERS | sed 's/\.//'`
+
+TCL_TCL_PLACES_D="$d \
+		$d/lib64/tcl$TCL_HI_VERS \
+		$d/lib64/tcl$TCL_VERS \
+		$d/lib64/tcl$TCL_ALT_VERS \
+		$d/lib64/tcl \
+		$d/lib/tcl$TCL_HI_VERS \
+		$d/lib/tcl$TCL_VERS \
+		$d/lib/tcl$TCL_ALT_VERS \
+		$d/lib/tcl \
+		$d/../lib/tcl$TCL_HI_VERS \
+		$d/../lib/tcl$TCL_VERS \
+		$d/../lib/tcl$TCL_ALT_VERS \
+		$d/lib/tcl$TCL_OLD_VERS \
+		$d/lib/tcl$TCL_OLD_ALT_VERS \
+		$d/../lib/tcl$TCL_OLD_VERS \
+		$d/../lib/tcl$TCL_OLD_ALT_VERS \
+		/usr/local/lib/tcl$TCL_HI_VERS \
+		/usr/local/lib/tcl$TCL_VERS \
+		/usr/local/lib/tcl$TCL_ALT_VERS \
+		$d/lib64 \
+		$d/lib \
+		$d/library \
+		"
+TCL_TCL_PLACES="../lib/tcl$TCL_HI_VERS \
+		../lib/tcl$TCL_ALT_VERS \
+		../lib/tcl$TCL_VERS \
+		../lib/tcl \
+		../tcl$TCL_HI_VERS/library \
+		../tcl$TCL_VERS/library \
+                ../tcl$TCL_ALT_VERS/library \
+		/usr/lib64/tcl$TCL_VERS \
+		/usr/lib64/tcl$TCL_HI_VERS \
+		/usr/lib64/tcl$TCL_ALT_VERS \
+		/usr/lib64/tcl \
+		/usr/lib/tcl$TCL_VERS \
+		/usr/lib/tcl$TCL_HI_VERS \
+		/usr/lib/tcl$TCL_ALT_VERS \
+		/usr/lib/tcl \
+		/usr/share/tcl$TCL_VERS \
+		/usr/share/tcl$TCL_HI_VERS \
+		/usr/share/tcl$TCL_ALT_VERS \
+		/usr/local/src/tcl$TCL_VERS \
+		/usr/local/src/tcl$TCL_HI_VERS \
+		/usr/local/src/tcl$TCL_ALT_VERS \
+		/usr/share/tcl \
+		/lib/tcl$TCL_VERS \
+		/lib/tcl$TCL_HI_VERS \
+		/lib/tcl$TCL_ALT_VERS \
+		/usr/lib/tcl$TCL_OLD_VERS \
+		/usr/lib/tcl$TCL_OLD_ALT_VERS \
+		/lib/tcl$TCL_OLD_VERS \
+		/lib/tcl$TCL_OLD_ALT_VERS \
+		/usr/lib \
+                /usr/src/local/tcl$TCL_VERS/library \
+                /usr/src/local/tcl$TCL_HI_VERS/library \
+                /usr/src/local/tcl$TCL_ALT_VERS/library \
+                /usr/local/lib/tcl$TCL_VERS \
+                /usr/local/lib/tcl$TCL_HI_VERS \
+                /usr/local/lib/tcl$TCL_ALT_VERS \
+                /usr/local/include/tcl$TCL_VERS \
+                /usr/local/include/tcl$TCL_HI_VERS \
+                /usr/local/include/tcl$TCL_ALT_VERS \
+		../tcl$TCL_OLD_VERS/library \
+                ../tcl$TCL_OLD_ALT_VERS/library \
+                /usr/src/local/tcl$TCL_OLD_VERS/library \
+                /usr/src/local/tcl$TCL_OLD_ALT_VERS/library \
+                /usr/local/lib/tcl$TCL_OLD_VERS \
+                /usr/local/lib/tcl$TCL_OLD_ALT_VERS \
+                /usr/local/include/tcl$TCL_OLD_VERS \
+                /usr/local/include/tcl$TCL_OLD_ALT_VERS \
+                /usr/local/include \
+                $prefix/include \
+		$prefix/lib/tcl \
+                $x_includes/tk \
+                $x_includes \
+                /usr/contrib/include \
+                /usr/include"
+TCL_H_PLACES_D="$d/generic \
+		$d/unix \
+		$d/include/tcl$TCL_HI_VERS \
+		$d/include/tcl$TCL_VERS \
+		$d/include/tcl$TCL_ALT_VERS \
+		$d/include \
+		/usr/local/include \
+		"
+TCL_H_PLACES=" \
+		../include \
+		../tcl$TCL_VERS/unix \
+		../tcl$TCL_ALT_VERS/unix \
+		../tcl$TCL_HI_VERS/generic \
+		../tcl$TCL_VERS/generic \
+		../tcl$TCL_ALT_VERS/generic \
+		/usr/src/local/tcl$TCL_VERS/generic \
+		/usr/src/local/tcl$TCL_HI_VERS/generic \
+		/usr/src/local/tcl$TCL_ALT_VERS/generic \
+		/usr/local/src/tcl$TCL_VERS/generic \
+		/usr/local/src/tcl$TCL_HI_VERS/generic \
+		/usr/local/src/tcl$TCL_ALT_VERS/generic \
+		/usr/src/local/tcl$TCL_VERS/unix \
+		/usr/src/local/tcl$TCL_HI_VERS/unix \
+		/usr/src/local/tcl$TCL_ALT_VERS/unix \
+		/usr/contrib/include \
+		/usr/local/lib/tcl$TCL_VERS \
+		/usr/local/lib/tcl$TCL_HI_VERS \
+		/usr/local/lib/tcl$TCL_ALT_VERS \
+		/usr/local/include/tcl$TCL_VERS \
+		/usr/local/include/tcl$TCL_HI_VERS \
+		/usr/local/include/tcl$TCL_ALT_VERS \
+		/usr/local/include \
+		/import/tcl/include/tcl$TCL_VERS \
+		/import/tcl/include/tcl$TCL_HI_VERS \
+		/import/tcl/include/tcl$TCL_ALT_VERS \
+		../tcl$TCL_OLD_VERS/generic \
+		../tcl$TCL_OLD_ALT_VERS/generic \
+		/usr/src/local/tcl$TCL_OLD_VERS/generic \
+		/usr/src/local/tcl$TCL_OLD_ALT_VERS/generic \
+		../tcl$TCL_OLD_VERS/unix \
+		../tcl$TCL_OLD_ALT_VERS/unix \
+		/usr/src/local/tcl$TCL_OLD_VERS/unix \
+		/usr/src/local/tcl$TCL_OLD_ALT_VERS/unix \
+		/usr/local/lib/tcl$TCL_OLD_VERS \
+		/usr/local/lib/tcl$TCL_OLD_ALT_VERS \
+		/usr/local/include/tcl$TCL_OLD_VERS \
+		/usr/local/include/tcl$TCL_OLD_ALT_VERS \
+		/import/tcl/include/tcl$TCL_OLD_VERS \
+		/import/tcl/include/tcl$TCL_OLD_ALT_VERS \
+		$prefix/include \
+		$x_includes/tk \
+		$x_includes \
+		/usr/include \
+		/usr/include/tcl$TCL_VERS/tcl-private/generic \
+		/usr/include/tcl$TCL_HI_VERS/tcl-private/generic \
+		/usr/include/tcl$TCL_ALT_VERS/tcl-private/generic \
+		/usr/include/tcl-private/generic \
+		/usr/include/tcl$TCL_VERS \
+		/usr/include/tcl$TCL_HI_VERS \
+		/usr/include/tcl$TCL_ALT_VERS \
+		/usr/include/tcl"
+TCL_LIB_PLACES_D="$d \
+		$d/lib \
+		$d/unix"
+TCL_LIB_PLACES=" \
+		../lib \
+		../tcl$TCL_VERS/unix \
+		../tcl$TCL_HI_VERS/unix \
+                ../tcl$TCL_ALT_VERS/unix \
+                /usr/src/local/tcl$TCL_VERS/unix \
+                /usr/src/local/tcl$TCL_HI_VERS/unix \
+                /usr/src/local/tcl$TCL_ALT_VERS/unix \
+                /usr/local/src/tcl$TCL_VERS/unix \
+                /usr/local/src/tcl$TCL_HI_VERS/unix \
+                /usr/local/src/tcl$TCL_ALT_VERS/unix \
+                /usr/contrib/lib \
+                /usr/local/lib/tcl$TCL_VERS \
+                /usr/local/lib/tcl$TCL_HI_VERS \
+                /usr/local/lib/tcl$TCL_ALT_VERS \
+		/usr/lib64/tcl$TCL_VERS \
+		/usr/lib64/tcl$TCL_HI_VERS \
+		/usr/lib64/tcl$TCL_ALT_VERS \
+		/usr/lib/tcl$TCL_VERS \
+		/usr/lib/tcl$TCL_HI_VERS \
+		/usr/lib/tcl$TCL_ALT_VERS \
+		../tcl$TCL_OLD_VERS/unix \
+                ../tcl$TCL_OLD_ALT_VERS/unix \
+                /usr/src/local/tcl$TCL_OLD_VERS/unix \
+                /usr/src/local/tcl$TCL_OLD_ALT_VERS/unix \
+                /usr/local/lib/tcl$TCL_OLD_VERS \
+                /usr/local/lib/tcl$TCL_OLD_ALT_VERS \
+		/usr/lib/tcl$TCL_OLD_VERS \
+		/usr/lib/tcl$TCL_OLD_ALT_VERS \
+                /usr/local/lib \
+                $prefix/lib \
+                $x_libs/tk \
+                $x_libs \
+                /usr/lib64 \
+                /usr/lib \
+		"
+
+
+
+
+NS_PACKAGE_tcl_UNDERWAY=false
+NS_PACKAGE_tcl_COMPLETE=true
+
+
+{ $as_echo "$as_me:$LINENO: checking for tcl.h" >&5
+$as_echo_n "checking for tcl.h... " >&6; }
+if test "x$d" = "xno"; then
+	: disable header
+	V_INCLUDE_TCL=FAIL
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$TCL_H_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCL_H_PLACES_D"
+	fi
+
+	V_INCLUDE_TCL=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/tcl.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_INCLUDE_TCL="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+
+				  ac_tr_hdr=HAVE_`echo tcl.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_INCLUDE_TCL $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_tcl_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_INCLUDE_TCL" >&5
+$as_echo "$V_INCLUDE_TCL" >&6; }
+	fi
+fi
+
+
+{ $as_echo "$as_me:$LINENO: checking for tclInt.h" >&5
+$as_echo_n "checking for tclInt.h... " >&6; }
+if test "x$d" = "xno"; then
+	: disable header
+	V_INCLUDE_TCL=FAIL
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$TCL_H_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCL_H_PLACES_D"
+	fi
+
+	V_INCLUDE_TCL=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/tclInt.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_INCLUDE_TCL="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+
+				  ac_tr_hdr=HAVE_`echo tclInt.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_INCLUDE_TCL $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_tcl_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_INCLUDE_TCL" >&5
+$as_echo "$V_INCLUDE_TCL" >&6; }
+	fi
+fi
+
+
+{ $as_echo "$as_me:$LINENO: checking for libtcl$TCL_HI_VERS" >&5
+$as_echo_n "checking for libtcl$TCL_HI_VERS... " >&6; }
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_TCL=FAIL
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$TCL_LIB_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCL_LIB_PLACES_D"
+	fi
+
+	V_LIB_TCL=""
+		full_lib_name="tcl$TCL_HI_VERS"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_TCL="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_TCL" = "FAIL" ; then
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+		if test "$solaris"; then
+			V_LIB_TCL="-R$dir $V_LIB_TCL"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo tcl$TCL_HI_VERS | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_TCL $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_tcl_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_LIB_TCL" >&5
+$as_echo "$V_LIB_TCL" >&6; }
+	fi
+fi
+
+
+{ $as_echo "$as_me:$LINENO: checking for init.tcl" >&5
+$as_echo_n "checking for init.tcl... " >&6; }
+if test "x$d" = "xno"; then
+	: disable header
+	V_LIBRARY_TCL=FAIL
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$TCL_TCL_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCL_TCL_PLACES_D"
+	fi
+
+	V_LIBRARY_TCL=""
+	for dir in $places; do
+		if test -r $dir/init.tcl; then
+			V_LIBRARY_TCL="$dir"
+			break
+		fi
+	done
+	if test "FAIL$V_LIBRARY_TCL" = "FAIL" ; then
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+
+		NS_PACKAGE_tcl_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_LIBRARY_TCL" >&5
+$as_echo "$V_LIBRARY_TCL" >&6; }
+	fi
+fi
+
+
+tcl_http_library_dir=/dev/null
+tcl_http_places=" \
+	$V_LIBRARY_TCL \
+	$V_LIBRARY_TCL/http \
+	$V_LIBRARY_TCL/http2.4 \
+	$V_LIBRARY_TCL/http2.3 \
+	$V_LIBRARY_TCL/http2.1 \
+	$V_LIBRARY_TCL/http2.0 \
+	$V_LIBRARY_TCL/http1.0 \
+	"
+
+{ $as_echo "$as_me:$LINENO: checking for http.tcl" >&5
+$as_echo_n "checking for http.tcl... " >&6; }
+if test "x""" = "xno"; then
+	: disable header
+	tcl_http_library_dir=FAIL
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$tcl_http_places"
+	if test "x""" != "x" -a "x""" != xyes; then
+		if test ! -d ""; then
+			{ { $as_echo "$as_me:$LINENO: error: \"\" is not a directory" >&5
+$as_echo "$as_me: error: \"\" is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places=""""
+	fi
+
+	tcl_http_library_dir=""
+	for dir in $places; do
+		if test -r $dir/http.tcl; then
+			tcl_http_library_dir="$dir"
+			break
+		fi
+	done
+	if test "FAIL$tcl_http_library_dir" = "FAIL" ; then
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+
+		NS_PACKAGE_tcl_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $tcl_http_library_dir" >&5
+$as_echo "$tcl_http_library_dir" >&6; }
+	fi
+fi
+
+{ $as_echo "$as_me:$LINENO: checking Tcl http.tcl library" >&5
+$as_echo_n "checking Tcl http.tcl library... " >&6; }
+if test -f $tcl_http_library_dir/http.tcl
+then
+	{ $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+	{ { $as_echo "$as_me:$LINENO: error: Couldn't find http.tcl in $tcl_http_places" >&5
+$as_echo "$as_me: error: Couldn't find http.tcl in $tcl_http_places" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+
+V_TCL_LIBRARY_FILES="\$(TCL_BASE_LIBRARY_FILES) $tcl_http_library_dir/http.tcl"
+
+
+#
+# check for tclsh
+#
+oldpath=$PATH
+# $d/unix works if $d is the 8.0 distribution
+# $d/bin is for the ns-allinone distribution (kind of hacky, isn't it?)
+PATH=../bin:../tcl$TCL_HI_VERS/unix:../tcl$TCL_VERS/unix:$d/unix:$d/bin:$PATH
+for ac_prog in tclsh$TCL_VERS tclsh$TCL_HI_VERS tclsh tclsh$TCL_OLD_VERS
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_V_TCLSH+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  case $V_TCLSH in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_V_TCLSH="$V_TCLSH" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_V_TCLSH="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+V_TCLSH=$ac_cv_path_V_TCLSH
+if test -n "$V_TCLSH"; then
+  { $as_echo "$as_me:$LINENO: result: $V_TCLSH" >&5
+$as_echo "$V_TCLSH" >&6; }
+else
+  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$V_TCLSH" && break
+done
+test -n "$V_TCLSH" || V_TCLSH="no"
+
+if test x"$V_TCLSH" = xno
+then
+	# out of luck
+
+NS_PACKAGE_tcl_COMPLETE=false
+
+fi
+# absolutize it
+V_TCLSH=`absolutize $V_TCLSH`
+PATH=$oldpath
+
+
+NS_PACKAGE_tcl_VALID=false
+if $NS_PACKAGE_tcl_UNDERWAY; then
+	if $NS_PACKAGE_tcl_COMPLETE; then
+		: All components of tcl found.
+		NS_PACKAGE_tcl_VALID=true
+	else
+		{ { $as_echo "$as_me:$LINENO: error: Installation of tcl seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tcl is
+using the argument --with-tcl=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tcl=no." >&5
+$as_echo "$as_me: error: Installation of tcl seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tcl is
+using the argument --with-tcl=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tcl=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xyes" = xyes; then
+	if $NS_PACKAGE_tcl_VALID; then
+		:
+	else
+		{ { $as_echo "$as_me:$LINENO: error: tcl is required but could not be completely found.
+Please correct the problem by telling configure where tcl is
+using the argument --with-tcl=/path/to/package,
+or the package is not required, disable it with --with-tcl=no." >&5
+$as_echo "$as_me: error: tcl is required but could not be completely found.
+Please correct the problem by telling configure where tcl is
+using the argument --with-tcl=/path/to/package,
+or the package is not required, disable it with --with-tcl=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+
+
+
+
+
+
+
+# Check whether --with-tk was given.
+if test "${with_tk+set}" = set; then
+  withval=$with_tk; d=$withval
+else
+  d=""
+fi
+
+
+
+# Check whether --with-tk-ver was given.
+if test "${with_tk_ver+set}" = set; then
+  withval=$with_tk_ver; TK_VERS=$withval
+else
+  TK_VERS=8.4.18
+fi
+
+
+
+
+TK_HI_VERS=`echo $TK_VERS | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1.\2/'`
+TK_MAJOR_VERS=`echo $TK_VERS | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1/'`
+TK_ALT_VERS=`echo $TK_VERS | sed 's/\.//'`
+
+TK_OLD_VERS=8.3.5
+TK_OLD_ALT_VERS=`echo $TK_OLD_VERS | sed 's/\.//'`
+
+TK_TCL_PLACES_D="$d \
+                $d/lib64/tk$TK_VERS \
+                $d/lib64/tk$TK_ALT_VERS \
+                $d/lib64/tk$TK_VERS \
+                $d/lib/tk$TK_ALT_VERS \
+		$d/lib/tk$TK_HI_VERS \
+                $d/library \
+                $d/lib/tk \
+                $d/../lib/tk$TK_VERS \
+                $d/../lib/tk$TK_ALT_VERS \
+                $d/../lib/tk$TK_HI_VERS \
+                $d/../lib/tk \
+                $d/lib/tk$TK_OLD_VERS \
+                $d/lib/tk$TK_OLD_ALT_VERS \
+                $d/../lib/tk$TK_OLD_VERS \
+                $d/../lib/tk$TK_OLD_ALT_VERS \
+                $d/../lib/tk \
+                $d/lib \
+                $d/library"
+TK_TCL_PLACES=" \
+		../lib/tk$TK_HI_VERS \
+		../lib/tk$TK_VERS \
+		../lib/tk$TK_ALT_VERS \
+		../tk$TK_VERS/library \
+                ../tk$TK_ALT_VERS/library \
+                ../tk$TK_HI_VERS/library \
+		../tk/library \
+                /usr/src/local/tk$TK_VERS/library \
+                /usr/src/local/tk$TK_ALT_VERS/library \
+                /usr/src/local/tk$TK_HI_VERS/library \
+                /usr/contrib/include \
+                /usr/local/lib/tk$TK_VERS \
+                /usr/local/lib/tk$TK_ALT_VERS \
+                /usr/local/lib/tk$TK_HI_VERS \
+                /usr/local/include/tk$TK_VERS \
+                /usr/local/include/tk$TK_ALT_VERS \
+                /usr/local/include/tk$TK_HI_VERS \
+                /usr/local/include \
+                /usr/lib64/tk$TK_VERS \
+                /usr/lib64/tk$TK_ALT_VERS \
+                /usr/lib64/tk$TK_HI_VERS \
+                /usr/lib64/tk \
+                /usr/lib/tk$TK_VERS \
+                /usr/lib/tk$TK_ALT_VERS \
+                /usr/lib/tk$TK_HI_VERS \
+                /usr/lib/tk \
+                /usr/share/tk$TK_VERS \
+                /usr/share/tk$TK_ALT_VERS \
+                /usr/share/tk$TK_HI_VERS \
+                /usr/share/tk \
+		../tk$TK_OLD_VERS/library \
+                ../tk$TK_OLD_ALT_VERS/library \
+                /usr/src/local/tk$TK_OLD_VERS/library \
+                /usr/src/local/tk$TK_OLD_ALT_VERS/library \
+                /usr/local/lib/tk$TK_OLD_VERS \
+                /usr/local/lib/tk$TK_OLD_ALT_VERS \
+                /usr/local/include/tk$TK_OLD_VERS \
+                /usr/local/include/tk$TK_OLD_ALT_VERS \
+                /usr/lib/tk$TK_OLD_VERS \
+                /usr/lib/tk$TK_OLD_ALT_VERS \
+                $prefix/include \
+		$prefix/lib/tk \
+                $x_includes/tk \
+                $x_includes \
+                /usr/include"
+TK_H_PLACES_D="$d \
+                $d/generic \
+                $d/../include/tk$TK_VERS \
+                $d/../include/tk$TK_HI_VERS \
+                $d/../include/tk$TK_OLD_VERS \
+		$d/include/tk$TK_VERS \
+		$d/include/tk$TK_HI_VERS \
+		$d/include/tk$TK_OLD_VERS \
+                $d/include"
+TK_H_PLACES=" \
+		../include \
+		../tk$TK_VERS/generic \
+                ../tk$TK_ALT_VERS/generic \
+                ../tk$TK_HI_VERS/generic \
+		/usr/src/local/tk$TK_VERS/generic \
+                /usr/src/local/tk$TK_ALT_VERS/generic \
+                /usr/src/local/tk$TK_HI_VERS/generic \
+                /usr/contrib/include \
+                /usr/local/lib/tk$TK_VERS \
+                /usr/local/lib/tk$TK_ALT_VERS \
+                /usr/local/lib/tk$TK_HI_VERS \
+                /usr/local/include/tk$TK_VERS \
+                /usr/local/include/tk$TK_ALT_VERS \
+                /usr/local/include/tk$TK_HI_VERS \
+                /usr/local/include \
+                /import/tk/include/tk$TK_VERS \
+                /import/tk/include/tk$TK_ALT_VERS \
+                /import/tk/include/tk$TK_HI_VERS \
+		../tk$TK_OLD_VERS/generic \
+                ../tk$TK_OLD_ALT_VERS/generic \
+		/usr/src/local/tk$TK_OLD_VERS/generic \
+                /usr/src/local/tk$TK_OLD_ALT_VERS/generic \
+                /usr/local/lib/tk$TK_OLD_VERS \
+                /usr/local/lib/tk$TK_OLD_ALT_VERS \
+                /usr/local/include/tk$TK_OLD_VERS \
+                /usr/local/include/tk$TK_OLD_ALT_VERS \
+                /import/tk/include/tk$TK_OLD_VERS \
+                /import/tk/include/tk$TK_OLD_ALT_VERS \
+                $prefix/include \
+                $x_includes/tk \
+                $x_includes \
+                /usr/include \
+                /usr/include/tcl \
+                /usr/include/tcl$TK_VERS \
+                /usr/include/tcl$TK_ALT_VERS \
+                /usr/include/tcl$TK_HI_VERS \
+                "
+TK_LIB_PLACES_D="$d \
+                $d/lib \
+		$d/unix"
+TK_LIB_PLACES=" \
+		../lib \
+		../lib/tk$TK_HI_VERS \
+		../lib/tk$TK_VERS \
+		../lib/tk$TK_ALT_VERS \
+		../tk$TK_VERS/unix \
+                ../tk$TK_ALT_VERS/unix \
+                ../tk$TK_HI_VERS/unix \
+                /usr/src/local/tk$TK_VERS/unix \
+                /usr/src/local/tk$TK_ALT_VERS/unix \
+                /usr/src/local/tk$TK_HI_VERS/unix \
+                /usr/contrib/lib \
+                /usr/local/lib/tk$TK_VERS \
+                /usr/local/lib/tk$TK_ALT_VERS \
+                /usr/local/lib/tk$TK_HI_VERS \
+		../tk$TK_OLD_VERS/unix \
+                ../tk$TK_OLD_ALT_VERS/unix \
+                /usr/src/local/tk$TK_OLD_VERS/unix \
+                /usr/src/local/tk$TK_OLD_ALT_VERS/unix \
+                /usr/local/lib/tk$TK_OLD_VERS \
+                /usr/local/lib/tk$TK_OLD_ALT_VERS \
+                /usr/local/lib \
+                $prefix/lib \
+                $x_libs/tk \
+                $x_libs \
+                /usr/lib64 \
+                /usr/lib"
+
+
+NS_PACKAGE_tk_UNDERWAY=false
+NS_PACKAGE_tk_COMPLETE=true
+
+
+{ $as_echo "$as_me:$LINENO: checking for tk.h" >&5
+$as_echo_n "checking for tk.h... " >&6; }
+if test "x$d" = "xno"; then
+	: disable header
+	V_INCLUDE_TK=FAIL
+
+NS_PACKAGE_tk_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$TK_H_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TK_H_PLACES_D"
+	fi
+
+	V_INCLUDE_TK=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/tk.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_INCLUDE_TK="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_tk_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+
+				  ac_tr_hdr=HAVE_`echo tk.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_INCLUDE_TK $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_tk_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_INCLUDE_TK" >&5
+$as_echo "$V_INCLUDE_TK" >&6; }
+	fi
+fi
+
+
+{ $as_echo "$as_me:$LINENO: checking for libtk$TK_HI_VERS" >&5
+$as_echo_n "checking for libtk$TK_HI_VERS... " >&6; }
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_TK=FAIL
+
+NS_PACKAGE_tk_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$TK_LIB_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TK_LIB_PLACES_D"
+	fi
+
+	V_LIB_TK=""
+		full_lib_name="tk$TK_HI_VERS"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_TK="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_TK" = "FAIL" ; then
+
+NS_PACKAGE_tk_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+		if test "$solaris"; then
+			V_LIB_TK="-R$dir $V_LIB_TK"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo tk$TK_HI_VERS | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_TK $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_tk_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_LIB_TK" >&5
+$as_echo "$V_LIB_TK" >&6; }
+	fi
+fi
+
+
+{ $as_echo "$as_me:$LINENO: checking for tk.tcl" >&5
+$as_echo_n "checking for tk.tcl... " >&6; }
+if test "x$d" = "xno"; then
+	: disable header
+	V_LIBRARY_TK=FAIL
+
+NS_PACKAGE_tk_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$TK_TCL_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TK_TCL_PLACES_D"
+	fi
+
+	V_LIBRARY_TK=""
+	for dir in $places; do
+		if test -r $dir/tk.tcl; then
+			V_LIBRARY_TK="$dir"
+			break
+		fi
+	done
+	if test "FAIL$V_LIBRARY_TK" = "FAIL" ; then
+
+NS_PACKAGE_tk_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+
+		NS_PACKAGE_tk_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_LIBRARY_TK" >&5
+$as_echo "$V_LIBRARY_TK" >&6; }
+	fi
+fi
+
+
+NS_PACKAGE_tk_VALID=false
+if $NS_PACKAGE_tk_UNDERWAY; then
+	if $NS_PACKAGE_tk_COMPLETE; then
+		: All components of tk found.
+		NS_PACKAGE_tk_VALID=true
+	else
+		{ { $as_echo "$as_me:$LINENO: error: Installation of tk seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tk is
+using the argument --with-tk=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tk=no." >&5
+$as_echo "$as_me: error: Installation of tk seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tk is
+using the argument --with-tk=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tk=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xno" = xyes; then
+	if $NS_PACKAGE_tk_VALID; then
+		:
+	else
+		{ { $as_echo "$as_me:$LINENO: error: tk is required but could not be completely found.
+Please correct the problem by telling configure where tk is
+using the argument --with-tk=/path/to/package,
+or the package is not required, disable it with --with-tk=no." >&5
+$as_echo "$as_me: error: tk is required but could not be completely found.
+Please correct the problem by telling configure where tk is
+using the argument --with-tk=/path/to/package,
+or the package is not required, disable it with --with-tk=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+
+if test -r $V_LIBRARY_TK/optionMenu.tcl ; then
+	V_TKDOSNAMES='$(LIBRARY_TK)/optionMenu.tcl $(LIBRARY_TK)/scrollbar.tcl'
+	V_NEED_DL=""
+else
+	V_TKDOSNAMES='$(LIBRARY_TK)/optMenu.tcl $(LIBRARY_TK)/scrlbar.tcl'
+	V_NEED_DL=YES
+fi
+
+
+
+
+
+
+# Check whether --with-otcl was given.
+if test "${with_otcl+set}" = set; then
+  withval=$with_otcl; d=$withval
+else
+  d=""
+fi
+
+
+OTCL_VERS=1.13
+OTCL_ALT_VERS=1.0
+
+OTCL_H_PLACES_D="$d \
+		$d/include"
+OTCL_H_PLACES="../otcl \
+		/usr/src/local/otcl \
+		../otcl-$OTCL_VERS \
+		/import/otcl/include \
+		/usr/src/local/otcl-$OTCL_VERS \
+		/usr/src/local/otcl-$OTCL_ALT_VERS \
+		$prefix/include \
+		/usr/local/include \
+		/usr/contrib/include \
+		/usr/include"
+OTCL_LIB_PLACES_D="$d \
+		$d/lib \
+		"
+OTCL_LIB_PLACES="../otcl \
+		../otcl-$OTCL_VERS \
+		../otcl-$OTCL_ALT_VERS \
+		$prefix/lib \
+		$x_libraries \
+		/usr/contrib/lib \
+		/usr/local/lib \
+		/usr/lib \
+		/usr/src/local/otcl \
+		/usr/src/local/otcl-$OTCL_VERS \
+		/usr/src/local/otcl-$OTCL_ALT_VERS \
+		"
+
+
+NS_PACKAGE_otcl_UNDERWAY=false
+NS_PACKAGE_otcl_COMPLETE=true
+
+
+{ $as_echo "$as_me:$LINENO: checking for otcl.h" >&5
+$as_echo_n "checking for otcl.h... " >&6; }
+if test "x$d" = "xno"; then
+	: disable header
+	V_INCLUDE_OTCL=FAIL
+
+NS_PACKAGE_otcl_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$OTCL_H_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$OTCL_H_PLACES_D"
+	fi
+
+	V_INCLUDE_OTCL=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/otcl.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_INCLUDE_OTCL="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_otcl_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+
+				  ac_tr_hdr=HAVE_`echo otcl.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_INCLUDE_OTCL $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_otcl_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_INCLUDE_OTCL" >&5
+$as_echo "$V_INCLUDE_OTCL" >&6; }
+	fi
+fi
+
+
+{ $as_echo "$as_me:$LINENO: checking for libotcl$OTCL_VERS" >&5
+$as_echo_n "checking for libotcl$OTCL_VERS... " >&6; }
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_OTCL=FAIL
+
+NS_PACKAGE_otcl_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$OTCL_LIB_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$OTCL_LIB_PLACES_D"
+	fi
+
+	V_LIB_OTCL=""
+		full_lib_name="otcl$OTCL_VERS"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_OTCL="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_OTCL" = "FAIL" ; then
+
+NS_PACKAGE_otcl_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+		if test "$solaris"; then
+			V_LIB_OTCL="-R$dir $V_LIB_OTCL"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo otcl$OTCL_VERS | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_OTCL $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_otcl_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_LIB_OTCL" >&5
+$as_echo "$V_LIB_OTCL" >&6; }
+	fi
+fi
+
+
+NS_PACKAGE_otcl_VALID=false
+if $NS_PACKAGE_otcl_UNDERWAY; then
+	if $NS_PACKAGE_otcl_COMPLETE; then
+		: All components of otcl found.
+		NS_PACKAGE_otcl_VALID=true
+	else
+		{ { $as_echo "$as_me:$LINENO: error: Installation of otcl seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where otcl is
+using the argument --with-otcl=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-otcl=no." >&5
+$as_echo "$as_me: error: Installation of otcl seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where otcl is
+using the argument --with-otcl=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-otcl=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xyes" = xyes; then
+	if $NS_PACKAGE_otcl_VALID; then
+		:
+	else
+		{ { $as_echo "$as_me:$LINENO: error: otcl is required but could not be completely found.
+Please correct the problem by telling configure where otcl is
+using the argument --with-otcl=/path/to/package,
+or the package is not required, disable it with --with-otcl=no." >&5
+$as_echo "$as_me: error: otcl is required but could not be completely found.
+Please correct the problem by telling configure where otcl is
+using the argument --with-otcl=/path/to/package,
+or the package is not required, disable it with --with-otcl=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+
+
+
+
+# Check whether --with-Tcl was given.
+if test "${with_Tcl+set}" = set; then
+  withval=$with_Tcl; { { $as_echo "$as_me:$LINENO: error: The --with-Tcl option has been replaced with --with-tclcl.
+Please insure you have an up-to-date copy of TclCL and re-run your configuration." >&5
+$as_echo "$as_me: error: The --with-Tcl option has been replaced with --with-tclcl.
+Please insure you have an up-to-date copy of TclCL and re-run your configuration." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+
+
+# Check whether --with-tclcl was given.
+if test "${with_tclcl+set}" = set; then
+  withval=$with_tclcl; d=$withval
+else
+  d=""
+fi
+
+
+TCLCL_VERS=1.19
+TCLCL_ALT_VERS=1.0
+
+TCLCL_H_PLACES="\
+		../tclcl-$TCLCL_VERS \
+		../tclcl-$TCLCL_ALT_VERS \
+		../tclcl \
+		../TclCL \
+		../Tcl-$TCLCL_VERS \
+		../Tcl-$TCLCL_ALT_VERS \
+		../Tcl \
+                /usr/src/local/Tcl \
+                /usr/src/local/Tcl-1.0 \
+                /import/Tcl/include \
+                /usr/local/include \
+                /usr/contrib/include \
+                /usr/include"
+TCLCL_H_PLACES_D="$d \
+ 		$d/include"
+TCLCL_LIB_PLACES="\
+		../tclcl-$TCLCL_VERS \
+		../tclcl-$TCLCL_ALT_VERS \
+		../tclcl \
+		../TclCL \
+		../Tcl-$TCLCL_VERS \
+		../Tcl-$TCLCL_ALT_VERS \
+		../Tcl \
+                $x_libraries \
+                /usr/contrib/lib \
+                /usr/local/lib \
+                /usr/lib \
+                /usr/src/local/Tcl \
+                /usr/src/local/Tcl-1.0"
+TCLCL_LIB_PLACES_D="\
+        $d \
+        $d/lib \
+        $d/bin"
+TCLCL_PROG_PLACES="\
+		../tclcl-$TCLCL_VERS \
+		../tclcl-$TCLCL_ALT_VERS \
+		../tclcl \
+		../TclCL \
+		../Tcl-$TCLCL_VERS \
+		../Tcl-$TCLCL_ALT_VERS \
+		../Tcl \
+                $prefix/bin \
+                $x_libraries \
+                /usr/contrib/bin \
+                /usr/local/bin \
+                /usr/bin \
+                /usr/src/local/Tcl \
+                /usr/src/local/Tcl-1.0 \
+                "
+TCLCL_PROG_PLACES_D="
+	$d \
+	$d/bin"
+
+
+
+NS_PACKAGE_tclcl_UNDERWAY=false
+NS_PACKAGE_tclcl_COMPLETE=true
+
+
+{ $as_echo "$as_me:$LINENO: checking for tclcl.h" >&5
+$as_echo_n "checking for tclcl.h... " >&6; }
+if test "x$d" = "xno"; then
+	: disable header
+	V_INCLUDE_TCLCL=FAIL
+
+NS_PACKAGE_tclcl_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$TCLCL_H_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCLCL_H_PLACES_D"
+	fi
+
+	V_INCLUDE_TCLCL=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/tclcl.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_INCLUDE_TCLCL="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_tclcl_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+
+				  ac_tr_hdr=HAVE_`echo tclcl.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_INCLUDE_TCLCL $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_tclcl_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_INCLUDE_TCLCL" >&5
+$as_echo "$V_INCLUDE_TCLCL" >&6; }
+	fi
+fi
+
+
+{ $as_echo "$as_me:$LINENO: checking for libtclcl$tclcl_VERS" >&5
+$as_echo_n "checking for libtclcl$tclcl_VERS... " >&6; }
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_TCLCL=FAIL
+
+NS_PACKAGE_tclcl_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$TCLCL_LIB_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCLCL_LIB_PLACES_D"
+	fi
+
+	V_LIB_TCLCL=""
+		full_lib_name="tclcl$tclcl_VERS"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_TCLCL="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_TCLCL" = "FAIL" ; then
+
+NS_PACKAGE_tclcl_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+		if test "$solaris"; then
+			V_LIB_TCLCL="-R$dir $V_LIB_TCLCL"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo tclcl$tclcl_VERS | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_TCLCL $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_tclcl_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_LIB_TCLCL" >&5
+$as_echo "$V_LIB_TCLCL" >&6; }
+	fi
+fi
+
+
+{ $as_echo "$as_me:$LINENO: checking for tcl2c++" >&5
+$as_echo_n "checking for tcl2c++... " >&6; }
+if test "x$d" = "xno"; then
+	: disable header
+	V_TCL2CPP_DIR=FAIL
+
+NS_PACKAGE_tclcl_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$TCLCL_PROG_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCLCL_PROG_PLACES_D"
+	fi
+
+	V_TCL2CPP_DIR=""
+	for dir in $places; do
+		if test -r $dir/tcl2c++; then
+			V_TCL2CPP_DIR="$dir"
+			break
+		fi
+	done
+	if test "FAIL$V_TCL2CPP_DIR" = "FAIL" ; then
+
+NS_PACKAGE_tclcl_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+
+		NS_PACKAGE_tclcl_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_TCL2CPP_DIR" >&5
+$as_echo "$V_TCL2CPP_DIR" >&6; }
+	fi
+fi
+
+
+V_TCL2CPP=$V_TCL2CPP_DIR/tcl2c++
+
+
+
+NS_PACKAGE_tclcl_VALID=false
+if $NS_PACKAGE_tclcl_UNDERWAY; then
+	if $NS_PACKAGE_tclcl_COMPLETE; then
+		: All components of tclcl found.
+		NS_PACKAGE_tclcl_VALID=true
+	else
+		{ { $as_echo "$as_me:$LINENO: error: Installation of tclcl seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tclcl is
+using the argument --with-tclcl=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tclcl=no." >&5
+$as_echo "$as_me: error: Installation of tclcl seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tclcl is
+using the argument --with-tclcl=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tclcl=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xyes" = xyes; then
+	if $NS_PACKAGE_tclcl_VALID; then
+		:
+	else
+		{ { $as_echo "$as_me:$LINENO: error: tclcl is required but could not be completely found.
+Please correct the problem by telling configure where tclcl is
+using the argument --with-tclcl=/path/to/package,
+or the package is not required, disable it with --with-tclcl=no." >&5
+$as_echo "$as_me: error: tclcl is required but could not be completely found.
+Please correct the problem by telling configure where tclcl is
+using the argument --with-tclcl=/path/to/package,
+or the package is not required, disable it with --with-tclcl=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+
+
+
+case "$target" in
+*-dec-*)
+					V_DEFINE="$V_DEFINE -D_XOPEN_SOURCE_EXTENDED"
+	cat >>confdefs.h <<\_ACEOF
+#define _XOPEN_SOURCE_EXTENDED 1
+_ACEOF
+
+	;;
+sparc-sun-solaris*)
+	if test $CC != gcc ; then
+	        V_DEFINE="$V_DEFINE -D__FUNCTION__=__func__ -features=extensions"
+	fi
+        V_DEFINE="$V_DEFINE -D__svr4__ -DSOLARIS_MIN_MAX"
+	V_LIB="$V_LIB -ldl"
+	;;
+sparc-sun-sunos*)
+	V_DEFINE="$V_DEFINE -DNEED_SUNOS_PROTOS"
+	;;
+*-sgi-irix5*)
+	V_DEFINE="$V_DEFINE -DIRIX5 -D_BSD_SIGNALS"
+	if test "$target_os" = irix5.3 ; then
+		V_DEFINE="$V_DEFINE -DIRIX5_3"
+	fi
+	V_TARCMD="tar cfL"
+	V_SHELL="SHELL = /bin/sh"
+	if test $CC != gcc ; then
+		V_DEFINE="$V_DEFINE -signed -g3"
+		V_CXXOPT="$V_CXXOPT +p -float"
+		CC="cc -xansi -D__STDC__ -Dinline="
+		CXX="CC +p -float -DSGI_COMPAT"
+	fi
+	V_RANLIB="ar ts"
+	;;
+*-sgi-irix6*)
+	V_DEFINE="$V_DEFINE -DIRIX6 -D_BSD_SIGNALS"
+	V_TARCMD="tar cfL"
+	V_SHELL="SHELL = /bin/sh"
+	if test $CC != gcc ; then
+		V_DEFINE="$V_DEFINE -signed -g3"
+		V_CXXOPT="$V_CXXOPT +p -float"
+		CC="cc -xansi -D__STDC__ -Dinline="
+		CXX="CC +p -float -DSGI_COMPAT"
+	fi
+	V_RANLIB="ar ts"
+	;;
+*-*-bsdi1*)
+	V_SHM=""
+	V_TARCMD="tar cfL"
+	;;
+*-*-bsdi2.0*)
+	V_SHM=""
+	V_TARCMD="tar cfL"
+	;;
+*-*-bsdi2.1*)
+	# bsdi2.1 added sys-v shared memory support but their implementation
+	# is broken so we have to turn it off.  If they ever fix libipc,
+	# the following line should be deleted.
+	V_SHM=""
+	V_TARCMD="tar cfL"
+	V_CCOPT="-O2 -m486"
+	V_LIB="$V_LIB -lipc -ldl"
+	;;
+*-*-bsdi3*)
+	V_SHM=""
+	V_TARCMD="tar cfL"
+	V_LIB="$V_LIB -lipc -ldl"
+	V_OBJ="$V_OBJ misc/serial.o"
+	;;
+*-*-freebsd*)
+	V_OBJ="$V_OBJ misc/serial.o"
+	;;
+*-*-netbsd*)
+	V_TARCMD="tar -h -c -f"
+	V_LIB="$V_LIB -L/usr/local/lib"
+	;;
+*-*-hpux*)
+	cat >>confdefs.h <<\_ACEOF
+#define random lrand48
+_ACEOF
+
+	cat >>confdefs.h <<\_ACEOF
+#define srandom srand
+_ACEOF
+
+	V_CCOPT="-O"
+	;;
+*-*-aix3*)
+	V_DEFINE="$V_DEFINE -DSIGARGS=int"
+	if test "$V_LIB_AIXSHM" != "" ; then
+		V_LIB="$V_LIB $V_LIB_AIXSHM"
+	else
+		V_SHM=""
+	fi
+	CXX="xlC -+"
+	;;
+*-*-aix4*)
+	V_DEFINE="$V_DEFINE -DSIGARGS=int -D_AIX41"
+	if test "$V_LIB_AIXSHM" != "" ; then
+		V_LIB="$V_LIB $V_LIB_AIXSHM"
+	else
+		V_SHM=""
+	fi
+	CXX="g++"
+	;;
+*-*-linux*)
+	V_BROKEN_OBJ=
+	;;
+powerpc-apple-darwin*)
+	V_CCOPT="-fno-common -fPIC -pipe"
+	;;
+esac
+
+
+xlibdirs="\
+	/usr/openwin/lib \
+	/usr/X11R6/lib \
+	/usr/lib/X11R6 \
+	/usr/X11R5/lib \
+	/usr/lib/X11R5 \
+	/usr/X11R4/lib \
+	/usr/lib/X11R4 \
+	/usr/local/lib \
+	/usr/X386/lib \
+	/usr/X11/lib \
+	/usr/unsupported/lib \
+	/Developer/SDKs/MacOSX10.4u.sdk/usr/X11R6/lib \
+	/import/X11R4/usr/lib"
+
+xincdirs="\
+	/usr/openwin/include \
+	/usr/X11R6/include \
+	/usr/include/X11R6 \
+	/usr/X11R5/include \
+	/usr/include/X11R5 \
+	/usr/X11R4/include \
+	/usr/include/X11R4 \
+	/usr/local/include \
+	/usr/X386/include \
+	/usr/X11/include \
+	/usr/lpp/X11/include \
+	/usr/unsupported/include \
+	/Developer/SDKs/MacOSX10.4u.sdk/usr/X11R6/include \
+	/import/X11R4/include"
+
+
+echo "checking for X11 header files"
+if test "$x_includes" = NONE ; then
+	cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <X11/Intrinsic.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  x_includes=""
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  x_includes=NONE
+fi
+
+rm -f conftest.err conftest.$ac_ext
+	if test "$x_includes" = NONE ; then
+	        for i in $xincdirs ; do
+			if test -r $i/X11/Intrinsic.h; then
+				x_includes=$i
+				break
+			fi
+	        done
+		if test "$x_includes" = NONE ; then
+			echo "can't find X includes"
+	       		exit 1
+		fi
+	fi
+fi
+if test -n "$x_includes" ; then
+	V_INCLUDE_X11=-I$x_includes
+
+fi
+
+echo "checking for X11 library archive"
+if test "$x_libraries" = NONE ; then
+	{ $as_echo "$as_me:$LINENO: checking for XOpenDisplay in -lX11" >&5
+$as_echo_n "checking for XOpenDisplay in -lX11... " >&6; }
+if test "${ac_cv_lib_X11_XOpenDisplay+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lX11  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XOpenDisplay ();
+int
+main ()
+{
+return XOpenDisplay ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_X11_XOpenDisplay=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_X11_XOpenDisplay=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_X11_XOpenDisplay" >&5
+$as_echo "$ac_cv_lib_X11_XOpenDisplay" >&6; }
+if test "x$ac_cv_lib_X11_XOpenDisplay" = x""yes; then
+  x_libraries=""
+else
+  x_libraries=NONE
+fi
+
+	if test "$x_libraries" = NONE ; then
+		for i in $xlibdirs ; do
+			if test -r $i/libX11.a -o -r $i/libX11.so -o -r $i/libX11.dll.a; then
+				x_libraries=$i
+				break
+			fi
+       		done
+		if test "$x_libraries" = NONE ; then
+			echo "can't find X library"
+			exit 1
+		fi
+	fi
+fi
+
+V_LIB_X11=-lX11
+
+if test -n "$V_SHM" ; then
+	if test -z "$x_libraries" ; then
+		{ $as_echo "$as_me:$LINENO: checking for XShmAttach in -lXext" >&5
+$as_echo_n "checking for XShmAttach in -lXext... " >&6; }
+if test "${ac_cv_lib_Xext_XShmAttach+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lXext -lX11 $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XShmAttach ();
+int
+main ()
+{
+return XShmAttach ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_Xext_XShmAttach=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_Xext_XShmAttach=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xext_XShmAttach" >&5
+$as_echo "$ac_cv_lib_Xext_XShmAttach" >&6; }
+if test "x$ac_cv_lib_Xext_XShmAttach" = x""yes; then
+  V_Xext="-lXext"
+else
+  V_Xext=NONE
+fi
+
+	else
+		echo "checking for libXext.a"
+		if test -f $x_libraries/libXext.a -o -f $x_libraries/libXext.so; then
+			V_Xext="-lXext"
+		else
+			echo "warning: compiling without -lXext"
+		fi
+	fi
+	if test "$V_Xext" = NONE ; then
+		echo "warning: compiling without -lXext"
+	else
+		V_LIB_X11="$V_Xext $V_LIB_X11"
+	fi
+fi
+
+if test -n "$x_libraries" ; then
+	V_LIB_X11="-L$x_libraries $V_LIB_X11"
+	if test $solaris ; then
+		V_LIB_X11="-R$x_libraries $V_LIB_X11"
+	fi
+fi
+
+
+
+
+# Check whether --with-tcldebug was given.
+if test "${with_tcldebug+set}" = set; then
+  withval=$with_tcldebug; d=$withval
+else
+  d=""
+fi
+
+
+#xxx: Don't know anything about 1.8
+# 2.0 = tcl 8.3
+# 1.9 = tcl 7.5, 7.6, 8.0
+TCLDEBUG_VERS="2.0 1.9 1.8 1.7"
+pwd_vers=""
+local_vers=""
+for vers in $TCLDEBUG_VERS; do
+	 pwd_vers="$pwd_vers $PWD/../tcl-debug-$vers"
+	 local_vers="$local_vers /usr/src/local/otcl-debug-$vers"
+done
+TCLDEBUG_PATH="\
+		$PWD/../tcl-debug \
+		$pwd_vers
+		/usr/contrib/lib \
+		/usr/local/lib \
+		/usr/lib \
+		/usr/src/local/tcl-debug \
+		$local_vers \
+		"
+TCLDEBUG_PATH_D="$d \
+		$d/lib \
+		$d/../lib \
+		"
+
+
+NS_PACKAGE_tcldebug_UNDERWAY=false
+NS_PACKAGE_tcldebug_COMPLETE=true
+
+
+
+{ $as_echo "$as_me:$LINENO: checking for libtcldbg" >&5
+$as_echo_n "checking for libtcldbg... " >&6; }
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_TCLDEBUG=FAIL
+
+NS_PACKAGE_tcldebug_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$TCLDEBUG_PATH"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$TCLDEBUG_PATH_D"
+	fi
+
+	V_LIB_TCLDEBUG=""
+		full_lib_name="tcldbg"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_TCLDEBUG="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_TCLDEBUG" = "FAIL" ; then
+
+NS_PACKAGE_tcldebug_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+		if test "$solaris"; then
+			V_LIB_TCLDEBUG="-R$dir $V_LIB_TCLDEBUG"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo tcldbg | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_TCLDEBUG $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_tcldebug_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_LIB_TCLDEBUG" >&5
+$as_echo "$V_LIB_TCLDEBUG" >&6; }
+	fi
+fi
+
+#if $NS_PACKAGE_tcldebug_COMPLETE; then
+	# look for debugger entry point function
+	#tmpLIBS=$LIBS
+	#LIBS="$V_LIB_TCL $V_LIB_TCLDEBUG"
+
+	# the following two may be needed for linking during tcldbg CHECK_LIB
+	#AC_CHECK_LIB(m, main)
+        #AC_CHECK_LIB(dl, dlopen)
+
+	#notfound=false
+	#AC_CHECK_LIB(tcldbg, Dbg_Init, V_DEFINES="-DHAVE_Dbg_Init $V_DEFINES",notfound=true)
+	#if $notfound; then
+	#	notfound=false
+	#	AC_CHECK_LIB(tcldbg, Tcldbg_Init, V_DEFINES="-DHAVE_Tcldbg_Init $V_DEFINES",notfound=true)
+	#fi
+	#LIBS=$tmpLIBS
+	#if $notfound; then
+	#	echo "configure: warning: Tcl debugger init point is not found.  You \
+#will not be able to use Tcl debugger." 1>&2
+	#	NS_PACKAGE_tcldebug_COMPLETE=false
+	#fi
+#fi
+
+if $NS_PACKAGE_tcldebug_COMPLETE; then
+
+NS_PACKAGE_tcldebug_VALID=false
+if $NS_PACKAGE_tcldebug_UNDERWAY; then
+	if $NS_PACKAGE_tcldebug_COMPLETE; then
+		: All components of tcldebug found.
+		NS_PACKAGE_tcldebug_VALID=true
+	else
+		{ { $as_echo "$as_me:$LINENO: error: Installation of tcldebug seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tcldebug is
+using the argument --with-tcldebug=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tcldebug=no." >&5
+$as_echo "$as_me: error: Installation of tcldebug seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tcldebug is
+using the argument --with-tcldebug=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tcldebug=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xno" = xyes; then
+	if $NS_PACKAGE_tcldebug_VALID; then
+		:
+	else
+		{ { $as_echo "$as_me:$LINENO: error: tcldebug is required but could not be completely found.
+Please correct the problem by telling configure where tcldebug is
+using the argument --with-tcldebug=/path/to/package,
+or the package is not required, disable it with --with-tcldebug=no." >&5
+$as_echo "$as_me: error: tcldebug is required but could not be completely found.
+Please correct the problem by telling configure where tcldebug is
+using the argument --with-tcldebug=/path/to/package,
+or the package is not required, disable it with --with-tcldebug=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+fi
+
+
+
+# Check whether --with-dmalloc was given.
+if test "${with_dmalloc+set}" = set; then
+  withval=$with_dmalloc; d="$withval"
+else
+  d="UNDEF"
+fi
+
+
+DMALLOC_VERS=3.2.1
+
+DMALLOC_PATH="$PWD/../dmalloc \
+	$PWD/../dmalloc-$DMALLOC_VERS \
+	/usr/contrib/lib \
+	/usr/local/lib \
+	/usr/lib \
+	/usr/contrib/include \
+	/usr/local/include \
+	/usr/include \
+	"
+DMALLOC_PATH_D="$d $d/lib $d/include"
+
+if test "x$d" = xUNDEF; then
+	{ $as_echo "$as_me:$LINENO: checking dmalloc" >&5
+$as_echo_n "checking dmalloc... " >&6; }
+	{ $as_echo "$as_me:$LINENO: result: not requested with --with-dmalloc" >&5
+$as_echo "not requested with --with-dmalloc" >&6; }
+else
+
+NS_PACKAGE_dmalloc_UNDERWAY=false
+NS_PACKAGE_dmalloc_COMPLETE=true
+
+
+{ $as_echo "$as_me:$LINENO: checking for libdmalloc" >&5
+$as_echo_n "checking for libdmalloc... " >&6; }
+if test "x$d" = "xno"; then
+	: disable library
+	V_LIB_DMALLOC=FAIL
+
+NS_PACKAGE_dmalloc_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$DMALLOC_PATH"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$DMALLOC_PATH_D"
+	fi
+
+	V_LIB_DMALLOC=""
+		full_lib_name="dmalloc"
+		simple_lib_name=`echo $full_lib_name | sed -e 's/\.//'`
+		other_simple_lib_name=`echo $full_lib_name | sed -e 's/\./_/'`
+		simpler_lib_name=`echo $simple_lib_name | sed -e 'y/0123456789/          /'`
+	double_break=false
+	for dir in $places; do
+		for file in $full_lib_name $simple_lib_name $other_simple_lib_name $simpler_lib_name
+		do
+			if test -r $dir/lib$file.so -o -r $dir/lib$file.a -o -r $dir/lib$file.dylib; then
+				V_LIB_DMALLOC="-L$dir -l$file"
+				double_break=true
+				break
+			fi
+		done
+		if $double_break; then
+			break
+		fi
+	done
+	if test "FAIL$V_LIB_DMALLOC" = "FAIL" ; then
+
+NS_PACKAGE_dmalloc_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+		if test "$solaris"; then
+			V_LIB_DMALLOC="-R$dir $V_LIB_DMALLOC"
+		fi
+
+				ac_tr_lib=HAVE_LIB`echo dmalloc | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+		    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+				cat >>confdefs.h <<_ACEOF
+#define $ac_tr_lib 1
+_ACEOF
+
+
+				V_LIBS="$V_LIB_DMALLOC $V_LIBS"
+		V_DEFINES="-D$ac_tr_lib $V_DEFINES"
+
+		NS_PACKAGE_dmalloc_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_LIB_DMALLOC" >&5
+$as_echo "$V_LIB_DMALLOC" >&6; }
+	fi
+fi
+
+
+{ $as_echo "$as_me:$LINENO: checking for dmalloc.h" >&5
+$as_echo_n "checking for dmalloc.h... " >&6; }
+if test "x$d" = "xno"; then
+	: disable header
+	V_HEADER_DMALLOC=FAIL
+
+NS_PACKAGE_dmalloc_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$DMALLOC_PATH"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$DMALLOC_PATH_D"
+	fi
+
+	V_HEADER_DMALLOC=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/dmalloc.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_HEADER_DMALLOC="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_dmalloc_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+
+				  ac_tr_hdr=HAVE_`echo dmalloc.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_HEADER_DMALLOC $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_dmalloc_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_HEADER_DMALLOC" >&5
+$as_echo "$V_HEADER_DMALLOC" >&6; }
+	fi
+fi
+
+
+{ $as_echo "$as_me:$LINENO: checking for return.h" >&5
+$as_echo_n "checking for return.h... " >&6; }
+if test "x$d" = "xno"; then
+	: disable header
+	V_HEADER_RETURN=FAIL
+
+NS_PACKAGE_dmalloc_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$DMALLOC_PATH"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$DMALLOC_PATH_D"
+	fi
+
+	V_HEADER_RETURN=""
+	found=""
+	for dir in $places; do
+		if test -r $dir/return.h; then
+                        found="$dir"
+                        if test "$CC" != "icc" ||
+                                test "$dir" != "/usr/include"; then
+                                V_HEADER_RETURN="-I$dir"
+                        fi
+			break
+		fi
+	done
+	if test "FAIL$found" = "FAIL" ; then
+
+NS_PACKAGE_dmalloc_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+
+				  ac_tr_hdr=HAVE_`echo return.h | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+		                cat >>confdefs.h <<_ACEOF
+#define $ac_tr_hdr 1
+_ACEOF
+
+
+		V_INCLUDES="$V_HEADER_RETURN $V_INCLUDES"
+		V_DEFINES="-D$ac_tr_hdr $V_DEFINES"
+
+		NS_PACKAGE_dmalloc_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $V_HEADER_RETURN" >&5
+$as_echo "$V_HEADER_RETURN" >&6; }
+	fi
+fi
+
+
+NS_PACKAGE_dmalloc_VALID=false
+if $NS_PACKAGE_dmalloc_UNDERWAY; then
+	if $NS_PACKAGE_dmalloc_COMPLETE; then
+		: All components of dmalloc found.
+		NS_PACKAGE_dmalloc_VALID=true
+	else
+		{ { $as_echo "$as_me:$LINENO: error: Installation of dmalloc seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where dmalloc is
+using the argument --with-dmalloc=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-dmalloc=no." >&5
+$as_echo "$as_me: error: Installation of dmalloc seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where dmalloc is
+using the argument --with-dmalloc=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-dmalloc=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+if test "xno" = xyes; then
+	if $NS_PACKAGE_dmalloc_VALID; then
+		:
+	else
+		{ { $as_echo "$as_me:$LINENO: error: dmalloc is required but could not be completely found.
+Please correct the problem by telling configure where dmalloc is
+using the argument --with-dmalloc=/path/to/package,
+or the package is not required, disable it with --with-dmalloc=no." >&5
+$as_echo "$as_me: error: dmalloc is required but could not be completely found.
+Please correct the problem by telling configure where dmalloc is
+using the argument --with-dmalloc=/path/to/package,
+or the package is not required, disable it with --with-dmalloc=no." >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+fi
+
+fi
+
+
+
+default_classinstvar=yes
+
+
+if test x$default_classinstvar = x
+then
+	default_classinstvar=no
+fi
+
+# Check whether --enable-tclcl-classinstvar was given.
+if test "${enable_tclcl_classinstvar+set}" = set; then
+  enableval=$enable_tclcl_classinstvar; enable_classinstvar=$enableval
+else
+  enable_classinstvar=$default_classinstvar
+fi
+
+if test "$enable_classinstvar" = "yes";
+then
+	V_DEFINE="-DTCLCL_CLASSINSTVAR $V_DEFINE"
+fi
+
+
+
+
+PERL_OPTIONAL=true
+
+
+
+# Check whether --with-perl was given.
+if test "${with_perl+set}" = set; then
+  withval=$with_perl; d=$withval
+else
+  d=""
+fi
+
+
+# Next line is the minimum version of perl required.
+# 5.000 and 5.001 are generally scorned because of age and bugs.
+PERL_VERSION=${PERL_VERSION:-5.002}
+
+PERL_PLACES=`echo $PATH | sed 's/:/ /g'`
+
+PERL_OPTIONAL=${PERL_OPTIONAL:-false}
+
+
+
+
+{ $as_echo "$as_me:$LINENO: checking for perl" >&5
+$as_echo_n "checking for perl... " >&6; }
+if test "x$d" = "xno"; then
+	: disable header
+	PERL=FAIL
+
+NS_PACKAGE_no_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$PERL_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$d"
+	fi
+
+	PERL=""
+	for dir in $places; do
+		if test -r $dir/perl; then
+			PERL="$dir"
+			break
+		fi
+	done
+	if test "FAIL$PERL" = "FAIL" ; then
+
+NS_PACKAGE_no_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+
+		NS_PACKAGE_no_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $PERL" >&5
+$as_echo "$PERL" >&6; }
+	fi
+fi
+
+if test "x$PERL" != x
+then
+    PERL=$PERL/perl
+
+echo $PERL -e "require $PERL_VERSION" 1>&5
+if $PERL -e "require $PERL_VERSION" 2>&5
+then
+    : good version
+else
+    : non-good version => zero pathname
+    { $as_echo "$as_me:$LINENO: result:     not version $PERL_VERSION" >&5
+$as_echo "    not version $PERL_VERSION" >&6; }
+    PERL=''
+fi
+
+fi
+
+if test "x$PERL" = "x"
+then
+
+{ $as_echo "$as_me:$LINENO: checking for perl5" >&5
+$as_echo_n "checking for perl5... " >&6; }
+if test "x$d" = "xno"; then
+	: disable header
+	PERL=FAIL
+
+NS_PACKAGE_no_COMPLETE=false
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+
+else
+	places="$PERL_PLACES"
+	if test "x$d" != "x" -a "x$d" != xyes; then
+		if test ! -d $d; then
+			{ { $as_echo "$as_me:$LINENO: error: $d is not a directory" >&5
+$as_echo "$as_me: error: $d is not a directory" >&2;}
+   { (exit 1); exit 1; }; }
+		fi
+		places="$d"
+	fi
+
+	PERL=""
+	for dir in $places; do
+		if test -r $dir/perl5; then
+			PERL="$dir"
+			break
+		fi
+	done
+	if test "FAIL$PERL" = "FAIL" ; then
+
+NS_PACKAGE_no_COMPLETE=false
+
+		{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	else
+
+		NS_PACKAGE_no_UNDERWAY=true
+
+		{ $as_echo "$as_me:$LINENO: result: $PERL" >&5
+$as_echo "$PERL" >&6; }
+	fi
+fi
+
+    if test "x$PERL" != "x"
+    then
+	PERL=$PERL/perl5
+
+echo $PERL -e "require $PERL_VERSION" 1>&5
+if $PERL -e "require $PERL_VERSION" 2>&5
+then
+    : good version
+else
+    : non-good version => zero pathname
+    { $as_echo "$as_me:$LINENO: result:     not version $PERL_VERSION" >&5
+$as_echo "    not version $PERL_VERSION" >&6; }
+    PERL=''
+fi
+
+    fi
+fi
+
+if test "x$PERL" = x
+then
+    if $PERL_OPTIONAL
+    then
+        { $as_echo "$as_me:$LINENO: result:     perl version $PERL_VERSION not found" >&5
+$as_echo "    perl version $PERL_VERSION not found" >&6; }
+    else
+        { { $as_echo "$as_me:$LINENO: error: Cannot find Perl 5." >&5
+$as_echo "$as_me: error: Cannot find Perl 5." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+fi
+
+
+
+
+if test "x$PERL" = x
+then
+	{ $as_echo "$as_me:$LINENO: WARNING: Perl5 not found; test scripts will not run succesfully." >&5
+$as_echo "$as_me: WARNING: Perl5 not found; test scripts will not run succesfully." >&2;}
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if test "${ac_cv_header_stdc+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_header_stdc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_header_stdc=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+
+
+
+
+
+
+
+
+
+for ac_header in arpa/inet.h fenv.h netinet/in.h string.h strings.h time.h unistd.h net/ethernet.h
+do
+as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
+$as_echo_n "checking $ac_header usability... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
+$as_echo_n "checking $ac_header presence... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+
+    ;;
+esac
+{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+
+fi
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+{ $as_echo "$as_me:$LINENO: checking for main in -lm" >&5
+$as_echo_n "checking for main in -lm... " >&6; }
+if test "${ac_cv_lib_m_main+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lm  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+return main ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_m_main=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_m_main=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_m_main" >&5
+$as_echo "$ac_cv_lib_m_main" >&6; }
+if test "x$ac_cv_lib_m_main" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBM 1
+_ACEOF
+
+  LIBS="-lm $LIBS"
+
+else
+  { { $as_echo "$as_me:$LINENO: error: Could not find math library" >&5
+$as_echo "$as_me: error: Could not find math library" >&2;}
+   { (exit cannot continue.); exit cannot continue.; }; }
+fi
+
+
+
+
+
+
+
+
+for ac_func in bcopy bzero fesetprecision feenableexcept getrusage sbrk snprintf
+do
+as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
+$as_echo_n "checking for $ac_func... " >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
+#endif
+
+int
+main ()
+{
+return $ac_func ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  eval "$as_ac_var=yes"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_var=no"
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+ac_res=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+{ $as_echo "$as_me:$LINENO: checking return type of random" >&5
+$as_echo_n "checking return type of random... " >&6; }
+touch confdefs.h
+if test "$cross_compiling" = yes; then
+  { $as_echo "$as_me:$LINENO: result: cross compiling--guessing int" >&5
+$as_echo "cross compiling--guessing int" >&6; }
+cat >>confdefs.h <<\_ACEOF
+#define RANDOM_RETURN_TYPE int
+_ACEOF
+
+
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include "confdefs.h"
+long random() { return 1; }
+main() { exit(0); }
+
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  { $as_echo "$as_me:$LINENO: result: long" >&5
+$as_echo "long" >&6; }
+cat >>confdefs.h <<\_ACEOF
+#define RANDOM_RETURN_TYPE long
+_ACEOF
+
+
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+{ $as_echo "$as_me:$LINENO: result: int" >&5
+$as_echo "int" >&6; }
+cat >>confdefs.h <<\_ACEOF
+#define RANDOM_RETURN_TYPE int
+_ACEOF
+
+
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+
+{ $as_echo "$as_me:$LINENO: checking for int8_t" >&5
+$as_echo_n "checking for int8_t... " >&6; }
+if test "${ac_cv_type_int8_t+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_type_int8_t=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof (int8_t))
+       return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof ((int8_t)))
+	  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_int8_t=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_int8_t" >&5
+$as_echo "$ac_cv_type_int8_t" >&6; }
+if test "x$ac_cv_type_int8_t" = x""yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define int8_t signed char
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for int16_t" >&5
+$as_echo_n "checking for int16_t... " >&6; }
+if test "${ac_cv_type_int16_t+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_type_int16_t=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof (int16_t))
+       return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof ((int16_t)))
+	  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_int16_t=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_int16_t" >&5
+$as_echo "$ac_cv_type_int16_t" >&6; }
+if test "x$ac_cv_type_int16_t" = x""yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define int16_t short
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for int32_t" >&5
+$as_echo_n "checking for int32_t... " >&6; }
+if test "${ac_cv_type_int32_t+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_type_int32_t=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof (int32_t))
+       return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof ((int32_t)))
+	  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_int32_t=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_int32_t" >&5
+$as_echo "$ac_cv_type_int32_t" >&6; }
+if test "x$ac_cv_type_int32_t" = x""yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define int32_t int
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for u_int8_t" >&5
+$as_echo_n "checking for u_int8_t... " >&6; }
+if test "${ac_cv_type_u_int8_t+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_type_u_int8_t=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof (u_int8_t))
+       return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof ((u_int8_t)))
+	  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_u_int8_t=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_u_int8_t" >&5
+$as_echo "$ac_cv_type_u_int8_t" >&6; }
+if test "x$ac_cv_type_u_int8_t" = x""yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define u_int8_t unsigned char
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for u_int16_t" >&5
+$as_echo_n "checking for u_int16_t... " >&6; }
+if test "${ac_cv_type_u_int16_t+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_type_u_int16_t=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof (u_int16_t))
+       return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof ((u_int16_t)))
+	  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_u_int16_t=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_u_int16_t" >&5
+$as_echo "$ac_cv_type_u_int16_t" >&6; }
+if test "x$ac_cv_type_u_int16_t" = x""yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define u_int16_t unsigned short
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for u_int32_t" >&5
+$as_echo_n "checking for u_int32_t... " >&6; }
+if test "${ac_cv_type_u_int32_t+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_type_u_int32_t=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof (u_int32_t))
+       return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof ((u_int32_t)))
+	  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_u_int32_t=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_u_int32_t" >&5
+$as_echo "$ac_cv_type_u_int32_t" >&6; }
+if test "x$ac_cv_type_u_int32_t" = x""yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define u_int32_t unsigned int
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for u_char" >&5
+$as_echo_n "checking for u_char... " >&6; }
+if test "${ac_cv_type_u_char+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_type_u_char=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof (u_char))
+       return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof ((u_char)))
+	  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_u_char=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_u_char" >&5
+$as_echo "$ac_cv_type_u_char" >&6; }
+if test "x$ac_cv_type_u_char" = x""yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define u_char unsigned char
+_ACEOF
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for u_int" >&5
+$as_echo_n "checking for u_int... " >&6; }
+if test "${ac_cv_type_u_int+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_type_u_int=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof (u_int))
+       return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if (sizeof ((u_int)))
+	  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  :
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_u_int=yes
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_u_int" >&5
+$as_echo "$ac_cv_type_u_int" >&6; }
+if test "x$ac_cv_type_u_int" = x""yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define u_int unsigned int
+_ACEOF
+
+fi
+
+
+
+
+
+for ac_func in strtoq strtoll
+do
+as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
+$as_echo_n "checking for $ac_func... " >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
+#endif
+
+int
+main ()
+{
+return $ac_func ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  eval "$as_ac_var=yes"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_var=no"
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+ac_res=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+INT64_T_ALTERNATIVE=none
+HAVE_SUPPORTING_FUNC=false
+
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:$LINENO: checking size of long" >&5
+$as_echo_n "checking size of long... " >&6; }
+if test "${ac_cv_sizeof_long+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test "$cross_compiling" = yes; then
+  # Depending upon the size, compute the lo and hi bounds.
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long int) (sizeof (long))) >= 0)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_lo=0 ac_mid=0
+  while :; do
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= $ac_mid)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_hi=$ac_mid; break
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_lo=`expr $ac_mid + 1`
+			if test $ac_lo -le $ac_mid; then
+			  ac_lo= ac_hi=
+			  break
+			fi
+			ac_mid=`expr 2 '*' $ac_mid + 1`
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long int) (sizeof (long))) < 0)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_hi=-1 ac_mid=-1
+  while :; do
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long int) (sizeof (long))) >= $ac_mid)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_lo=$ac_mid; break
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_hi=`expr '(' $ac_mid ')' - 1`
+			if test $ac_mid -le $ac_hi; then
+			  ac_lo= ac_hi=
+			  break
+			fi
+			ac_mid=`expr 2 '*' $ac_mid`
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_lo= ac_hi=
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+# Binary search between lo and hi bounds.
+while test "x$ac_lo" != "x$ac_hi"; do
+  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= $ac_mid)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_hi=$ac_mid
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_lo=`expr '(' $ac_mid ')' + 1`
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+case $ac_lo in
+?*) ac_cv_sizeof_long=$ac_lo;;
+'') if test "$ac_cv_type_long" = yes; then
+     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (long)
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: cannot compute sizeof (long)
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }; }
+   else
+     ac_cv_sizeof_long=0
+   fi ;;
+esac
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+static long int longval () { return (long int) (sizeof (long)); }
+static unsigned long int ulongval () { return (long int) (sizeof (long)); }
+#include <stdio.h>
+#include <stdlib.h>
+int
+main ()
+{
+
+  FILE *f = fopen ("conftest.val", "w");
+  if (! f)
+    return 1;
+  if (((long int) (sizeof (long))) < 0)
+    {
+      long int i = longval ();
+      if (i != ((long int) (sizeof (long))))
+	return 1;
+      fprintf (f, "%ld", i);
+    }
+  else
+    {
+      unsigned long int i = ulongval ();
+      if (i != ((long int) (sizeof (long))))
+	return 1;
+      fprintf (f, "%lu", i);
+    }
+  /* Do not output a trailing newline, as this causes \r\n confusion
+     on some platforms.  */
+  return ferror (f) || fclose (f) != 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_sizeof_long=`cat conftest.val`
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+if test "$ac_cv_type_long" = yes; then
+     { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot compute sizeof (long)
+See \`config.log' for more details." >&5
+$as_echo "$as_me: error: cannot compute sizeof (long)
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }; }
+   else
+     ac_cv_sizeof_long=0
+   fi
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f conftest.val
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_sizeof_long" >&5
+$as_echo "$ac_cv_sizeof_long" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_LONG $ac_cv_sizeof_long
+_ACEOF
+
+
+if test $ac_cv_sizeof_long -ge 8
+then
+	INT64_T_ALTERNATIVE=long
+	{ $as_echo "$as_me:$LINENO: checking for strtol" >&5
+$as_echo_n "checking for strtol... " >&6; }
+if test "${ac_cv_func_strtol+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define strtol to an innocuous variant, in case <limits.h> declares strtol.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define strtol innocuous_strtol
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char strtol (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef strtol
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char strtol ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_strtol || defined __stub___strtol
+choke me
+#endif
+
+int
+main ()
+{
+return strtol ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_func_strtol=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_func_strtol=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_strtol" >&5
+$as_echo "$ac_cv_func_strtol" >&6; }
+
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for __int64_t" >&5
+$as_echo_n "checking for __int64_t... " >&6; }
+if test "${nsnam_cv_int64_t_HAVE___INT64_T+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+
+if test "$cross_compiling" = yes; then
+  nsnam_cv_int64_t_HAVE___INT64_T=cross
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+main() { __int64_t x; exit (sizeof(x) >= 8 ? 0 : 1); }
+
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  nsnam_cv_int64_t_HAVE___INT64_T=yes
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+nsnam_cv_int64_t_HAVE___INT64_T=no
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $nsnam_cv_int64_t_HAVE___INT64_T" >&5
+$as_echo "$nsnam_cv_int64_t_HAVE___INT64_T" >&6; }
+if test x"$nsnam_cv_int64_t_HAVE___INT64_T" = x"yes" -a "x$INT64_T_ALTERNATIVE" = xnone; then
+	INT64_T_ALTERNATIVE=__int64_t
+fi
+
+{ $as_echo "$as_me:$LINENO: checking for long long" >&5
+$as_echo_n "checking for long long... " >&6; }
+if test "${nsnam_cv_int64_t_HAVE_LONG_LONG+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+
+if test "$cross_compiling" = yes; then
+  nsnam_cv_int64_t_HAVE_LONG_LONG=cross
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+main() { long long x; exit (sizeof(x) >= 8 ? 0 : 1); }
+
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  nsnam_cv_int64_t_HAVE_LONG_LONG=yes
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+nsnam_cv_int64_t_HAVE_LONG_LONG=no
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $nsnam_cv_int64_t_HAVE_LONG_LONG" >&5
+$as_echo "$nsnam_cv_int64_t_HAVE_LONG_LONG" >&6; }
+if test x"$nsnam_cv_int64_t_HAVE_LONG_LONG" = x"yes" -a "x$INT64_T_ALTERNATIVE" = xnone; then
+	INT64_T_ALTERNATIVE="long long"
+fi
+
+
+
+{ $as_echo "$as_me:$LINENO: checking for int64_t" >&5
+$as_echo_n "checking for int64_t... " >&6; }
+if test "${ac_cv_type_int64_t+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "(^|[^a-zA-Z_0-9])int64_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
+  ac_cv_type_int64_t=yes
+else
+  ac_cv_type_int64_t=no
+fi
+rm -f conftest*
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_int64_t" >&5
+$as_echo "$ac_cv_type_int64_t" >&6; }
+if test $ac_cv_type_int64_t = no; then
+
+cat >>confdefs.h <<_ACEOF
+#define int64_t $INT64_T_ALTERNATIVE
+_ACEOF
+
+fi
+
+
+{ $as_echo "$as_me:$LINENO: checking which kind of 64-bit int to use" >&5
+$as_echo_n "checking which kind of 64-bit int to use... " >&6; }
+if test $ac_cv_type_int64_t = yes -o "$INT64_T_ALTERNATIVE" != none
+then
+	if test "$INT64_T_ALTERNATIVE" = long -o "$ac_cv_func_strtoq" = yes -o "$ac_cv_func_strtoll" = yes
+	then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_INT64 1
+_ACEOF
+
+		if test $ac_cv_type_int64_t = yes
+		then
+			{ $as_echo "$as_me:$LINENO: result: int64_t" >&5
+$as_echo "int64_t" >&6; }
+		else
+			{ $as_echo "$as_me:$LINENO: result: $INT64_T_ALTERNATIVE" >&5
+$as_echo "$INT64_T_ALTERNATIVE" >&6; }
+		fi
+	else
+		{ $as_echo "$as_me:$LINENO: result: missing strto 64-bit-type" >&5
+$as_echo "missing strto 64-bit-type" >&6; }
+	fi
+else
+	{ $as_echo "$as_me:$LINENO: result: none" >&5
+$as_echo "none" >&6; }
+fi
+
+
+
+
+
+
+
+#--------------------------------------------------------------------
+#	The statements below define a collection of symbols related to
+#	dynamic loading and shared libraries:
+#
+#	DL_LIBS -	Library file(s) to include in tclsh and other base
+#			applications in order for the "load" command to work.
+#	DL_LD_FLAGS -	Flags to pass to the compiler when linking object
+#			files into an executable application binary such
+#			as tclsh.
+#	DL_LD_SEARCH_FLAGS-Flags to pass to ld, such as "-R /usr/local/tcl/lib"
+#			that tell the run-time dynamic linker where to look
+#			for shared libraries such as libtcl.so.  Depends on
+#			the variable SHLIB_RUNTIME_DIR in the Makefile.
+#	SHLIB_CFLAGS -	Flags to pass to cc when compiling the components
+#			of a shared library (may request position-independent
+#			code, among other things).
+#	SHLIB_LD -	Base command to use for combining object files
+#			into a shared library.
+#	SHLIB_LD_LIBS -	Dependent libraries for the linker to scan when
+#			creating shared libraries.  This symbol typically
+#			goes at the end of the "ld" commands that build
+#			shared libraries. The value of the symbol is
+#			"$V_LIB" if all of the dependent libraries should
+#			be specified when creating a shared library.  If
+#			dependent libraries should not be specified (as on
+#			SunOS 4.x, where they cause the link to fail, or in
+#			general if Tcl and Tk aren't themselves shared
+#			libraries), then this symbol has an empty string
+#			as its value.
+#	SHLIB_SUFFIX -	Suffix to use for the names of dynamically loadable
+#			extensions.  An empty string means we don't know how
+#			to use shared libraries on this platform.
+#--------------------------------------------------------------------
+
+
+### XXX: AC_ARG_ENABLE(shlib, --enable-shlib          enable Makefile flags
+###for building shared libraries, , enable_shlib="no")
+
+
+# Check whether --enable-shlib was given.
+if test "${enable_shlib+set}" = set; then
+  enableval=$enable_shlib;
+else
+  enable_shlib="no"
+fi
+
+
+
+# Step 1: set the variable "system" to hold the name and version number
+# for the system.  This can usually be done via the "uname" command, but
+# there are a few systems, like Next, where this doesn't work.
+
+{ $as_echo "$as_me:$LINENO: checking system version (for dynamic loading)" >&5
+$as_echo_n "checking system version (for dynamic loading)... " >&6; }
+if test -f /usr/lib/NextStep/software_version; then
+    system=NEXTSTEP-`awk '/3/,/3/' /usr/lib/NextStep/software_version`
+else
+    system=`uname -s`-`uname -r`
+    if test "$?" -ne 0 ; then
+	{ $as_echo "$as_me:$LINENO: result: unknown (can't find uname command)" >&5
+$as_echo "unknown (can't find uname command)" >&6; }
+	system=unknown
+    else
+	# Special check for weird MP-RAS system (uname returns weird
+	# results, and the version is kept in special file).
+
+	if test -r /etc/.relid -a "X`uname -n`" = "X`uname -s`" ; then
+	    system=MP-RAS-`awk '{print $3}' /etc/.relid`
+	fi
+	if test "`uname -s`" = "AIX" ; then
+	    system=AIX-`uname -v`.`uname -r`
+	fi
+	{ $as_echo "$as_me:$LINENO: result: $system" >&5
+$as_echo "$system" >&6; }
+    fi
+fi
+
+# Step 2: check for existence of -ldl library.  This is needed because
+# Linux can use either -ldl or -ldld for dynamic loading.
+
+{ $as_echo "$as_me:$LINENO: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_dl_dlopen=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_dl_dlopen=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then
+  have_dl=yes
+else
+  have_dl=no
+fi
+
+
+if test -z "$V_TCLSH"
+then
+	local_TCLSH=tclsh
+else
+	local_TCLSH=$V_TCLSH
+fi
+
+# Step 3: set configuration options based on system name and version.
+
+case $system in
+    AIX-*)
+	enable_dl="no"
+	;;
+    BSD/OS-2.1*|BSD/OS-3*)
+	SHLIB_CFLAGS=""
+	SHLIB_LD="shlicc -r"
+	SHLIB_LD_LIBS="$V_LIB"
+	SHLIB_SUFFIX=".so"
+	DL_LIBS="-ldl"
+	DL_LD_FLAGS=""
+	DL_LD_SEARCH_FLAGS=""
+	;;
+    Darwin-5.*|Darwin-6.*|Darwin-7.*|Darwin-8.*)
+	LDFLAGS="${LDFLAGS} -Wl,-bind_at_load"
+	;;
+    dgux*)
+	SHLIB_CFLAGS="-K PIC"
+	SHLIB_LD="cc -G"
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	DL_LIBS="-ldl"
+	DL_LD_FLAGS=""
+	DL_LD_SEARCH_FLAGS=""
+	;;
+    HP-UX-*.08.*|HP-UX-*.09.*|HP-UX-*.10.*)
+	{ $as_echo "$as_me:$LINENO: checking for shl_load in -ldld" >&5
+$as_echo_n "checking for shl_load in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_shl_load+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char shl_load ();
+int
+main ()
+{
+return shl_load ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_dld_shl_load=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_dld_shl_load=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dld_shl_load" >&5
+$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
+if test "x$ac_cv_lib_dld_shl_load" = x""yes; then
+  dl_ok=yes
+else
+  dl_ok=no
+fi
+
+	if test "$dl_ok" = yes; then
+	    SHLIB_CFLAGS="+z"
+	    SHLIB_LD="ld -b"
+	    SHLIB_LD_LIBS=""
+	    SHLIB_SUFFIX=".sl"
+	    DL_LIBS="-ldld"
+	    DL_LD_FLAGS="-Wl,-E"
+	    DL_LD_SEARCH_FLAGS='-Wl,+b,${SHLIB_RUNTIME_DIR}:.'
+	fi
+	;;
+    IRIX-4.*)
+	SHLIB_CFLAGS="-G 0"
+	SHLIB_SUFFIX=".a"
+	SHLIB_LD="echo tclLdAout $CC \{$SHLIB_CFLAGS\} | $local_TCLSH -r -G 0"
+	SHLIB_LD_LIBS="$V_LIB"
+	DL_LIBS=""
+	DL_LD_FLAGS="-Wl,-D,08000000"
+	DL_LD_SEARCH_FLAGS='-L${SHLIB_RUNTIME_DIR}'
+	;;
+    IRIX-5.*|IRIX-6.*)
+	SHLIB_CFLAGS=""
+	SHLIB_LD="ld -shared -rdata_shared"
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	DL_LIBS=""
+	DL_LD_FLAGS=""
+	DL_LD_SEARCH_FLAGS='-Wl,-rpath,${SHLIB_RUNTIME_DIR}'
+	;;
+    IRIX64-6.*)
+	SHLIB_CFLAGS=""
+	SHLIB_LD="ld -32 -shared -rdata_shared -rpath /usr/local/lib"
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	DL_LIBS=""
+	DL_LD_FLAGS=""
+	DL_LD_SEARCH_FLAGS='-Wl,-rpath,${SHLIB_RUNTIME_DIR}'
+	;;
+    Linux*)
+	SHLIB_CFLAGS="-fPIC"
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	LDFLAGS="$LDFLAGS -Wl,-export-dynamic"
+	if test "$have_dl" = yes; then
+	    SHLIB_LD="${CC} -shared"
+	    DL_LIBS="-ldl"
+	    DL_LD_FLAGS="-rdynamic"
+	    DL_LD_SEARCH_FLAGS=""
+	else
+	    if test "${ac_cv_header_dld_h+set}" = set; then
+  { $as_echo "$as_me:$LINENO: checking for dld.h" >&5
+$as_echo_n "checking for dld.h... " >&6; }
+if test "${ac_cv_header_dld_h+set}" = set; then
+  $as_echo_n "(cached) " >&6
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_dld_h" >&5
+$as_echo "$ac_cv_header_dld_h" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:$LINENO: checking dld.h usability" >&5
+$as_echo_n "checking dld.h usability... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <dld.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:$LINENO: checking dld.h presence" >&5
+$as_echo_n "checking dld.h presence... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <dld.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { $as_echo "$as_me:$LINENO: WARNING: dld.h: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: dld.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dld.h: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: dld.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:$LINENO: WARNING: dld.h: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: dld.h: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dld.h:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: dld.h:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dld.h: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: dld.h: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dld.h:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: dld.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dld.h: proceeding with the preprocessor's result" >&5
+$as_echo "$as_me: WARNING: dld.h: proceeding with the preprocessor's result" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dld.h: in the future, the compiler will take precedence" >&5
+$as_echo "$as_me: WARNING: dld.h: in the future, the compiler will take precedence" >&2;}
+
+    ;;
+esac
+{ $as_echo "$as_me:$LINENO: checking for dld.h" >&5
+$as_echo_n "checking for dld.h... " >&6; }
+if test "${ac_cv_header_dld_h+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_header_dld_h=$ac_header_preproc
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_dld_h" >&5
+$as_echo "$ac_cv_header_dld_h" >&6; }
+
+fi
+if test "x$ac_cv_header_dld_h" = x""yes; then
+
+		SHLIB_LD="ld -shared"
+		DL_LIBS="-ldld"
+		DL_LD_FLAGS=""
+		DL_LD_SEARCH_FLAGS=""
+fi
+
+
+	fi
+	;;
+    CYGWIN*)
+	SHLIB_CFLAGS="-fPIC"
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".dll"
+	SHLIB_LD="g++ -shared"
+	LDFLAGS="$LDFLAGS -Wl,-export-dynamic"
+	DL_LIBS="-ldl"
+	DL_LD_FLAGS="-rdynamic"
+	DL_LD_SEARCH_FLAGS=""
+	{ $as_echo "$as_me:$LINENO: checking for import libraries" >&5
+$as_echo_n "checking for import libraries... " >&6; }
+	V_IMPORT_LIBS=`echo "$V_LIBS" | sed "s/-L//g" | sed "s/ \-l/\/lib/g" | sed "s/ /\.a /g" `
+	for libfile in $V_IMPORT_LIBS ; do
+	        if test ! -f "$libfile" ; then
+	                { $as_echo "$as_me:$LINENO: result: failed!" >&5
+$as_echo "failed!" >&6; }
+	                { { $as_echo "$as_me:$LINENO: error: Could not find \"$libfile\"" >&5
+$as_echo "$as_me: error: Could not find \"$libfile\"" >&2;}
+   { (exit 1); exit 1; }; }
+	        fi
+	done
+	        { $as_echo "$as_me:$LINENO: result: ok" >&5
+$as_echo "ok" >&6; }
+
+	;;
+    MP-RAS-02*)
+	SHLIB_CFLAGS="-K PIC"
+	SHLIB_LD="cc -G"
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	DL_LIBS="-ldl"
+	DL_LD_FLAGS=""
+	DL_LD_SEARCH_FLAGS=""
+	;;
+    MP-RAS-*)
+	SHLIB_CFLAGS="-K PIC"
+	SHLIB_LD="cc -G"
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	DL_LIBS="-ldl"
+	DL_LD_FLAGS="-Wl,-Bexport"
+	DL_LD_SEARCH_FLAGS=""
+	;;
+    NetBSD-*|FreeBSD-*|OpenBSD-*)
+	# Not available on all versions:  check for include file.
+	if test "${ac_cv_header_dlfcn_h+set}" = set; then
+  { $as_echo "$as_me:$LINENO: checking for dlfcn.h" >&5
+$as_echo_n "checking for dlfcn.h... " >&6; }
+if test "${ac_cv_header_dlfcn_h+set}" = set; then
+  $as_echo_n "(cached) " >&6
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_dlfcn_h" >&5
+$as_echo "$ac_cv_header_dlfcn_h" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:$LINENO: checking dlfcn.h usability" >&5
+$as_echo_n "checking dlfcn.h usability... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <dlfcn.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:$LINENO: checking dlfcn.h presence" >&5
+$as_echo_n "checking dlfcn.h presence... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <dlfcn.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: dlfcn.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: dlfcn.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: dlfcn.h: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: dlfcn.h:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: dlfcn.h: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: dlfcn.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: proceeding with the preprocessor's result" >&5
+$as_echo "$as_me: WARNING: dlfcn.h: proceeding with the preprocessor's result" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: in the future, the compiler will take precedence" >&5
+$as_echo "$as_me: WARNING: dlfcn.h: in the future, the compiler will take precedence" >&2;}
+
+    ;;
+esac
+{ $as_echo "$as_me:$LINENO: checking for dlfcn.h" >&5
+$as_echo_n "checking for dlfcn.h... " >&6; }
+if test "${ac_cv_header_dlfcn_h+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_header_dlfcn_h=$ac_header_preproc
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_dlfcn_h" >&5
+$as_echo "$ac_cv_header_dlfcn_h" >&6; }
+
+fi
+if test "x$ac_cv_header_dlfcn_h" = x""yes; then
+
+	    SHLIB_CFLAGS="-fpic"
+	    SHLIB_LD="ld -Bshareable -x"
+	    SHLIB_LD_LIBS=""
+	    SHLIB_SUFFIX=".so"
+	    DL_LIBS=""
+	    DL_LD_FLAGS=""
+	    DL_LD_SEARCH_FLAGS=""
+
+else
+
+	    SHLIB_CFLAGS=""
+	    SHLIB_LD="echo tclLdAout $CC \{$SHLIB_CFLAGS\} | $local_TCLSH -r"
+	    SHLIB_LD_LIBS='$V_LIB'
+	    SHLIB_SUFFIX=".a"
+	    DL_LIBS=""
+	    DL_LD_FLAGS=""
+	    DL_LD_SEARCH_FLAGS='-L${SHLIB_RUNTIME_DIR}'
+
+fi
+
+
+
+	;;
+    NEXTSTEP-*)
+	SHLIB_CFLAGS=""
+	SHLIB_LD="cc -nostdlib -r"
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	DL_LIBS=""
+	DL_LD_FLAGS=""
+	DL_LD_SEARCH_FLAGS=""
+	;;
+    OSF1-1.0|OSF1-1.1|OSF1-1.2)
+	# OSF/1 1.[012] from OSF, and derivatives, including Paragon OSF/1
+	SHLIB_CFLAGS=""
+	# Hack: make package name same as library name
+	SHLIB_LD='ld -R -export $@:'
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	DL_LIBS=""
+	DL_LD_FLAGS=""
+	DL_LD_SEARCH_FLAGS=""
+	;;
+    OSF1-1.*)
+	# OSF/1 1.3 from OSF using ELF, and derivatives, including AD2
+	SHLIB_CFLAGS="-fpic"
+	SHLIB_LD="ld -shared"
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	DL_LIBS=""
+	DL_LD_FLAGS=""
+	DL_LD_SEARCH_FLAGS=""
+	;;
+    OSF1-V*)
+        # Digital OSF/1
+	SHLIB_CFLAGS=""
+	SHLIB_LD='ld -shared -expect_unresolved "*"'
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	DL_LIBS=""
+	DL_LD_FLAGS=""
+	DL_LD_SEARCH_FLAGS='-Wl,-rpath,${SHLIB_RUNTIME_DIR}'
+	;;
+    RISCos-*)
+	SHLIB_CFLAGS="-G 0"
+	SHLIB_LD="echo tclLdAout $CC \{$SHLIB_CFLAGS\} | $local_TCLSH -r -G 0"
+	SHLIB_LD_LIBS='$V_LIB'
+	SHLIB_SUFFIX=".a"
+	DL_LIBS=""
+	DL_LD_FLAGS="-Wl,-D,08000000"
+	DL_LD_SEARCH_FLAGS='-L${SHLIB_RUNTIME_DIR}'
+	;;
+    SCO_SV-3.2*)
+        # Note, dlopen is available only on SCO 3.2.5 and greater.  However,
+        # this test works, since "uname -s" was non-standard in 3.2.4 and
+        # below.
+	SHLIB_CFLAGS="-Kpic -belf"
+	SHLIB_LD="ld -G"
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	DL_LIBS=""
+	DL_LD_FLAGS="-belf -Wl,-Bexport"
+	DL_LD_SEARCH_FLAGS=""
+	;;
+     SINIX*5.4*)
+	SHLIB_CFLAGS="-K PIC"
+	SHLIB_LD="cc -G"
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	DL_LIBS="-ldl"
+	DL_LD_FLAGS=""
+	DL_LD_SEARCH_FLAGS=""
+	;;
+    SunOS-4*)
+	SHLIB_CFLAGS="-PIC"
+	SHLIB_LD="ld"
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	DL_LIBS="-ldl"
+	DL_LD_FLAGS=""
+	DL_LD_SEARCH_FLAGS='-L${SHLIB_RUNTIME_DIR}'
+	;;
+    SunOS-5*)
+	SHLIB_CFLAGS="-KPIC"
+	SHLIB_LD="/usr/ccs/bin/ld -G -z text"
+
+	# Note: need the LIBS below, otherwise Tk won't find Tcl's
+	# symbols when dynamically loaded into tclsh.
+
+	SHLIB_LD_LIBS='$V_LIB'
+	SHLIB_SUFFIX=".so"
+	DL_LIBS="-ldl"
+	DL_LD_FLAGS=""
+	DL_LD_SEARCH_FLAGS='-R ${SHLIB_RUNTIME_DIR}'
+	;;
+    ULTRIX-4.*)
+	SHLIB_CFLAGS="-G 0"
+	SHLIB_SUFFIX=".a"
+	SHLIB_LD="echo tclLdAout $CC \{$SHLIB_CFLAGS\} | $local_TCLSH -r -G 0"
+	SHLIB_LD_LIBS='$V_LIB'
+	DL_LIBS=""
+	DL_LD_FLAGS="-Wl,-D,08000000"
+	DL_LD_SEARCH_FLAGS='-L${SHLIB_RUNTIME_DIR}'
+	;;
+    UNIX_SV*)
+	SHLIB_CFLAGS="-KPIC"
+	SHLIB_LD="cc -G"
+	SHLIB_LD_LIBS=""
+	SHLIB_SUFFIX=".so"
+	DL_LIBS="-ldl"
+	# Some UNIX_SV* systems (unixware 1.1.2 for example) have linkers
+	# that don't grok the -Bexport option.  Test that it does.
+	hold_ldflags=$LDFLAGS
+	{ $as_echo "$as_me:$LINENO: checking for ld accepts -Bexport flag" >&5
+$as_echo_n "checking for ld accepts -Bexport flag... " >&6; }
+	LDFLAGS="${LDFLAGS} -Wl,-Bexport"
+	cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+int i;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  found=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	found=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+	LDFLAGS=$hold_ldflags
+	{ $as_echo "$as_me:$LINENO: result: $found" >&5
+$as_echo "$found" >&6; }
+	if test $found = yes; then
+	  SH_LD_FLAGS="-Wl,-Bexport"
+	else
+	  SH_LD_FLAGS=""
+	fi
+	SH_LD_SEARCH_FLAGS=""
+	;;
+esac
+
+# Step 4: disable dynamic loading if requested via a command-line switch.
+#
+#XXX:if test $enable_shlib = "no" ; then
+#    echo "Disabling dynamic loading and shared libraries"
+#    SHLIB_CFLAGS=""
+#    SHLIB_LD=""
+#    SHLIB_SUFFIX=""
+#    DL_LIBS=""
+#    DL_LD_FLAGS=""
+#    DL_LD_SEARCH_FLAGS=""
+#fi
+
+
+# If we're running gcc, then change the C flags for compiling shared
+# libraries to the right flags for gcc, instead of those for the
+# standard manufacturer compiler.
+
+####XXX:if test "enable_shlib" != "no" ; then
+    if test "$CC" = "gcc" -o `$CC -v 2>&1 | grep -c gcc` != "0" ; then
+	case $system in
+	    AIX-*)
+		;;
+	    BSD/OS*)
+		;;
+	    IRIX*)
+		;;
+	    NetBSD-*|FreeBSD-*|OpenBSD-*)
+		;;
+	    RISCos-*)
+		;;
+	    ULTRIX-4.*)
+		;;
+	    *)
+		SHLIB_CFLAGS="-fPIC"
+		;;
+	esac
+    fi
+####fi
+
+
+if test "$enable_shlib" != "no" ; then
+        PKG_SHLIB_CFLAGS=$SHLIB_CFLAGS
+else
+        PKG_SHLIB_CFLAGS=""
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+if test "${ac_cv_header_dlfcn_h+set}" = set; then
+  { $as_echo "$as_me:$LINENO: checking for dlfcn.h" >&5
+$as_echo_n "checking for dlfcn.h... " >&6; }
+if test "${ac_cv_header_dlfcn_h+set}" = set; then
+  $as_echo_n "(cached) " >&6
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_dlfcn_h" >&5
+$as_echo "$ac_cv_header_dlfcn_h" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:$LINENO: checking dlfcn.h usability" >&5
+$as_echo_n "checking dlfcn.h usability... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <dlfcn.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:$LINENO: checking dlfcn.h presence" >&5
+$as_echo_n "checking dlfcn.h presence... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <dlfcn.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: dlfcn.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: dlfcn.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: dlfcn.h: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: dlfcn.h:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: dlfcn.h: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: dlfcn.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: proceeding with the preprocessor's result" >&5
+$as_echo "$as_me: WARNING: dlfcn.h: proceeding with the preprocessor's result" >&2;}
+    { $as_echo "$as_me:$LINENO: WARNING: dlfcn.h: in the future, the compiler will take precedence" >&5
+$as_echo "$as_me: WARNING: dlfcn.h: in the future, the compiler will take precedence" >&2;}
+
+    ;;
+esac
+{ $as_echo "$as_me:$LINENO: checking for dlfcn.h" >&5
+$as_echo_n "checking for dlfcn.h... " >&6; }
+if test "${ac_cv_header_dlfcn_h+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_header_dlfcn_h=$ac_header_preproc
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_dlfcn_h" >&5
+$as_echo "$ac_cv_header_dlfcn_h" >&6; }
+
+fi
+if test "x$ac_cv_header_dlfcn_h" = x""yes; then
+  :
+else
+   { { $as_echo "$as_me:$LINENO: error: cannot find dlfcn.h" >&5
+$as_echo "$as_me: error: cannot find dlfcn.h" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+
+{ $as_echo "$as_me:$LINENO: checking for ns library name" >&5
+$as_echo_n "checking for ns library name... " >&6; }
+NSLIB=libns${SHLIB_SUFFIX}
+{ $as_echo "$as_me:$LINENO: result: $NSLIB" >&5
+$as_echo "$NSLIB" >&6; }
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:$LINENO: checking for struct ether_header" >&5
+$as_echo_n "checking for struct ether_header... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#include <net/ethernet.h>
+
+int
+main ()
+{
+
+int main()
+{
+	struct ether_header etherHdr;
+
+	return 1;
+}
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ETHER_HEADER_STRUCT 1
+_ACEOF
+
+{ $as_echo "$as_me:$LINENO: result: found" >&5
+$as_echo "found" >&6; }
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+{ $as_echo "$as_me:$LINENO: result: not found" >&5
+$as_echo "not found" >&6; }
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+{ $as_echo "$as_me:$LINENO: checking for struct ether_addr" >&5
+$as_echo_n "checking for struct ether_addr... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#include <net/ethernet.h>
+
+int
+main ()
+{
+
+int main()
+{
+	struct ether_addr etherAddr;
+
+	return 0;
+}
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ETHER_ADDRESS_STRUCT 1
+_ACEOF
+
+{ $as_echo "$as_me:$LINENO: result: found" >&5
+$as_echo "found" >&6; }
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+{ $as_echo "$as_me:$LINENO: result: not found" >&5
+$as_echo "not found" >&6; }
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+cross_compiling=no
+
+for ac_func in addr2ascii
+do
+as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
+$as_echo_n "checking for $ac_func... " >&6; }
+if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$ac_func || defined __stub___$ac_func
+choke me
+#endif
+
+int
+main ()
+{
+return $ac_func ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  eval "$as_ac_var=yes"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_var=no"
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+ac_res=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+if test "$cross_compiling" = yes; then
+  echo 1
+
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdio.h>
+#include <sys/ioctl.h>
+int main()
+{
+	int i = SIOCGIFHWADDR;
+	return 0;
+}
+
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_SIOCGIFHWADDR 1
+_ACEOF
+
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+
+tcphdr=no
+pcap=no
+
+{ $as_echo "$as_me:$LINENO: checking for Linux compliant tcphdr" >&5
+$as_echo_n "checking for Linux compliant tcphdr... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#include <netinet/tcp.h>
+
+int
+main ()
+{
+
+int main()
+{
+	struct tcphdr *tcp;
+	tcp->source= 1;
+
+	return 0;
+}
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+
+V_DEFINE="$V_DEFINE -DLINUX_TCP_HEADER"
+{ $as_echo "$as_me:$LINENO: result: found" >&5
+$as_echo "found" >&6; }
+tcphdr=yes
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+{ $as_echo "$as_me:$LINENO: result: not found" >&5
+$as_echo "not found" >&6; }
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+{ $as_echo "$as_me:$LINENO: checking for BSD compliant tcphdr" >&5
+$as_echo_n "checking for BSD compliant tcphdr... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#include <netinet/tcp.h>
+
+int
+main ()
+{
+
+int main()
+{
+	struct tcphdr *tcp;
+	tcp->th_sport= 1;
+
+	return 0;
+}
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+
+{ $as_echo "$as_me:$LINENO: result: found" >&5
+$as_echo "found" >&6; }
+tcphdr=yes
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+{ $as_echo "$as_me:$LINENO: result: not found" >&5
+$as_echo "not found" >&6; }
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+{ $as_echo "$as_me:$LINENO: checking for socklen_t" >&5
+$as_echo_n "checking for socklen_t... " >&6; }
+if test "${ac_cv_type_socklen_t+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+   #include <sys/socket.h>
+int
+main ()
+{
+socklen_t len = 42; return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_type_socklen_t=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_socklen_t=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_type_socklen_t" >&5
+$as_echo "$ac_cv_type_socklen_t" >&6; }
+
+if test x"$ac_cv_type_socklen_t" = xyes; then
+    cat >>confdefs.h <<\_ACEOF
+#define HAVE_SOCKLEN_T 1
+_ACEOF
+
+fi
+
+
+
+
+{ $as_echo "$as_me:$LINENO: checking for main in -lpcap" >&5
+$as_echo_n "checking for main in -lpcap... " >&6; }
+if test "${ac_cv_lib_pcap_main+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpcap  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+return main ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_pcap_main=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_pcap_main=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_pcap_main" >&5
+$as_echo "$ac_cv_lib_pcap_main" >&6; }
+if test "x$ac_cv_lib_pcap_main" = x""yes; then
+  V_LIB="$V_LIB -lpcap" pcap=yes
+fi
+
+V_INCLUDES="$V_INCLUDES -I/usr/include/pcap"
+
+
+{ $as_echo "$as_me:$LINENO: checking to make nse" >&5
+$as_echo_n "checking to make nse... " >&6; }
+if test $tcphdr = yes && test $pcap = yes; then
+		build_nse="nse"
+		{ $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+
+else
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+
+
+
+
+
+
+
+if test "$enable_static" = "yes" ; then
+	echo Explicitly enabling static compilation
+	V_STATIC="-static"
+elif test "$enable_static" = "no" ; then
+	echo Explicitly disabling static compilation
+	V_STATIC=""
+else
+	echo No explicit static compilation flag\; setting V_STATIC to \"$V_STATIC\"
+fi
+
+
+
+#
+# tcl7.x needs a dynamic loading library (unless built with the
+# -disable-load flag).  Try to find the appropriate one.
+
+if test ! -z "$V_NEED_DL" ; then
+	V_LIB_DL=""
+	case "$target" in
+	*-*-solaris*)
+		V_LIB_DL="dl"
+		;;
+	sparc-sun-sunos*)
+		V_LIB_DL="dl"
+		;;
+	*-*-bsdi2.1)
+		V_LIB_DL="dl"
+		;;
+	*-*-bsdi3.0)
+		V_LIB_DL="dl"
+		;;
+	*-*-hpux*)
+		V_LIB_DL="dld"
+		;;
+	*-*-linux*)
+		{ $as_echo "$as_me:$LINENO: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  ac_cv_lib_dl_dlopen=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_lib_dl_dlopen=no
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then
+  V_LIB_DL="dl"
+else
+  V_LIB_DL="dld"
+fi
+
+		;;
+	*-*-cygwin*)
+		V_LIB_DL="dl"
+		;;
+	esac
+	if test ! -z "$V_LIB_DL" ; then
+		case "$target" in
+		*-*-linux*)
+			;;
+		*)
+
+as_ac_Lib=`$as_echo "ac_cv_lib_$V_LIB_DL''_main" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for main in -l$V_LIB_DL" >&5
+$as_echo_n "checking for main in -l$V_LIB_DL... " >&6; }
+if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-l$V_LIB_DL $V_STATIC $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+return main ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then
+  eval "$as_ac_Lib=yes"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_Lib=no"
+fi
+
+rm -rf conftest.dSYM
+rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+ac_res=`eval 'as_val=${'$as_ac_Lib'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_Lib'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_LIB$V_LIB_DL" | $as_tr_cpp` 1
+_ACEOF
+
+  LIBS="-l$V_LIB_DL $LIBS"
+
+else
+  V_LIB_DL=""
+fi
+
+			;;
+		esac
+	fi
+	if test ! -z "$V_LIB_DL" ; then
+		case "$target" in
+		*-*-bsdi*)
+			;;
+		*-*-linux*)
+			if test -z "$V_STATIC" ; then
+				V_LIB="$V_LIB -l$V_LIB_DL"
+			fi
+			;;
+		*)
+			V_LIB="$V_LIB -l$V_LIB_DL"
+			;;
+		esac
+	else
+		echo "no dynamic load lib"
+	fi
+fi
+
+
+if test "$host_cpu" = alpha ; then
+	V_DEFINE="$V_DEFINE -DINT_64=u_long"
+fi
+
+# various include hacks
+dirs="/usr/src/local/include-fixes \
+	/import/mcast/include"
+for dir in $dirs; do
+	if test -d $dir ; then
+		V_INCLUDE="$V_INCLUDE -I$dir"
+	fi
+done
+
+# always use -g with gcc during development (even with -O)
+# force noline so that we can debug all functions
+if test "$CC" = gcc && test -f .devel ; then
+	V_CCOPT="$V_CCOPT -g -Wall -Werror"
+	V_DEFINE="$V_DEFINE -fsigned-char -fno-inline"
+fi
+
+V_DEFINE="$V_DEFINE $V_SHM"
+
+V_TAR_TARGET=$target_os
+
+
+absolutize_list() {
+    tmp=""
+    for p
+    do
+	case $p in
+	-L* | -I*) tmp="$tmp `absolutize $p`";;
+	*) tmp="$tmp $p";;
+        esac
+    done
+    echo $tmp
+}
+
+# Replace relative path with absolute path
+V_LIB_TCLCL=`absolutize_list $V_LIB_TCLCL`
+V_LIB_OTCL=`absolutize_list $V_LIB_OTCL`
+V_LIB_TCL=`absolutize_list $V_LIB_TCL`
+V_LIB_TK=`absolutize_list $V_LIB_TK`
+V_LIBS=`absolutize_list $V_LIBS`
+V_INCLUDES=`absolutize_list $V_INCLUDES`
+
+# Since SMASH and MASH need different sets of libraries, we
+# use each lib definition seperately instead of using V_LIBS.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+# Reject install programs that cannot install multiple files.
+{ $as_echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+$as_echo_n "checking for a BSD-compatible install... " >&6; }
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    rm -rf conftest.one conftest.two conftest.dir
+	    echo one > conftest.one
+	    echo two > conftest.two
+	    mkdir conftest.dir
+	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
+	      test -s conftest.one && test -s conftest.two &&
+	      test -s conftest.dir/conftest.one &&
+	      test -s conftest.dir/conftest.two
+	    then
+	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	      break 3
+	    fi
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+
+done
+IFS=$as_save_IFS
+
+rm -rf conftest.one conftest.two conftest.dir
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ $as_echo "$as_me:$LINENO: result: $INSTALL" >&5
+$as_echo "$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+
+ac_config_files="$ac_config_files Makefile tcl/lib/ns-autoconf.tcl indep-utils/webtrace-conv/ucb/Makefile indep-utils/webtrace-conv/dec/Makefile indep-utils/webtrace-conv/nlanr/Makefile indep-utils/webtrace-conv/epa/Makefile indep-utils/cmu-scen-gen/setdest/Makefile"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) $as_unset $ac_var ;;
+      esac ;;
+    esac
+  done
+
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    test "x$cache_file" != "x/dev/null" &&
+      { $as_echo "$as_me:$LINENO: updating cache $cache_file" >&5
+$as_echo "$as_me: updating cache $cache_file" >&6;}
+    cat confcache >$cache_file
+  else
+    { $as_echo "$as_me:$LINENO: not updating unwritable cache $cache_file" >&5
+$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_write_fail=0
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ $as_echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+
+
+# PATH needs CR
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+if (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  { (exit 1); exit 1; }
+fi
+
+# Work around bugs in pre-3.0 UWIN ksh.
+for as_var in ENV MAIL MAILPATH
+do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# CDPATH.
+$as_unset CDPATH
+
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line after each line using $LINENO; the second 'sed'
+  # does the real work.  The second script uses 'N' to pair each
+  # line-number line with the line containing $LINENO, and appends
+  # trailing '-' during substitution so that $LINENO is not a special
+  # case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # scripts with optimization help from Paolo Bonzini.  Blame Lee
+  # E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in
+-n*)
+  case `echo 'x\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  *)   ECHO_C='\c';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+
+# Save the log message, to keep $[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.63.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+_ACEOF
+
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+case $ac_config_headers in *"
+"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+esac
+
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+# Files that config.status was made for.
+config_files="$ac_config_files"
+config_headers="$ac_config_headers"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTION]... [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+  -q, --quiet, --silent
+                   do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+      --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+      --header=FILE[:TEMPLATE]
+                   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Report bugs to <bug-autoconf@gnu.org>."
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_version="\\
+config.status
+configured by $0, generated by GNU Autoconf 2.63,
+  with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2008 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+INSTALL='$INSTALL'
+test -n "\$AWK" || AWK=awk
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# The default lists apply if the user does not specify any file.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    $as_echo "$ac_cs_version"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    CONFIG_FILES="$CONFIG_FILES '$ac_optarg'"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    CONFIG_HEADERS="$CONFIG_HEADERS '$ac_optarg'"
+    ac_need_defaults=false;;
+  --he | --h)
+    # Conflict between --help and --header
+    { $as_echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    $as_echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { $as_echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+if \$ac_cs_recheck; then
+  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  shift
+  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  CONFIG_SHELL='$SHELL'
+  export CONFIG_SHELL
+  exec "\$@"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  $as_echo "$ac_log"
+} >&5
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "autoconf.h") CONFIG_HEADERS="$CONFIG_HEADERS autoconf.h" ;;
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+    "tcl/lib/ns-autoconf.tcl") CONFIG_FILES="$CONFIG_FILES tcl/lib/ns-autoconf.tcl" ;;
+    "indep-utils/webtrace-conv/ucb/Makefile") CONFIG_FILES="$CONFIG_FILES indep-utils/webtrace-conv/ucb/Makefile" ;;
+    "indep-utils/webtrace-conv/dec/Makefile") CONFIG_FILES="$CONFIG_FILES indep-utils/webtrace-conv/dec/Makefile" ;;
+    "indep-utils/webtrace-conv/nlanr/Makefile") CONFIG_FILES="$CONFIG_FILES indep-utils/webtrace-conv/nlanr/Makefile" ;;
+    "indep-utils/webtrace-conv/epa/Makefile") CONFIG_FILES="$CONFIG_FILES indep-utils/webtrace-conv/epa/Makefile" ;;
+    "indep-utils/cmu-scen-gen/setdest/Makefile") CONFIG_FILES="$CONFIG_FILES indep-utils/cmu-scen-gen/setdest/Makefile" ;;
+
+  *) { { $as_echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+$as_echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp=
+  trap 'exit_status=$?
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} ||
+{
+   $as_echo "$as_me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+# Set up the scripts for CONFIG_FILES section.
+# No need to generate them if there are no CONFIG_FILES.
+# This happens for instance with `./config.status config.h'.
+if test -n "$CONFIG_FILES"; then
+
+
+ac_cr=''
+ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
+if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
+  ac_cs_awk_cr='\\r'
+else
+  ac_cs_awk_cr=$ac_cr
+fi
+
+echo 'BEGIN {' >"$tmp/subs1.awk" &&
+_ACEOF
+
+
+{
+  echo "cat >conf$$subs.awk <<_ACEOF" &&
+  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
+  echo "_ACEOF"
+} >conf$$subs.sh ||
+  { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
+$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  . ./conf$$subs.sh ||
+    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
+$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
+    break
+  elif $ac_last_try; then
+    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
+$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+rm -f conf$$subs.sh
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
+_ACEOF
+sed -n '
+h
+s/^/S["/; s/!.*/"]=/
+p
+g
+s/^[^!]*!//
+:repl
+t repl
+s/'"$ac_delim"'$//
+t delim
+:nl
+h
+s/\(.\{148\}\).*/\1/
+t more1
+s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
+p
+n
+b repl
+:more1
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t nl
+:delim
+h
+s/\(.\{148\}\).*/\1/
+t more2
+s/["\\]/\\&/g; s/^/"/; s/$/"/
+p
+b
+:more2
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t delim
+' <conf$$subs.awk | sed '
+/^[^""]/{
+  N
+  s/\n//
+}
+' >>$CONFIG_STATUS || ac_write_fail=1
+rm -f conf$$subs.awk
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACAWK
+cat >>"\$tmp/subs1.awk" <<_ACAWK &&
+  for (key in S) S_is_set[key] = 1
+  FS = ""
+
+}
+{
+  line = $ 0
+  nfields = split(line, field, "@")
+  substed = 0
+  len = length(field[1])
+  for (i = 2; i < nfields; i++) {
+    key = field[i]
+    keylen = length(key)
+    if (S_is_set[key]) {
+      value = S[key]
+      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
+      len += length(value) + length(field[++i])
+      substed = 1
+    } else
+      len += 1 + keylen
+  }
+
+  print line
+}
+
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
+  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+else
+  cat
+fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
+  || { { $as_echo "$as_me:$LINENO: error: could not setup config files machinery" >&5
+$as_echo "$as_me: error: could not setup config files machinery" >&2;}
+   { (exit 1); exit 1; }; }
+_ACEOF
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/
+s/:*\${srcdir}:*/:/
+s/:*@srcdir@:*/:/
+s/^\([^=]*=[	 ]*\):*/\1/
+s/:*$//
+s/^[^=]*=[	 ]*$//
+}'
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+fi # test -n "$CONFIG_FILES"
+
+# Set up the scripts for CONFIG_HEADERS section.
+# No need to generate them if there are no CONFIG_HEADERS.
+# This happens for instance with `./config.status Makefile'.
+if test -n "$CONFIG_HEADERS"; then
+cat >"$tmp/defines.awk" <<\_ACAWK ||
+BEGIN {
+_ACEOF
+
+# Transform confdefs.h into an awk script `defines.awk', embedded as
+# here-document in config.status, that substitutes the proper values into
+# config.h.in to produce config.h.
+
+# Create a delimiter string that does not exist in confdefs.h, to ease
+# handling of long lines.
+ac_delim='%!_!# '
+for ac_last_try in false false :; do
+  ac_t=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_t"; then
+    break
+  elif $ac_last_try; then
+    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_HEADERS" >&5
+$as_echo "$as_me: error: could not make $CONFIG_HEADERS" >&2;}
+   { (exit 1); exit 1; }; }
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+
+# For the awk script, D is an array of macro values keyed by name,
+# likewise P contains macro parameters if any.  Preserve backslash
+# newline sequences.
+
+ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
+sed -n '
+s/.\{148\}/&'"$ac_delim"'/g
+t rset
+:rset
+s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
+t def
+d
+:def
+s/\\$//
+t bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3"/p
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
+d
+:bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3\\\\\\n"\\/p
+t cont
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
+t cont
+d
+:cont
+n
+s/.\{148\}/&'"$ac_delim"'/g
+t clear
+:clear
+s/\\$//
+t bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/"/p
+d
+:bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
+b cont
+' <confdefs.h | sed '
+s/'"$ac_delim"'/"\\\
+"/g' >>$CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  for (key in D) D_is_set[key] = 1
+  FS = ""
+}
+/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
+  line = \$ 0
+  split(line, arg, " ")
+  if (arg[1] == "#") {
+    defundef = arg[2]
+    mac1 = arg[3]
+  } else {
+    defundef = substr(arg[1], 2)
+    mac1 = arg[2]
+  }
+  split(mac1, mac2, "(") #)
+  macro = mac2[1]
+  prefix = substr(line, 1, index(line, defundef) - 1)
+  if (D_is_set[macro]) {
+    # Preserve the white space surrounding the "#".
+    print prefix "define", macro P[macro] D[macro]
+    next
+  } else {
+    # Replace #undef with comments.  This is necessary, for example,
+    # in the case of _POSIX_SOURCE, which is predefined and required
+    # on some systems where configure will not decide to define it.
+    if (defundef == "undef") {
+      print "/*", prefix defundef, macro, "*/"
+      next
+    }
+  }
+}
+{ print }
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+  { { $as_echo "$as_me:$LINENO: error: could not setup config headers machinery" >&5
+$as_echo "$as_me: error: could not setup config headers machinery" >&2;}
+   { (exit 1); exit 1; }; }
+fi # test -n "$CONFIG_HEADERS"
+
+
+eval set X "  :F $CONFIG_FILES  :H $CONFIG_HEADERS    "
+shift
+for ac_tag
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) { { $as_echo "$as_me:$LINENO: error: invalid tag $ac_tag" >&5
+$as_echo "$as_me: error: invalid tag $ac_tag" >&2;}
+   { (exit 1); exit 1; }; };;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   { { $as_echo "$as_me:$LINENO: error: cannot find input file: $ac_f" >&5
+$as_echo "$as_me: error: cannot find input file: $ac_f" >&2;}
+   { (exit 1); exit 1; }; };;
+      esac
+      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      ac_file_inputs="$ac_file_inputs '$ac_f'"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input='Generated from '`
+	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	`' by configure.'
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { $as_echo "$as_me:$LINENO: creating $ac_file" >&5
+$as_echo "$as_me: creating $ac_file" >&6;}
+    fi
+    # Neutralize special characters interpreted by sed in replacement strings.
+    case $configure_input in #(
+    *\&* | *\|* | *\\* )
+       ac_sed_conf_input=`$as_echo "$configure_input" |
+       sed 's/[\\\\&|]/\\\\&/g'`;; #(
+    *) ac_sed_conf_input=$configure_input;;
+    esac
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$tmp/stdin" \
+      || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
+$as_echo "$as_me: error: could not create $ac_file" >&2;}
+   { (exit 1); exit 1; }; } ;;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  { as_dir="$ac_dir"
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || { { $as_echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
+$as_echo "$as_me: error: cannot create directory $as_dir" >&2;}
+   { (exit 1); exit 1; }; }; }
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+
+ac_sed_dataroot='
+/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p
+'
+case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { $as_echo "$as_me:$LINENO: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  ac_datarootdir_hack='
+  s&@datadir@&$datadir&g
+  s&@docdir@&$docdir&g
+  s&@infodir@&$infodir&g
+  s&@localedir@&$localedir&g
+  s&@mandir@&$mandir&g
+    s&\\\${datarootdir}&$datarootdir&g' ;;
+esac
+_ACEOF
+
+# Neutralize VPATH when `$srcdir' = `.'.
+# Shell code in configure.ac might set extrasub.
+# FIXME: do we really want to maintain this feature?
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_sed_extra="$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s|@configure_input@|$ac_sed_conf_input|;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@top_build_prefix@&$ac_top_build_prefix&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+s&@INSTALL@&$ac_INSTALL&;t t
+$ac_datarootdir_hack
+"
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
+  || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
+$as_echo "$as_me: error: could not create $ac_file" >&2;}
+   { (exit 1); exit 1; }; }
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
+  { $as_echo "$as_me:$LINENO: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&5
+$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&2;}
+
+  rm -f "$tmp/stdin"
+  case $ac_file in
+  -) cat "$tmp/out" && rm -f "$tmp/out";;
+  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
+  esac \
+  || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
+$as_echo "$as_me: error: could not create $ac_file" >&2;}
+   { (exit 1); exit 1; }; }
+ ;;
+  :H)
+  #
+  # CONFIG_HEADER
+  #
+  if test x"$ac_file" != x-; then
+    {
+      $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
+    } >"$tmp/config.h" \
+      || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
+$as_echo "$as_me: error: could not create $ac_file" >&2;}
+   { (exit 1); exit 1; }; }
+    if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
+      { $as_echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+$as_echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      rm -f "$ac_file"
+      mv "$tmp/config.h" "$ac_file" \
+	|| { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
+$as_echo "$as_me: error: could not create $ac_file" >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+  else
+    $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
+      || { { $as_echo "$as_me:$LINENO: error: could not create -" >&5
+$as_echo "$as_me: error: could not create -" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+ ;;
+
+
+  esac
+
+done # for ac_tag
+
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+test $ac_write_fail = 0 ||
+  { { $as_echo "$as_me:$LINENO: error: write failure creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: error: write failure creating $CONFIG_STATUS" >&2;}
+   { (exit 1); exit 1; }; }
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
+  { $as_echo "$as_me:$LINENO: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+fi
+
+
+if test ! -d gen ; then
+	echo "creating ./gen"
+	mkdir gen
+fi
+
+if test ! -d bin ; then
+	echo "creating ./bin"
+	mkdir bin
+fi
+
+if test -f .devel -o "$enable_devel" = "yes" ; then
+	make depend
+fi
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/diffusion/diffusion.h ns-2.34/diffusion/diffusion.h
--- ns-2.34-pure/diffusion/diffusion.h	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/diffusion/diffusion.h	2010-02-28 09:31:39.000000000 -0800
@@ -138,6 +138,10 @@
 };
 
 
+void XmitFailedCallback(Packet *pkt, void *data);
+class ArpBufferTimer;
+class SendBufTimer;
+
 class DiffusionAgent : public Agent {
  public:
   DiffusionAgent();
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/diffusion/omni_mcast.h ns-2.34/diffusion/omni_mcast.h
--- ns-2.34-pure/diffusion/omni_mcast.h	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/diffusion/omni_mcast.h	2010-02-28 09:31:39.000000000 -0800
@@ -157,6 +157,10 @@
 
 
 
+void OmniMcastXmitFailedCallback(Packet *pkt, void *data);
+
+class OmniMcastArpBufferTimer;
+class OmniMcastSendBufTimer;
 
 class OmniMcastAgent : public Agent {
  public:
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/dsr/dsragent.h ns-2.34/dsr/dsragent.h
--- ns-2.34-pure/dsr/dsragent.h	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/dsr/dsragent.h	2010-02-28 09:31:39.000000000 -0800
@@ -110,6 +110,12 @@
 
 LIST_HEAD(DSRAgent_List, DSRAgent);
 
+void XmitFailureCallback(Packet *pkt, void *data);
+void XmitFlowFailureCallback(Packet *pkt, void *data);
+int FilterFailure(Packet *p, void *data);
+class SendBufferTimer;
+
+
 class DSRAgent : public Tap, public Agent {
 public:
 
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/channel.cc ns-2.34/mac/channel.cc
--- ns-2.34-pure/mac/channel.cc	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/mac/channel.cc	2010-02-28 09:31:39.000000000 -0800
@@ -121,6 +121,12 @@
 			((Phy*) obj)->setchnl(this);
 			return TCL_OK;
 		}
+		else if(strcmp(argv[1], "delif") == 0) {
+			// Remove phy from channel
+			((Phy*) obj)->setchnl(0);
+			((Phy*) obj)->removechnl();
+			return TCL_OK;
+		}
 
 		// add interface for grid_keeper_
 		/*else if(strncasecmp(argv[1], "grid_keeper", 5) == 0) {
@@ -345,17 +351,18 @@
 						         outlist);
 	    for (i=0; i < out_index; i ++) {
 		
-		  newp = p->copy();
+		  // fix Szymon Chachulski
 		  rnode = outlist[i];
 		  propdelay = get_pdelay(tnode, rnode);
 
 		  rifp = (rnode->ifhead()).lh_first; 
 		  for(; rifp; rifp = rifp->nextnode()){
 			  if (rifp->channel() == this){
+				 newp = p->copy();
 				 s.schedule(rifp, newp, propdelay); 
-				 break;
 			  }
 		  }
+		  //!fix Szymon Chachulski
  	    }
 	    delete [] outlist; 
 	 
@@ -376,14 +383,17 @@
 			 if(rnode == tnode)
 				 continue;
 			 
-			 newp = p->copy();
-			 
+			 // fix Szymon Chachulski
 			 propdelay = get_pdelay(tnode, rnode);
 			 
 			 rifp = (rnode->ifhead()).lh_first;
 			 for(; rifp; rifp = rifp->nextnode()){
-				 s.schedule(rifp, newp, propdelay);
+				 if (rifp->channel() == this){
+					 newp = p->copy();
+					 s.schedule(rifp, newp, propdelay);
+				}
 			 }
+			//!fix Szymon Chachulski
 		 }
 		 delete [] affectedNodes;
 	 }
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/channel.cc.orig ns-2.34/mac/channel.cc.orig
--- ns-2.34-pure/mac/channel.cc.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/mac/channel.cc.orig	2009-06-14 10:35:44.000000000 -0700
@@ -0,0 +1,775 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1996 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory and the Daedalus
+ *	research group at UC Berkeley.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Contributed by Giao Nguyen, http://daedalus.cs.berkeley.edu/~gnguyen
+ */
+
+#ifndef lint
+static const char rcsid[] =
+    "@(#) $Header: /cvsroot/nsnam/ns-2/mac/channel.cc,v 1.47 2009/01/02 21:50:24 tom_henderson Exp $ (UCB)";
+#endif
+
+// Time interval for updating a position of a node in the X-List
+// (can be adjusted by the user, depending on the nodes mobility). /* VAL NAUMOV */
+#define XLIST_POSITION_UPDATE_INTERVAL 1.0 //seconds
+
+
+
+//#include "template.h"
+#include <float.h>
+
+#include "trace.h"
+#include "delay.h"
+#include "object.h"
+#include "packet.h"
+#include "mac.h"
+#include "channel.h"
+#include "lib/bsd-list.h"
+#include "phy.h"
+#include "wireless-phy.h"
+#include "mobilenode.h"
+#include "ip.h"
+#include "dsr/hdr_sr.h"
+#include "gridkeeper.h"
+#include "tworayground.h"
+#include "wireless-phyExt.h"
+
+static class ChannelClass : public TclClass {
+public:
+	ChannelClass() : TclClass("Channel") {}
+	TclObject* create(int, const char*const*) {
+		return (new Channel);
+	}
+} class_channel;
+
+/*static class DuplexChannelClass : public TclClass {
+public:
+	DuplexChannelClass() : TclClass("Channel/Duplex") {}
+	TclObject* create(int, const char*const*) {
+		return (new DuplexChannel);
+	}
+	} class_channel_duplex; */
+
+static class WirelessChannelClass : public TclClass {
+public:
+        WirelessChannelClass() : TclClass("Channel/WirelessChannel") {}
+        TclObject* create(int, const char*const*) {
+                return (new WirelessChannel);
+        }
+} class_Wireless_channel;
+
+
+
+/* ==================================================================
+   NS Initialization Functions
+   =================================================================*/
+static int ChannelIndex = 0;
+Channel::Channel() : TclObject()
+{
+	index_ = ChannelIndex++;
+	LIST_INIT(&ifhead_);
+	bind_time("delay_", &delay_);
+}
+
+int Channel::command(int argc, const char*const* argv)
+{
+	
+	if (argc == 3) {
+		TclObject *obj;
+
+		if( (obj = TclObject::lookup(argv[2])) == 0) {
+			fprintf(stderr, "%s lookup failed\n", argv[1]);
+			return TCL_ERROR;
+		}
+		if (strcmp(argv[1], "trace-target") == 0) {
+			trace_ = (Trace*) obj;
+			return (TCL_OK);
+		}
+		else if(strcmp(argv[1], "addif") == 0) {
+			((Phy*) obj)->insertchnl(&ifhead_);
+			((Phy*) obj)->setchnl(this);
+			return TCL_OK;
+		}
+
+		// add interface for grid_keeper_
+		/*else if(strncasecmp(argv[1], "grid_keeper", 5) == 0) {
+			grid_keeper_ = (GridKeeper*)obj;
+			return TCL_OK;
+			}*/
+	} else if (argc == 2) {
+		Tcl& tcl = Tcl::instance();
+		if (strcmp(argv[1], "trace-target") == 0) {
+			tcl.resultf("%s", trace_->name());
+			return (TCL_OK);
+		}
+		else if(strcmp(argv[1], "id") == 0) {
+			tcl.resultf("%d", index_);
+			return TCL_OK;
+		}
+	}
+	return TclObject::command(argc, argv);
+}
+
+
+void Channel::recv(Packet* p, Handler* h)
+{
+	sendUp(p, (Phy*)h);
+}
+
+
+
+void
+Channel::sendUp(Packet* p, Phy *tifp)
+{
+	Scheduler &s = Scheduler::instance();
+	Phy *rifp = ifhead_.lh_first;
+	Node *tnode = tifp->node();
+	Node *rnode = 0;
+	Packet *newp;
+	double propdelay = 0.0;
+	struct hdr_cmn *hdr = HDR_CMN(p);
+
+	hdr->direction() = hdr_cmn::UP;
+	for( ; rifp; rifp = rifp->nextchnl()) {
+		rnode = rifp->node();
+		if(rnode == tnode)
+			continue;
+		/*
+		 * Each node needs to get their own copy of this packet.
+		 * Since collisions occur at the receiver, we can have
+		 * two nodes canceling and freeing the *same* simulation
+		 * event.
+		 *
+		 */
+		newp = p->copy();
+		propdelay = get_pdelay(tnode, rnode);
+		
+		/*
+		 * Each node on the channel receives a copy of the
+		 * packet.  The propagation delay determines exactly
+		 * when the receiver's interface detects the first
+		 * bit of this packet.
+		 */
+		s.schedule(rifp, newp, propdelay);
+	}
+
+	Packet::free(p);
+}
+
+
+
+
+double 
+Channel::get_pdelay(Node* /*tnode*/, Node* /*rnode*/)
+{
+	// Dummy function
+	return delay_;
+}
+
+
+void
+Channel::dump(void)
+{
+	Phy *n;
+	
+	fprintf(stdout, "Network Interface List\n");
+ 	for(n = ifhead_.lh_first; n; n = n->nextchnl() )
+		n->dump();
+	fprintf(stdout, "--------------------------------------------------\n");
+}
+
+/* NoDupChannel------------------------------------------------------------
+ * NoDupChannel is currently acting the same as Channel but with one
+ * important difference: it uses reference-copying of the packet,
+ * thus, a lot of time is saved (e.g. for 49 senders and 1 receiver
+ * overflowing mac802.3 and running for 10 seconds sim time, factors
+ * of 60 and more of savings in actual running time have been
+ * observed).
+ *
+ * DRAWBACKS: 
+ *
+ *	- No propagation model supported (uses constant prop delay for 
+ *        all nodes), although it should be easy to change that.
+ *	- Macs should be EXTREMELY careful handling these reference 
+ *        copies: essentially they all are expected not to modify them 
+ *	  in any way (including scheduling!) while reference counter is
+ *        positive.  802.3 seems to work with it, other macs may need
+ *	  some changes.
+ */
+
+struct ChannelDelayEvent : public Event {
+public:
+	ChannelDelayEvent(Packet *p, Phy *txphy) : p_(p), txphy_(txphy) {};
+	Packet *p_;
+	Phy *txphy_;
+};
+
+class NoDupChannel : public Channel, public Handler {
+public:
+	void recv(Packet* p, Handler*);	
+	void handle(Event*);
+protected:
+	int phy_counter_;
+private:
+	void sendUp(Packet *p, Phy *txif);
+
+};
+
+void NoDupChannel::recv(Packet* p, Handler* h) {
+	assert(hdr_cmn::access(p)->direction() == hdr_cmn::DOWN);
+	// Delay this packet
+	Scheduler &s = Scheduler::instance();
+	ChannelDelayEvent *de = new ChannelDelayEvent(p, (Phy *)h);
+	s.schedule(this, de, delay_);
+}
+void NoDupChannel::handle(Event *e) {
+	ChannelDelayEvent *cde = (ChannelDelayEvent *)e;
+	sendUp(cde->p_, cde->txphy_);
+	delete cde;
+}
+
+void NoDupChannel::sendUp(Packet *p, Phy *txif) {
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	hdr->direction() = hdr_cmn::UP;
+
+	for(Phy *rifp = ifhead_.lh_first; rifp; rifp = rifp->nextchnl()) {
+		if(rifp == txif)
+			continue;
+		rifp->recv(p->refcopy(), 0);
+	}
+	Packet::free(p);
+}
+
+static class NoDupChannelClass : public TclClass {
+public:
+	NoDupChannelClass() : TclClass("Channel/NoDup") {}
+	TclObject* create(int, const char*const*) {
+		return (new NoDupChannel);
+	}
+} class_nodupchannel;
+
+
+
+// Wireless extensions
+class MobileNode;
+
+double WirelessChannel::highestAntennaZ_ = -1; // i.e., uninitialized
+double WirelessChannel::distCST_ = -1;
+
+WirelessChannel::WirelessChannel(void) : Channel(), numNodes_(0), 
+					 xListHead_(NULL), sorted_(0) {}
+
+int WirelessChannel::command(int argc, const char*const* argv)
+{
+	
+	if (argc == 3) {
+		TclObject *obj;
+
+		if( (obj = TclObject::lookup(argv[2])) == 0) {
+			fprintf(stderr, "%s lookup failed\n", argv[1]);
+			return TCL_ERROR;
+		}
+		if (strcmp(argv[1], "add-node") == 0) {
+			addNodeToList((MobileNode*) obj);
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "remove-node") == 0) {
+			removeNodeFromList((MobileNode*) obj);
+			return TCL_OK;
+		}
+	}
+	return Channel::command(argc, argv);
+}
+
+
+void
+WirelessChannel::sendUp(Packet* p, Phy *tifp)
+{
+	Scheduler &s = Scheduler::instance();
+	Phy *rifp = ifhead_.lh_first;
+	Node *tnode = tifp->node();
+	Node *rnode = 0;
+	Packet *newp;
+	double propdelay = 0.0;
+	struct hdr_cmn *hdr = HDR_CMN(p);
+
+         /* list-based improvement */
+         if(highestAntennaZ_ == -1) {
+                 fprintf(stdout, "channel.cc:sendUp - Calc highestAntennaZ_ and distCST_\n");
+                 calcHighestAntennaZ(tifp);
+                 fprintf(stdout, "highestAntennaZ_ = %0.1f,  distCST_ = %0.1f\n", highestAntennaZ_, distCST_);
+         }
+	
+	 hdr->direction() = hdr_cmn::UP;
+
+	 // still keep grid-keeper around ??
+	 if (GridKeeper::instance()) {
+	    int i;
+	    GridKeeper* gk = GridKeeper::instance();
+	    int size = gk->size_; 
+	    
+	    MobileNode **outlist = new MobileNode *[size];
+	 
+       	    int out_index = gk->get_neighbors((MobileNode*)tnode,
+						         outlist);
+	    for (i=0; i < out_index; i ++) {
+		
+		  newp = p->copy();
+		  rnode = outlist[i];
+		  propdelay = get_pdelay(tnode, rnode);
+
+		  rifp = (rnode->ifhead()).lh_first; 
+		  for(; rifp; rifp = rifp->nextnode()){
+			  if (rifp->channel() == this){
+				 s.schedule(rifp, newp, propdelay); 
+				 break;
+			  }
+		  }
+ 	    }
+	    delete [] outlist; 
+	 
+	 } else { // use list-based improvement
+	 
+		 MobileNode *mtnode = (MobileNode *) tnode;
+		 MobileNode **affectedNodes;// **aN;
+		 int numAffectedNodes = -1, i;
+		 
+		 if(!sorted_){
+			 sortLists();
+		 }
+		 
+		 affectedNodes = getAffectedNodes(mtnode, distCST_ + /* safety */ 5, &numAffectedNodes);
+		 for (i=0; i < numAffectedNodes; i++) {
+			 rnode = affectedNodes[i];
+			 
+			 if(rnode == tnode)
+				 continue;
+			 
+			 newp = p->copy();
+			 
+			 propdelay = get_pdelay(tnode, rnode);
+			 
+			 rifp = (rnode->ifhead()).lh_first;
+			 for(; rifp; rifp = rifp->nextnode()){
+				 s.schedule(rifp, newp, propdelay);
+			 }
+		 }
+		 delete [] affectedNodes;
+	 }
+	 Packet::free(p);
+}
+
+
+void
+WirelessChannel::addNodeToList(MobileNode *mn)
+{
+	MobileNode *tmp;
+
+	// create list of mobilenodes for this channel
+	if (xListHead_ == NULL) {
+		fprintf(stderr, "INITIALIZE THE LIST xListHead\n");
+		xListHead_ = mn;
+		xListHead_->nextX_ = NULL;
+		xListHead_->prevX_ = NULL;
+	} else {
+		for (tmp = xListHead_; tmp->nextX_ != NULL; tmp=tmp->nextX_);
+		tmp->nextX_ = mn;
+		mn->prevX_ = tmp;
+		mn->nextX_ = NULL;
+	}
+	numNodes_++;
+}
+
+void
+WirelessChannel::removeNodeFromList(MobileNode *mn) {
+	
+	MobileNode *tmp;
+	// Find node in list
+	for (tmp = xListHead_; tmp->nextX_ != NULL; tmp=tmp->nextX_) {
+		if (tmp == mn) {
+			if (tmp == xListHead_) {
+				xListHead_ = tmp->nextX_;
+				if (tmp->nextX_ != NULL)
+					tmp->nextX_->prevX_ = NULL;
+			} else if (tmp->nextX_ == NULL) 
+				tmp->prevX_->nextX_ = NULL;
+			else {
+				tmp->prevX_->nextX_ = tmp->nextX_;
+				tmp->nextX_->prevX_ = tmp->prevX_;
+			}
+			numNodes_--;
+			return;
+		}
+	}
+	fprintf(stderr, "Channel: node not found in list\n");
+}
+
+void
+WirelessChannel::sortLists(void) {
+	bool flag = true;
+	MobileNode *m, *q;
+
+	sorted_ = true;
+	
+	fprintf(stderr, "SORTING LISTS ...");
+	/* Buble sort algorithm */
+	// SORT x-list
+	while(flag) {
+		flag = false;
+		m = xListHead_;
+		while (m != NULL){
+			if(m->nextX_ != NULL)
+				if ( m->X() > m->nextX_->X() ){
+					flag = true;
+					//delete_after m;
+					q = m->nextX_;
+					m->nextX_ = q->nextX_;
+					if (q->nextX_ != NULL)
+						q->nextX_->prevX_ = m;
+			    
+					//insert_before m;
+					q->nextX_ = m;
+					q->prevX_ = m->prevX_;
+					m->prevX_ = q;
+					if (q->prevX_ != NULL)
+						q->prevX_->nextX_ = q;
+
+					// adjust Head of List
+					if(m == xListHead_) 
+						xListHead_ = m->prevX_;
+				}
+			m = m -> nextX_;
+		}
+	}
+	
+	fprintf(stderr, "DONE!\n");
+}
+
+void
+WirelessChannel::updateNodesList(class MobileNode *mn, double oldX) {
+	
+	MobileNode* tmp;
+	double X = mn->X();
+	bool skipX=false;
+	
+	if(!sorted_) {
+		sortLists();
+		return;
+	}
+	
+	/* xListHead cannot be NULL here (they are created during creation of mobilenode) */
+	
+	/***  DELETE ***/
+	// deleting mn from x-list
+	if(mn->nextX_ != NULL) {
+		if(mn->prevX_ != NULL){
+			if((mn->nextX_->X() >= X) && (mn->prevX_->X() <= X)) skipX = true; // the node doesn't change its position in the list
+			else{
+				mn->nextX_->prevX_ = mn->prevX_;
+				mn->prevX_->nextX_ = mn->nextX_;
+			}
+		}
+		
+		else{
+			if(mn->nextX_->X() >= X) skipX = true; // skip updating the first element
+			else{
+				mn->nextX_->prevX_ = NULL;
+				xListHead_ = mn->nextX_;
+			}
+		}
+	}
+	
+	else if(mn->prevX_ !=NULL){
+		if(mn->prevX_->X() <= X) skipX = true; // skip updating the last element
+		else mn->prevX_->nextX_ = NULL;
+	}
+	
+	if ((mn->prevX_ == NULL) && (mn->nextX_ == NULL)) skipX = true; //skip updating if only one element in list
+	
+	/*** INSERT ***/
+	//inserting mn in x-list
+	if(!skipX){
+		if(X > oldX){			
+			for(tmp = mn; tmp->nextX_ != NULL && tmp->nextX_->X() < X; tmp = tmp->nextX_);
+			//fprintf(stdout,"Scanning the element addr %d X=%0.f, next addr %d X=%0.f\n", tmp, tmp->X(), tmp->nextX_, tmp->nextX_->X());
+			if(tmp->nextX_ == NULL) { 
+				//fprintf(stdout, "tmp->nextX_ is NULL\n");
+				tmp->nextX_ = mn;
+				mn->prevX_ = tmp;
+				mn->nextX_ = NULL;
+			} 
+			else{ 
+				//fprintf(stdout, "tmp->nextX_ is not NULL, tmp->nextX_->X()=%0.f\n", tmp->nextX_->X());
+				mn->prevX_ = tmp->nextX_->prevX_;
+				mn->nextX_ = tmp->nextX_;
+				tmp->nextX_->prevX_ = mn;  	
+				tmp->nextX_ = mn;
+			} 
+		}
+		else{
+			for(tmp = mn; tmp->prevX_ != NULL && tmp->prevX_->X() > X; tmp = tmp->prevX_);
+				//fprintf(stdout,"Scanning the element addr %d X=%0.f, prev addr %d X=%0.f\n", tmp, tmp->X(), tmp->prevX_, tmp->prevX_->X());
+			if(tmp->prevX_ == NULL) {
+				//fprintf(stdout, "tmp->prevX_ is NULL\n");
+				tmp->prevX_ = mn;
+				mn->nextX_ = tmp;
+				mn->prevX_ = NULL;
+				xListHead_ = mn;
+			} 
+			else{
+				//fprintf(stdout, "tmp->prevX_ is not NULL, tmp->prevX_->X()=%0.f\n", tmp->prevX_->X());
+				mn->nextX_ = tmp->prevX_->nextX_;
+				mn->prevX_ = tmp->prevX_;
+				tmp->prevX_->nextX_ = mn;  	
+				tmp->prevX_ = mn;		
+			}
+		}
+	}
+}
+
+
+MobileNode **
+WirelessChannel::getAffectedNodes(MobileNode *mn, double radius,
+				  int *numAffectedNodes)
+{
+	double xmin, xmax, ymin, ymax;
+	int n = 0;
+	MobileNode *tmp, **list, **tmpList;
+
+	if (xListHead_ == NULL) {
+		*numAffectedNodes=-1;
+		fprintf(stderr, "xListHead_ is NULL when trying to send!!!\n");
+		return NULL;
+	}
+	
+	xmin = mn->X() - radius;
+	xmax = mn->X() + radius;
+	ymin = mn->Y() - radius;
+	ymax = mn->Y() + radius;
+	
+	// First allocate as much as possibly needed
+	tmpList = new MobileNode*[numNodes_];
+	
+	for(tmp = xListHead_; tmp != NULL; tmp = tmp->nextX_) tmpList[n++] = tmp;
+	for(int i = 0; i < n; ++i)
+		if(tmpList[i]->speed()!=0.0 && (Scheduler::instance().clock() -
+						tmpList[i]->getUpdateTime()) > XLIST_POSITION_UPDATE_INTERVAL )
+			tmpList[i]->update_position();
+	n=0;
+	
+	for(tmp = mn; tmp != NULL && tmp->X() >= xmin; tmp=tmp->prevX_)
+		if(tmp->Y() >= ymin && tmp->Y() <= ymax){
+			tmpList[n++] = tmp;
+		}
+	for(tmp = mn->nextX_; tmp != NULL && tmp->X() <= xmax; tmp=tmp->nextX_){
+		if(tmp->Y() >= ymin && tmp->Y() <= ymax){
+			tmpList[n++] = tmp;
+		}
+	}
+	
+	list = new MobileNode*[n];
+	memcpy(list, tmpList, n * sizeof(MobileNode *));
+	delete [] tmpList;
+         
+	*numAffectedNodes = n;
+	return list;
+}
+ 
+
+
+/* Only to be used with mobile nodes (WirelessPhy).
+ * NS-2 at its current state support only a flat (non 3D) movement of nodes,
+ * so we assume antenna heights do not change for the dureation of
+ * a simulation.
+ * Another assumption - all nodes have the same wireless interface, so that
+ * the maximum distance, corresponding to CST (at max transmission power 
+ * level) stays the same for all nodes.
+ */
+void
+WirelessChannel::calcHighestAntennaZ(Phy *tifp)
+{
+       double highestZ = 0;
+       Phy *n;
+ 
+       // HACK: the dynamic_cast is a workaround only!
+       for(n = ifhead_.lh_first; n; n = n->nextchnl()) {
+    	   if(dynamic_cast<WirelessPhyExt*>(n)) {
+    		   if(((WirelessPhyExt *)n)->getAntennaZ() > highestZ)
+    			   highestZ = ((WirelessPhyExt *)n)->getAntennaZ();
+    	   } else if (dynamic_cast<WirelessPhy*>(n)) {
+    		   if(((WirelessPhy *)n)->getAntennaZ() > highestZ)
+    			   highestZ = ((WirelessPhy *)n)->getAntennaZ();
+    	   } else highestZ = 0;
+       }
+
+       highestAntennaZ_ = highestZ;
+
+       if (dynamic_cast<WirelessPhyExt*>(tifp)) {
+    	   WirelessPhyExt *wifp = (WirelessPhyExt *)tifp;
+    	   distCST_ = wifp->getDist(wifp->getPowerMonitorThresh(), wifp->getPt(), wifp->getAntennaRxGain(), wifp->getAntennaTxGain(),
+			   highestZ , highestZ, wifp->getL(),
+			   wifp->getLambda());
+       } else if (dynamic_cast<WirelessPhy*>(tifp)) {
+    	   WirelessPhy *wifp = (WirelessPhy *)tifp;
+    	   distCST_ = wifp->getDist(wifp->getCSThresh(), wifp->getPt(), 1.0, 1.0,
+    			   highestZ , highestZ, wifp->getL(),
+    			   wifp->getLambda());
+       } else distCST_ = DBL_MAX;
+}
+
+
+double
+WirelessChannel::get_pdelay(Node* tnode, Node* rnode)
+{
+	// Scheduler	&s = Scheduler::instance();
+	MobileNode* tmnode = (MobileNode*)tnode;
+	MobileNode* rmnode = (MobileNode*)rnode;
+	double propdelay = 0;
+	
+	propdelay = tmnode->propdelay(rmnode);
+
+	assert(propdelay >= 0.0);
+	if (propdelay == 0.0) {
+		/* if the propdelay is 0 b/c two nodes are on top of 
+		   each other, move them slightly apart -dam 7/28/98 */
+		propdelay = 2 * DBL_EPSILON;
+		//printf ("propdelay 0: %d->%d at %f\n",
+		//	tmnode->address(), rmnode->address(), s.clock());
+	}
+	return propdelay;
+}
+
+	
+
+// send():
+//  The packet occupies the channel for the transmission time, txtime
+//  If collision occur (>1 pkts overlap), corrupt all pkts involved
+//	by setting the error bit or discard them
+
+// int Channel::send(Packet* p, Phy *tifp)
+// {
+// 	// without collision, return 0
+// 	Scheduler& s = Scheduler::instance();
+// 	double now = s.clock();
+
+// 	// busy = time when the channel are still busy with earlier tx
+// 	double busy = max(txstop_, cwstop_);
+
+// 	// txstop = when the channel is no longer busy from this tx
+// 	txstop_ = max(busy, now + txtime);
+
+// 	// now < busy => collision
+// 	//	mark the pkt error bit, EF_COLLISION
+// 	//	drop if there is a drop target, drop_
+// 	if (now < busy) {
+// 		// if still transmit earlier packet, pkt_, then corrupt it
+// 		if (pkt_ && pkt_->time_ > now) {
+// 			hdr_cmn::access(pkt_)->error() |= EF_COLLISION;
+// 			if (drop_) {
+// 				s.cancel(pkt_);
+// 				drop(pkt_);
+// 				pkt_ = 0;
+// 			}
+// 		}
+
+// 		// corrupts the current packet p, and drop if drop_ exists
+// 		hdr_cmn::access(p)->error() |= EF_COLLISION;
+// 		if (drop_) {
+// 			drop(p);
+// 			return 1;
+// 		}
+// 	}
+
+// 	// if p was not dropped, call recv() or hand it to trace_ if present
+// 	pkt_ = p;
+// 	trace_ ? trace_->recv(p, 0) : recv(p, 0);
+// 	return 0;
+// }
+
+
+// contention():
+//  The MAC calls this Channel::contention() to enter contention period
+//  It determines when the contention window is over, cwstop_,
+//	and schedule a callback to the MAC for the actual send()
+
+// void Channel::contention(Packet* p, Handler* h)
+// {
+// 	Scheduler& s = Scheduler::instance();
+// 	double now = s.clock();
+// 	if (now > cwstop_) {
+// 		cwstop_ = now + delay_;
+// 		numtx_ = 0;
+// 	}
+// 	numtx_++;
+// 	s.schedule(h, p, cwstop_ - now);
+// }
+
+
+// jam():
+//  Jam the channel for a period txtime
+//  Some MAC protocols use this to let other MAC detect collisions
+
+// int Channel::jam(double txtime)
+// {
+// 	// without collision, return 0
+// 	double now = Scheduler::instance().clock();
+// 	if (txstop_ > now) {
+// 		txstop_ = max(txstop_, now + txtime);
+// 		return 1;
+// 	}
+// 	txstop_ = now + txtime;
+// 	return (now < cwstop_);
+// }
+
+
+// int DuplexChannel::send(Packet* p, double txtime)
+// {
+// 	double now = Scheduler::instance().clock();
+// 	txstop_ = now + txtime;
+// 	trace_ ? trace_->recv(p, 0) : recv(p, 0);
+// 	return 0;
+// }
+
+
+// void DuplexChannel::contention(Packet* p, Handler* h)
+// {
+// 	Scheduler::instance().schedule(h, p, delay_);
+// 	numtx_ = 1;
+// }
+
+
+
+
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/ll-ext.cc ns-2.34/mac/ll-ext.cc
--- ns-2.34-pure/mac/ll-ext.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/mac/ll-ext.cc	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,173 @@
+/*
+ * ll-ext.cc
+ * This is a special link layer which explicitly notifies the attached
+ * queue when it becomes free.
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+// XXX This is really a click link layer now - not just ext...
+
+#include "config.h"
+#include <stdlib.h>
+#include <ctype.h>
+#include <sys/time.h>
+#include <unistd.h>
+//#include <stl.h>
+//#include <hash_map.h>
+#include <map>
+#include <math.h>
+#include <string>
+#include "packet.h"
+#include "ip.h"
+#include "mac.h"
+#include "classifier.h"
+//#include "classifier-hash.h"
+#include "scheduler.h"
+#include "ll.h"
+#include <click/simclick.h>
+#include "ll-ext.h"
+#include "packet.h"
+#include "extrouter.h"
+#include "classifier.h"
+#include "classifier-ext.h"
+#include "classifier-click.h"
+#include "clickqueue.h"
+
+static class LLExtClass : public TclClass {
+public:
+  LLExtClass() : TclClass("LL/Ext") {}
+  TclObject* create(int, const char*const*) {
+    return (new LLExt());
+  }
+} class_ll_ext;
+
+void
+LLExtEventHandler::handle(Event* event) {
+  // XXX dangerous downcast - should use RTTI
+  LLExtEvent* myevent = (LLExtEvent*) event;
+  myevent->llext->setpending(0);
+  delete myevent;
+}
+
+
+LLExt::LLExt() {
+  extid_ = -1;
+  macDA_ = -1;
+  packetpending_ = 0;
+}
+
+LLExt::~LLExt() {
+}
+
+int LLExt::command(int argc, const char*const* argv) {
+  //Tcl& tcl = Tcl::instance();
+  if(argc == 2) {
+  }
+  else if (argc == 3) {
+    if (strcmp("setid",argv[1]) == 0) {
+      extid_ = atoi(argv[2]);
+      return TCL_OK;
+    }
+    else if (strcmp("setpromiscuous",argv[1]) == 0) {
+      bool promisc = (atoi(argv[2]) != 0);
+      setpromiscuous(promisc);
+      return TCL_OK;
+    }
+  }
+  else if (argc == 4) {
+  }
+
+  return LL::command(argc,argv);
+}
+
+void LLExt::recv(Packet* p, Handler* h) {
+  /*
+   * Tag the packet and then defer to standard link layer handling.
+   */
+  struct hdr_cmn* hdr = HDR_CMN(p);
+  hdr->iface() = extid_;
+  // printf("ll = %d, ifid = %d\n",(int)this,hdr->iface());
+  LL::recv(p,h);
+}
+
+void LLExt::sendDown(Packet* p) {
+  // Someone decided that it would be A Good Thing to overlay
+  // the 802.11 MAC packet info on top of the regular MAC packet info.
+  // We need to fix the source and destination addresses here by accessing the
+  // MAC object itself.
+  struct hdr_mac* mhdr = HDR_MAC(p);
+  int macdst = mhdr->macDA();
+  int macsrc = mhdr->macSA();
+  memset(mhdr,0,sizeof(struct hdr_mac));
+  mac_->hdr_dst((char*)mhdr,macdst);
+  mac_->hdr_src((char*)mhdr,macsrc);
+
+  // Bleah. Send the packet down, mark ourself as being busy, and then
+  // schedule an event to mark ourselves unbusy.
+  packetpending_ = 1;
+  LL::sendDown(p);
+  LLExtEvent* llev = new LLExtEvent();
+  llev->llext = this;
+  Scheduler& s = Scheduler::instance();
+  s.schedule(&evhandle_,llev,delay_);
+}
+
+int LLExt::ready() {
+  ClickQueue* pcq = (ClickQueue*) ifq_;
+  if (pcq) {
+    return (!packetpending_ && pcq->ready());
+  }
+
+  // No ClickQueue? Then we're always ready.
+  return 1;
+}
+
+void
+LLExt::setpromiscuous(bool promisc) {
+  if (!mac_) {
+    return;
+  }
+
+  if (promisc) {
+    mac_->installTap(this,true);
+  }
+  else {
+    mac_->installTap(0,true);
+  }
+}
+
+void 
+LLExt::tap(const Packet *packet)
+  /* process packets that are promiscously listened to from the MAC layer tap
+  *** do not change or free packet *** */
+{
+  // XXX send a copy of packets received here up to the next layer.
+  // This code assumes that the tap is being used with the "filterown"
+  // option set, otherwise duplicate packets will get sent up the pipe.
+  Packet* newp = packet->copy();
+  recv(newp,0);
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/ll-ext.h ns-2.34/mac/ll-ext.h
--- ns-2.34-pure/mac/ll-ext.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/mac/ll-ext.h	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,78 @@
+/*
+ * ll-ext.h
+ *
+ * Much like the multicast routing system, ext routers needs to know what
+ * interface packets come in from. However, the multicast interface
+ * thing doesn't quite do what we need it to, so you get what
+ * we've got here. 
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#ifndef ns_ll_ext_h
+#define ns_ll_ext_h
+
+#include "object.h"
+
+class Packet;
+class LLExt;
+
+class LLExtEvent : public Event {
+ public:
+  LLExt* llext;
+};
+
+class LLExtEventHandler : public Handler {
+ public:
+  virtual void handle(Event* event);
+};
+
+class LLExt : public LL, public Tap {
+ public:
+  LLExt();
+  virtual ~LLExt();
+	
+  virtual void recv(Packet* p, Handler* h);
+  virtual void sendDown(Packet* p);
+
+  // Allow us to do promiscuous mode by acting as a tap.
+  void tap(const Packet *p);
+
+  void setExtID(int newid) {extid_ = newid;}
+  int getExtID() {return extid_;}
+  int ready();
+  int getpending() { return packetpending_; }
+  void setpending(int newpend) { packetpending_ = newpend; };
+  void setpromiscuous(bool promisc);
+  
+ protected:
+  virtual int command(int argc, const char*const* argv);
+  int extid_;
+  int packetpending_;
+  LLExtEventHandler evhandle_;
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/ll.cc ns-2.34/mac/ll.cc
--- ns-2.34-pure/mac/ll.cc	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/mac/ll.cc	2010-02-28 09:31:39.000000000 -0800
@@ -203,6 +203,9 @@
 			tx = arptable_->arpresolve(dst, p, this);
 			break;
 		}
+		if (PT_RAW == ch->ptype()) {
+			break;
+		}
 		//if (varp_) {
 		//tx = varp_->arpresolve(dst, p);
 		//break;
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/mac-802_11.cc ns-2.34/mac/mac-802_11.cc
--- ns-2.34-pure/mac/mac-802_11.cc	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/mac/mac-802_11.cc	2010-02-28 09:31:39.000000000 -0800
@@ -39,9 +39,17 @@
  *   - Sushmita
  */
 
+/*
+ *	Modified by Nicolas Letor to support wifi elements.
+ * 	Performance Analysis of Telecommunication Systems (PATS) research group,
+ * 	Interdisciplinary Institute for Broadband Technology (IBBT) & Universiteit Antwerpen.
+ */
 #include "delay.h"
 #include "connector.h"
+#include "agent.h"
 #include "packet.h"
+#include "rawpacket.h"
+#include "packet_anno.h"
 #include "random.h"
 #include "mobilenode.h"
 
@@ -1054,6 +1062,39 @@
 	transmit(pktTx_, timeout);
 	return 0;
 }
+
+// helper function
+click_wifi_extra* 
+getWifiExtra(Packet* p)
+{
+  	struct hdr_cmn* chdr = HDR_CMN(p);
+	if (chdr->ptype() == PT_RAW){
+		hdr_raw* rhdr = hdr_raw::access(p);
+		if (rhdr->subtype == hdr_raw::MADWIFI) {
+			click_wifi_extra* ceh = (click_wifi_extra*)(p->accessdata());
+			if (ceh->magic == WIFI_EXTRA_MAGIC){
+				return ceh;
+			}			
+		}
+	}
+	return 0;
+}
+
+click_wifi* 
+getWifi(Packet* p)
+{
+  	struct hdr_cmn* chdr = HDR_CMN(p);
+	if (chdr->ptype() == PT_RAW){
+		hdr_raw* rhdr = hdr_raw::access(p);
+		if (rhdr->subtype == hdr_raw::MADWIFI) {
+			click_wifi_extra* ceh = (click_wifi_extra*)(p->accessdata());
+			if (ceh->magic == WIFI_EXTRA_MAGIC){
+				return (click_wifi*)(p->accessdata() + sizeof(click_wifi_extra));
+			}			
+		}
+	}
+	return 0;
+}
 /*
  * Low-level transmit functions that actually place the packet onto
  * the channel.
@@ -1072,10 +1113,26 @@
 	 *  If the size of the packet is larger than the
 	 *  RTSThreshold, then perform the RTS/CTS exchange.
 	 */
-	if( (u_int32_t) HDR_CMN(pktTx_)->size() < macmib_.getRTSThreshold() ||
+	click_wifi_extra* ceh = getWifiExtra(pktTx_);
+	if ((ceh != 0) && ((u_int32_t) dst != MAC_BROADCAST)) { 	
+		// madwifi case
+		if (!(ceh->flags & WIFI_EXTRA_DO_RTS_CTS)) {
+			Packet::free(p);
+			//p = 0;
+			return;
+		}
+		
+		if	( ceh->power > 0){
+			p->txinfo_.setPrLevel(ceh->power);	
+		}
+
+	} else {
+		// normal case
+		if( (u_int32_t) HDR_CMN(pktTx_)->size() < macmib_.getRTSThreshold() ||
             (u_int32_t) dst == MAC_BROADCAST) {
-		Packet::free(p);
-		return;
+			Packet::free(p);
+			return;
+		}
 	}
 
 	ch->uid() = 0;
@@ -1219,6 +1276,7 @@
 	/*
 	 * Update the MAC header
 	 */
+	click_wifi_extra* ceh = getWifiExtra(p);
 	ch->size() += phymib_.getHdrLen11();
 
 	dh->dh_fc.fc_protocol_version = MAC_ProtocolVersion;
@@ -1247,6 +1305,20 @@
 	if(dst != MAC_BROADCAST) {
 		/* store data tx time for unicast packets */
 		ch->txtime() = txtime(ch->size(), dataRate_);
+		p->txinfo_.setRate(dataRate_);
+
+		// nsmadwifi
+		if ( ceh != 0 ){
+			
+			if ( ceh->rate > 0){
+				double rate = ((short int)(ceh->rate))*500000; 
+				ch->txtime() = txtime(ch->size(),rate);
+				p->txinfo_.setRate(rate);
+			}
+			if	( ceh->power > 0){
+				p->txinfo_.setPrLevel(ceh->power);	
+			}
+		}
 		
 		dh->dh_duration = usec(txtime(phymib_.getACKlen(), basicRate_)
 				       + phymib_.getSIFS());
@@ -1256,6 +1328,7 @@
 	} else {
 		/* store data tx time for broadcast packets (see 9.6) */
 		ch->txtime() = txtime(ch->size(), basicRate_);
+		p->txinfo_.setRate(basicRate_);
 		
 		dh->dh_duration = 0;
 	}
@@ -1276,7 +1349,25 @@
 
 	ssrc_ += 1;			// STA Short Retry Count
 		
+	bool failure = false;
+	double count = ssrc_;
+
+	click_wifi_extra* ceh = getWifiExtra(pktTx_);
+	if ((ceh != 0) && (ceh->max_tries != 0)){
+		ceh->retries = ssrc_;
+		if (count <= ceh->max_tries){
+		
+		} else {
+			failure = true;	
+		}
+	} else {
 	if(ssrc_ >= macmib_.getShortRetryLimit()) {
+			failure = true;	
+		}	
+	}
+
+
+	if(failure){
 		discard(pktRTS_, DROP_MAC_RETRY_COUNT_EXCEEDED); pktRTS_ = 0;
 		/* tell the callback the send operation failed 
 		   before discarding the packet */
@@ -1292,7 +1383,24 @@
                         ch->xmit_failure_(pktTx_->copy(),
                                           ch->xmit_failure_data_);
                 }
+
+		if (ceh != 0){
+			Packet* p2 = pktTx_->copy();
+			click_wifi_extra* ceh2 = getWifiExtra(p2);
+			ceh2->flags |= WIFI_EXTRA_TX_FAIL;
+			ceh2->flags |= WIFI_EXTRA_TX;
+			struct hdr_cmn* ch2 = HDR_CMN(p2); 
+			ch2->direction() = hdr_cmn::UP; 
+			//printf("(%d)....discarding RTS:%x\n",index_,pktRTS_);
 		discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED); 
+			uptarget_->recv(p2, (Handler*) 0);
+		
+		} else {
+			//printf("(%d)....discarding RTS:%x\n",index_,pktRTS_);
+			discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED); 
+		}
+		
+		pktRTS_ = 0;
 		pktTx_ = 0;
 		ssrc_ = 0;
 		rst_cw();
@@ -1361,7 +1469,44 @@
 		sendPROBEREQ(MAC_BROADCAST);
 		return;
 	}	
-	if(*rcount >= thresh) {
+	bool failure = false;
+	double count = *rcount;
+	click_wifi_extra* ceh = getWifiExtra(pktTx_);
+
+	if ((ceh != 0) && (ceh->max_tries != 0)){
+		ceh->retries = (*rcount);
+			
+		if (count <= ceh->max_tries){
+			double rate = ((short int)(ceh->rate))*500000; 
+			ch->txtime() = txtime(ch->size(),rate);
+			pktTx_->txinfo_.setRate(rate);
+		} else if ( (count-=ceh->max_tries) <= ceh->max_tries1 ){
+			double rate = ((short int)(ceh->rate1))*500000; 
+			ch->txtime() = txtime(ch->size(),rate);
+			pktTx_->txinfo_.setRate(rate);
+			ceh->flags |= WIFI_EXTRA_TX_USED_ALT_RATE;
+		} else if ( (count-=ceh->max_tries1) <= ceh->max_tries2 ){
+			double rate = ((short int)(ceh->rate2))*500000; 
+			ch->txtime() = txtime(ch->size(),rate);
+			pktTx_->txinfo_.setRate(rate);
+			ceh->flags |= WIFI_EXTRA_TX_USED_ALT_RATE;
+		} else if ( (count-=ceh->max_tries2) <= ceh->max_tries3 ){
+			double rate = ((short int)(ceh->rate3))*500000; 
+			ch->txtime() = txtime(ch->size(),rate);
+			pktTx_->txinfo_.setRate(rate);
+			ceh->flags |= WIFI_EXTRA_TX_USED_ALT_RATE;
+		} else {
+			failure = true;	
+		}
+		
+	} else {
+		if(*rcount >= thresh) {
+			failure = true;	
+		}	
+	}
+
+	//if(*rcount >= thresh) {
+	if(failure){
 		/* IEEE Spec section 9.2.3.5 says this should be greater than
 		   or equal */
 		macmib_.FailedCount++;
@@ -1375,7 +1520,24 @@
                                           ch->xmit_failure_data_);
                 }
 
-		discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED); 
+		if (ceh != 0){
+			Packet* p2 = pktTx_->copy();
+			click_wifi_extra* ceh2 = getWifiExtra(p2);
+			ceh2->flags |= WIFI_EXTRA_TX_FAIL;
+			ceh2->flags |= WIFI_EXTRA_TX;
+			struct hdr_cmn* ch2 = HDR_CMN(p2); 
+			ch2->direction() = hdr_cmn::UP; 
+			
+			// drop packet first
+			discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED); 
+			// send feedback to madwifi 
+			uptarget_->recv(p2, (Handler*) 0);
+		
+		} else {
+			discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED); 
+			//printf("(%d)DATA discarded: count exceeded\n",index_);
+		}
+		
 		pktTx_ = 0;
 		*rcount = 0;
 		rst_cw();
@@ -1384,7 +1546,13 @@
 		struct hdr_mac802_11 *dh;
 		dh = HDR_MAC802_11(pktTx_);
 		dh->dh_fc.fc_retry = 1;
-
+		
+		// nletor
+		click_wifi* cwh = getWifi(pktTx_);
+		if (cwh != 0){
+			cwh->i_fc[1] |= WIFI_FC1_RETRY;	
+		}
+		//!nletor 
 
 		sendRTS(ETHER_ADDR(mh->dh_ra));
 		inc_cw();
@@ -1584,6 +1752,8 @@
 	 *
 	 */
 
+	click_wifi_extra* rceh = getWifiExtra(p);
+
 	/*
 	 *  If the interface is currently in transmit mode, then
 	 *  it probably won't even see this packet.  However, the
@@ -1593,6 +1763,9 @@
 	 */
 	if(tx_active_ && hdr->error() == 0) {
 		hdr->error() = 1;
+		if(rceh != 0 && hdr->error()){
+			rceh->flags |= WIFI_EXTRA_RX_ERR;
+		}
 	}
 
 	if(rx_state_ == MAC_IDLE) {
@@ -1678,8 +1851,12 @@
 
         /* tap out - */
         if (tap_ && type == MAC_Type_Data &&
-            MAC_Subtype_Data == subtype ) 
-		tap_->tap(pktRx_);
+            MAC_Subtype_Data == subtype ) {
+		if (!tap_filterown_ ||
+		    ((dst != (u_int32_t)index_) && (dst != MAC_BROADCAST))) {
+			tap_->tap(pktRx_);
+		}
+	}
 	/*
 	 * Adaptive Fidelity Algorithm Support - neighborhood infomation 
 	 * collection
@@ -1905,6 +2082,7 @@
 	 * Adjust the MAC packet size - ie; strip
 	 * off the mac header
 	 */
+	click_wifi_extra* rceh = getWifiExtra(p);
 	ch->size() -= phymib_.getHdrLen11();
 	ch->num_forwards() += 1;
 
@@ -1912,7 +2090,9 @@
 	 *  If we sent a CTS, clean up...
 	 */
 	if(dst != MAC_BROADCAST) {
-		if(size >= macmib_.getRTSThreshold()) {
+		//if(size >= macmib_.getRTSThreshold()) {
+		if ( 	(!rceh && size >= macmib_.getRTSThreshold()) ||
+			 	( rceh && pktCTRL_)){
 			if (tx_state_ == MAC_CTS) {
 				assert(pktCTRL_);
 				Packet::free(pktCTRL_); pktCTRL_ = 0;
@@ -2063,7 +2243,9 @@
 			assert(mhBackoff_.busy() == 0);
 			mhBackoff_.start(cw_, is_idle());
 		}
-		goto done;
+		tx_resume();
+		mac_log(p);
+		return;
 	}
 	if(tx_state_ != MAC_SEND) {
 		discard(p, DROP_MAC_INVALID_STATE);
@@ -2071,6 +2253,17 @@
 	}
 	assert(pktTx_);
 
+	// nletor
+	Packet* p2 = 0;	//prepare feedback WIFI_EXTRA_TX
+	click_wifi_extra* ceh = getWifiExtra(pktTx_);
+	if (ceh != 0){
+		p2 = pktTx_->copy();
+		click_wifi_extra* ceh2 = getWifiExtra(p2);
+		ceh2->flags |= WIFI_EXTRA_TX;
+		struct hdr_cmn* ch2 = HDR_CMN(p2); 
+		ch2->direction() = hdr_cmn::UP; 
+	} 
+	//!nletor
 	mhSend_.stop();
 
 	/*
@@ -2095,11 +2288,15 @@
 
 	assert(mhBackoff_.busy() == 0);
 	mhBackoff_.start(cw_, is_idle());
-done:
 
 	tx_resume();
 
 	mac_log(p);
+	// nletor
+	if (p2 != 0 ){
+		uptarget_->recv(p2, (Handler*) 0);	// send feedback WIFI_EXTRA_TX
+	}
+	//!nletor
 }
 
 
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/mac-802_11.cc.orig ns-2.34/mac/mac-802_11.cc.orig
--- ns-2.34-pure/mac/mac-802_11.cc.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/mac/mac-802_11.cc.orig	2009-06-14 10:35:44.000000000 -0700
@@ -0,0 +1,3233 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*-
+ *
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $Header: /cvsroot/nsnam/ns-2/mac/mac-802_11.cc,v 1.58 2008/12/14 14:31:59 tom_henderson Exp $
+ *
+ * Ported from CMU/Monarch's code, nov'98 -Padma.
+ * Contributions by:
+ *   - Mike Holland
+ *   - Sushmita
+ */
+
+#include "delay.h"
+#include "connector.h"
+#include "packet.h"
+#include "random.h"
+#include "mobilenode.h"
+
+// #define DEBUG 99
+
+#include "arp.h"
+#include "ll.h"
+#include "mac.h"
+#include "mac-timers.h"
+#include "mac-802_11.h"
+#include "cmu-trace.h"
+
+// Added by Sushmita to support event tracing
+#include "agent.h"
+#include "basetrace.h"
+
+
+/* our backoff timer doesn't count down in idle times during a
+ * frame-exchange sequence as the mac tx state isn't idle; genreally
+ * these idle times are less than DIFS and won't contribute to
+ * counting down the backoff period, but this could be a real
+ * problem if the frame exchange ends up in a timeout! in that case,
+ * i.e. if a timeout happens we've not been counting down for the
+ * duration of the timeout, and in fact begin counting down only
+ * DIFS after the timeout!! we lose the timeout interval - which
+ * will is not the REAL case! also, the backoff timer could be NULL
+ * and we could have a pending transmission which we could have
+ * sent! one could argue this is an implementation artifact which
+ * doesn't violate the spec.. and the timeout interval is expected
+ * to be less than DIFS .. which means its not a lot of time we
+ * lose.. anyway if everyone hears everyone the only reason a ack will
+ * be delayed will be due to a collision => the medium won't really be
+ * idle for a DIFS for this to really matter!!
+ */
+
+inline void
+Mac802_11::checkBackoffTimer()
+{
+	if(is_idle() && mhBackoff_.paused())
+		mhBackoff_.resume(phymib_.getDIFS());
+	if(! is_idle() && mhBackoff_.busy() && ! mhBackoff_.paused())
+		mhBackoff_.pause();
+}
+
+inline void
+Mac802_11::transmit(Packet *p, double timeout)
+{
+	tx_active_ = 1;
+	
+	if (EOTtarget_) {
+		assert (eotPacket_ == NULL);
+		eotPacket_ = p->copy();
+	}
+
+	/*
+	 * If I'm transmitting without doing CS, such as when
+	 * sending an ACK, any incoming packet will be "missed"
+	 * and hence, must be discarded.
+	 */
+	if(rx_state_ != MAC_IDLE) {
+		//assert(dh->dh_fc.fc_type == MAC_Type_Control);
+		//assert(dh->dh_fc.fc_subtype == MAC_Subtype_ACK);
+		assert(pktRx_);
+		struct hdr_cmn *ch = HDR_CMN(pktRx_);
+		ch->error() = 1;        /* force packet discard */
+	}
+
+	/*
+	 * pass the packet on the "interface" which will in turn
+	 * place the packet on the channel.
+	 *
+	 * NOTE: a handler is passed along so that the Network
+	 *       Interface can distinguish between incoming and
+	 *       outgoing packets.
+	 */
+	downtarget_->recv(p->copy(), this);	
+	mhSend_.start(timeout);
+	mhIF_.start(txtime(p));
+}
+inline void
+Mac802_11::setRxState(MacState newState)
+{
+	rx_state_ = newState;
+	checkBackoffTimer();
+}
+
+inline void
+Mac802_11::setTxState(MacState newState)
+{
+	tx_state_ = newState;
+	checkBackoffTimer();
+}
+
+
+/* ======================================================================
+   TCL Hooks for the simulator
+   ====================================================================== */
+static class Mac802_11Class : public TclClass {
+public:
+	Mac802_11Class() : TclClass("Mac/802_11") {}
+	TclObject* create(int, const char*const*) {
+	return (new Mac802_11());
+
+}
+} class_mac802_11;
+
+
+/* ======================================================================
+   Mac  and Phy MIB Class Functions
+   ====================================================================== */
+
+PHY_MIB::PHY_MIB(Mac802_11 *parent)
+{
+	/*
+	 * Bind the phy mib objects.  Note that these will be bound
+	 * to Mac/802_11 variables
+	 */
+
+	parent->bind("CWMin_", &CWMin);
+	parent->bind("CWMax_", &CWMax);
+	parent->bind("SlotTime_", &SlotTime);
+	parent->bind("SIFS_", &SIFSTime);
+	parent->bind("BeaconInterval_", &BeaconInterval);
+	
+	parent->bind("PreambleLength_", &PreambleLength);
+	parent->bind("PLCPHeaderLength_", &PLCPHeaderLength);
+	parent->bind_bw("PLCPDataRate_", &PLCPDataRate);
+}
+
+MAC_MIB::MAC_MIB(Mac802_11 *parent)
+{
+	/*
+	 * Bind the phy mib objects.  Note that these will be bound
+	 * to Mac/802_11 variables
+	 */
+	
+	parent->bind("RTSThreshold_", &RTSThreshold);
+	parent->bind("ShortRetryLimit_", &ShortRetryLimit);
+	parent->bind("LongRetryLimit_", &LongRetryLimit);
+	parent->bind("ScanType_", &ScanType);
+	parent->bind("ProbeDelay_", &ProbeDelay);
+	parent->bind("MaxChannelTime_", &MaxChannelTime);
+	parent->bind("MinChannelTime_", &MinChannelTime);
+	parent->bind("ChannelTime_", &ChannelTime);
+}
+	
+
+
+/* ======================================================================
+   Mac Class Functions
+   ====================================================================== */
+Mac802_11::Mac802_11() : 
+	Mac(), phymib_(this), macmib_(this), mhIF_(this), mhNav_(this), 
+	mhRecv_(this), mhSend_(this), 
+	mhDefer_(this), mhBackoff_(this), mhBeacon_(this), mhProbe_(this)
+{
+	
+	nav_ = 0.0;
+	tx_state_ = rx_state_ = MAC_IDLE;
+	tx_active_ = 0;
+	eotPacket_ = NULL;
+	pktRTS_ = 0;
+	pktCTRL_ = 0;	
+	pktBEACON_ = 0;
+	pktASSOCREP_ = 0;
+	pktASSOCREQ_ = 0;
+	pktAUTHENTICATE_ = 0;
+	pktPROBEREQ_ = 0;
+	pktPROBEREP_ = 0;
+	BeaconTxtime_ = 0;
+	infra_mode_ = 0;	
+	cw_ = phymib_.getCWMin();
+	ssrc_ = slrc_ = 0;
+	// Added by Sushmita
+        et_ = new EventTrace();
+	
+	sta_seqno_ = 1;
+	cache_ = 0;
+	cache_node_count_ = 0;
+	client_list = NULL;
+	ap_list = NULL;
+	queue_head = NULL;
+	Pr = 0;
+	ap_temp = -1;
+	ap_addr = -1;
+	tx_mgmt_ = 0;
+	associated = 0;
+	authenticated = 0;
+	OnMinChannelTime = 0;
+	OnMaxChannelTime = 0;
+	Recv_Busy_ = 0;
+	handoff= 0;
+//	ssid_ = "0";
+	
+	// chk if basic/data rates are set
+	// otherwise use bandwidth_ as default;
+	
+	Tcl& tcl = Tcl::instance();
+	tcl.evalf("Mac/802_11 set basicRate_");
+	if (strcmp(tcl.result(), "0") != 0) 
+		bind_bw("basicRate_", &basicRate_);
+	else
+		basicRate_ = bandwidth_;
+
+	tcl.evalf("Mac/802_11 set dataRate_");
+	if (strcmp(tcl.result(), "0") != 0) 
+		bind_bw("dataRate_", &dataRate_);
+	else
+		dataRate_ = bandwidth_;
+
+		
+	bind_bool("bugFix_timer_", &bugFix_timer_);
+
+        EOTtarget_ = 0;
+       	bss_id_ = IBSS_ID;
+}
+
+
+int
+Mac802_11::command(int argc, const char*const* argv)
+{
+	if (argc == 3) {
+		if (strcmp(argv[1], "eot-target") == 0) {
+			EOTtarget_ = (NsObject*) TclObject::lookup(argv[2]);
+			if (EOTtarget_ == 0)
+				return TCL_ERROR;
+			return TCL_OK;
+		}
+		if (strcmp(argv[1], "ap") == 0) {
+			ap_addr = addr();
+			bss_id_ = addr();
+			infra_mode_ = 1;
+			mhBeacon_.start((Random::random() % cw_) * 
+					phymib_.getSlotTime());
+			return TCL_OK;
+		} 
+		if (strcmp(argv[1], "ScanType") == 0) {
+			if (strcmp(argv[2], "ACTIVE") == 0) {
+				ScanType_ = ACTIVE;
+				infra_mode_ = 1;
+				mhProbe_.start(macmib_.getProbeDelay());
+				probe_delay = 1;
+			} else if (strcmp(argv[2], "PASSIVE") == 0) {
+				ScanType_ = PASSIVE;
+				mhProbe_.start(macmib_.getChannelTime());
+				infra_mode_ = 1;
+			}
+			return TCL_OK;
+		} else if (strcmp(argv[1], "log-target") == 0) { 
+			logtarget_ = (NsObject*) TclObject::lookup(argv[2]);
+			if(logtarget_ == 0)
+				return TCL_ERROR;
+			return TCL_OK;
+		} else if(strcmp(argv[1], "nodes") == 0) {
+			if(cache_) return TCL_ERROR;
+			cache_node_count_ = atoi(argv[2]);
+			cache_ = new Host[cache_node_count_ + 1];
+			assert(cache_);
+			bzero(cache_, sizeof(Host) * (cache_node_count_+1 ));
+			return TCL_OK;
+		} else if(strcmp(argv[1], "eventtrace") == 0) {
+			// command added to support event tracing by Sushmita
+                        et_ = (EventTrace *)TclObject::lookup(argv[2]);
+                        return (TCL_OK);
+                }
+	}
+	return Mac::command(argc, argv);
+}
+
+// Added by Sushmita to support event tracing
+void Mac802_11::trace_event(char *eventtype, Packet *p) 
+{
+        if (et_ == NULL) return;
+        char *wrk = et_->buffer();
+        char *nwrk = et_->nbuffer();
+        //char *src_nodeaddr =
+	//       Address::instance().print_nodeaddr(iph->saddr());
+        //char *dst_nodeaddr =
+        //      Address::instance().print_nodeaddr(iph->daddr());
+	
+        struct hdr_mac802_11* dh = HDR_MAC802_11(p);
+	
+        //struct hdr_cmn *ch = HDR_CMN(p);
+	
+	if(wrk != 0) {
+		sprintf(wrk, "E -t "TIME_FORMAT" %s %2x ",
+			et_->round(Scheduler::instance().clock()),
+                        eventtype,
+                        //ETHER_ADDR(dh->dh_sa)
+                        ETHER_ADDR(dh->dh_ta)
+                        );
+        }
+        if(nwrk != 0) {
+                sprintf(nwrk, "E -t "TIME_FORMAT" %s %2x ",
+                        et_->round(Scheduler::instance().clock()),
+                        eventtype,
+                        //ETHER_ADDR(dh->dh_sa)
+                        ETHER_ADDR(dh->dh_ta)
+                        );
+        }
+        et_->dump();
+}
+
+/* ======================================================================
+   Debugging Routines
+   ====================================================================== */
+void
+Mac802_11::trace_pkt(Packet *p) 
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_mac802_11* dh = HDR_MAC802_11(p);
+	u_int16_t *t = (u_int16_t*) &dh->dh_fc;
+
+	fprintf(stderr, "\t[ %2x %2x %2x %2x ] %x %s %d\n",
+		*t, dh->dh_duration,
+		 ETHER_ADDR(dh->dh_ra), ETHER_ADDR(dh->dh_ta),
+		index_, packet_info.name(ch->ptype()), ch->size());
+}
+
+void
+Mac802_11::dump(char *fname)
+{
+	fprintf(stderr,
+		"\n%s --- (INDEX: %d, time: %2.9f)\n",
+		fname, index_, Scheduler::instance().clock());
+
+	fprintf(stderr,
+		"\ttx_state_: %x, rx_state_: %x, nav: %2.9f, idle: %d\n",
+		tx_state_, rx_state_, nav_, is_idle());
+
+	fprintf(stderr,
+		"\tpktTx_: %lx, pktRx_: %lx, pktRTS_: %lx, pktCTRL_: %lx, pktBEACON_: %lx, pktASSOCREQ_: %lx, pktASSOCREP_: %lx, pktPROBEREQ_: %lx, pktPROBEREP_: %lx, pktAUTHENTICATE_: %lx, callback: %lx\n", (long) pktTx_, (long) pktRx_, (long) pktRTS_,
+		(long) pktCTRL_, (long) pktBEACON_, (long) pktASSOCREQ_, (long) pktASSOCREP_, (long) pktPROBEREQ_, (long) pktPROBEREP_, (long) pktAUTHENTICATE_, (long) callback_);
+
+	fprintf(stderr,
+		"\tDefer: %d, Backoff: %d (%d), Recv: %d, Timer: %d Nav: %d\n",
+		mhDefer_.busy(), mhBackoff_.busy(), mhBackoff_.paused(),
+		mhRecv_.busy(), mhSend_.busy(), mhNav_.busy());
+	fprintf(stderr,
+		"\tBackoff Expire: %f\n",
+		mhBackoff_.expire());
+}
+
+
+/* ======================================================================
+   Packet Headers Routines
+   ====================================================================== */
+inline int
+Mac802_11::hdr_dst(char* hdr, int dst )
+{
+	struct hdr_mac802_11 *dh = (struct hdr_mac802_11*) hdr;
+	
+       if (dst > -2) {
+               if (bss_id() == ((int)IBSS_ID)) {
+			STORE4BYTE(&dst, (dh->dh_ra));
+		} else if ( addr() == bss_id_) {
+			if ( find_client(dst) == 1 || (u_int32_t) dst == MAC_BROADCAST) {
+				STORE4BYTE(&dst, (dh->dh_ra));
+				dh->dh_fc.fc_to_ds      = 0;
+				dh->dh_fc.fc_from_ds    = 1;
+			} else {
+				int dst_broadcast;
+				dst_broadcast = MAC_BROADCAST;
+				
+				STORE4BYTE(&dst_broadcast, (dh->dh_ra));
+				STORE4BYTE(&dst, (dh->dh_3a));
+				dh->dh_fc.fc_to_ds      = 1;
+				dh->dh_fc.fc_from_ds    = 1;		
+			}
+		} else {
+			STORE4BYTE(&bss_id_, (dh->dh_ra));
+                        STORE4BYTE(&dst, (dh->dh_3a));
+		}
+	}
+       return (u_int32_t)ETHER_ADDR(dh->dh_ra);
+}
+
+inline int 
+Mac802_11::hdr_src(char* hdr, int src )
+{
+	struct hdr_mac802_11 *dh = (struct hdr_mac802_11*) hdr;
+        if(src > -2)
+               STORE4BYTE(&src, (dh->dh_ta));
+        return ETHER_ADDR(dh->dh_ta);
+}
+
+inline int 
+Mac802_11::hdr_type(char* hdr, u_int16_t type)
+{
+	struct hdr_mac802_11 *dh = (struct hdr_mac802_11*) hdr;
+	if(type)
+		STORE2BYTE(&type,(dh->dh_body));
+	return GET2BYTE(dh->dh_body);
+}
+
+
+/* ======================================================================
+   Misc Routines
+   ====================================================================== */
+inline int
+Mac802_11::is_idle()
+{
+	if(rx_state_ != MAC_IDLE)
+		return 0;
+	if(tx_state_ != MAC_IDLE)
+		return 0;
+	if(nav_ > Scheduler::instance().clock())
+		return 0;
+	
+	return 1;
+}
+
+void
+Mac802_11::discard(Packet *p, const char* why)
+{
+	hdr_mac802_11* mh = HDR_MAC802_11(p);
+	hdr_cmn *ch = HDR_CMN(p);
+
+	/* if the rcvd pkt contains errors, a real MAC layer couldn't
+	   necessarily read any data from it, so we just toss it now */
+	if(ch->error() != 0) {
+		Packet::free(p);
+		return;
+	}
+
+	switch(mh->dh_fc.fc_type) {
+	case MAC_Type_Management:
+		switch(mh->dh_fc.fc_subtype) {
+		case MAC_Subtype_Auth:
+			 if((u_int32_t)ETHER_ADDR(mh->dh_ra) == (u_int32_t)index_) {
+				drop(p, why);
+				return;
+			}
+			break;
+
+		case MAC_Subtype_AssocReq:
+			if((u_int32_t)ETHER_ADDR(mh->dh_ra) == (u_int32_t)index_) {
+				drop(p, why);
+				return;
+			}
+			break;
+		case MAC_Subtype_AssocRep:
+			break;
+		case MAC_Subtype_ProbeReq:
+			 if((u_int32_t)ETHER_ADDR(mh->dh_ra) == (u_int32_t)index_) {
+				drop(p, why);
+				return;
+			}
+			break;
+		case MAC_Subtype_ProbeRep:
+			break;
+		case MAC_Subtype_80211_Beacon:
+			break;
+		default:
+			fprintf(stderr, "invalid MAC Management subtype\n");
+			exit(1);
+		}
+		break;
+	case MAC_Type_Control:
+		switch(mh->dh_fc.fc_subtype) {
+		case MAC_Subtype_RTS:
+			 if((u_int32_t)ETHER_ADDR(mh->dh_ta) ==  (u_int32_t)index_) {
+				drop(p, why);
+				return;
+			}
+			/* fall through - if necessary */
+		case MAC_Subtype_CTS:
+		case MAC_Subtype_ACK:
+			if((u_int32_t)ETHER_ADDR(mh->dh_ra) == (u_int32_t)index_) {
+				drop(p, why);
+				return;
+			}
+			break;
+		default:
+			fprintf(stderr, "invalid MAC Control subtype\n");
+			exit(1);
+		}
+		break;
+	case MAC_Type_Data:
+		switch(mh->dh_fc.fc_subtype) {
+		case MAC_Subtype_Data:
+			if((u_int32_t)ETHER_ADDR(mh->dh_ra) == \
+                           (u_int32_t)index_ ||
+                          (u_int32_t)ETHER_ADDR(mh->dh_ta) == \
+                           (u_int32_t)index_ ||
+                          ((u_int32_t)ETHER_ADDR(mh->dh_ra) == MAC_BROADCAST && mh->dh_fc.fc_to_ds == 0)) {
+                                drop(p,why);
+                                return;
+			}
+			break;
+		default:
+			fprintf(stderr, "invalid MAC Data subtype\n");
+			exit(1);
+		}
+		break;
+	default:
+		fprintf(stderr, "invalid MAC type (%x)\n", mh->dh_fc.fc_type);
+		trace_pkt(p);
+		exit(1);
+	}
+	Packet::free(p);
+}
+
+void
+Mac802_11::capture(Packet *p)
+{
+	/*
+	 * Update the NAV so that this does not screw
+	 * up carrier sense.
+	 */	
+	set_nav(usec(phymib_.getEIFS() + txtime(p)));
+	Packet::free(p);
+}
+
+void
+Mac802_11::collision(Packet *p)
+{
+	switch(rx_state_) {
+	case MAC_RECV:
+		setRxState(MAC_COLL);
+		/* fall through */
+	case MAC_COLL:
+		assert(pktRx_);
+		assert(mhRecv_.busy());
+		/*
+		 *  Since a collision has occurred, figure out
+		 *  which packet that caused the collision will
+		 *  "last" the longest.  Make this packet,
+		 *  pktRx_ and reset the Recv Timer if necessary.
+		 */
+		if(txtime(p) > mhRecv_.expire()) {
+			mhRecv_.stop();
+			discard(pktRx_, DROP_MAC_COLLISION);
+			pktRx_ = p;
+			mhRecv_.start(txtime(pktRx_));
+		}
+		else {
+			discard(p, DROP_MAC_COLLISION);
+		}
+		break;
+	default:
+		assert(0);
+	}
+}
+
+void
+Mac802_11::tx_resume()
+{
+	double rTime;
+	assert(mhSend_.busy() == 0);
+	assert(mhDefer_.busy() == 0);
+
+	if(pktCTRL_) {
+		/*
+		 *  Need to send a CTS or ACK.
+		 */
+		mhDefer_.start(phymib_.getSIFS());
+	} else if(pktRTS_) {
+		if (mhBackoff_.busy() == 0) {
+			if (bugFix_timer_) {
+				mhBackoff_.start(cw_, is_idle(), 
+						 phymib_.getDIFS());
+			}
+			else {
+				rTime = (Random::random() % cw_) * 
+					phymib_.getSlotTime();
+				mhDefer_.start( phymib_.getDIFS() + rTime);
+			}
+		}
+	} else if(pktTx_) {
+		if (mhBackoff_.busy() == 0) {
+			hdr_cmn *ch = HDR_CMN(pktTx_);
+			struct hdr_mac802_11 *mh = HDR_MAC802_11(pktTx_);
+			
+			if ((u_int32_t) ch->size() < macmib_.getRTSThreshold()
+			    || (u_int32_t) ETHER_ADDR(mh->dh_ra) == MAC_BROADCAST) {
+				if (bugFix_timer_) {
+					mhBackoff_.start(cw_, is_idle(), 
+							 phymib_.getDIFS());
+				}
+				else {
+					rTime = (Random::random() % cw_)
+						* phymib_.getSlotTime();
+					mhDefer_.start(phymib_.getDIFS() + 
+						       rTime);
+				}
+                        } else {
+				mhDefer_.start(phymib_.getSIFS());
+                        }
+		}
+	} else if(callback_) {
+		Handler *h = callback_;
+		callback_ = 0;
+		h->handle((Event*) 0);
+	}
+	setTxState(MAC_IDLE);
+
+}
+
+void
+Mac802_11::rx_resume()
+{
+	assert(pktRx_ == 0);
+	assert(mhRecv_.busy() == 0);
+	setRxState(MAC_IDLE);
+}
+
+
+/* ======================================================================
+   Timer Handler Routines
+   ====================================================================== */
+void
+Mac802_11::backoffHandler()
+{
+	if(addr() != bss_id_ && infra_mode_ == 1) {
+		if(check_pktPROBEREQ() == 0)
+			return;
+		if(check_pktAUTHENTICATE() == 0)
+			return;
+		if(check_pktASSOCREQ() == 0)
+			return;
+	}
+
+	if(pktCTRL_) {
+		assert(mhSend_.busy() || mhDefer_.busy());
+		return;
+	}
+
+	if ( addr() == bss_id_ ) {
+		if (pktPROBEREP_ && queue_head->frame_priority == 1) {
+			if (check_pktPROBEREP() == 0) 
+				return;
+		} else if (pktBEACON_ && queue_head->frame_priority == 2) {
+			if (check_pktBEACON() == 0) {
+				return;
+			}
+		} else if (pktAUTHENTICATE_ && queue_head->frame_priority == 3) { 
+			if (check_pktAUTHENTICATE() == 0)
+				return;
+		} else if(pktASSOCREP_ && queue_head->frame_priority == 4) {
+			if (check_pktASSOCREP() == 0)
+				return;
+		}
+	}
+
+	if(check_pktRTS() == 0)
+		return;
+	if(check_pktTx() == 0)
+		return;
+}
+
+void
+Mac802_11::BeaconHandler()
+{
+	
+	mhBeacon_.start(phymib_.getBeaconInterval());
+	sendBEACON(index_);
+	
+}
+
+
+// Probe timer is used for multiple purposes. It can be set to 4 different values
+// Probe Delay, MinChannelTime and MaxChannelTime -  for Active Scanning
+// ChannelTime - Passive Scanning
+
+
+
+void
+Mac802_11::ProbeHandler()
+{
+	if (ScanType_ == ACTIVE) {
+		if ( (bss_id_ == (int)IBSS_ID || handoff == 1) && OnMinChannelTime == 0 && Recv_Busy_ == 0 && OnMaxChannelTime == 0) {
+			
+			if (probe_delay == 1) {   // Probe delay over - Active Scan starts here, when the ap_table has not been built yet
+				sendPROBEREQ(MAC_BROADCAST); 
+				probe_delay = 0;
+				return;
+			} else {
+				checkAssocAuthStatus();	 // MaxChannelTime Over - Handoff is taking place and ap_table is built, complete authentication and (re)association
+				return;
+			}
+		}
+		else if (OnMinChannelTime == 1 && Recv_Busy_ == 1 && OnMaxChannelTime == 0) {
+			// MinChannelTime Over - receiver indicated busy before timer expiry, hence Probe timer should be continued for MaxChannelTime, to receive all probe responses
+			OnMinChannelTime = 0;
+			OnMaxChannelTime = 1;
+			mhProbe_.start(macmib_.getMaxChannelTime()); 
+			return;
+		}
+		else if (OnMinChannelTime == 0 && Recv_Busy_ == 1 && OnMaxChannelTime == 1) {
+			// MaxChannelTime Over - Active Scanning is over, start authentication and association
+			OnMaxChannelTime = 0;
+			Recv_Busy_ = 0;
+			if (strongest_ap() > -1)
+				active_scan();
+			else 
+				printf("No APs in range\n");
+			return;
+		}
+		else if (OnMinChannelTime == 1 && Recv_Busy_ == 0 && OnMaxChannelTime == 0) {
+			//printf("Out of range of any Access Point or channel without APs\n");
+			OnMinChannelTime = 0;
+			//  MinChannelTime Over 
+			return;
+		}				
+	} else {
+		if (ScanType_ == PASSIVE && bss_id_ == (int)IBSS_ID) {
+			 //  ChannelTime Over - Passive Scanning is over, start authentication and association
+			passive_scan();	 // 
+			return;
+		}
+	}
+	if (bss_id_ != (int)IBSS_ID && !mhProbe_.busy()) {
+	// Start Authentication and Association
+		checkAssocAuthStatus();
+	}
+}
+
+void
+Mac802_11::deferHandler()
+{
+	assert(pktCTRL_ || pktRTS_ || pktTx_);
+	
+	if(check_pktCTRL() == 0)
+		return;
+	assert(mhBackoff_.busy() == 0);
+	if(check_pktRTS() == 0)
+		return;
+	if(check_pktTx() == 0)
+		return;
+}
+
+void
+Mac802_11::navHandler()
+{
+	if(is_idle() && mhBackoff_.paused())
+		mhBackoff_.resume(phymib_.getDIFS());
+}
+
+void
+Mac802_11::recvHandler()
+{
+	recv_timer();
+}
+
+void
+Mac802_11::sendHandler()
+{
+	send_timer();
+}
+
+
+void
+Mac802_11::txHandler()
+{
+	if (EOTtarget_) {
+		assert(eotPacket_);
+		EOTtarget_->recv(eotPacket_, (Handler *) 0);
+		eotPacket_ = NULL;
+	}
+	tx_active_ = 0;
+}
+
+
+/* ======================================================================
+   The "real" Timer Handler Routines
+   ====================================================================== */
+void
+Mac802_11::send_timer()
+{
+	switch(tx_state_) {
+	
+	case MAC_MGMT:
+		if (pktAUTHENTICATE_) {
+				
+			if(addr() == bss_id_ ) {
+				if (tx_mgmt_ == 3) {
+					assert(pktAUTHENTICATE_);
+					Packet::free(pktAUTHENTICATE_);
+					pktAUTHENTICATE_ = 0;
+					shift_priority_queue();
+					assert(mhBackoff_.busy() == 0);
+					mhBackoff_.start(cw_, is_idle());
+					break;
+				}
+			} else {
+				assert(pktAUTHENTICATE_);
+				Packet::free(pktAUTHENTICATE_);
+				pktAUTHENTICATE_ = 0;
+				checkAssocAuthStatus();
+				break;
+			}
+		
+		}
+ 		if (pktASSOCREQ_) {
+			assert(pktASSOCREQ_);
+			Packet::free(pktASSOCREQ_);
+			pktASSOCREQ_ = 0;
+			checkAssocAuthStatus();
+			break;
+ 		}
+		if (pktASSOCREP_) {
+
+			if (tx_mgmt_ == 4) {
+				assert(pktASSOCREP_);
+				Packet::free(pktASSOCREP_);
+				pktASSOCREP_ = 0;
+				shift_priority_queue();
+				assert(mhBackoff_.busy() == 0);
+				mhBackoff_.start(cw_, is_idle());
+				update_client_table(associating_node_,1,2);
+				break;
+			}
+		}
+		if (pktPROBEREQ_) {
+			assert(pktPROBEREQ_);
+			Packet::free(pktPROBEREQ_);
+			pktPROBEREQ_ = 0;
+			break;
+ 		}
+		if (pktPROBEREP_) {
+			if (tx_mgmt_ == 1) {
+				assert(pktPROBEREP_);
+				Packet::free(pktPROBEREP_);
+				pktPROBEREP_ = 0;
+			
+				shift_priority_queue();
+				assert(mhBackoff_.busy() == 0);
+				mhBackoff_.start(cw_, is_idle());
+				break;
+			}
+		}
+	case MAC_BCN:
+		assert(pktBEACON_);
+		Packet::free(pktBEACON_);
+		pktBEACON_ = 0;
+		shift_priority_queue();
+		assert(mhBackoff_.busy() == 0);
+		mhBackoff_.start(cw_, is_idle());
+		break;
+
+	case MAC_RTS:
+		RetransmitRTS();
+		break;
+	/*
+	 * Sent a CTS, but did not receive a DATA packet.
+	 */
+	case MAC_CTS:
+		assert(pktCTRL_);
+		Packet::free(pktCTRL_); 
+		pktCTRL_ = 0;
+		break;
+	/*
+	 * Sent DATA, but did not receive an ACK packet.
+	 */
+	case MAC_SEND:
+		RetransmitDATA();
+		break;
+	/*
+	 * Sent an ACK, and now ready to resume transmission.
+	 */
+	case MAC_ACK:
+		assert(pktCTRL_);
+		Packet::free(pktCTRL_); 
+		pktCTRL_ = 0;
+		break;
+	case MAC_IDLE:
+		break;
+	default:
+		assert(0);
+	}
+	tx_resume();
+}
+
+
+/* ======================================================================
+   Outgoing Packet Routines
+   ====================================================================== */
+int
+Mac802_11::check_pktCTRL()
+{
+	struct hdr_mac802_11 *mh;
+	double timeout;
+
+	if(pktCTRL_ == 0)
+		return -1;
+	if(tx_state_ == MAC_CTS || tx_state_ == MAC_ACK)
+		return -1;
+
+	mh = HDR_MAC802_11(pktCTRL_);
+							  
+	switch(mh->dh_fc.fc_subtype) {
+	/*
+	 *  If the medium is not IDLE, don't send the CTS.
+	 */
+	case MAC_Subtype_CTS:
+		if(!is_idle()) {
+			discard(pktCTRL_, DROP_MAC_BUSY); pktCTRL_ = 0;
+			return 0;
+		}
+		setTxState(MAC_CTS);
+		/*
+		 * timeout:  cts + data tx time calculated by
+		 *           adding cts tx time to the cts duration
+		 *           minus ack tx time -- this timeout is
+		 *           a guess since it is unspecified
+		 *           (note: mh->dh_duration == cf->cf_duration)
+		 */		
+		 timeout = txtime(phymib_.getCTSlen(), basicRate_)
+                        + DSSS_MaxPropagationDelay                      // XXX
+                        + sec(mh->dh_duration)
+                        + DSSS_MaxPropagationDelay                      // XXX
+                       - phymib_.getSIFS()
+                       - txtime(phymib_.getACKlen(), basicRate_);
+		break;
+		/*
+		 * IEEE 802.11 specs, section 9.2.8
+		 * Acknowledments are sent after an SIFS, without regard to
+		 * the busy/idle state of the medium.
+		 */
+	case MAC_Subtype_ACK:		
+		setTxState(MAC_ACK);
+		timeout = txtime(phymib_.getACKlen(), basicRate_);
+		break;
+	default:
+		fprintf(stderr, "check_pktCTRL:Invalid MAC Control subtype\n");
+		exit(1);
+	}
+	transmit(pktCTRL_, timeout);
+	return 0;
+}
+
+int
+Mac802_11::check_pktRTS()
+{
+	struct hdr_mac802_11 *mh;
+	double timeout;
+
+	assert(mhBackoff_.busy() == 0);
+
+	if(pktRTS_ == 0)
+ 		return -1;
+	mh = HDR_MAC802_11(pktRTS_);
+
+ 	switch(mh->dh_fc.fc_subtype) {
+	case MAC_Subtype_RTS:
+		if(! is_idle()) {
+			inc_cw();
+			mhBackoff_.start(cw_, is_idle());
+			return 0;
+		}
+		setTxState(MAC_RTS);
+		timeout = txtime(phymib_.getRTSlen(), basicRate_)
+			+ DSSS_MaxPropagationDelay                      // XXX
+			+ phymib_.getSIFS()
+			+ txtime(phymib_.getCTSlen(), basicRate_)
+			+ DSSS_MaxPropagationDelay;
+		break;
+	default:
+		fprintf(stderr, "check_pktRTS:Invalid MAC Control subtype\n");
+		exit(1);
+	}
+	transmit(pktRTS_, timeout);
+  
+
+	return 0;
+}
+
+int
+Mac802_11::check_pktTx()
+{
+
+	struct hdr_mac802_11 *mh;
+	double timeout;
+	
+	assert(mhBackoff_.busy() == 0);
+
+	if(pktTx_ == 0)
+		return -1;
+
+	mh = HDR_MAC802_11(pktTx_);
+	
+	if (addr() != bss_id_ && bss_id_ != (int)IBSS_ID) {
+		if (handoff == 0)
+			STORE4BYTE(&bss_id_, (mh->dh_ra));
+	}
+
+	switch(mh->dh_fc.fc_subtype) {
+	case MAC_Subtype_Data:
+		if(! is_idle()) {
+			sendRTS(ETHER_ADDR(mh->dh_ra));
+			inc_cw();
+			mhBackoff_.start(cw_, is_idle());
+			return 0;
+		}
+		setTxState(MAC_SEND);
+		if((u_int32_t)ETHER_ADDR(mh->dh_ra) != MAC_BROADCAST)
+                        timeout = txtime(pktTx_)
+                                + DSSS_MaxPropagationDelay              // XXX
+                               + phymib_.getSIFS()
+                               + txtime(phymib_.getACKlen(), basicRate_)
+                               + DSSS_MaxPropagationDelay;             // XXX
+		else
+			timeout = txtime(pktTx_);
+		break;
+	default:
+		fprintf(stderr, "check_pktTx:Invalid MAC Control subtype\n");
+		exit(1);
+	}
+	transmit(pktTx_, timeout);
+	return 0;
+}
+/*
+ * Low-level transmit functions that actually place the packet onto
+ * the channel.
+ */
+void
+Mac802_11::sendRTS(int dst)
+{
+	Packet *p = Packet::alloc();
+	hdr_cmn* ch = HDR_CMN(p);
+	struct rts_frame *rf = (struct rts_frame*)p->access(hdr_mac::offset_);
+	
+	assert(pktTx_);
+	assert(pktRTS_ == 0);
+
+	/*
+	 *  If the size of the packet is larger than the
+	 *  RTSThreshold, then perform the RTS/CTS exchange.
+	 */
+	if( (u_int32_t) HDR_CMN(pktTx_)->size() < macmib_.getRTSThreshold() ||
+            (u_int32_t) dst == MAC_BROADCAST) {
+		Packet::free(p);
+		return;
+	}
+
+	ch->uid() = 0;
+	ch->ptype() = PT_MAC;
+	ch->size() = phymib_.getRTSlen();
+	ch->iface() = -2;
+	ch->error() = 0;
+
+	bzero(rf, MAC_HDR_LEN);
+
+	rf->rf_fc.fc_protocol_version = MAC_ProtocolVersion;
+ 	rf->rf_fc.fc_type	= MAC_Type_Control;
+ 	rf->rf_fc.fc_subtype	= MAC_Subtype_RTS;
+	rf->rf_fc.fc_to_ds	= 0;
+	rf->rf_fc.fc_from_ds	= 0;
+ 	rf->rf_fc.fc_more_frag	= 0;
+ 	rf->rf_fc.fc_retry	= 0;
+ 	rf->rf_fc.fc_pwr_mgt	= 0;
+ 	rf->rf_fc.fc_more_data	= 0;
+ 	rf->rf_fc.fc_wep	= 0;
+ 	rf->rf_fc.fc_order	= 0;
+
+
+	//rf->rf_duration = RTS_DURATION(pktTx_);
+	STORE4BYTE(&dst, (rf->rf_ra));
+	
+	/* store rts tx time */
+ 	ch->txtime() = txtime(ch->size(), basicRate_);
+	
+	STORE4BYTE(&index_, (rf->rf_ta));
+
+	/* calculate rts duration field */	
+	rf->rf_duration = usec(phymib_.getSIFS()
+			       + txtime(phymib_.getCTSlen(), basicRate_)
+			       + phymib_.getSIFS()
+                               + txtime(pktTx_)
+			       + phymib_.getSIFS()
+			       + txtime(phymib_.getACKlen(), basicRate_));
+	pktRTS_ = p;
+}
+
+void
+Mac802_11::sendCTS(int dst, double rts_duration)
+{
+	Packet *p = Packet::alloc();
+	hdr_cmn* ch = HDR_CMN(p);
+	struct cts_frame *cf = (struct cts_frame*)p->access(hdr_mac::offset_);
+
+	assert(pktCTRL_ == 0);
+
+	ch->uid() = 0;
+	ch->ptype() = PT_MAC;
+	ch->size() = phymib_.getCTSlen();
+
+
+	ch->iface() = -2;
+	ch->error() = 0;
+	//ch->direction() = hdr_cmn::DOWN;
+	bzero(cf, MAC_HDR_LEN);
+
+	cf->cf_fc.fc_protocol_version = MAC_ProtocolVersion;
+	cf->cf_fc.fc_type	= MAC_Type_Control;
+	cf->cf_fc.fc_subtype	= MAC_Subtype_CTS;
+ 	cf->cf_fc.fc_to_ds	= 0;
+	cf->cf_fc.fc_from_ds	= 0;
+ 	cf->cf_fc.fc_more_frag	= 0;
+ 	cf->cf_fc.fc_retry	= 0;
+ 	cf->cf_fc.fc_pwr_mgt	= 0;
+ 	cf->cf_fc.fc_more_data	= 0;
+ 	cf->cf_fc.fc_wep	= 0;
+ 	cf->cf_fc.fc_order	= 0;
+
+		
+	//cf->cf_duration = CTS_DURATION(rts_duration);
+	STORE4BYTE(&dst, (cf->cf_ra));
+	
+	/* store cts tx time */
+	ch->txtime() = txtime(ch->size(), basicRate_);
+	
+	/* calculate cts duration */
+	cf->cf_duration = usec(sec(rts_duration)
+                              - phymib_.getSIFS()
+                              - txtime(phymib_.getCTSlen(), basicRate_));
+
+
+	
+	pktCTRL_ = p;
+	
+}
+
+void
+Mac802_11::sendACK(int dst)
+{
+	Packet *p = Packet::alloc();
+	hdr_cmn* ch = HDR_CMN(p);
+	struct ack_frame *af = (struct ack_frame*)p->access(hdr_mac::offset_);
+
+	assert(pktCTRL_ == 0);
+
+	ch->uid() = 0;
+	ch->ptype() = PT_MAC;
+	// CHANGE WRT Mike's code
+	ch->size() = phymib_.getACKlen();
+	ch->iface() = -2;
+	ch->error() = 0;
+	
+	bzero(af, MAC_HDR_LEN);
+
+	af->af_fc.fc_protocol_version = MAC_ProtocolVersion;
+ 	af->af_fc.fc_type	= MAC_Type_Control;
+ 	af->af_fc.fc_subtype	= MAC_Subtype_ACK;
+ 	af->af_fc.fc_to_ds	= 0;
+ 	af->af_fc.fc_from_ds	= 0;
+ 	af->af_fc.fc_more_frag	= 0;
+ 	af->af_fc.fc_retry	= 0;
+ 	af->af_fc.fc_pwr_mgt	= 0;
+ 	af->af_fc.fc_more_data	= 0;
+ 	af->af_fc.fc_wep	= 0;
+ 	af->af_fc.fc_order	= 0;
+
+	//af->af_duration = ACK_DURATION();
+	STORE4BYTE(&dst, (af->af_ra));
+
+	/* store ack tx time */
+ 	ch->txtime() = txtime(ch->size(), basicRate_);
+	
+	/* calculate ack duration */
+ 	af->af_duration = 0;	
+	
+	pktCTRL_ = p;
+}
+
+void
+Mac802_11::sendDATA(Packet *p)
+{
+	hdr_cmn* ch = HDR_CMN(p);
+	struct hdr_mac802_11* dh = HDR_MAC802_11(p);
+	u_int32_t dst = ETHER_ADDR(dh->dh_ra);
+	assert(pktTx_ == 0);
+
+	/*
+	 * Update the MAC header
+	 */
+	ch->size() += phymib_.getHdrLen11();
+
+	dh->dh_fc.fc_protocol_version = MAC_ProtocolVersion;
+	dh->dh_fc.fc_type       = MAC_Type_Data;
+	dh->dh_fc.fc_subtype    = MAC_Subtype_Data;
+	if ( bss_id_ != (int)IBSS_ID ) {
+		if ( index_ != ap_addr ) {
+		dh->dh_fc.fc_to_ds	= 1;
+		dh->dh_fc.fc_from_ds	= 0;
+		}
+	} else {
+		dh->dh_fc.fc_to_ds	= 0;
+		dh->dh_fc.fc_from_ds	= 0;
+	}	
+
+	dh->dh_fc.fc_more_frag  = 0;
+	dh->dh_fc.fc_retry      = 0;
+	dh->dh_fc.fc_pwr_mgt    = 0;
+	dh->dh_fc.fc_more_data  = 0;
+	dh->dh_fc.fc_wep        = 0;
+	dh->dh_fc.fc_order      = 0;
+
+	/* store data tx time */
+ 	ch->txtime() = txtime(ch->size(), dataRate_);
+
+	if(dst != MAC_BROADCAST) {
+		/* store data tx time for unicast packets */
+		ch->txtime() = txtime(ch->size(), dataRate_);
+		
+		dh->dh_duration = usec(txtime(phymib_.getACKlen(), basicRate_)
+				       + phymib_.getSIFS());
+
+
+
+	} else {
+		/* store data tx time for broadcast packets (see 9.6) */
+		ch->txtime() = txtime(ch->size(), basicRate_);
+		
+		dh->dh_duration = 0;
+	}
+	pktTx_ = p;
+}
+
+/* ======================================================================
+   Retransmission Routines
+   ====================================================================== */
+void
+Mac802_11::RetransmitRTS()
+{
+	assert(pktTx_);
+	assert(pktRTS_);
+	assert(mhBackoff_.busy() == 0);
+	macmib_.RTSFailureCount++;
+
+
+	ssrc_ += 1;			// STA Short Retry Count
+		
+	if(ssrc_ >= macmib_.getShortRetryLimit()) {
+		discard(pktRTS_, DROP_MAC_RETRY_COUNT_EXCEEDED); pktRTS_ = 0;
+		/* tell the callback the send operation failed 
+		   before discarding the packet */
+		hdr_cmn *ch = HDR_CMN(pktTx_);
+		if (ch->xmit_failure_) {
+                        /*
+                         *  Need to remove the MAC header so that 
+                         *  re-cycled packets don't keep getting
+                         *  bigger.
+                         */
+			ch->size() -= phymib_.getHdrLen11();
+                        ch->xmit_reason_ = XMIT_REASON_RTS;
+                        ch->xmit_failure_(pktTx_->copy(),
+                                          ch->xmit_failure_data_);
+                }
+		discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED); 
+		pktTx_ = 0;
+		ssrc_ = 0;
+		rst_cw();
+	} else {
+		struct rts_frame *rf;
+		rf = (struct rts_frame*)pktRTS_->access(hdr_mac::offset_);
+		rf->rf_fc.fc_retry = 1;
+
+		inc_cw();
+		mhBackoff_.start(cw_, is_idle());
+	}
+}
+
+void
+Mac802_11::RetransmitDATA()
+{
+	struct hdr_cmn *ch;
+	struct hdr_mac802_11 *mh;
+	u_int32_t *rcount, thresh;
+	assert(mhBackoff_.busy() == 0);
+
+	assert(pktTx_);
+	assert(pktRTS_ == 0);
+
+	ch = HDR_CMN(pktTx_);
+	mh = HDR_MAC802_11(pktTx_);
+
+	/*
+	 *  Broadcast packets don't get ACKed and therefore
+	 *  are never retransmitted.
+	 */
+	if((u_int32_t)ETHER_ADDR(mh->dh_ra) == MAC_BROADCAST) {
+		Packet::free(pktTx_); 
+		pktTx_ = 0;
+
+		/*
+		 * Backoff at end of TX.
+		 */
+		rst_cw();
+		mhBackoff_.start(cw_, is_idle());
+
+		return;
+	}
+
+	macmib_.ACKFailureCount++;
+
+	if((u_int32_t) ch->size() <= macmib_.getRTSThreshold()) {
+                rcount = &ssrc_;
+               thresh = macmib_.getShortRetryLimit();
+        } else {
+                rcount = &slrc_;
+               thresh = macmib_.getLongRetryLimit();
+        }
+
+	(*rcount)++;
+
+// Bug reported by Mayur - Handoff triggered in Ad-hoc mode too. Bug resolved by checking if it is infrastructure mode before handoff trigger.
+
+	if (bss_id_ != (int)IBSS_ID && *rcount == 3 && handoff == 0) {
+		//start handoff process
+		printf("Client %d: Handoff Attempted\n",index_);
+		associated = 0;
+		authenticated = 0;
+		handoff = 1;
+		ScanType_ = ACTIVE;
+		sendPROBEREQ(MAC_BROADCAST);
+		return;
+	}	
+	if(*rcount >= thresh) {
+		/* IEEE Spec section 9.2.3.5 says this should be greater than
+		   or equal */
+		macmib_.FailedCount++;
+		/* tell the callback the send operation failed 
+		   before discarding the packet */
+		hdr_cmn *ch = HDR_CMN(pktTx_);
+		if (ch->xmit_failure_) {
+                        ch->size() -= phymib_.getHdrLen11();
+			ch->xmit_reason_ = XMIT_REASON_ACK;
+                        ch->xmit_failure_(pktTx_->copy(),
+                                          ch->xmit_failure_data_);
+                }
+
+		discard(pktTx_, DROP_MAC_RETRY_COUNT_EXCEEDED); 
+		pktTx_ = 0;
+		*rcount = 0;
+		rst_cw();
+	}
+	else {
+		struct hdr_mac802_11 *dh;
+		dh = HDR_MAC802_11(pktTx_);
+		dh->dh_fc.fc_retry = 1;
+
+
+		sendRTS(ETHER_ADDR(mh->dh_ra));
+		inc_cw();
+		mhBackoff_.start(cw_, is_idle());
+	}
+}
+
+void
+Mac802_11::RetransmitPROBEREP()
+{
+double rTime;
+
+	if(mhBackoff_.busy() == 0) {
+		if(is_idle()) {
+			if (mhDefer_.busy() == 0) {
+				/*
+				 * If we are already deferring, there is no
+				 * need to reset the Defer timer.
+				 */
+				if (bugFix_timer_) {
+				 	mhBackoff_.start(cw_, is_idle(), 
+							  phymib_.getDIFS());
+				}
+				else {
+					rTime = (Random::random() % cw_)
+						* (phymib_.getSlotTime());
+					mhDefer_.start(phymib_.getDIFS() + 
+						       rTime);
+				}
+			}
+		} else {
+			/*
+			 * If the medium is NOT IDLE, then we start
+			 * the backoff timer.
+			 */
+			mhBackoff_.start(cw_, is_idle());
+
+			
+		}
+		
+	} 
+
+}
+
+void
+Mac802_11::RetransmitAUTHENTICATE()
+{
+double rTime;
+
+	if(mhBackoff_.busy() == 0) {
+		if(is_idle()) {
+			if (mhDefer_.busy() == 0) {
+				/*
+				 * If we are already deferring, there is no
+				 * need to reset the Defer timer.
+				 */
+				if (bugFix_timer_) {
+				 	mhBackoff_.start(cw_, is_idle(), 
+							  phymib_.getDIFS());
+				}
+				else {
+					rTime = (Random::random() % cw_)
+						* (phymib_.getSlotTime());
+					mhDefer_.start(phymib_.getDIFS() + 
+						       rTime);
+				}
+			}
+		} else {
+			/*
+			 * If the medium is NOT IDLE, then we start
+			 * the backoff timer.
+			 */
+			mhBackoff_.start(cw_, is_idle());
+			
+			
+		}
+		
+	} 
+
+}
+
+void
+Mac802_11::RetransmitASSOCREP()
+{
+double rTime;
+
+	if(mhBackoff_.busy() == 0) {
+		if(is_idle()) {
+			if (mhDefer_.busy() == 0) {
+				/*
+				 * If we are already deferring, there is no
+				 * need to reset the Defer timer.
+				 */
+				if (bugFix_timer_) {
+				 	mhBackoff_.start(cw_, is_idle(), 
+							  phymib_.getDIFS());
+					
+				}
+				else {
+					rTime = (Random::random() % cw_)
+						* (phymib_.getSlotTime());
+					mhDefer_.start(phymib_.getDIFS() + 
+						       rTime);
+				}
+			}
+		} else {
+			/*
+			 * If the medium is NOT IDLE, then we start
+			 * the backoff timer.
+			 */
+			mhBackoff_.start(cw_, is_idle());
+			
+		}
+		
+	} 
+
+}
+/* ======================================================================
+   Incoming Packet Routines
+   ====================================================================== */
+void
+Mac802_11::send(Packet *p, Handler *h)
+{
+	double rTime;
+	struct hdr_mac802_11* dh = HDR_MAC802_11(p);
+
+	EnergyModel *em = netif_->node()->energy_model();
+	if (em && em->sleep()) {
+		em->set_node_sleep(0);
+		em->set_node_state(EnergyModel::INROUTE);
+	}
+	
+	callback_ = h;
+	sendDATA(p);
+	sendRTS(ETHER_ADDR(dh->dh_ra));
+
+	/*
+	 * Assign the data packet a sequence number.
+	 */
+	dh->dh_scontrol = sta_seqno_++;
+
+	/*
+	 *  If the medium is IDLE, we must wait for a DIFS
+	 *  Space before transmitting.
+	 */
+       
+	if(mhBackoff_.busy() == 0) {
+		if(is_idle()) {
+			if (mhDefer_.busy() == 0) {
+				/*
+				 * If we are already deferring, there is no
+				 * need to reset the Defer timer.
+				 */
+				if (bugFix_timer_) {
+					 mhBackoff_.start(cw_, is_idle(), 
+							  phymib_.getDIFS());
+				}
+				else {
+					rTime = (Random::random() % cw_)
+						* (phymib_.getSlotTime());
+					mhDefer_.start(phymib_.getDIFS() + 
+						       rTime);
+				}
+			} 
+		} else {
+			/*
+			 * If the medium is NOT IDLE, then we start
+			 * the backoff timer.
+			 */
+			mhBackoff_.start(cw_, is_idle());
+		}
+	}
+	
+}
+
+void
+Mac802_11::recv(Packet *p, Handler *h)
+{
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	/*
+	 * Sanity Check
+	 */
+	assert(initialized());
+
+	/*
+	 *  Handle outgoing packets.
+	 */
+	if(hdr->direction() == hdr_cmn::DOWN) {
+                send(p, h);
+                return;
+        }
+	/*
+	 *  Handle incoming packets.
+	 *
+	 *  We just received the 1st bit of a packet on the network
+	 *  interface.
+	 *
+	 */
+
+	/*
+	 *  If the interface is currently in transmit mode, then
+	 *  it probably won't even see this packet.  However, the
+	 *  "air" around me is BUSY so I need to let the packet
+	 *  proceed.  Just set the error flag in the common header
+	 *  to that the packet gets thrown away.
+	 */
+	if(tx_active_ && hdr->error() == 0) {
+		hdr->error() = 1;
+	}
+
+	if(rx_state_ == MAC_IDLE) {
+		setRxState(MAC_RECV);
+		pktRx_ = p;
+		/*
+		 * Schedule the reception of this packet, in
+		 * txtime seconds.
+		 */
+		if (mhProbe_.busy() && OnMinChannelTime) {
+			Recv_Busy_ = 1;  // Receiver busy indication for Probe Timer 
+		}
+			
+			
+		mhRecv_.start(txtime(p));
+	} else {
+		/*
+		 *  If the power of the incoming packet is smaller than the
+		 *  power of the packet currently being received by at least
+                 *  the capture threshold, then we ignore the new packet.
+		 */
+		if(pktRx_->txinfo_.RxPr / p->txinfo_.RxPr >= p->txinfo_.CPThresh) {
+			capture(p);
+		} else {
+			collision(p);
+		}
+	}
+}
+
+void
+Mac802_11::recv_timer()
+{
+	u_int32_t src; 
+	hdr_cmn *ch = HDR_CMN(pktRx_);
+	hdr_mac802_11 *mh = HDR_MAC802_11(pktRx_);
+	u_int32_t dst = ETHER_ADDR(mh->dh_ra);
+	u_int32_t ap_dst = ETHER_ADDR(mh->dh_3a);
+	u_int8_t  type = mh->dh_fc.fc_type;
+	u_int8_t  subtype = mh->dh_fc.fc_subtype;
+
+	assert(pktRx_);
+	assert(rx_state_ == MAC_RECV || rx_state_ == MAC_COLL);
+	
+	
+        /*
+         *  If the interface is in TRANSMIT mode when this packet
+         *  "arrives", then I would never have seen it and should
+         *  do a silent discard without adjusting the NAV.
+         */
+        if(tx_active_) {
+                Packet::free(pktRx_);
+                goto done;
+        }
+
+	/*
+	 * Handle collisions.
+	 */
+	if(rx_state_ == MAC_COLL) {
+		discard(pktRx_, DROP_MAC_COLLISION);		
+		set_nav(usec(phymib_.getEIFS()));
+		goto done;
+	}
+
+	/*
+	 * Check to see if this packet was received with enough
+	 * bit errors that the current level of FEC still could not
+	 * fix all of the problems - ie; after FEC, the checksum still
+	 * failed.
+	 */
+	if( ch->error() ) {
+		Packet::free(pktRx_);
+		set_nav(usec(phymib_.getEIFS()));
+		goto done;
+	}
+
+	/*
+	 * IEEE 802.11 specs, section 9.2.5.6
+	 *	- update the NAV (Network Allocation Vector)
+	 */
+	if(dst != (u_int32_t)index_) {
+		set_nav(mh->dh_duration);
+	}
+
+        /* tap out - */
+        if (tap_ && type == MAC_Type_Data &&
+            MAC_Subtype_Data == subtype ) 
+		tap_->tap(pktRx_);
+	/*
+	 * Adaptive Fidelity Algorithm Support - neighborhood infomation 
+	 * collection
+	 *
+	 * Hacking: Before filter the packet, log the neighbor node
+	 * I can hear the packet, the src is my neighbor
+	 */
+	if (netif_->node()->energy_model() && 
+	    netif_->node()->energy_model()->adaptivefidelity()) {
+		src = ETHER_ADDR(mh->dh_ta);
+		netif_->node()->energy_model()->add_neighbor(src);
+	}
+	/*
+	 * Address Filtering
+	 */
+	if(dst != (u_int32_t)index_ && dst != MAC_BROADCAST) {
+		/*
+		 *  We don't want to log this event, so we just free
+		 *  the packet instead of calling the drop routine.
+		 */
+		discard(pktRx_, "---");
+		goto done;
+	}
+	
+	
+	if ( dst == MAC_BROADCAST && mh->dh_fc.fc_to_ds == 1 && mh->dh_fc.fc_from_ds == 1) {
+		if (addr() != bss_id_) {
+ 			discard(pktRx_, "---");
+ 			goto done;
+		}
+		if (addr() == bss_id_ && find_client(ap_dst) == 0) {
+			discard(pktRx_, "---");
+ 			goto done;
+		}
+ 	}
+	
+	
+	if ( addr() == bss_id_ && subtype == MAC_Subtype_80211_Beacon) {
+		discard(pktRx_, "---");
+ 			goto done;
+	}
+
+	
+	if ( addr() == bss_id_ && subtype == MAC_Subtype_80211_Beacon) {
+		discard(pktRx_, "---");
+ 			goto done;
+	}
+
+
+
+	if ( addr() != bss_id_ && subtype == MAC_Subtype_ProbeReq) {
+		discard(pktRx_, "---");
+ 			goto done;
+	}
+
+	switch(type) {
+
+	case MAC_Type_Management:
+		switch(subtype) {
+		case MAC_Subtype_80211_Beacon:
+			recvBEACON(pktRx_);
+			break;
+		case MAC_Subtype_Auth:
+			recvAUTHENTICATE(pktRx_);
+			break;
+		case MAC_Subtype_AssocReq:
+			recvASSOCREQ(pktRx_);
+			break;
+		case MAC_Subtype_AssocRep:
+			recvASSOCREP(pktRx_);
+			break;
+		case MAC_Subtype_ProbeReq:
+			recvPROBEREQ(pktRx_);
+			break;
+		case MAC_Subtype_ProbeRep:
+			recvPROBEREP(pktRx_);
+			break;
+		default:
+			fprintf(stderr,"recvTimer1:Invalid MAC Management Subtype %x\n",
+				subtype);
+			exit(1);
+		}
+		break;
+	case MAC_Type_Control:
+		switch(subtype) {
+		case MAC_Subtype_RTS:
+			recvRTS(pktRx_);
+			break;
+		case MAC_Subtype_CTS:
+			recvCTS(pktRx_);
+			break;
+		case MAC_Subtype_ACK:
+			recvACK(pktRx_);
+			break;
+		default:
+			fprintf(stderr,"recvTimer2:Invalid MAC Control Subtype %x\n",
+				subtype);
+			exit(1);
+		}
+		break;
+	case MAC_Type_Data:
+		switch(subtype) {
+		case MAC_Subtype_Data:
+			recvDATA(pktRx_);
+			break;
+		default:
+			fprintf(stderr, "recv_timer3:Invalid MAC Data Subtype %x\n",
+				subtype);
+			exit(1);
+		}
+		break;
+	default:
+		fprintf(stderr, "recv_timer4:Invalid MAC Type %x\n", subtype);
+		exit(1);
+	}
+ done:
+	pktRx_ = 0;
+	rx_resume();
+
+}
+
+
+void
+Mac802_11::recvRTS(Packet *p)
+{
+	struct rts_frame *rf = (struct rts_frame*)p->access(hdr_mac::offset_);
+
+	if(tx_state_ != MAC_IDLE) {
+		discard(p, DROP_MAC_BUSY);
+		return;
+	}
+
+	/*
+	 *  If I'm responding to someone else, discard this RTS.
+	 */
+	if(pktCTRL_) {
+		discard(p, DROP_MAC_BUSY);
+		return;
+	}
+
+	sendCTS(ETHER_ADDR(rf->rf_ta), rf->rf_duration);
+
+	/*
+	 *  Stop deferring - will be reset in tx_resume().
+	 */
+	if(mhDefer_.busy()) mhDefer_.stop();
+
+	tx_resume();
+
+	mac_log(p);
+}
+
+/*
+ * txtime()	- pluck the precomputed tx time from the packet header
+ */
+double
+Mac802_11::txtime(Packet *p)
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	double t = ch->txtime();
+	if (t < 0.0) {
+		drop(p, "XXX");
+ 		exit(1);
+	}
+	return t;
+}
+
+ 
+/*
+ * txtime()	- calculate tx time for packet of size "psz" bytes 
+ *		  at rate "drt" bps
+ */
+double
+Mac802_11::txtime(double psz, double drt)
+{
+	double dsz = psz - phymib_.getPLCPhdrLen();
+        int plcp_hdr = phymib_.getPLCPhdrLen() << 3;	
+	int datalen = (int)dsz << 3;
+	double t = (((double)plcp_hdr)/phymib_.getPLCPDataRate())
+                                       + (((double)datalen)/drt);
+	return(t);
+}
+
+
+
+void
+Mac802_11::recvCTS(Packet *p)
+{
+	if(tx_state_ != MAC_RTS) {
+		discard(p, DROP_MAC_INVALID_STATE);
+		return;
+	}
+
+	assert(pktRTS_);
+	Packet::free(pktRTS_); pktRTS_ = 0;
+
+	assert(pktTx_);	
+	mhSend_.stop();
+
+	/*
+	 * The successful reception of this CTS packet implies
+	 * that our RTS was successful. 
+	 * According to the IEEE spec 9.2.5.3, you must 
+	 * reset the ssrc_, but not the congestion window.
+	 */
+	ssrc_ = 0;
+	tx_resume();
+
+	mac_log(p);
+}
+
+void
+Mac802_11::recvDATA(Packet *p)
+{
+	struct hdr_mac802_11 *dh = HDR_MAC802_11(p);
+	u_int32_t dst, src, size;
+	struct hdr_cmn *ch = HDR_CMN(p);
+
+	dst = ETHER_ADDR(dh->dh_ra);
+	src = ETHER_ADDR(dh->dh_ta);
+	size = ch->size();
+	/*
+	 * Adjust the MAC packet size - ie; strip
+	 * off the mac header
+	 */
+	ch->size() -= phymib_.getHdrLen11();
+	ch->num_forwards() += 1;
+
+	/*
+	 *  If we sent a CTS, clean up...
+	 */
+	if(dst != MAC_BROADCAST) {
+		if(size >= macmib_.getRTSThreshold()) {
+			if (tx_state_ == MAC_CTS) {
+				assert(pktCTRL_);
+				Packet::free(pktCTRL_); pktCTRL_ = 0;
+				mhSend_.stop();
+				/*
+				 * Our CTS got through.
+				 */
+			} else {
+				discard(p, DROP_MAC_BUSY);
+				return;
+			}
+			sendACK(src);
+			tx_resume();
+		} else {
+			/*
+			 *  We did not send a CTS and there's no
+			 *  room to buffer an ACK.
+			 */
+			if(pktCTRL_) {
+				discard(p, DROP_MAC_BUSY);
+				return;
+			}
+			sendACK(src);
+			if(mhSend_.busy() == 0)
+				tx_resume();
+		}
+	}
+	
+	/* ============================================================
+	   Make/update an entry in our sequence number cache.
+	   ============================================================ */
+
+	/* Changed by Debojyoti Dutta. This upper loop of if{}else was 
+	   suggested by Joerg Diederich <dieder@ibr.cs.tu-bs.de>. 
+	   Changed on 19th Oct'2000 */
+
+        if(dst != MAC_BROADCAST) {
+                if (src < (u_int32_t) cache_node_count_) {
+                        Host *h = &cache_[src];
+
+                        if(h->seqno && h->seqno == dh->dh_scontrol) {
+                                discard(p, DROP_MAC_DUPLICATE);
+                                return;
+                        }
+                        h->seqno = dh->dh_scontrol;
+                } else {
+			static int count = 0;
+			if (++count <= 10) {
+				printf ("MAC_802_11: accessing MAC cache_ array out of range (src %u, dst %u, size %d)!\n", src, dst, cache_node_count_);
+				if (count == 10)
+					printf ("[suppressing additional MAC cache_ warnings]\n");
+			};
+		};
+	}
+
+	/*
+	 *  Pass the packet up to the link-layer.
+	 *  XXX - we could schedule an event to account
+	 *  for this processing delay.
+	 */
+	
+	/* in BSS mode, if a station receives a packet via
+	 * the AP, and higher layers are interested in looking
+	 * at the src address, we might need to put it at
+	 * the right place - lest the higher layers end up
+	 * believing the AP address to be the src addr! a quick
+	 * grep didn't turn up any higher layers interested in
+	 * the src addr though!
+	 * anyway, here if I'm the AP and the destination
+	 * address (in dh_3a) isn't me, then we have to fwd
+	 * the packet; we pick the real destination and set
+	 * set it up for the LL; we save the real src into
+	 * the dh_3a field for the 'interested in the info'
+	 * receiver; we finally push the packet towards the
+	 * LL to be added back to my queue - accomplish this
+	 * by reversing the direction!*/
+	
+
+
+		
+	if ((bss_id() == addr()) && ((u_int32_t)ETHER_ADDR(dh->dh_ra)!= MAC_BROADCAST) && ((u_int32_t)ETHER_ADDR(dh->dh_3a) != ((u_int32_t)addr())) && dh->dh_fc.fc_from_ds == 0) {
+		struct hdr_cmn *ch = HDR_CMN(p);
+	
+				
+		u_int32_t dst = ETHER_ADDR(dh->dh_3a);
+		u_int32_t src = ETHER_ADDR(dh->dh_ta);
+		/* if it is a broadcast pkt then send a copy up
+		 * my stack also
+		 */
+		
+		if (dst == MAC_BROADCAST) {
+			uptarget_->recv(p->copy(), (Handler*) 0);
+		}
+
+		ch->next_hop() = dst;
+
+		if (find_client(dst) == 1 || dst == MAC_BROADCAST) {
+			STORE4BYTE(&src, (dh->dh_3a));
+		} else {
+			STORE4BYTE(&src, (dh->dh_4a));	
+		}
+
+		ch->addr_type() = NS_AF_ILINK;
+		ch->direction() = hdr_cmn::DOWN;
+		
+	}
+
+ 	if ((bss_id() == addr()) && dh->dh_fc.fc_to_ds == 1 && dh->dh_fc.fc_from_ds == 1) {
+ 		u_int32_t dst = ETHER_ADDR(dh->dh_3a);
+ 		u_int32_t src = ETHER_ADDR(dh->dh_4a);
+		/*if (find_client(src)) { 
+			update_client_table(src,0,0);   // If the source is from another BSS and it is found in this AP's table, delete the node from the table
+		}*/	
+
+ 		ch->next_hop() = dst;
+ 		STORE4BYTE(&src, (dh->dh_3a));
+
+ 		ch->addr_type() = NS_AF_ILINK;
+ 		ch->direction() = hdr_cmn::DOWN;
+ 	}
+
+	uptarget_->recv(p, (Handler*) 0);
+	
+}
+
+
+void
+Mac802_11::recvACK(Packet *p)
+{	
+	if (tx_state_ == MAC_MGMT) {
+		mhSend_.stop();
+		if (addr() == bss_id_) {
+			if (pktASSOCREP_ && tx_mgmt_ == 4) {
+				Packet::free(pktASSOCREP_);
+				pktASSOCREP_ = 0;
+				update_client_table(associating_node_,1,1);
+			} 
+			if (pktPROBEREP_ && tx_mgmt_ == 1) {
+				Packet::free(pktPROBEREP_);
+				pktPROBEREP_ = 0;
+			}
+			if (pktAUTHENTICATE_ && tx_mgmt_ == 3) {
+				Packet::free(pktAUTHENTICATE_);
+				pktAUTHENTICATE_ = 0;
+				update_client_table(authenticating_node_,1,0);
+			}
+			shift_priority_queue();
+			assert(mhBackoff_.busy() == 0);
+			mhBackoff_.start(cw_, is_idle());
+		}
+		goto done;
+	}
+	if(tx_state_ != MAC_SEND) {
+		discard(p, DROP_MAC_INVALID_STATE);
+		return;
+	}
+	assert(pktTx_);
+
+	mhSend_.stop();
+
+	/*
+	 * The successful reception of this ACK packet implies
+	 * that our DATA transmission was successful.  Hence,
+	 * we can reset the Short/Long Retry Count and the CW.
+	 *
+	 * need to check the size of the packet we sent that's being
+	 * ACK'd, not the size of the ACK packet.
+	 */
+	if((u_int32_t) HDR_CMN(pktTx_)->size() <= macmib_.getRTSThreshold())
+		ssrc_ = 0;
+	else
+		slrc_ = 0;
+	rst_cw();
+	Packet::free(pktTx_); 
+	pktTx_ = 0;
+	
+	/*
+	 * Backoff before sending again.
+// 	 */
+
+	assert(mhBackoff_.busy() == 0);
+	mhBackoff_.start(cw_, is_idle());
+done:
+
+	tx_resume();
+
+	mac_log(p);
+}
+
+
+/* AP's association table funtions
+*/
+void Mac802_11::update_client_table(int num, int auth_status, int assoc_status) {
+
+	std::list<client_table>::iterator it;
+	for (it=client_list1.begin(); it != client_list1.end(); it++) {
+		if ((*it).client_id == num) {
+			(*it).auth_status = auth_status;
+			(*it).assoc_status = assoc_status;
+			break;
+		}
+;
+	}
+	
+	if (it == client_list1.end()) {
+		client_list = (struct client_table*)malloc(sizeof(struct client_table));
+		client_list->client_id=num;
+		client_list->auth_status=auth_status;
+		client_list->assoc_status=assoc_status;
+		
+		client_list1.push_front(*client_list);
+
+		free(client_list);
+
+	}
+
+//	printf("Client List for AP %d at %f\n",index_,NOW);
+
+
+
+//	for (it=client_list1.begin(); it != client_list1.end(); it++) {
+//		printf("Client %d: Authenticated = %d Associated = %d at %f\n", (*it).client_id,(*it).auth_status,(*it).assoc_status,NOW);
+//		temp=temp->next;
+//	}
+//	printf("\n");
+	
+}
+
+
+int Mac802_11::find_client(int num) {
+	std::list<client_table>::iterator it;
+
+	for (it=client_list1.begin(); it != client_list1.end(); it++) {
+		if ((*it).client_id == num) {
+			return 1;
+		}
+
+	}
+
+	return 0;
+}
+
+
+/* Beacon send and Receive functions
+*/
+void
+Mac802_11::sendBEACON(int src)
+{
+	Packet *p = Packet::alloc();
+	
+	hdr_cmn* ch = HDR_CMN(p);
+	struct beacon_frame *bf = (struct beacon_frame*)p->access(hdr_mac::offset_);
+	double rTime;
+	pktBEACON_ = 0;
+
+	ch->uid() = 0;
+	
+
+	ch->ptype() = PT_MAC;
+	ch->size() = phymib_.getBEACONlen();
+	ch->iface() = -2;
+	ch->error() = 0;
+	
+	bzero(bf, MAC_HDR_LEN);
+
+/* Note: I had to give a different name for MAC_Subtype_80211_Beacon as MAC_Subtype_80211_Beacon as MAC_Subtype_80211_Beacon is already defined for 802.15.4 with a different value!! (See cmu-trace.cc).
+*/
+
+	bf->bf_fc.fc_protocol_version = MAC_ProtocolVersion;
+ 	bf->bf_fc.fc_type	= MAC_Type_Management;
+ 	bf->bf_fc.fc_subtype	= MAC_Subtype_80211_Beacon;
+ 	bf->bf_fc.fc_to_ds	= 0;
+ 	bf->bf_fc.fc_from_ds	= 0;
+ 	bf->bf_fc.fc_more_frag	= 0;
+ 	bf->bf_fc.fc_retry	= 0;
+ 	bf->bf_fc.fc_pwr_mgt	= 0;
+ 	bf->bf_fc.fc_more_data	= 0;
+ 	bf->bf_fc.fc_wep	= 0;
+ 	bf->bf_fc.fc_order	= 0;
+
+	int  dst = MAC_BROADCAST;
+	STORE4BYTE(&dst, (bf->bf_ra));
+	STORE4BYTE(&src, (bf->bf_ta));
+	STORE4BYTE(&ap_addr, (bf->bf_3a));
+	
+	bf->bf_timestamp = Scheduler::instance().clock();
+	bf->bf_bcninterval = phymib_.getBeaconInterval();
+
+	/* store beacon tx time */
+
+ 	ch->txtime() = txtime(ch->size(), basicRate_);
+	
+	/* calculate beacon duration??? */
+ 	bf->bf_duration = 0;
+	
+	pktBEACON_ = p;
+	
+	BeaconTxtime_ = txtime(phymib_.getBEACONlen(), basicRate_);
+
+	add_priority_queue(2);
+	
+	if(mhBackoff_.busy() == 0) {
+		if(is_idle()) {
+			if (mhDefer_.busy() == 0) {
+				
+				if (bugFix_timer_) {
+				 	mhBackoff_.start(cw_, is_idle(), 
+							  phymib_.getDIFS());
+				}
+				else {
+					rTime = (Random::random() % cw_)
+						* (phymib_.getSlotTime());
+					mhDefer_.start(phymib_.getDIFS() + 
+						       rTime);
+				}
+			}
+		} else {
+			/*
+			 * If the medium is NOT IDLE, then we start
+			 * the backoff timer.
+			 */
+			
+			mhBackoff_.start(cw_, is_idle());
+
+		}
+	} 		
+
+}
+
+int
+Mac802_11::check_pktBEACON()
+{	
+	struct beacon_frame *bf = (struct beacon_frame*)pktBEACON_->access(hdr_mac::offset_);
+	bf->bf_timestamp = Scheduler::instance().clock();
+	
+	struct hdr_mac802_11 *mh;
+	double timeout;
+
+	assert(mhBackoff_.busy() == 0);
+
+	if(pktBEACON_ == 0)
+ 		return -1;
+	mh = HDR_MAC802_11(pktBEACON_);
+
+ 	switch(mh->dh_fc.fc_subtype) {
+	case MAC_Subtype_80211_Beacon:
+		if(! is_idle()) {
+			inc_cw();
+			mhBackoff_.start(cw_, is_idle());
+			return 0;
+		}
+		setTxState(MAC_BCN);
+		timeout = txtime(phymib_.getBEACONlen(), basicRate_);
+		break;
+	default:
+		fprintf(stderr, "check_pktBEACON:Invalid MAC Control subtype\n");
+		exit(1);
+	}
+	transmit(pktBEACON_, timeout);
+
+	return 0;
+}
+ 
+
+void
+Mac802_11::recvBEACON(Packet *p)
+{
+	struct beacon_frame *bf = (struct beacon_frame*)p->access(hdr_mac::offset_);
+
+	if(tx_state_ != MAC_IDLE) {
+		discard(p, DROP_MAC_BUSY);
+		return;
+	}
+	u_int32_t bss_id, src;
+
+	bss_id = ETHER_ADDR(bf->bf_3a);
+ 	src = ETHER_ADDR(bf->bf_ta);
+	infra_mode_ = 1;
+
+	Pr = p->txinfo_.RxPr;
+	if ( addr() != ap_addr && ScanType_ == PASSIVE) {
+		if (authenticated == 0 && associated == 0) {
+			if (find_ap(src,Pr) != 1) {
+				update_ap_table(src,Pr);
+			}
+ 		}
+	}
+
+	mac_log(p);
+}
+
+void
+Mac802_11::passive_scan()
+{
+	if ( addr() != ap_addr && ScanType_ == PASSIVE) {
+		if (authenticated == 0 && associated == 0) {
+			ap_temp = strongest_ap();
+			if (!pktAUTHENTICATE_)
+				sendAUTHENTICATE(ap_temp);						
+		}
+			
+	}
+}
+void
+Mac802_11::active_scan()
+{
+	
+	if ( addr() != ap_addr && ScanType_ == ACTIVE) {
+		if (authenticated == 0 && associated == 0) {
+			ap_temp = strongest_ap();
+			sendAUTHENTICATE(ap_temp);						
+		}
+			
+	}
+}
+
+
+// Association functions
+
+void
+Mac802_11::sendASSOCREQ(int dst)
+{
+	Packet *p = Packet::alloc();
+	hdr_cmn* ch = HDR_CMN(p);
+	struct assocreq_frame *acrqf =(struct assocreq_frame*)p->access(hdr_mac::offset_);
+	
+	double rTime;
+	pktASSOCREQ_ = 0;
+
+	ch->uid() = 0;
+	
+
+	ch->ptype() = PT_MAC;
+	ch->size() = phymib_.getASSOCREQlen();
+	ch->iface() = -2;
+	ch->error() = 0;
+	
+	bzero(acrqf, MAC_HDR_LEN);
+
+	acrqf->acrqf_fc.fc_protocol_version = MAC_ProtocolVersion;
+ 	acrqf->acrqf_fc.fc_type	= MAC_Type_Management;
+ 	acrqf->acrqf_fc.fc_subtype	= MAC_Subtype_AssocReq;
+ 	acrqf->acrqf_fc.fc_to_ds	= 0;
+ 	acrqf->acrqf_fc.fc_from_ds	= 0;
+ 	acrqf->acrqf_fc.fc_more_frag= 0;
+ 	acrqf->acrqf_fc.fc_retry	= 0;
+ 	acrqf->acrqf_fc.fc_pwr_mgt	= 0;
+ 	acrqf->acrqf_fc.fc_more_data= 0;
+ 	acrqf->acrqf_fc.fc_wep	= 0;
+ 	acrqf->acrqf_fc.fc_order	= 0;
+	
+	STORE4BYTE(&dst, (acrqf->acrqf_ra));
+	STORE4BYTE(&index_, (acrqf->acrqf_ta));
+	STORE4BYTE(&dst, (acrqf->acrqf_3a));
+
+	
+	ch->txtime() = txtime(ch->size(), basicRate_);
+ 	acrqf->acrqf_duration = 0;
+
+	
+	pktASSOCREQ_ = p;
+
+	if(mhBackoff_.busy() == 0) {
+		if(is_idle()) {
+			if (mhDefer_.busy() == 0) {
+				/*
+				 * If we are already deferring, there is no
+				 * need to reset the Defer timer.
+				 */
+				if (bugFix_timer_) {
+				 	mhBackoff_.start(cw_, is_idle(), 
+							  phymib_.getDIFS());
+				}
+				else {
+					rTime = (Random::random() % cw_)
+						* (phymib_.getSlotTime());
+					mhDefer_.start(phymib_.getDIFS() + 
+						       rTime);
+				}
+			}
+		} else {
+			/*
+			 * If the medium is NOT IDLE, then we start
+			 * the backoff timer.
+			 */
+			mhBackoff_.start(cw_, is_idle());	
+		}
+	}
+}
+
+int
+Mac802_11::check_pktASSOCREQ()
+{	
+	struct hdr_mac802_11 *mh;
+	double timeout;
+
+	assert(mhBackoff_.busy() == 0);
+
+	if(pktASSOCREQ_ == 0)
+ 		return -1;
+	mh = HDR_MAC802_11(pktASSOCREQ_);
+
+ 	switch(mh->dh_fc.fc_subtype) {
+	case MAC_Subtype_AssocReq:
+		if(! is_idle()) {
+			inc_cw();
+			mhBackoff_.start(cw_, is_idle());
+			return 0;
+		}
+		setTxState(MAC_MGMT);
+		timeout = txtime(phymib_.getASSOCREQlen(), basicRate_)
+			+ DSSS_MaxPropagationDelay
+			+ macmib_.getMaxChannelTime()
+			+ txtime(phymib_.getASSOCREPlen(), basicRate_)
+			+ DSSS_MaxPropagationDelay;
+		break;
+	default:
+		fprintf(stderr, "check_pktASSOCREQ:Invalid MAC Control subtype\n");
+		exit(1);
+	}
+	transmit(pktASSOCREQ_, timeout);
+  
+
+	return 0;
+}
+
+void
+Mac802_11::sendASSOCREP(int dst)
+{
+	Packet *p = Packet::alloc();
+	hdr_cmn* ch = HDR_CMN(p);
+	struct assocrep_frame *acrpf =(struct assocrep_frame*)p->access(hdr_mac::offset_);
+	double rTime;
+	pktASSOCREP_ = 0;
+
+	ch->uid() = 0;
+	
+
+	ch->ptype() = PT_MAC;
+	ch->size() = phymib_.getASSOCREPlen();
+	ch->iface() = -2;
+	ch->error() = 0;
+	
+	bzero(acrpf, MAC_HDR_LEN);
+
+	acrpf->acrpf_fc.fc_protocol_version = MAC_ProtocolVersion;
+ 	acrpf->acrpf_fc.fc_type	= MAC_Type_Management;
+ 	acrpf->acrpf_fc.fc_subtype	= MAC_Subtype_AssocRep;
+ 	acrpf->acrpf_fc.fc_to_ds	= 0;
+ 	acrpf->acrpf_fc.fc_from_ds	= 0;
+ 	acrpf->acrpf_fc.fc_more_frag= 0;
+ 	acrpf->acrpf_fc.fc_retry	= 0;
+ 	acrpf->acrpf_fc.fc_pwr_mgt	= 0;
+ 	acrpf->acrpf_fc.fc_more_data= 0;
+ 	acrpf->acrpf_fc.fc_wep	= 0;
+ 	acrpf->acrpf_fc.fc_order	= 0;
+	
+	STORE4BYTE(&dst, (acrpf->acrpf_ra));
+	STORE4BYTE(&index_, (acrpf->acrpf_ta));
+	STORE4BYTE(&index_, (acrpf->acrpf_3a));
+
+	acrpf->acrpf_statuscode = 0;
+	ch->txtime() = txtime(ch->size(), basicRate_);
+ 	acrpf->acrpf_duration = 0;
+	
+	
+ 	pktASSOCREP_ = p;
+
+
+	add_priority_queue(4);
+
+	if(mhBackoff_.busy() == 0) {
+		if(is_idle()) {
+			if (mhDefer_.busy() == 0) {
+				/*
+				 * If we are already deferring, there is no
+				 * need to reset the Defer timer.
+				 */
+				if (bugFix_timer_) {
+				 	mhBackoff_.start(cw_, is_idle(), 
+							  phymib_.getDIFS());
+				}
+				else {
+					rTime = (Random::random() % cw_)
+						* (phymib_.getSlotTime());
+					mhDefer_.start(phymib_.getDIFS() + 
+						       rTime);
+				}
+			}
+		} else {
+			/*
+			 * If the medium is NOT IDLE, then we start
+			 * the backoff timer.
+			 */
+			mhBackoff_.start(cw_, is_idle());
+			
+		} 
+			
+	
+	} 
+}
+
+int
+Mac802_11::check_pktASSOCREP()
+{
+ 	struct hdr_mac802_11 *mh;
+ 	double timeout;
+
+ 	assert(mhBackoff_.busy() == 0);
+ 	if(pktASSOCREP_ == 0)
+  		return -1;
+	mh = HDR_MAC802_11(pktASSOCREP_);
+  	switch(mh->dh_fc.fc_subtype) {
+ 	case MAC_Subtype_AssocRep:
+ 		if(!is_idle()) {
+ 			inc_cw();
+			mhBackoff_.start(cw_, is_idle());
+			return 0;
+ 		}
+		
+ 		setTxState(MAC_MGMT);
+		tx_mgmt_ = 4;
+ 		timeout = txtime(phymib_.getASSOCREPlen(), basicRate_)
+			+ DSSS_MaxPropagationDelay
+			+ phymib_.getSIFS()
+			+ txtime(phymib_.getACKlen(), basicRate_)
+			+ DSSS_MaxPropagationDelay;
+			
+ 		break;
+	default:
+ 		fprintf(stderr, "check_pktASSOCREP:Invalid MAC Control subtype\n");
+ 		exit(1);
+	}
+ 	transmit(pktASSOCREP_, timeout);
+		
+ 	return 0;
+}
+
+void
+Mac802_11::recvASSOCREQ(Packet *p)
+{
+	struct assocreq_frame *acrqf = (struct assocreq_frame*)p->access(hdr_mac::offset_);
+
+	if(tx_state_ != MAC_IDLE) {
+		discard(p, DROP_MAC_BUSY);
+		return;
+	}
+	u_int32_t bss_id, src;
+	
+	bss_id = ETHER_ADDR(acrqf->acrqf_3a);
+ 	src = ETHER_ADDR(acrqf->acrqf_ta);
+	
+	if (!pktASSOCREP_) {
+		sendASSOCREP(src);
+		associating_node_ = src;
+	} else {
+		discard(p, DROP_MAC_BUSY);
+		return;
+	}
+	tx_resume();
+			
+	mac_log(p);
+}
+
+void
+Mac802_11::recvASSOCREP(Packet *p)
+{
+	struct assocrep_frame *acrpf = (struct assocrep_frame*)p->access(hdr_mac::offset_);
+
+	assert(pktASSOCREQ_);
+	Packet::free(pktASSOCREQ_);
+	pktASSOCREQ_ = 0;
+	mhSend_.stop();
+
+	u_int32_t src;
+	u_int16_t statuscode;
+	
+ 	src = ETHER_ADDR(acrpf->acrpf_ta);
+	statuscode = acrpf->acrpf_statuscode;
+	
+	if (statuscode == 0) {
+		associated = 1;
+		deletelist();
+		if (handoff) {
+			handoff = 0; //handoff completed
+		}
+		sendACK(src);
+		
+	}
+	if(mhSend_.busy() == 0)
+		tx_resume();
+	
+	mac_log(p);
+
+	
+}
+
+//Authentication functions
+
+void
+Mac802_11::sendAUTHENTICATE(int dst)
+{
+	Packet *p = Packet::alloc();
+	hdr_cmn* ch = HDR_CMN(p);
+	struct auth_frame *authf =(struct auth_frame*)p->access(hdr_mac::offset_);
+	
+	double rTime;
+	pktAUTHENTICATE_ = 0;
+
+	ch->uid() = 0;
+	
+
+	ch->ptype() = PT_MAC;
+	ch->size() = phymib_.getAUTHENTICATElen();
+	ch->iface() = -2;
+	ch->error() = 0;
+	
+	bzero(authf, MAC_HDR_LEN);
+
+	authf->authf_fc.fc_protocol_version = MAC_ProtocolVersion;
+ 	authf->authf_fc.fc_type	= MAC_Type_Management;
+ 	authf->authf_fc.fc_subtype	= MAC_Subtype_Auth;
+ 	authf->authf_fc.fc_to_ds	= 0;
+ 	authf->authf_fc.fc_from_ds	= 0;
+ 	authf->authf_fc.fc_more_frag= 0;
+ 	authf->authf_fc.fc_retry	= 0;
+ 	authf->authf_fc.fc_pwr_mgt	= 0;
+ 	authf->authf_fc.fc_more_data= 0;
+ 	authf->authf_fc.fc_wep	= 0;
+ 	authf->authf_fc.fc_order	= 0;
+	
+	
+	STORE4BYTE(&dst, (authf->authf_ra));
+	STORE4BYTE(&index_, (authf->authf_ta));
+	if (addr() != bss_id_)
+		STORE4BYTE(&dst, (authf->authf_3a));
+	else 
+		STORE4BYTE(&index_, (authf->authf_3a));
+	authf->authf_algono = 0; //Open system authentication
+
+	if (addr() != bss_id_) {
+		authf->authf_seqno = 1;   
+	} else {
+		authf->authf_seqno = 2;  
+		authf->authf_statuscode = 0;
+	}
+	
+	ch->txtime() = txtime(ch->size(), basicRate_);
+	if (addr() == bss_id_) {
+ 		authf->authf_duration = usec(txtime(phymib_.getACKlen(), basicRate_)
+				       + phymib_.getSIFS());
+	} else { 
+		authf->authf_duration = 0;
+	}
+
+	
+	pktAUTHENTICATE_ = p;
+
+	if (addr() == bss_id_) {
+		add_priority_queue(3);
+	}
+	
+
+	if(mhBackoff_.busy() == 0) {
+		if(is_idle()) {
+			if (mhDefer_.busy() == 0) {
+				/*
+				 * If we are already deferring, there is no
+				 * need to reset the Defer timer.
+				 */
+				if (bugFix_timer_) {
+				 	mhBackoff_.start(cw_, is_idle(), 
+							  phymib_.getDIFS());
+				}
+				else {
+					rTime = (Random::random() % cw_)
+						* (phymib_.getSlotTime());
+					mhDefer_.start(phymib_.getDIFS() + 
+						       rTime);
+				}
+			}
+		} else {
+			/*
+			 * If the medium is NOT IDLE, then we start
+			 * the backoff timer.
+			 */
+			mhBackoff_.start(cw_, is_idle());
+			
+		}
+	} 
+
+}
+
+int
+Mac802_11::check_pktAUTHENTICATE()
+{	
+	struct hdr_mac802_11 *mh;
+	double timeout;
+
+	assert(mhBackoff_.busy() == 0);
+
+	if(pktAUTHENTICATE_ == 0)
+ 		return -1;
+	mh = HDR_MAC802_11(pktAUTHENTICATE_);
+
+ 	switch(mh->dh_fc.fc_subtype) {
+	case MAC_Subtype_Auth:
+		if(! is_idle()) {
+			inc_cw();
+			mhBackoff_.start(cw_, is_idle());
+			return 0;
+		}
+		setTxState(MAC_MGMT);
+		if (addr() != bss_id_) {
+			timeout = txtime(phymib_.getAUTHENTICATElen(), basicRate_)
+				+ DSSS_MaxPropagationDelay                      // XXX
+				+ macmib_.getMaxChannelTime()
+				+ txtime(phymib_.getAUTHENTICATElen(), basicRate_)
+				+ DSSS_MaxPropagationDelay;
+		} else {
+			timeout = txtime(phymib_.getAUTHENTICATElen(), basicRate_)
+				+ DSSS_MaxPropagationDelay                      // XXX
+				+ phymib_.getSIFS()
+				+ txtime(phymib_.getACKlen(), basicRate_)
+				+ DSSS_MaxPropagationDelay;
+			tx_mgmt_ = 3;
+		}
+		break;
+	default:
+		fprintf(stderr, "check_pktAUTHENTICATE:Invalid MAC Control subtype\n");
+		exit(1);
+	}
+
+	transmit(pktAUTHENTICATE_, timeout);
+
+	return 0;
+}
+
+void
+Mac802_11::recvAUTHENTICATE(Packet *p)
+{
+	struct auth_frame *authf = (struct auth_frame*)p->access(hdr_mac::offset_);
+	
+	if (addr() != bss_id_) {
+			assert(pktAUTHENTICATE_);
+			Packet::free(pktAUTHENTICATE_);
+			pktAUTHENTICATE_ = 0;
+			mhSend_.stop();
+	} else {
+		if ( tx_state_ != MAC_IDLE) {
+		discard(p, DROP_MAC_BUSY);
+		return;
+		}
+	}
+	
+	u_int32_t src;
+		
+ 	src = ETHER_ADDR(authf->authf_ta);
+	
+	if (addr() == ap_addr) {
+		if (authf->authf_seqno == 1) {
+			if (!pktAUTHENTICATE_) {// AP is not currently involved in Authentication with any other STA 
+				sendAUTHENTICATE(src);
+				authenticating_node_ = src;
+			} else {
+				discard(p, DROP_MAC_BUSY);
+				return;
+			}
+		} else 
+			printf("Out of sequence\n");
+	} else if (authf->authf_seqno == 2 && authf->authf_statuscode == 0) {
+		authenticated = 1;
+		if (bss_id_ != ETHER_ADDR(authf->authf_3a) && handoff == 1) {
+			printf("Client %d: Handoff from AP %d to AP %d\n",index_, bss_id_,ETHER_ADDR(authf->authf_3a));
+		}
+		bss_id_ = ETHER_ADDR(authf->authf_3a);
+		sendACK(src);
+		mhProbe_.start(phymib_.getSIFS() + txtime(phymib_.getACKlen(), basicRate_) + macmib_.getMaxChannelTime());
+		
+	}
+	
+	if(mhSend_.busy() == 0)
+		tx_resume();
+		
+	mac_log(p);
+
+}
+
+// Active Scanning Functions 
+void
+Mac802_11::sendPROBEREQ(int dst)
+{
+	Packet *p = Packet::alloc();
+	hdr_cmn* ch = HDR_CMN(p);
+	struct probereq_frame *prrqf =(struct probereq_frame*)p->access(hdr_mac::offset_);
+	
+	double rTime;
+	pktPROBEREQ_ = 0;
+
+	ch->uid() = 0;
+	
+
+	ch->ptype() = PT_MAC;
+	ch->size() = phymib_.getPROBEREQlen();
+	ch->iface() = -2;
+	ch->error() = 0;
+	
+	bzero(prrqf, MAC_HDR_LEN);
+
+	prrqf->prrqf_fc.fc_protocol_version = MAC_ProtocolVersion;
+ 	prrqf->prrqf_fc.fc_type	= MAC_Type_Management;
+ 	prrqf->prrqf_fc.fc_subtype	= MAC_Subtype_ProbeReq;
+ 	prrqf->prrqf_fc.fc_to_ds	= 0;
+ 	prrqf->prrqf_fc.fc_from_ds	= 0;
+ 	prrqf->prrqf_fc.fc_more_frag= 0;
+ 	prrqf->prrqf_fc.fc_retry	= 0;
+ 	prrqf->prrqf_fc.fc_pwr_mgt	= 0;
+ 	prrqf->prrqf_fc.fc_more_data= 0;
+ 	prrqf->prrqf_fc.fc_wep	= 0;
+ 	prrqf->prrqf_fc.fc_order	= 0;
+	
+		
+	STORE4BYTE(&dst, (prrqf->prrqf_ra));
+	STORE4BYTE(&index_, (prrqf->prrqf_ta));
+	STORE4BYTE(&dst, (prrqf->prrqf_3a));
+
+	
+	ch->txtime() = txtime(ch->size(), basicRate_);
+ 	prrqf->prrqf_duration = 0;
+
+	
+	pktPROBEREQ_ = p;
+
+	if(mhBackoff_.busy() == 0) {
+		if(is_idle()) {
+			if (mhDefer_.busy() == 0) {
+				/*
+				 * If we are already deferring, there is no
+				 * need to reset the Defer timer.
+				 */
+				if (bugFix_timer_) {
+				 	mhBackoff_.start(cw_, is_idle(), 
+							  phymib_.getDIFS());
+				}
+				else {
+					rTime = (Random::random() % cw_)
+						* (phymib_.getSlotTime());
+					mhDefer_.start(phymib_.getDIFS() + 
+						       rTime);
+				}
+			}
+		} else {
+			/*
+			 * If the medium is NOT IDLE, then we start
+			 * the backoff timer.
+			 */
+			mhBackoff_.start(cw_, is_idle());
+			
+		}
+	}
+}
+
+
+int
+Mac802_11::check_pktPROBEREQ()
+{	
+	struct hdr_mac802_11 *mh;
+	double timeout;
+
+	assert(mhBackoff_.busy() == 0);
+
+	if(pktPROBEREQ_ == 0)
+ 		return -1;
+	mh = HDR_MAC802_11(pktPROBEREQ_);
+
+ 	switch(mh->dh_fc.fc_subtype) {
+	case MAC_Subtype_ProbeReq:
+		if(! is_idle()) {
+			inc_cw();
+			mhBackoff_.start(cw_, is_idle());
+			return 0;
+		}
+		setTxState(MAC_MGMT);
+		timeout = txtime(phymib_.getPROBEREQlen(), basicRate_)
+			+ DSSS_MaxPropagationDelay;                      // XXX
+		break;
+	default:
+		fprintf(stderr, "check_pktPROBEREQ:Invalid MAC Control subtype\n");
+		exit(1);
+	}
+	transmit(pktPROBEREQ_, timeout);
+	mhProbe_.start(macmib_.getMinChannelTime());
+	OnMinChannelTime = 1;
+	return 0;
+}
+
+
+
+void
+Mac802_11::sendPROBEREP(int dst)
+{
+	Packet *p = Packet::alloc();
+	
+	hdr_cmn* ch = HDR_CMN(p);
+	struct proberep_frame *prrpf = (struct proberep_frame*)p->access(hdr_mac::offset_);
+	
+	pktPROBEREP_ = 0;
+
+	ch->uid() = 0;
+	
+	double rTime;
+
+	ch->ptype() = PT_MAC;
+	ch->size() = phymib_.getPROBEREPlen();
+	ch->iface() = -2;
+	ch->error() = 0;
+	
+	bzero(prrpf, MAC_HDR_LEN);
+
+	prrpf->prrpf_fc.fc_protocol_version = MAC_ProtocolVersion;
+ 	prrpf->prrpf_fc.fc_type	= MAC_Type_Management;
+ 	prrpf->prrpf_fc.fc_subtype	= MAC_Subtype_ProbeRep;
+ 	prrpf->prrpf_fc.fc_to_ds	= 0;
+ 	prrpf->prrpf_fc.fc_from_ds	= 0;
+ 	prrpf->prrpf_fc.fc_more_frag= 0;
+ 	prrpf->prrpf_fc.fc_retry	= 0;
+ 	prrpf->prrpf_fc.fc_pwr_mgt	= 0;
+ 	prrpf->prrpf_fc.fc_more_data= 0;
+ 	prrpf->prrpf_fc.fc_wep	= 0;
+ 	prrpf->prrpf_fc.fc_order	= 0;
+	
+	STORE4BYTE(&dst, (prrpf->prrpf_ra));
+	STORE4BYTE(&index_, (prrpf->prrpf_ta));
+	STORE4BYTE(&index_, (prrpf->prrpf_3a));
+	
+	prrpf->prrpf_bcninterval = phymib_.getBeaconInterval();
+
+	ch->txtime() = txtime(ch->size(), basicRate_);
+ 	prrpf->prrpf_duration = 0;
+	
+	pktPROBEREP_ = p;
+
+	add_priority_queue(1);
+
+	if(mhBackoff_.busy() == 0) {
+		if(is_idle()) {
+			if (mhDefer_.busy() == 0) {
+				/*
+				 * If we are already deferring, there is no
+				 * need to reset the Defer timer.
+				 */
+				if (bugFix_timer_) {
+				 	mhBackoff_.start(cw_, is_idle(), 
+							  phymib_.getDIFS());
+				}
+				else {
+					rTime = (Random::random() % cw_)
+						* (phymib_.getSlotTime());
+					mhDefer_.start(phymib_.getDIFS() + 
+						       rTime);
+				}
+			}
+		} else {
+			/*
+			 * If the medium is NOT IDLE, then we start
+			 * the backoff timer.
+			 */
+			mhBackoff_.start(cw_, is_idle());
+			
+		}
+		
+	} 
+
+}
+
+int
+Mac802_11::check_pktPROBEREP()
+{	
+	struct proberep_frame *prrpf = (struct proberep_frame*)pktPROBEREP_->access(hdr_mac::offset_);
+	prrpf->prrpf_timestamp = Scheduler::instance().clock();
+	
+	struct hdr_mac802_11 *mh;
+	double timeout;
+
+	assert(mhBackoff_.busy() == 0);
+
+	if(pktPROBEREP_ == 0)
+ 		return -1;
+	mh = HDR_MAC802_11(pktPROBEREP_);
+
+ 	switch(mh->dh_fc.fc_subtype) {
+	case MAC_Subtype_ProbeRep:
+		if(! is_idle()) {
+			inc_cw();
+			mhBackoff_.start(cw_, is_idle());
+			return 0;
+		}
+		setTxState(MAC_MGMT);
+		tx_mgmt_ = 1;
+		timeout = txtime(phymib_.getPROBEREPlen(), basicRate_)
+			+ DSSS_MaxPropagationDelay                     // XXX
+			+ phymib_.getSIFS()
+			+ txtime(phymib_.getACKlen(), basicRate_)
+			+ DSSS_MaxPropagationDelay;
+		break;
+	default:
+		fprintf(stderr, "check_pktPROBEREP:Invalid MAC Control subtype\n");
+		exit(1);
+	}
+	transmit(pktPROBEREP_, timeout);
+  
+
+	return 0;
+}
+
+
+void
+Mac802_11::recvPROBEREQ(Packet *p)
+{
+	struct probereq_frame *prrqf = (struct probereq_frame*)p->access(hdr_mac::offset_);
+
+	if(tx_state_ != MAC_IDLE) {
+		discard(p, DROP_MAC_BUSY);
+		return;
+	}
+	u_int32_t bss_id, src;
+	bss_id = ETHER_ADDR(prrqf->prrqf_3a);
+ 	src = ETHER_ADDR(prrqf->prrqf_ta);
+	
+	if (!pktPROBEREP_) {
+		sendPROBEREP(src);
+	} else {
+		discard(p, DROP_MAC_BUSY);
+		return;
+	}		 
+		
+	
+	tx_resume();
+			
+	mac_log(p);
+}
+
+void
+Mac802_11::recvPROBEREP(Packet *p)
+{
+	struct proberep_frame *prrpf = (struct proberep_frame*)p->access(hdr_mac::offset_);
+
+	u_int32_t bss_id, src;
+
+	Pr = p->txinfo_.RxPr;
+ 	src = ETHER_ADDR(prrpf->prrpf_ta);
+	bss_id = ETHER_ADDR(prrpf->prrpf_ta);
+	
+	update_ap_table(src,Pr);
+		
+	sendACK(src);
+		
+
+	if(mhSend_.busy() == 0)
+		tx_resume();
+	
+	mac_log(p);
+
+	
+}
+
+void Mac802_11::checkAssocAuthStatus() {
+	if ( addr() != bss_id_ ) {
+		if (authenticated == 0 && associated == 0) {
+
+			sendAUTHENTICATE(strongest_ap());
+		} 
+		if (authenticated == 1 && associated == 0) {
+			sendASSOCREQ(bss_id_);
+		}
+	}
+}
+
+/* STA's beacon power table funtions
+*/
+void Mac802_11::update_ap_table(int num, double power) {
+	
+	std::list<ap_table>::iterator it;
+
+		ap_list = (struct ap_table*)malloc(sizeof(struct ap_table));
+		ap_list->ap_id=num;
+		ap_list->ap_power =power;
+		
+		ap_list1.push_front(*ap_list);
+
+		free(ap_list);
+
+
+}
+
+
+int Mac802_11::strongest_ap() {
+
+	std::list<ap_table>::iterator it;
+	it=ap_list1.begin();
+	double max_power;
+	int ap;
+	max_power = 0;
+	if (it == ap_list1.end()) {
+		return -1;
+		
+	}
+
+	for (it=ap_list1.begin(); it != ap_list1.end(); it++) {
+		if ((*it).ap_power > max_power) {
+			max_power = (*it).ap_power;
+			ap = (*it).ap_id;	
+		}
+
+
+
+	}
+	
+	return ap;
+
+	
+}
+
+
+int Mac802_11::find_ap(int num, double power) {
+
+	std::list<ap_table>::iterator it;
+
+	for (it=ap_list1.begin(); it != ap_list1.end(); it++) {
+		if ((*it).ap_id  ==  num) {
+			if ((*it).ap_power != power) {
+				(*it).ap_power = power;
+			}
+			return 1;
+		}
+
+	}
+
+	return 0;
+
+}
+
+void Mac802_11::deletelist() {
+	ap_list1.clear();
+	
+}
+
+
+void Mac802_11::add_priority_queue(int num)
+{
+	if (queue_head == NULL) {
+		queue_head = (struct priority_queue*)malloc(sizeof(struct priority_queue));
+		queue_head->frame_priority = num;
+		queue_head->next = NULL;
+	} else if (queue_head->next == NULL && queue_head->frame_priority == 0) {
+		 queue_head->frame_priority = num;
+	} else {
+		push_priority(num);
+	}
+
+
+}
+
+void Mac802_11::push_priority(int num) {
+	struct priority_queue *temp;
+	temp = queue_head;
+	while (temp->next != NULL) {
+		temp=temp->next;
+	}
+	temp->next = (struct priority_queue*)malloc(sizeof(struct priority_queue));
+	temp->next->frame_priority = num;
+	temp->next->next = NULL;
+}
+
+void Mac802_11::delete_lastnode() {
+	struct priority_queue *temp;
+	temp = queue_head;
+	if (queue_head == NULL) {
+		return;
+	}
+	if (queue_head->next == NULL) {
+		return;
+	}
+
+	while (temp->next->next != NULL) {
+	
+		temp = temp->next;
+	}
+	
+	temp->next = NULL;
+	free(temp->next);
+}
+
+void Mac802_11::shift_priority_queue()
+{
+	struct priority_queue *temp;
+	
+	if (queue_head == NULL) {
+		return;
+	}
+	if (queue_head->next == NULL) {
+		queue_head->frame_priority = 0;
+		goto done;
+	}
+	
+	temp =  queue_head;
+	while(temp->next != NULL) {
+		temp->frame_priority = temp->next->frame_priority;
+		temp = temp->next;
+	}
+
+	delete_lastnode();
+
+done:	
+	temp = queue_head;
+	
+}
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/mac-802_11.h ns-2.34/mac/mac-802_11.h
--- ns-2.34-pure/mac/mac-802_11.h	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/mac/mac-802_11.h	2010-02-28 09:31:39.000000000 -0800
@@ -43,7 +43,6 @@
 // Added by Sushmita to support event tracing (singal@nunki.usc.edu)
 #include "address.h"
 #include "ip.h"
-
 #include "mac-timers.h"
 #include "marshall.h"
 #include <math.h>
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/mac-802_3.cc ns-2.34/mac/mac-802_3.cc
--- ns-2.34-pure/mac/mac-802_3.cc	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/mac/mac-802_3.cc	2010-02-28 09:31:39.000000000 -0800
@@ -298,10 +298,6 @@
 	hdr_mac *mh= HDR_MAC(p);
 	int dst= mh->macDA();
 
-	if ((dst != BCAST_ADDR) && (dst != index_)) {
-		Packet::free(p);
-		goto done;
-	}
 	/* Strip off the mac header and padding if any */
 	ch->size() -= (ETHER_HDR_LEN + mh->padding_);
 
@@ -314,6 +310,19 @@
 		goto done;
 	}
 
+	/* tap out - */
+	if (tap_) {
+		if (!tap_filterown_ ||
+		    ((dst != index_) && (dst != BCAST_ADDR))) {
+			tap_->tap(p);
+		}
+	}
+
+
+	if ((dst != BCAST_ADDR) && (dst != index_)) {
+		Packet::free(p);
+		goto done;
+	}
 
 	/* we could schedule an event to account for mac-delay */
 	
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/mac.h ns-2.34/mac/mac.h
--- ns-2.34-pure/mac/mac.h	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/mac/mac.h	2010-02-28 09:31:39.000000000 -0800
@@ -179,7 +179,10 @@
 	virtual void sendUp(Packet *p);
 
 	virtual void resume(Packet* p = 0);
-	virtual void installTap(Tap *t) { tap_ = t; }
+	virtual void installTap(Tap *t,bool filterown = false) {
+		tap_ = t;
+		tap_filterown_ = filterown;
+	}
 	
 	inline double txtime(int bytes) {
 		return (8. * bytes / bandwidth_);
@@ -233,6 +236,7 @@
         
 	Phy *netif_;            // network interface
         Tap *tap_;              // tap agent
+	bool tap_filterown_;    // filter tap packets destined for use anyhow
 	LL *ll_;             	// LL this MAC is connected to
 	Channel *channel_;	// channel this MAC is connected to
 
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/mac.h.orig ns-2.34/mac/mac.h.orig
--- ns-2.34-pure/mac/mac.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/mac/mac.h.orig	2009-06-14 10:35:44.000000000 -0700
@@ -0,0 +1,252 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Daedalus Research
+ *	Group at the University of California Berkeley.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Contributed by Giao Nguyen, http://daedalus.cs.berkeley.edu/~gnguyen
+ *
+ * @(#) $Header: /cvsroot/nsnam/ns-2/mac/mac.h,v 1.37 2008/01/24 01:53:19 tom_henderson Exp $ (UCB)
+ */
+
+#ifndef ns_mac_h
+#define ns_mac_h
+
+#include <assert.h>
+#include "bi-connector.h"
+#include "packet.h"
+#include "ip.h"
+#include "route.h"
+#include "ll.h"
+#include "phy.h"
+#include "marshall.h"
+#include "channel.h"
+
+class Channel;
+
+#define ZERO	0.00000
+
+/*
+ * Medium Access Control (MAC)
+ */
+
+#define EF_COLLISION 2		// collision error flag
+
+/* ======================================================================
+   Defines / Macros used by all MACs.
+   ====================================================================== */
+
+#define ETHER_ADDR(x)	(GET4BYTE(x))
+
+#define MAC_HDR_LEN	64
+
+#define MAC_BROADCAST	((u_int32_t) 0xffffffff)
+#define BCAST_ADDR -1
+
+#define ETHER_ADDR_LEN	6
+#define ETHER_TYPE_LEN	2
+#define ETHER_FCS_LEN	4
+
+#define ETHERTYPE_IP	0x0800
+#define ETHERTYPE_ARP	0x0806
+
+enum MacState {
+	MAC_IDLE	= 0x0000,
+	MAC_POLLING	= 0x0001,
+	MAC_RECV 	= 0x0010,
+	MAC_SEND 	= 0x0100,
+	MAC_RTS		= 0x0200,
+	MAC_BCN		= 0x0300,
+	MAC_CTS		= 0x0400,
+	MAC_ACK		= 0x0800,
+	MAC_COLL	= 0x1000,
+	MAC_MGMT	= 0x1001
+};
+
+enum MacFrameType {
+	MF_BEACON	= 0x0008, // beaconing
+	MF_CONTROL	= 0x0010, // used as mask for control frame
+	MF_SLOTS	= 0x001a, // announce slots open for contention
+	MF_RTS		= 0x001b, // request to send
+	MF_CTS		= 0x001c, // clear to send, grant
+	MF_ACK		= 0x001d, // acknowledgement
+	MF_CF_END	= 0x001e, // contention free period end
+	MF_POLL		= 0x001f, // polling
+	MF_DATA		= 0x0020, // also used as mask for data frame
+	MF_DATA_ACK	= 0x0021  // ack for data frames
+};
+
+struct hdr_mac {
+	MacFrameType ftype_;	// frame type
+	int macSA_;		// source MAC address
+	int macDA_;		// destination MAC address
+	u_int16_t hdr_type_;     // mac_hdr type
+
+	double txtime_;		// transmission time
+	double sstime_;		// slot start time
+
+	int padding_;
+
+	inline void set(MacFrameType ft, int sa, int da=-1) {
+		ftype_ = ft;
+		macSA_ = sa;
+		if (da != -1)  macDA_ = da;
+	}
+	inline MacFrameType& ftype() { return ftype_; }
+	inline int& macSA() { return macSA_; }
+	inline int& macDA() { return macDA_; }
+	inline u_int16_t& hdr_type() {return hdr_type_; }
+
+	inline double& txtime() { return txtime_; }
+	inline double& sstime() { return sstime_; }
+
+	// Header access methods
+	static int offset_;
+	inline static int& offset() { return offset_; }
+	inline static hdr_mac* access(const Packet* p) {
+		return (hdr_mac*) p->access(offset_);
+	}
+};
+
+/* ===================================================================
+   Objects that want to promiscously listen to the packets before
+   address filtering must inherit from class Tap in order to plug into
+   the tap
+   =================================================================*/
+
+class Tap {
+public:
+	virtual ~Tap () {}
+	virtual void tap(const Packet *p) = 0;
+	// tap is given all packets received by the host.
+	// it must not alter or free the pkt.  If you want to frob it, copy it.
+};
+
+
+class MacHandlerResume : public Handler {
+public:
+	MacHandlerResume(Mac* m) : mac_(m) {}
+	void handle(Event*);
+protected:
+	Mac* mac_;
+};
+
+class MacHandlerSend : public Handler {
+public:
+	MacHandlerSend(Mac* m) : mac_(m) {}
+	void handle(Event*);
+protected:
+	Mac* mac_;
+};
+
+
+/* ==================================================================
+   MAC data structure
+   ================================================================*/
+
+class Mac : public BiConnector {
+public:
+	Mac();
+	virtual void recv(Packet* p, Handler* h);
+	virtual void sendDown(Packet* p);
+	virtual void sendUp(Packet *p);
+
+	virtual void resume(Packet* p = 0);
+	virtual void installTap(Tap *t) { tap_ = t; }
+	
+	inline double txtime(int bytes) {
+		return (8. * bytes / bandwidth_);
+	}
+ 	inline double txtime(Packet* p) {
+		return 8. * (MAC_HDR_LEN + \
+			     (HDR_CMN(p))->size()) / bandwidth_;
+	}
+	inline double bandwidth() const { return bandwidth_; }
+	
+	inline int addr() { return index_; }
+	inline MacState state() { return state_; }
+	inline MacState state(int m) { return state_ = (MacState) m; }
+	
+        //mac methods to set dst, src and hdt_type in pkt hdrs.
+	// note: -1 is the broadcast mac addr.
+	virtual inline int hdr_dst(char* hdr, int dst = -2) {
+		struct hdr_mac *dh = (struct hdr_mac*) hdr;
+		if(dst > -2)
+			dh->macDA_ = dst;
+		return dh->macDA();
+	}
+	virtual inline int hdr_src(char* hdr, int src = -2) {
+		struct hdr_mac *dh = (struct hdr_mac*) hdr;
+		if(src > -2)
+			dh->macSA_ = src;
+		return dh->macSA();
+	}
+	virtual inline int hdr_type(char *hdr, u_int16_t type = 0) {
+		struct hdr_mac *dh = (struct hdr_mac*) hdr;
+		if (type)
+			dh->hdr_type_ = type;
+		return dh->hdr_type();
+	}
+
+private:
+        void mac_log(Packet *p) {
+                logtarget_->recv(p, (Handler*) 0);
+        }
+        NsObject*       logtarget_;
+
+protected:
+	int command(int argc, const char*const* argv);
+	virtual int initialized() { 
+		return (netif_ && uptarget_ && downtarget_); 
+	}
+	int index_;		// MAC address
+	double bandwidth_;      // channel bitrate
+	double delay_;		// MAC overhead
+	int abstract_;         //   MAC support for abstract LAN 
+        
+	Phy *netif_;            // network interface
+        Tap *tap_;              // tap agent
+	LL *ll_;             	// LL this MAC is connected to
+	Channel *channel_;	// channel this MAC is connected to
+
+	Handler* callback_;	// callback for end-of-transmission
+	MacHandlerResume hRes_;	// resume handler
+	MacHandlerSend hSend_;	// handle delay send due to busy channel
+	Event intr_;
+
+	/*
+	 * Internal MAC State
+	 */
+	MacState state_;	// MAC's current state
+	Packet *pktRx_;
+	Packet *pktTx_;
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/phy.cc ns-2.34/mac/phy.cc
--- ns-2.34-pure/mac/phy.cc	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/mac/phy.cc	2010-02-28 09:31:39.000000000 -0800
@@ -68,6 +68,16 @@
 			tcl.resultf("%d", index_);
 			return TCL_OK;
 		}
+		
+		if (strcmp(argv[1],"getchannel") == 0) {
+			if (channel_) {
+				tcl.resultf("%s",channel_->name());
+			}
+			else {
+				tcl.resultf("%s","");
+			}
+			return TCL_OK;
+		}
 	}
 
 	else if(argc == 3) {
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/wireless-phy.cc ns-2.34/mac/wireless-phy.cc
--- ns-2.34-pure/mac/wireless-phy.cc	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/mac/wireless-phy.cc	2010-02-28 09:31:39.000000000 -0800
@@ -37,9 +37,13 @@
  * Ported from CMU/Monarch's code, nov'98 -Padma Haldar.
  * wireless-phy.cc
  */
-
+/*
+ *	Modified by Nicolas Letor to support wifi elements.
+ * 	Performance Analysis of Telecommunication Systems (PATS) research group,
+ * 	Interdisciplinary Institute for Broadband Technology (IBBT) & Universiteit Antwerpen.
+ */
 #include <math.h>
-
+#include <limits>
 #include <packet.h>
 
 #include <mobilenode.h>
@@ -55,6 +59,8 @@
 #include <sys/param.h>  /* for MIN/MAX */
 
 #include "diffusion/diff_header.h"
+#include "rawpacket.h"
+#include "packet_anno.h"
 
 void Sleep_Timer::expire(Event *) {
 	a_->UpdateSleepEnergy();
@@ -98,6 +104,28 @@
 	bind("freq_", &freq_);
 	bind("L_", &L_);
 	
+	// nletor -- multirate madwifi configuration
+	RateCount_ = 0;
+	bind("RateCount_",&RateCount_);
+	if (RateCount_ > 0) {
+		//ratelist = RateList(RateCount_);
+		//rxlist = RXList(RateCount_);
+		char buffer[32];
+		for (int i=0; i< RateCount_; i++) {
+				double rate;
+				sprintf(buffer,"Rate%d",i);
+				bind_bw(buffer,&rate);
+				ratelist.push_back(rate);
+				
+				double thr;
+				sprintf(buffer,"RXThresh%d",i);
+				bind(buffer,&thr);
+				rxlist.push_back(thr);
+		}
+
+	}
+	//!nletor
+
 	lambda_ = SPEED_OF_LIGHT / freq_;
 
 	node_ = 0;
@@ -135,6 +163,7 @@
 WirelessPhy::command(int argc, const char*const* argv)
 {
 	TclObject *obj; 
+	Tcl& tcl = Tcl::instance();
 
 	if (argc==2) {
 		if (strcasecmp(argv[1], "NodeOn") == 0) {
@@ -157,7 +186,11 @@
 				update_energy_time_ = NOW;
 			}
 			return TCL_OK;
+		} else if (strcasecmp(argv[1], "getantenna") == 0) {
+			tcl.result(ant_->name());
+			return TCL_OK;
 		}
+
 	} else if(argc == 3) {
 		if (strcasecmp(argv[1], "setTxPower") == 0) {
 			Pt_consume_ = atof(argv[2]);
@@ -200,6 +233,9 @@
 	return Phy::command(argc,argv);
 }
  
+click_wifi_extra* 
+getWifiExtra(Packet* p);
+
 void 
 WirelessPhy::sendDown(Packet *p)
 {
@@ -314,6 +350,22 @@
 	 */
 	assert(initialized());
 
+	//unsigned char* pdat = p->accessdata();
+	
+	click_wifi_extra *ceh = 0;
+	struct hdr_cmn* chdr = HDR_CMN(p);
+	if (chdr->ptype() == PT_RAW){
+		hdr_raw* rhdr = hdr_raw::access(p);
+		if (rhdr->subtype == hdr_raw::MADWIFI) {
+			ceh = (click_wifi_extra*)(p->accessdata());
+			//u_int8_t rate = ceh->rate;
+			memset(ceh,0,sizeof(click_wifi_extra));
+			ceh->rate = int(p->txinfo_.getRate()/500000);
+			ceh->magic = WIFI_EXTRA_MAGIC;
+			//printf("Rate is %e Rate is %i and %i %i \n",p->txinfo_.getRate(),rate,int(p->txinfo_.getRate()/500000),ceh->rate);
+		} 
+	} 
+
 	PacketStamp s;
 	double Pr;
 	int pkt_recvd = 0;
@@ -344,11 +396,36 @@
 	if(propagation_) {
 		s.stamp((MobileNode*)node(), ant_, 0, lambda_);
 		Pr = propagation_->Pr(&p->txinfo_, &s, this);
+		if(ceh != 0){	
+			//analog to atheros formule -95dBm is lowest sens.
+			double LPr = (10 * log(Pr * 1000));
+			double LRXThr = (10 * log(RXThresh_ * 1000));
+			if (LPr < numeric_limits<double>::infinity()){
+				ceh->rssi = (short int)( (LPr - LRXThr ) * (60.0/100.0) );	
+				ceh->rssi = (ceh->rssi > 60) ? 60 : ceh->rssi;
+			} else {
+				ceh->rssi = 60;
+			}			
+		}
+
 		if (Pr < CSThresh_) {
 			pkt_recvd = 0;
 			goto DONE;
 		}
-		if (Pr < RXThresh_) {
+
+
+		double RXThr = RXThresh_; //rxlist[RateCount_ - 1];
+		
+		// compare to correct rate,moet nog aan gesleuteld worden
+		for (int i = 0; i < RateCount_; i++){
+			if (ratelist[i] >= p->txinfo_.getRate()){
+				RXThr = rxlist[i]; 	
+			}	
+		}
+		//printf("Rate is %e Pr is %e RXThr is %e\n",p->txinfo_.getRate(),Pr,RXThr);
+		
+		if (RateCount_ > 0 ) { 
+			if (Pr < RXThr) {
 			/*
 			 * We can detect, but not successfully receive
 			 * this packet.
@@ -362,10 +439,29 @@
 			       Pr,RXThresh);
 #endif
 		}
+		} else {
+			if (Pr < RXThresh_) {
+				/*
+				 * We can detect, but not successfully receive
+				 * this packet.
+				 */
+				hdr_cmn *hdr = HDR_CMN(p);
+				hdr->error() = 1;
+			#if DEBUG > 3
+				printf("SM %f.9 _%d_ drop pkt from %d low POWER %e/%e\n",
+				       Scheduler::instance().clock(), node()->index(),
+				       p->txinfo_.getNode()->index(),
+				       Pr,RXThresh);
+			#endif
+			}
+		}
 	}
 	if(modulation_) {
 		hdr_cmn *hdr = HDR_CMN(p);
 		hdr->error() = modulation_->BitError(Pr);
+		if(ceh != 0){
+			ceh->flags |= WIFI_EXTRA_RX_ERR;	
+		}
 	}
 	
 	/*
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/wireless-phy.cc.orig ns-2.34/mac/wireless-phy.cc.orig
--- ns-2.34-pure/mac/wireless-phy.cc.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/mac/wireless-phy.cc.orig	2009-06-14 10:35:44.000000000 -0700
@@ -0,0 +1,602 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- 
+ *
+ * Copyright (c) 1996 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory and the Daedalus
+ *	research group at UC Berkeley.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $Header: /cvsroot/nsnam/ns-2/mac/wireless-phy.cc,v 1.28 2007/09/04 04:32:18 tom_henderson Exp $
+ *
+ * Ported from CMU/Monarch's code, nov'98 -Padma Haldar.
+ * wireless-phy.cc
+ */
+
+#include <math.h>
+
+#include <packet.h>
+
+#include <mobilenode.h>
+#include <phy.h>
+#include <propagation.h>
+#include <modulation.h>
+#include <omni-antenna.h>
+#include <wireless-phy.h>
+#include <packet.h>
+#include <ip.h>
+#include <agent.h>
+#include <trace.h>
+#include <sys/param.h>  /* for MIN/MAX */
+
+#include "diffusion/diff_header.h"
+
+void Sleep_Timer::expire(Event *) {
+	a_->UpdateSleepEnergy();
+}
+
+
+/* ======================================================================
+   WirelessPhy Interface
+   ====================================================================== */
+static class WirelessPhyClass: public TclClass {
+public:
+        WirelessPhyClass() : TclClass("Phy/WirelessPhy") {}
+        TclObject* create(int, const char*const*) {
+                return (new WirelessPhy);
+        }
+} class_WirelessPhy;
+
+
+WirelessPhy::WirelessPhy() : Phy(), sleep_timer_(this), status_(IDLE)
+{
+	/*
+	 *  It sounds like 10db should be the capture threshold.
+	 *
+	 *  If a node is presently receiving a packet a a power level
+	 *  Pa, and a packet at power level Pb arrives, the following
+	 *  comparion must be made to determine whether or not capture
+	 *  occurs:
+	 *
+	 *    10 * log(Pa) - 10 * log(Pb) > 10db
+	 *
+	 *  OR equivalently
+	 *
+	 *    Pa/Pb > 10.
+	 *
+	 */
+	bind("CPThresh_", &CPThresh_);
+	bind("CSThresh_", &CSThresh_);
+	bind("RXThresh_", &RXThresh_);
+	//bind("bandwidth_", &bandwidth_);
+	bind("Pt_", &Pt_);
+	bind("freq_", &freq_);
+	bind("L_", &L_);
+	
+	lambda_ = SPEED_OF_LIGHT / freq_;
+
+	node_ = 0;
+	ant_ = 0;
+	propagation_ = 0;
+	modulation_ = 0;
+
+	// Assume AT&T's Wavelan PCMCIA card -- Chalermek
+        //	Pt_ = 8.5872e-4; // For 40m transmission range.
+	//      Pt_ = 7.214e-3;  // For 100m transmission range.
+	//      Pt_ = 0.2818; // For 250m transmission range.
+	//	Pt_ = pow(10, 2.45) * 1e-3;         // 24.5 dbm, ~ 281.8mw
+	
+	Pt_consume_ = 0.660;  // 1.6 W drained power for transmission
+	Pr_consume_ = 0.395;  // 1.2 W drained power for reception
+
+	//	P_idle_ = 0.035; // 1.15 W drained power for idle
+
+	P_idle_ = 0.0;
+	P_sleep_ = 0.00;
+	T_sleep_ = 10000;
+	P_transition_ = 0.00;
+	T_transition_ = 0.00; // 2.31 change: Was not initialized earlier
+	node_on_=1;
+	
+	channel_idle_time_ = NOW;
+	update_energy_time_ = NOW;
+	last_send_time_ = NOW;
+	
+	sleep_timer_.resched(1.0);
+
+}
+
+int
+WirelessPhy::command(int argc, const char*const* argv)
+{
+	TclObject *obj; 
+
+	if (argc==2) {
+		if (strcasecmp(argv[1], "NodeOn") == 0) {
+			node_on();
+
+			if (em() == NULL) 
+				return TCL_OK;
+			if (NOW > update_energy_time_) {
+				update_energy_time_ = NOW;
+			}
+			return TCL_OK;
+		} else if (strcasecmp(argv[1], "NodeOff") == 0) {
+			node_off();
+
+			if (em() == NULL) 
+				return TCL_OK;
+			if (NOW > update_energy_time_) {
+				em()->DecrIdleEnergy(NOW-update_energy_time_,
+						     P_idle_);
+				update_energy_time_ = NOW;
+			}
+			return TCL_OK;
+		}
+	} else if(argc == 3) {
+		if (strcasecmp(argv[1], "setTxPower") == 0) {
+			Pt_consume_ = atof(argv[2]);
+			return TCL_OK;
+		} else if (strcasecmp(argv[1], "setRxPower") == 0) {
+			Pr_consume_ = atof(argv[2]);
+			return TCL_OK;
+		} else if (strcasecmp(argv[1], "setIdlePower") == 0) {
+			P_idle_ = atof(argv[2]);
+			return TCL_OK;
+		}else if (strcasecmp(argv[1], "setSleepPower") == 0) {
+			P_sleep_ = atof(argv[2]);
+			return TCL_OK;
+		}else if (strcasecmp(argv[1], "setSleepTime") == 0) {
+			T_sleep_ = atof(argv[2]);
+			return TCL_OK;		
+		} else if (strcasecmp(argv[1], "setTransitionPower") == 0) {
+			P_transition_ = atof(argv[2]);
+			return TCL_OK;
+		} else if (strcasecmp(argv[1], "setTransitionTime") == 0) {
+			T_transition_ = atof(argv[2]);
+			return TCL_OK;
+		}else if( (obj = TclObject::lookup(argv[2])) == 0) {
+			fprintf(stderr,"WirelessPhy: %s lookup of %s failed\n", 
+				argv[1], argv[2]);
+			return TCL_ERROR;
+		}else if (strcmp(argv[1], "propagation") == 0) {
+			assert(propagation_ == 0);
+			propagation_ = (Propagation*) obj;
+			return TCL_OK;
+		} else if (strcasecmp(argv[1], "antenna") == 0) {
+			ant_ = (Antenna*) obj;
+			return TCL_OK;
+		} else if (strcasecmp(argv[1], "node") == 0) {
+			assert(node_ == 0);
+			node_ = (Node *)obj;
+			return TCL_OK;
+		}
+	}
+	return Phy::command(argc,argv);
+}
+ 
+void 
+WirelessPhy::sendDown(Packet *p)
+{
+	/*
+	 * Sanity Check
+	 */
+	assert(initialized());
+	
+	if (em()) {
+			//node is off here...
+			if (Is_node_on() != true ) {
+			Packet::free(p);
+			return;
+			}
+			if(Is_node_on() == true && Is_sleeping() == true){
+			em()-> DecrSleepEnergy(NOW-update_energy_time_,
+							P_sleep_);
+			update_energy_time_ = NOW;
+
+			}
+
+	}
+	/*
+	 * Decrease node's energy
+	 */
+	if(em()) {
+		if (em()->energy() > 0) {
+
+		    double txtime = hdr_cmn::access(p)->txtime();
+		    double start_time = MAX(channel_idle_time_, NOW);
+		    double end_time = MAX(channel_idle_time_, NOW+txtime);
+		    double actual_txtime = end_time-start_time;
+
+		    if (start_time > update_energy_time_) {
+			    em()->DecrIdleEnergy(start_time - 
+						 update_energy_time_, P_idle_);
+			    update_energy_time_ = start_time;
+		    }
+
+		    /* It turns out that MAC sends packet even though, it's
+		       receiving some packets.
+		    
+		    if (txtime-actual_txtime > 0.000001) {
+			    fprintf(stderr,"Something may be wrong at MAC\n");
+			    fprintf(stderr,"act_tx = %lf, tx = %lf\n", actual_txtime, txtime);
+		    }
+		    */
+
+		   // Sanity check
+		   double temp = MAX(NOW,last_send_time_);
+
+		   /*
+		   if (NOW < last_send_time_) {
+			   fprintf(stderr,"Argggg !! Overlapping transmission. NOW %lf last %lf temp %lf\n", NOW, last_send_time_, temp);
+		   }
+		   */
+		   
+		   double begin_adjust_time = MIN(channel_idle_time_, temp);
+		   double finish_adjust_time = MIN(channel_idle_time_, NOW+txtime);
+		   double gap_adjust_time = finish_adjust_time - begin_adjust_time;
+		   if (gap_adjust_time < 0.0) {
+			   fprintf(stderr,"What the heck ! negative gap time.\n");
+		   }
+
+		   if ((gap_adjust_time > 0.0) && (status_ == RECV)) {
+			   em()->DecrTxEnergy(gap_adjust_time,
+					      Pt_consume_-Pr_consume_);
+		   }
+
+		   em()->DecrTxEnergy(actual_txtime,Pt_consume_);
+//		   if (end_time > channel_idle_time_) {
+//			   status_ = SEND;
+//		   }
+//
+		   status_ = IDLE;
+
+		   last_send_time_ = NOW+txtime;
+		   channel_idle_time_ = end_time;
+		   update_energy_time_ = end_time;
+
+		   if (em()->energy() <= 0) {
+			   em()->setenergy(0);
+			   ((MobileNode*)node())->log_energy(0);
+		   }
+
+		} else {
+
+			// log node energy
+			if (em()->energy() > 0) {
+				((MobileNode *)node_)->log_energy(1);
+			} 
+//
+			Packet::free(p);
+			return;
+		}
+	}
+
+	/*
+	 *  Stamp the packet with the interface arguments
+	 */
+	p->txinfo_.stamp((MobileNode*)node(), ant_->copy(), Pt_, lambda_);
+	
+	// Send the packet
+	channel_->recv(p, this);
+}
+
+int 
+WirelessPhy::sendUp(Packet *p)
+{
+	/*
+	 * Sanity Check
+	 */
+	assert(initialized());
+
+	PacketStamp s;
+	double Pr;
+	int pkt_recvd = 0;
+
+	Pr = p->txinfo_.getTxPr();
+	
+	// if the node is in sleeping mode, drop the packet simply
+	if (em()) {
+			if (Is_node_on()!= true){
+			pkt_recvd = 0;
+			goto DONE;
+			}
+
+			if (Is_sleeping()==true && (Is_node_on() == true)) {
+				pkt_recvd = 0;
+				goto DONE;
+			}
+			
+	}
+	// if the energy goes to ZERO, drop the packet simply
+	if (em()) {
+		if (em()->energy() <= 0) {
+			pkt_recvd = 0;
+			goto DONE;
+		}
+	}
+
+	if(propagation_) {
+		s.stamp((MobileNode*)node(), ant_, 0, lambda_);
+		Pr = propagation_->Pr(&p->txinfo_, &s, this);
+		if (Pr < CSThresh_) {
+			pkt_recvd = 0;
+			goto DONE;
+		}
+		if (Pr < RXThresh_) {
+			/*
+			 * We can detect, but not successfully receive
+			 * this packet.
+			 */
+			hdr_cmn *hdr = HDR_CMN(p);
+			hdr->error() = 1;
+#if DEBUG > 3
+			printf("SM %f.9 _%d_ drop pkt from %d low POWER %e/%e\n",
+			       Scheduler::instance().clock(), node()->index(),
+			       p->txinfo_.getNode()->index(),
+			       Pr,RXThresh);
+#endif
+		}
+	}
+	if(modulation_) {
+		hdr_cmn *hdr = HDR_CMN(p);
+		hdr->error() = modulation_->BitError(Pr);
+	}
+	
+	/*
+	 * The MAC layer must be notified of the packet reception
+	 * now - ie; when the first bit has been detected - so that
+	 * it can properly do Collision Avoidance / Detection.
+	 */
+	pkt_recvd = 1;
+
+DONE:
+	p->txinfo_.getAntenna()->release();
+
+	/* WILD HACK: The following two variables are a wild hack.
+	   They will go away in the next release...
+	   They're used by the mac-802_11 object to determine
+	   capture.  This will be moved into the net-if family of 
+	   objects in the future. */
+	p->txinfo_.RxPr = Pr;
+	p->txinfo_.CPThresh = CPThresh_;
+
+	/*
+	 * Decrease energy if packet successfully received
+	 */
+	if(pkt_recvd && em()) {
+
+		double rcvtime = hdr_cmn::access(p)->txtime();
+		// no way to reach here if the energy level < 0
+		
+		double start_time = MAX(channel_idle_time_, NOW);
+		double end_time = MAX(channel_idle_time_, NOW+rcvtime);
+		double actual_rcvtime = end_time-start_time;
+
+		if (start_time > update_energy_time_) {
+			em()->DecrIdleEnergy(start_time-update_energy_time_,
+					     P_idle_);
+			update_energy_time_ = start_time;
+		}
+		
+		em()->DecrRcvEnergy(actual_rcvtime,Pr_consume_);
+/*
+  if (end_time > channel_idle_time_) {
+  status_ = RECV;
+  }
+*/
+		channel_idle_time_ = end_time;
+		update_energy_time_ = end_time;
+
+		status_ = IDLE;
+
+		/*
+		  hdr_diff *dfh = HDR_DIFF(p);
+		  printf("Node %d receives (%d, %d, %d) energy %lf.\n",
+		  node()->address(), dfh->sender_id.addr_, 
+		  dfh->sender_id.port_, dfh->pk_num, node()->energy());
+		*/
+
+		// log node energy
+		if (em()->energy() > 0) {
+		((MobileNode *)node_)->log_energy(1);
+        	} 
+
+		if (em()->energy() <= 0) {  
+			// saying node died
+			em()->setenergy(0);
+			((MobileNode*)node())->log_energy(0);
+		}
+	}
+	
+	return pkt_recvd;
+}
+
+void
+WirelessPhy::node_on()
+{
+
+        node_on_= TRUE;
+	status_ = IDLE;
+
+       if (em() == NULL)
+ 	    return;	
+   	if (NOW > update_energy_time_) {
+      	    update_energy_time_ = NOW;
+   	}
+}
+
+void 
+WirelessPhy::node_off()
+{
+
+        node_on_= FALSE;
+	status_ = SLEEP;
+
+	if (em() == NULL)
+            return;
+        if (NOW > update_energy_time_) {
+            em()->DecrIdleEnergy(NOW-update_energy_time_,
+                                P_idle_);
+            update_energy_time_ = NOW;
+	}
+}
+
+void 
+WirelessPhy::node_wakeup()
+{
+
+	if (status_== IDLE)
+		return;
+
+	if (em() == NULL)
+            return;
+
+        if ( NOW > update_energy_time_ && (status_== SLEEP) ) {
+		//the power consumption when radio goes from SLEEP mode to IDLE mode
+		em()->DecrTransitionEnergy(T_transition_,P_transition_);
+		
+		em()->DecrSleepEnergy(NOW-update_energy_time_,
+				      P_sleep_);
+		status_ = IDLE;
+	        update_energy_time_ = NOW;
+		
+		// log node energy
+		if (em()->energy() > 0) {
+			((MobileNode *)node_)->log_energy(1);
+	        } else {
+			((MobileNode *)node_)->log_energy(0);   
+	        }
+	}
+}
+
+void 
+WirelessPhy::node_sleep()
+{
+//
+//        node_on_= FALSE;
+//
+	if (status_== SLEEP)
+		return;
+
+	if (em() == NULL)
+            return;
+
+        if ( NOW > update_energy_time_ && (status_== IDLE) ) {
+	//the power consumption when radio goes from IDLE mode to SLEEP mode
+	    em()->DecrTransitionEnergy(T_transition_,P_transition_);
+
+            em()->DecrIdleEnergy(NOW-update_energy_time_,
+                                P_idle_);
+		status_ = SLEEP;
+	        update_energy_time_ = NOW;
+
+	// log node energy
+		if (em()->energy() > 0) {
+			((MobileNode *)node_)->log_energy(1);
+	        } else {
+			((MobileNode *)node_)->log_energy(0);   
+	        }
+	}
+}
+//
+void
+WirelessPhy::dump(void) const
+{
+	Phy::dump();
+	fprintf(stdout,
+		"\tPt: %f, Gt: %f, Gr: %f, lambda: %f, L: %f\n",
+		Pt_, ant_->getTxGain(0,0,0,lambda_), ant_->getRxGain(0,0,0,lambda_), lambda_, L_);
+	//fprintf(stdout, "\tbandwidth: %f\n", bandwidth_);
+	fprintf(stdout, "--------------------------------------------------\n");
+}
+
+
+void WirelessPhy::UpdateIdleEnergy()
+{
+	if (em() == NULL) {
+		return;
+	}
+	if (NOW > update_energy_time_ && (Is_node_on()==TRUE && status_ == IDLE ) ) {
+		  em()-> DecrIdleEnergy(NOW-update_energy_time_,
+					P_idle_);
+		  update_energy_time_ = NOW;
+	}
+
+	// log node energy
+	if (em()->energy() > 0) {
+		((MobileNode *)node_)->log_energy(1);
+        } else {
+		((MobileNode *)node_)->log_energy(0);   
+        }
+
+//	idle_timer_.resched(10.0);
+}
+
+double WirelessPhy::getDist(double Pr, double Pt, double Gt, double Gr,
+			    double hr, double ht, double L, double lambda)
+{
+	if (propagation_) {
+		return propagation_->getDist(Pr, Pt, Gt, Gr, hr, ht, L,
+					     lambda);
+	}
+	return 0;
+}
+
+//
+void WirelessPhy::UpdateSleepEnergy()
+{
+	if (em() == NULL) {
+		return;
+	}
+	if (NOW > update_energy_time_ && ( Is_node_on()==TRUE  && Is_sleeping() == true) ) {
+		  em()-> DecrSleepEnergy(NOW-update_energy_time_,
+					P_sleep_);
+		  update_energy_time_ = NOW;
+		// log node energy
+		if (em()->energy() > 0) {
+			((MobileNode *)node_)->log_energy(1);
+        	} else {
+			((MobileNode *)node_)->log_energy(0);   
+        	}
+	}
+	
+	//A hack to make states consistent with those of in Energy Model for AF
+	int static s=em()->sleep();
+	if(em()->sleep()!=s){
+
+		s=em()->sleep();	
+		if(s==1)
+			node_sleep();
+		else
+			node_wakeup();			
+//		printf("\n AF hack %d\n",em()->sleep());	
+	}	
+	
+	sleep_timer_.resched(10.0);
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/wireless-phy.h ns-2.34/mac/wireless-phy.h
--- ns-2.34-pure/mac/wireless-phy.h	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/mac/wireless-phy.h	2010-02-28 09:31:39.000000000 -0800
@@ -42,6 +42,11 @@
 #ifndef ns_WirelessPhy_h
 #define ns_WirelessPhy_h
 
+#include <vector>
+#include <map>
+typedef std::vector< double > RateList;
+typedef std::vector< double > RXList;
+
 #include "propagation.h"
 #include "modulation.h"
 #include "omni-antenna.h"
@@ -119,6 +124,7 @@
 	double RXThresh_;	// receive power threshold (W)
 	double CSThresh_;	// carrier sense threshold (W)
 	double CPThresh_;	// capture threshold (db)
+  	int RateCount_;		// number of rates
   
 	Antenna *ant_;
 	Propagation *propagation_;	// Propagation Model
@@ -144,6 +150,8 @@
 
 	friend class Sleep_Timer;
 
+	RateList ratelist;
+	RXList rxlist;
 };
 
 #endif /* !ns_WirelessPhy_h */
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mac/wireless-phy.h.orig ns-2.34/mac/wireless-phy.h.orig
--- ns-2.34-pure/mac/wireless-phy.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/mac/wireless-phy.h.orig	2009-06-14 10:35:44.000000000 -0700
@@ -0,0 +1,149 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*-  *
+ *
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $Header: /cvsroot/nsnam/ns-2/mac/wireless-phy.h,v 1.15 2007/01/30 05:00:50 tom_henderson Exp $
+ *
+ * Ported from CMU/Monarch's code, nov'98 -Padma Haldar.
+ *
+ * wireless-phy.h
+ * -- a SharedMedia network interface
+ */
+
+#ifndef ns_WirelessPhy_h
+#define ns_WirelessPhy_h
+
+#include "propagation.h"
+#include "modulation.h"
+#include "omni-antenna.h"
+#include "phy.h"
+#include "mobilenode.h"
+#include "timer-handler.h"
+
+class Phy;
+class Propagation;
+class WirelessPhy;
+
+class Sleep_Timer : public TimerHandler {
+ public:
+	Sleep_Timer(WirelessPhy *a) : TimerHandler() { a_ = a; }
+ protected:
+	virtual void expire(Event *e);
+	WirelessPhy *a_;
+};
+
+//
+class WirelessPhy : public Phy {
+public:
+	WirelessPhy();
+	
+	void sendDown(Packet *p);
+	int sendUp(Packet *p);
+	
+	inline double getL() const {return L_;}
+	inline double getLambda() const {return lambda_;}
+	inline Node* node(void) const { return node_; }
+	inline double getPtconsume() { return Pt_consume_; }
+
+	double getDist(double Pr, double Pt, double Gt, double Gr, double hr,
+		       double ht, double L, double lambda);
+  
+	virtual int command(int argc, const char*const* argv);
+	virtual void dump(void) const;
+	
+	//void setnode (MobileNode *node) { node_ = node; }
+	void node_on();
+	void node_off();	
+
+        /* -NEW- */
+        inline double getAntennaZ() { return ant_->getZ(); }
+        inline double getPt() { return Pt_; }
+        inline double getRXThresh() { return RXThresh_; }
+        inline double getCSThresh() { return CSThresh_; }
+        inline double getFreq() { return freq_; }
+        /* End -NEW- */
+
+	void node_sleep();
+	void node_wakeup();
+	inline bool& Is_node_on() { return node_on_; }
+	inline bool Is_sleeping() { if (status_==SLEEP) return(1); else return(0); }
+	double T_sleep_;	// 2.31 change: Time at which sleeping is to be enabled (sec)
+
+protected:
+	double Pt_;		// transmitted signal power (W)
+	double Pt_consume_;	// power consumption for transmission (W)
+	double Pr_consume_;	// power consumption for reception (W)
+	double P_idle_;         // idle power consumption (W)
+	double P_sleep_;	// sleep power consumption (W)
+	double P_transition_;	// power consumed when transiting from SLEEP mode to IDLE mode and vice versa.
+	double T_transition_;	// time period to transit from SLEEP mode to IDLE mode and vice versa.
+//
+
+	double last_send_time_;	// the last time the node sends somthing.
+	double channel_idle_time_;	// channel idle time.
+	double update_energy_time_;	// the last time we update energy.
+
+	double freq_;           // frequency
+	double lambda_;		// wavelength (m)
+	double L_;		// system loss factor
+  
+	double RXThresh_;	// receive power threshold (W)
+	double CSThresh_;	// carrier sense threshold (W)
+	double CPThresh_;	// capture threshold (db)
+  
+	Antenna *ant_;
+	Propagation *propagation_;	// Propagation Model
+	Modulation *modulation_;	// Modulation Schem
+
+	// Why phy has a node_ and this guy has it all over again??
+//  	MobileNode* node_;         	// Mobile Node to which interface is attached .
+
+ 	enum ChannelStatus { SLEEP, IDLE, RECV, SEND };	
+	bool node_on_; // on-off status of this node
+	Sleep_Timer sleep_timer_;
+	int status_;
+
+private:
+	inline int initialized() {
+		return (node_ && uptarget_ && downtarget_ && propagation_);
+	}
+	void UpdateIdleEnergy();
+	void UpdateSleepEnergy();
+
+	// Convenience method
+	EnergyModel* em() { return node()->energy_model(); }
+
+	friend class Sleep_Timer;
+
+};
+
+#endif /* !ns_WirelessPhy_h */
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mobile/pattern-antenna.cc ns-2.34/mobile/pattern-antenna.cc
--- ns-2.34-pure/mobile/pattern-antenna.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/mobile/pattern-antenna.cc	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,238 @@
+
+/*
+ * Copyright (c) 2003 University of Colorado, Boulder
+ * All rights reserved.
+ *
+ */
+
+#include <antenna.h>
+#include <pattern-antenna.h> 
+#include <math.h>
+#include <iostream>
+#include <fstream>
+#include <string>
+
+static class PatternAntennaClass : public TclClass {
+public:
+  PatternAntennaClass() : TclClass("Antenna/PatternAntenna") {}
+  TclObject* create(int, const char*const*) {
+    return (new PatternAntenna);
+  }
+} class_PatternAntenna;
+
+PatternAntenna::PatternAntenna() {
+  Dir_ = 0.0;
+  bind("Dir_", &Dir_);
+}
+
+double
+PatternAntenna::normalize(double deg) {
+  while (360.0 <= deg) {
+    deg -= 360.0;
+  }
+
+  while (0.0 > deg) {
+    deg += 360.0;
+  }
+
+  return deg;
+}
+
+double
+PatternAntenna::get_angle(double dX, double dY) {
+  double angle;
+
+  // First take care of dX or both == 0
+  if ((0.0 == dY) && (0.0 == dX)) {
+    angle = 0.0;
+  }
+  else if (0.0 == dX) {
+    angle = M_PI/2.0;
+  }
+  else {
+    angle = atan2(dY,dX);
+    if (0.0 > angle) {
+      angle += 2*M_PI;
+    }
+  }
+
+  angle = (180.0/M_PI) * angle;
+
+  return angle;
+}
+
+PatternAntenna::gain_pattern::gain_pattern() {
+  samplecount_ = 0;
+  samples_ = 0;
+}
+
+PatternAntenna::gain_pattern::~gain_pattern() {
+  if (samples_) {
+    free(samples_);
+    samples_ = 0;
+  }
+}
+
+void
+PatternAntenna::gain_pattern::set_gain_pattern(int samplecount,double* samples)
+{
+  if (samples_) {
+    free(samples_);
+    samples_ = 0;
+    samplecount = 0;
+  }
+  samples_ = (double*)malloc(samplecount*sizeof(double));
+  samplecount_ = samplecount;
+  sample_quantum_ = 360.0/samplecount_;
+  memcpy(samples_,samples,samplecount*sizeof(double));
+}
+
+double
+PatternAntenna::gain_pattern::get_gain(double angle) {
+  // Find closest sample to angle.
+  // XXX Maybe interpolate between samples at some point?
+  int whichsamp = ( (int)((angle/sample_quantum_) + 0.5) ) % samplecount_;
+  return samples_[whichsamp];
+}
+
+void
+PatternAntenna::gain_pattern::copy_pattern(gain_pattern& pat) {
+  set_gain_pattern(pat.samplecount_,pat.samples_);
+}
+
+// return the gain for a signal to a node at vector dX, dY, dZ
+// from the transmitter at wavelength lambda  
+double
+PatternAntenna::getTxGain(double dX, double dY, double dZ, double l) {
+  double angle = get_angle(dX,dY);
+  return horiz_tx_gain_.get_gain(angle);
+}
+
+// return the gain for a signal from a node at vector dX, dY, dZ
+// from the receiver at wavelength lambda
+double
+PatternAntenna::getRxGain(double dX, double dY, double dZ, double l) {
+  double angle = get_angle(dX,dY);
+  return horiz_rx_gain_.get_gain(angle);
+}
+
+void
+PatternAntenna::setHorizRxGainPattern(int samplecount, double* samples) {
+  horiz_rx_gain_.set_gain_pattern(samplecount,samples);
+}
+
+
+void
+PatternAntenna::setHorizTxGainPattern(int samplecount, double* samples) {
+  horiz_tx_gain_.set_gain_pattern(samplecount,samples);
+}
+
+
+// return a pointer to a copy of this antenna that will return the 
+// same thing for get{Rx,Tx}Gain that this one would at this point
+// in time.  This is needed b/c if a pkt is sent with a directable
+// antenna, this antenna may be have been redirected by the time we
+// call getTxGain on the copy to determine if the pkt is received.  
+Antenna*
+PatternAntenna::copy() {
+  PatternAntenna* antcopy =
+    (PatternAntenna*)TclObject::New("Antenna/PatternAntenna");
+  antcopy->horiz_rx_gain_.copy_pattern(horiz_rx_gain_);
+  antcopy->horiz_tx_gain_.copy_pattern(horiz_tx_gain_);
+  return antcopy;
+}
+
+void
+PatternAntenna::release() {
+  TclObject::Delete((TclObject*)this);
+}
+
+int
+PatternAntenna::read_pattern_from_msi(const char* msifile) {
+  // XXX This code is by no means great. It is simplistic
+  // and fragile, but I think it'll work well enough for the
+  // simplistic kinds of tasks we'll give it.
+  double gain;
+  double* hpoints = 0;
+  int hpointcount = 0;
+  string units;
+  string nxttok;
+  int i = 0;
+  //int result = 0;
+  int finalresult = 0;
+  ifstream msistrm(msifile);
+  // MSI uses 0 deg as due north, we have 0 deg as due east (and 90 as N).
+  // Add 90 deg to MSI numbers to fix this.
+  int hoffset = 90;
+  // MSI can use either dBd or dBi. I believe that ns-2 uses dBi.
+  // We'll set this appropriately when we get the units.
+  double gainoffset = 0.0;
+
+  if (!msistrm) {
+    return -1;
+  }
+
+  while (!msistrm.eof()) {
+    msistrm >> nxttok;
+
+    if (msistrm.eof()) {
+      continue;
+    }
+    else if ("GAIN" == nxttok) {
+      msistrm >> gain;
+      msistrm >> units;
+      //cout << "GAIN " << gain  << " " << units << endl;
+      gainoffset = 0.0;
+      if ("dBd" == units) {
+	gainoffset = 2.15;
+      }
+    }
+    else if ("HORIZONTAL" == nxttok) {
+      msistrm >> hpointcount;
+      //cout << "Horizontal pointcount: " << hpointcount << endl;
+      hpoints = (double*) malloc(hpointcount*sizeof(double));
+      for (i=0;i<hpointcount;i++) {
+	double index = 0;
+	double curpoint = 0;
+	msistrm >> index;
+	msistrm >> curpoint;
+	//cout << "POINTS: " << index << " " << curpoint << endl;
+	int hindx = (i + hoffset) % 360;
+	if (0 > hindx) hindx += 360;
+	hpoints[hindx] = gain - curpoint + gainoffset;
+      }
+    }
+  }
+
+  if (hpoints) {
+    if (hpointcount) {
+      // Assume same gain for Tx and Rx
+      setHorizRxGainPattern(hpointcount,hpoints);
+      setHorizTxGainPattern(hpointcount,hpoints);
+    }
+    free(hpoints);
+    hpoints = 0;
+    hpointcount = 0;
+  }
+  return finalresult;
+}
+
+int
+PatternAntenna::command(int argc, const char*const* argv)
+{
+  Tcl& tcl = Tcl::instance();
+  if (2 == argc) {
+  }
+  else if (3 == argc) {
+    if(strcmp(argv[1], "loadmsi") == 0) {
+      int result = read_pattern_from_msi(argv[2]);
+      tcl.resultf("%d",result);
+      return TCL_OK;
+    }
+  }
+  else if (4 == argc) {
+  } else if (argc == 5) {
+  }
+
+  return Antenna::command(argc, argv);
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mobile/pattern-antenna.h ns-2.34/mobile/pattern-antenna.h
--- ns-2.34-pure/mobile/pattern-antenna.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/mobile/pattern-antenna.h	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2003 University of Colorado, Boulder
+ * All rights reserved.
+ *
+ */
+
+#ifndef ns_patternantenna_h
+#define ns_patternantenna_h
+
+#include <antenna.h>
+
+class PatternAntenna : public Antenna {
+
+public:
+  PatternAntenna();
+  virtual int command(int argc, const char*const* argv);
+  // return the gain for a signal to a node at vector dX, dY, dZ
+  // from the transmitter at wavelength lambda  
+  virtual double getTxGain(double, double, double, double);
+
+  // return the gain for a signal from a node at vector dX, dY, dZ
+  // from the receiver at wavelength lambda
+  virtual double getRxGain(double, double, double, double);
+
+  // return a pointer to a copy of this antenna that will return the 
+  // same thing for get{Rx,Tx}Gain that this one would at this point
+  // in time.  This is needed b/c if a pkt is sent with a directable
+  // antenna, this antenna may be have been redirected by the time we
+  // call getTxGain on the copy to determine if the pkt is received.  
+  virtual Antenna* copy();
+  virtual void release();
+
+  void setDir(double newdir) { Dir_ = newdir; }
+  double getDir() { return Dir_; }
+
+  void setHorizRxGainPattern(int samplecount, double* samples);
+  void setHorizTxGainPattern(int samplecount, double* samples);
+
+  static double get_angle(double dX, double dY);
+  static double normalize(double deg);
+
+  int read_pattern_from_msi(const char* msifile);
+
+protected:
+  double Dir_;
+  typedef class gain_pattern {
+  public:
+    gain_pattern();
+    ~gain_pattern();
+    void set_gain_pattern(int samplecount, double* samples);
+    double get_gain(double angle);
+    void copy_pattern(gain_pattern& pat);
+
+  protected:
+    int samplecount_;
+    double* samples_;
+    double sample_quantum_;
+  };
+
+  gain_pattern horiz_tx_gain_;
+  gain_pattern horiz_rx_gain_;
+};
+
+
+#endif // ns_uniantenna_h
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mobile/uni-antenna.cc ns-2.34/mobile/uni-antenna.cc
--- ns-2.34-pure/mobile/uni-antenna.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/mobile/uni-antenna.cc	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,197 @@
+
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Daedalus Research
+ *	Group at the University of California Berkeley.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+
+ * Ported from CMU/Monarch's code, nov'98 -Padma.
+   omni-antenna.cc
+   */
+
+#include <antenna.h>
+#include <uni-antenna.h> 
+#include <math.h>
+
+static class UniAntennaClass : public TclClass {
+public:
+  UniAntennaClass() : TclClass("Antenna/UniAntenna") {}
+  TclObject* create(int, const char*const*) {
+    return (new UniAntenna);
+  }
+} class_UniAntenna;
+
+UniAntenna::UniAntenna() : is_copy_(false) {
+  Gt_ = 1.0;
+  Gr_ = 1.0;
+  GtOmni_ = 0.0;
+  GrOmni_ = 0.0;
+  Dir_ = 0.0;
+  Width_ = 360.0;
+  bind("Gt_", &Gt_);
+  bind("Gr_", &Gr_);
+  bind("GtOmni_", &GtOmni_);
+  bind("GrOmni_", &GrOmni_);
+  bind("Dir_", &Dir_);
+  bind("Width_", &Width_);
+}
+
+double
+UniAntenna::normalize(double deg) {
+  while (360.0 <= deg) {
+    deg -= 360.0;
+  }
+
+  while (0.0 > deg) {
+    deg += 360.0;
+  }
+
+  return deg;
+}
+
+double
+UniAntenna::get_angle(double dX, double dY) {
+  double angle;
+
+  // First take care of dX or both == 0
+  if ((0.0 == dY) && (0.0 == dX)) {
+    angle = 0.0;
+  }
+  else if (0.0 == dX) {
+    angle = M_PI/2.0;
+  }
+  else {
+    angle = atan2(dY,dX);
+    if (0.0 > angle) {
+      angle += 2*M_PI;
+    }
+  }
+
+  angle = (180.0/M_PI) * angle;
+
+  return angle;
+}
+
+void
+UniAntenna::get_cone(double& lb, double& ub) {
+  lb = Dir_ - (Width_/2.0);
+  ub = Dir_ + (Width_/2.0);
+  lb = normalize(lb);
+  ub = normalize(ub);
+}
+
+bool
+UniAntenna::is_in_cone(double dX, double dY) {
+  bool result = false;
+  double angle = get_angle(dX,dY);
+  double lb, ub;
+  get_cone(lb,ub);
+
+  // If lb and ub are swapped, we had a wraparound. In this
+  // case, the specified range is the inverse of the cone
+  // we want to check for.
+  if (lb > ub) {
+    result = ! ((ub <= angle) && (angle <= lb));
+  }
+  else if (lb == ub) {
+    result = true;
+  }
+  else {
+    result = (lb <= angle) && (angle <= ub);
+  }
+
+  return result;
+}
+
+// return the gain for a signal to a node at vector dX, dY, dZ
+// from the transmitter at wavelength lambda  
+double
+UniAntenna::getTxGain(double dX, double dY, double dZ, double l) {
+  // XXX for now ignore dZ, just do 2 dimensions, and ignore lambda, too
+  double gain = Gt_;
+
+  // XXX very stupid model. Gt_ gain within cone, GtOmni_ outside.
+  // Hopefully good enough for what we need initially...
+  if (is_in_cone(dX,dY)) {
+    gain = Gt_;
+  }
+  else {
+    gain = GtOmni_;
+  }
+  
+  return gain;
+}
+
+// return the gain for a signal from a node at vector dX, dY, dZ
+// from the receiver at wavelength lambda
+double
+UniAntenna::getRxGain(double dX, double dY, double dZ, double l) {
+  // XXX for now ignore dZ, just do 2 dimensions, and ignore lambda, too.
+  double gain = Gr_;
+
+  // XXX very stupid model. Gr_ gain within cone, GrOmni_ outside.
+  // Hopefully good enough for what we need initially...
+  if (is_in_cone(dX,dY)) {
+    gain = Gr_;
+  }
+  else {
+    gain = GrOmni_;
+  }
+
+  return gain;
+}
+
+// return a pointer to a copy of this antenna that will return the 
+// same thing for get{Rx,Tx}Gain that this one would at this point
+// in time.  This is needed b/c if a pkt is sent with a directable
+// antenna, this antenna may be have been redirected by the time we
+// call getTxGain on the copy to determine if the pkt is received.  
+Antenna*
+UniAntenna::copy() {
+  UniAntenna* antcopy = (UniAntenna*)TclObject::New("Antenna/UniAntenna");
+  antcopy->X_ = X_;
+  antcopy->Y_ = Y_;
+  antcopy->Z_ = Z_;
+  antcopy->Gt_ = Gt_;
+  antcopy->Gr_ = Gr_;
+  antcopy->Dir_ = Dir_;
+  antcopy->Width_ = Width_;
+  antcopy->is_copy_ = true;
+  return antcopy;
+}
+
+void
+UniAntenna::release() {
+  if (is_copy_) {
+    TclObject::Delete((TclObject*)this);
+  }
+}
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/mobile/uni-antenna.h ns-2.34/mobile/uni-antenna.h
--- ns-2.34-pure/mobile/uni-antenna.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/mobile/uni-antenna.h	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,82 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+/* Ported from CMU/Monarch's code, nov'98 -Padma.
+   omni-antenna.h
+   omni-directional antenna
+
+*/
+
+#ifndef ns_uniantenna_h
+#define ns_uniantenna_h
+
+#include <antenna.h>
+
+class UniAntenna : public Antenna {
+
+public:
+  UniAntenna();
+
+  // return the gain for a signal to a node at vector dX, dY, dZ
+  // from the transmitter at wavelength lambda  
+  virtual double getTxGain(double, double, double, double);
+
+  // return the gain for a signal from a node at vector dX, dY, dZ
+  // from the receiver at wavelength lambda
+  virtual double getRxGain(double, double, double, double);
+
+  // return a pointer to a copy of this antenna that will return the 
+  // same thing for get{Rx,Tx}Gain that this one would at this point
+  // in time.  This is needed b/c if a pkt is sent with a directable
+  // antenna, this antenna may be have been redirected by the time we
+  // call getTxGain on the copy to determine if the pkt is received.  
+  virtual Antenna* copy();
+  virtual void release();
+
+  static double get_angle(double dX, double dY);
+  static double normalize(double deg);
+  bool is_in_cone(double dX, double dY);
+  void get_cone(double& lb,double& ub);
+
+protected:
+  double Gt_;			// gain of transmitter (db)
+  double Gr_;			// gain of receiver (db)
+  double GtOmni_;               // Tx gain outside of cone
+  double GrOmni_;               // Rx gain outside of cone
+  double Dir_;
+  double Width_;
+  bool is_copy_;
+};
+
+
+#endif // ns_uniantenna_h
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/queue/clickqueue.cc ns-2.34/queue/clickqueue.cc
--- ns-2.34-pure/queue/clickqueue.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/queue/clickqueue.cc	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,144 @@
+/*
+ * clickqueue.cc
+ * Special queue which runs the external Click router when it unblocks
+ *
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#include <stdlib.h>
+#include <ctype.h>
+#include <sys/time.h>
+#include <unistd.h>
+//#include <stl.h>
+//#include <hash_map.h>
+#include <map>
+#include <math.h>
+#include <string>
+#include <click/simclick.h>
+#include "packet.h"
+#include "extrouter.h"
+#include "classifier.h"
+#include "classifier-ext.h"
+#include "classifier-click.h"
+#include "clickqueue.h"
+
+static class ClickQueueClass : public TclClass {
+public:
+	ClickQueueClass() : TclClass("Queue/ClickQueue") {}
+	TclObject* create(int, const char*const*) {
+		return (new ClickQueue);
+	}
+} class_click_queue;
+
+int 
+ClickQueue::command(int argc, const char*const* argv) {
+	if (3 == argc) {
+		if (!strcmp(argv[1],"setclickclassifier")) {
+			cc_ = (ClickClassifier*)TclObject::lookup(argv[2]);
+			return TCL_OK;
+		}
+	}
+	return Queue::command(argc, argv);
+}
+/*
+ * drop-tail
+ */
+ClickQueue::ClickQueue() { 
+	pq_ = new PacketQueue; 
+	qlim_ = 1;
+	cc_ = 0;
+}
+
+ClickQueue::~ClickQueue() {
+	delete pq_;
+}
+
+int
+ClickQueue::is_full() {
+	return (pq_->length() >= qlim_);
+}
+
+int
+ClickQueue::ready() {
+	return (!is_full() && !blocked());
+}
+
+void ClickQueue::enque(Packet* p)
+{
+	pq_->enque(p);
+	if (pq_->length() > qlim_) {
+		fprintf(stderr,"Hey!!! IFQ Overflow!!!\n");
+		Packet *pp = pq_->deque();
+		drop(pp);
+	}
+}
+
+Packet* ClickQueue::deque()
+{
+	Packet* retval = pq_->deque();
+	return retval;
+}
+
+void ClickQueue::on_unblock() {
+	//
+	// Queue has space - run the external router 
+	// and give it a chance to fill things up.
+	//
+	if (cc_) {
+		Scheduler& s = Scheduler::instance();
+		double dcurtime = s.clock();
+		double fracp, intp;
+		fracp = modf(dcurtime,&intp);
+		cc_->simclick_node_t::curtime.tv_sec = intp;
+		cc_->simclick_node_t::curtime.tv_usec = (fracp*1.0e6+0.5);
+		simclick_click_run(cc_);
+	}
+}
+
+#if 0
+void ClickQueue::runclick() {
+	if (is_full()) {
+		return;
+	}
+	//
+	// Queue has space - run the external router 
+	// and give it a chance to fill things up.
+	//
+	if (cc_) {
+		simclick_click clickinst = cc_->GetClickinst();
+		Scheduler& s = Scheduler::instance();
+		double dcurtime = s.clock();
+		simclick_simstate curstate;
+		memset(&curstate,0,sizeof(curstate));
+		double fracp, intp;
+		fracp = modf(dcurtime,&intp);
+		curstate.curtime.tv_sec = intp;
+		curstate.curtime.tv_usec = (fracp*1.0e6+0.5);
+		simclick_click_run(clickinst,&curstate);
+	}
+}
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/queue/clickqueue.h ns-2.34/queue/clickqueue.h
--- ns-2.34-pure/queue/clickqueue.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/queue/clickqueue.h	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,61 @@
+/*
+ * clickqueue.h
+ * Special queue which runs the external Click router when it unblocks
+ *
+ */
+
+/*****************************************************************************
+ *  Copyright 2002, Univerity of Colorado at Boulder.                        *
+ *                                                                           *
+ *                        All Rights Reserved                                *
+ *                                                                           *
+ *  Permission to use, copy, modify, and distribute this software and its    *
+ *  documentation for any purpose other than its incorporation into a        *
+ *  commercial product is hereby granted without fee, provided that the      *
+ *  above copyright notice appear in all copies and that both that           *
+ *  copyright notice and this permission notice appear in supporting         *
+ *  documentation, and that the name of the University not be used in        *
+ *  advertising or publicity pertaining to distribution of the software      *
+ *  without specific, written prior permission.                              *
+ *                                                                           *
+ *  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      *
+ *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        *
+ *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    *
+ *  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         *
+ *  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA       *
+ *  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER        *
+ *  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         *
+ *  PERFORMANCE OF THIS SOFTWARE.                                            *
+ *                                                                           *
+ ****************************************************************************/
+
+#ifndef ns_clickqueue_h
+#define ns_clickqueue_h
+
+#include <string.h>
+#include "queue.h"
+#include "config.h"
+
+/*
+ * A degenerate queue designed to work with Click routers. Should only
+ * have 1 packet ever sitting in it since the queueing should be handled
+ * by Click. Also makes sure that simclick gets run whenever the queue
+ * empties and unblocks so that the polling simulated network driver
+ * will insert packets when it has them.
+ */
+class ClickQueue : public Queue {
+  public:
+	ClickQueue();
+	~ClickQueue();
+	void enque(Packet*);
+	Packet* deque();
+
+	int is_full();
+	int ready();
+  protected:
+	int command(int argc, const char*const* argv); 
+	ClickClassifier* cc_;
+	virtual void on_unblock();
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/queue/queue.cc ns-2.34/queue/queue.cc
--- ns-2.34-pure/queue/queue.cc	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/queue/queue.cc	2010-02-28 09:31:39.000000000 -0800
@@ -218,6 +218,7 @@
 			utilUpdate(last_change_, now, blocked_);
 			last_change_ = now;
 			blocked_ = 0;
+			on_unblock();
 		}
 		else {
 			utilUpdate(last_change_, now, blocked_);
@@ -227,6 +228,10 @@
 	}
 }
 
+void Queue::on_unblock() {
+	// Do nothing in base class
+}
+
 void Queue::reset()
 {
 	Packet* p;
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/queue/queue.h ns-2.34/queue/queue.h
--- ns-2.34-pure/queue/queue.h	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/queue/queue.h	2010-02-28 09:31:39.000000000 -0800
@@ -145,6 +145,7 @@
 protected:
 	Queue();
 	void reset();
+	virtual void on_unblock();
 	int qlim_;		/* maximum allowed pkts in queue */
 	int blocked_;		/* blocked now? */
 	int unblock_on_resume_;	/* unblock q on idle? */
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/routing/extclickrouter.cc ns-2.34/routing/extclickrouter.cc
--- ns-2.34-pure/routing/extclickrouter.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/routing/extclickrouter.cc	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,20 @@
+/*
+ * XXX Insert CU copyright stuff here...
+ *
+ */
+
+#include "packet.h"
+#include "extrouter.h"
+#include "extclickrouter.h"
+
+ExtClickRouter::ExtClickRouter() {
+}
+
+ExtClickRouter::~ExtClickRouter() {
+}
+
+int ExtClickRouter::recv(Packet* p) {
+  int result = 0;
+
+  return result;
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/routing/extclickrouter.h ns-2.34/routing/extclickrouter.h
--- ns-2.34-pure/routing/extclickrouter.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/routing/extclickrouter.h	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,27 @@
+/*
+ * XXX Insert CU copyright stuff here...
+ * 
+ * This defines the interface used by all external raw packet routing
+ * modules bolted on to ns.
+ *
+ */
+
+#ifndef __ns_extclickrouter_h__
+#define __ns_extclickrouter_h__
+
+class ExtClickRouter
+{
+
+ public:
+  ExtClickRouter();
+  virtual ~ExtClickRouter();
+  virtual int recv(Packet* p);
+
+  void* SetClickRouterPtr(void* crtptr);
+
+ private:
+  void* clickrouter_;
+  
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/routing/extrouter.cc ns-2.34/routing/extrouter.cc
--- ns-2.34-pure/routing/extrouter.cc	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/routing/extrouter.cc	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,15 @@
+/*
+ * XXX Insert CU copyright stuff here...
+ * 
+ * This defines the interface used by all external raw packet routing
+ * modules bolted on to ns.
+ *
+ */
+
+#include "packet.h"
+#include "extrouter.h"
+
+// Just here so we get virtual destructors
+ExtRouter::~ExtRouter() {
+}
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/routing/extrouter.h ns-2.34/routing/extrouter.h
--- ns-2.34-pure/routing/extrouter.h	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/routing/extrouter.h	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,29 @@
+/*
+ * XXX Insert CU copyright stuff here...
+ * 
+ * This defines the interface used by all external raw packet routing
+ * modules bolted on to ns.
+ *
+ */
+
+#ifndef __ns_extrouter_h__
+#define __ns_extrouter_h__
+
+class ExtRouter
+{
+
+public:
+  enum {
+    IFID_NONE = -1,
+    IFID_KERNELTAP = 0,
+    IFID_FIRSTIF = 1,
+    IFID_LASTIF = 32,
+    IFID_FIRSTIFDROP = 33,
+    IFID_LASTIFDROP = 64
+  };
+  virtual ~ExtRouter();
+  virtual int route(Packet* p) = 0;
+  
+};
+
+#endif
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/routing/rtmodule.cc ns-2.34/routing/rtmodule.cc
--- ns-2.34-pure/routing/rtmodule.cc	2009-06-14 10:35:43.000000000 -0700
+++ ns-2.34/routing/rtmodule.cc	2010-02-28 09:31:39.000000000 -0800
@@ -137,6 +137,14 @@
         }
 } class_lms_routing_module;
 
+static class ClickRoutingModuleClass : public TclClass {
+public:
+        ClickRoutingModuleClass() : TclClass("RtModule/Click") {}
+        TclObject* create(int, const char*const*) {
+                return (new ClickRoutingModule);
+        }
+} class_click_routing_module;
+
 RoutingModule::RoutingModule() : 
 	next_rtm_(NULL), n_(NULL), classifier_(NULL) {
 	bind("classifier_", (TclObject**)&classifier_);
@@ -508,4 +516,3 @@
 	if (next_rtm_ != NULL)
 		next_rtm_->add_route(dst, target); 
 }
-
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/routing/rtmodule.h ns-2.34/routing/rtmodule.h
--- ns-2.34-pure/routing/rtmodule.h	2009-06-14 10:35:43.000000000 -0700
+++ ns-2.34/routing/rtmodule.h	2010-02-28 09:31:39.000000000 -0800
@@ -178,4 +178,10 @@
 	virtual void add_route(char *dst, NsObject *target){}
 };
 
+class ClickRoutingModule : public RoutingModule {
+public:
+        ClickRoutingModule() : RoutingModule() {}
+        virtual const char* module_name() const { return "Click"; }
+};
+
 #endif //  ns_rtmodule_h
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/ex/nsclick-raw-wlan.click ns-2.34/tcl/ex/nsclick-raw-wlan.click
--- ns-2.34-pure/tcl/ex/nsclick-raw-wlan.click	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/ex/nsclick-raw-wlan.click	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,114 @@
+//
+//  Copyright 2002, Univerity of Colorado at Boulder.                        
+//                                                                            
+//                         All Rights Reserved                                
+//                                                                            
+//  Permission to use, copy, modify, and distribute this software and its    
+//  documentation for any purpose other than its incorporation into a        
+//  commercial product is hereby granted without fee, provided that the      
+//  above copyright notice appear in all copies and that both that           
+//  copyright notice and this permission notice appear in supporting         
+//  documentation, and that the name of the University not be used in        
+//  advertising or publicity pertaining to distribution of the software      
+//  without specific, written prior permission.                              
+//                                                                            
+//  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+//  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+//  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+//  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+//  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+//  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+//  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+//  PERFORMANCE OF THIS SOFTWARE.                                            
+//
+
+// nsclick-simple-lan.click
+//
+// This is a simple and stupid flat routing mechanism.
+// It broadcasts ARP requests if it wants to find a destination
+// address, and it responds to ARP requests made for it.
+
+elementclass DumbRouter {
+  $myaddr, $myaddr_ethernet |
+
+  class :: Classifier(12/0806 20/0001,12/0806 20/0002, -);
+  mypackets :: IPClassifier(dst host $myaddr,-);
+  myarpquerier :: ARPQuerier($myaddr,$myaddr_ethernet);
+  myarpresponder :: ARPResponder($myaddr $myaddr_ethernet);
+
+  rinfo::AvailableRates(DEFAULT 2 4 11 22)
+  rateselection::MadwifiRate(RT rinfo,ACTIVE true,OFFSET 4);
+  wlinfo :: WirelessInfo(SSID raw, BSSID 01:01:01:01:01:01,CHANNEL 2, IFID 0);
+  ethout :: Queue 	
+	-> WifiEncap(0x0, WIRELESS_INFO wlinfo)	
+	-> rateselection
+	-> PrintWifi(eth0_out)
+	-> ToDump(out_eth0,PER_NODE 1,ENCAP 802_11)
+	-> ExtraEncap()
+	-> ToSimDevice(eth0);
+
+  FromSimDevice(eth0,4096)
+	-> ExtraDecap()
+	-> filtertx::FilterTX()
+	-> ToDump(in_eth0,PER_NODE 1,ENCAP 802_11)
+	-> WifiDecap()
+	-> Print(eth0,64)	
+	-> HostEtherFilter($myaddr_ethernet)
+	-> class;
+
+  // transmission is fed back to the rate selection module	
+  filtertx[1]
+	-> [1]rateselection;
+
+  // ARP queries from other nodes go to the ARP responder module
+  class[0] -> myarpresponder;
+
+  // ARP responses go to our query module
+  class[1] -> [1]myarpquerier;
+
+  // All other packets get checked to see if they're meant for us
+  class[2]				
+	-> Strip(14)
+	-> CheckIPHeader
+	-> MarkIPHeader
+	-> GetIPAddress(16)
+	-> mypackets; 
+
+  // Packets for us go to "tap0" which sends them to the kernel
+  mypackets[0]
+	-> IPPrint(tokernel) 
+	-> ToDump(tokernel,2000,IP,PER_NODE 1) 
+	-> ToSimDevice(tap0,IP);
+
+  // Packets for other folks or broadcast packets get discarded
+  mypackets[1]
+	-> Print(discard,64)
+	-> ToDump(discard,2000,PER_NODE 1)
+	-> Discard;
+
+  // Packets sent out by the "kernel" get pushed into the ARP query module
+  FromSimDevice(tap0,4096)
+	-> CheckIPHeader 
+	-> IPPrint(fromkernel) 
+	-> ToDump(fromkernel,2000,IP,PER_NODE 1)
+	-> GetIPAddress(16)
+	-> myarpquerier;
+
+  // Both the ARP query and response modules send data out to
+  // the simulated network device, eth0.
+  myarpquerier
+	-> Print(fromarpquery,64)
+	-> ToDump(out_arpquery,PER_NODE 1)
+	-> ethout;
+
+  myarpresponder
+	-> Print(arpresponse,64)
+	-> ToDump(out_arprespond,PER_NODE 1)
+	-> ethout;
+}
+
+
+u :: DumbRouter(eth0,eth0);
+
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/ex/nsclick-raw-wlan.tcl ns-2.34/tcl/ex/nsclick-raw-wlan.tcl
--- ns-2.34-pure/tcl/ex/nsclick-raw-wlan.tcl	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/ex/nsclick-raw-wlan.tcl	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,331 @@
+#
+#  Copyright 2002, Univerity of Colorado at Boulder.                        
+#                                                                            
+#                         All Rights Reserved                                
+#                                                                            
+#  Permission to use, copy, modify, and distribute this software and its    
+#  documentation for any purpose other than its incorporation into a        
+#  commercial product is hereby granted without fee, provided that the      
+#  above copyright notice appear in all copies and that both that           
+#  copyright notice and this permission notice appear in supporting         
+#  documentation, and that the name of the University not be used in        
+#  advertising or publicity pertaining to distribution of the software      
+#  without specific, written prior permission.                              
+#                                                                            
+#  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+#  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+#  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+#  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+#  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+#  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+#  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+#  PERFORMANCE OF THIS SOFTWARE.                                            
+#
+# nsclick-simple-lan.tcl
+#
+# A sample nsclick script simulating a small LAN
+#
+
+#
+#	Modified by Nicolas Letor to support wifi elements.
+# 	Performance Analysis of Telecommunication Systems (PATS) research group,
+# 	Interdisciplinary Institute for Broadband Technology (IBBT) & Universiteit Antwerpen.
+#
+
+#
+# Set some general simulation parameters
+#
+
+#
+# Unity gain, omnidirectional antennas, centered 1.5m above each node.
+# These values are lifted from the ns-2 sample files.
+#
+
+Antenna/OmniAntenna set X_ 0
+Antenna/OmniAntenna set Y_ 0
+Antenna/OmniAntenna set Z_ 1.5
+Antenna/OmniAntenna set Gt_ 1.0
+Antenna/OmniAntenna set Gr_ 1.0
+
+#
+# Initialize the SharedMedia interface with parameters to make
+# it work like the 914MHz Lucent WaveLAN DSSS radio interface
+# These are taken directly from the ns-2 sample files.
+#
+Phy/WirelessPhy set CPThresh_ 10.0
+Phy/WirelessPhy set CSThresh_ 1.559e-11
+Phy/WirelessPhy set RXThresh_ 3.652e-10
+Phy/WirelessPhy set Rb_ 2*1e6
+Phy/WirelessPhy set Pt_ 0.2818
+Phy/WirelessPhy set freq_ 914e+6 
+Phy/WirelessPhy set L_ 1.0
+
+# Configure multirate aspect
+Phy/WirelessPhy set RateCount_ 4
+Phy/WirelessPhy set Rate0 11e6
+Phy/WirelessPhy set Rate1 5.5e6
+Phy/WirelessPhy set Rate2 2e6
+Phy/WirelessPhy set Rate3 1e6
+Phy/WirelessPhy set RXThresh0 1.427e-08 ;# 100m transmission range
+Phy/WirelessPhy set RXThresh1 2.818e-09 ;# 150m transmission range
+Phy/WirelessPhy set RXThresh2 8.916e-10 ;# 200m transmission range
+Phy/WirelessPhy set RXThresh3 3.652e-10 ;# 250m transmission range
+
+# 
+# Set the size of the playing field and the topography.
+#
+set xsize 100
+set ysize 100
+set wtopo	[new Topography]
+$wtopo load_flatgrid $xsize $ysize
+set gkeeper [new GridKeeper]
+$gkeeper dimension $xsize $ysize
+
+#
+# The network channel, physical layer, MAC, propagation model,
+# and antenna model are all standard ns-2.
+#  
+set netchan	Channel/WirelessChannel
+set netphy	Phy/WirelessPhy
+set netmac	Mac/802_11
+set netprop     Propagation/TwoRayGround
+set antenna     Antenna/OmniAntenna
+
+#
+# We have to use a special queue and link layer. This is so that
+# Click can have control over the network interface packet queue,
+# which is vital if we want to play with, e.g. QoS algorithms.
+#
+set netifq	Queue/ClickQueue
+set netll	LL/Ext
+LL set delay_			1ms
+
+#
+# These are pretty self-explanatory, just the number of nodes
+# and when we'll stop.
+#
+set nodecount   4
+set stoptime	10.0
+
+#
+# With nsclick, we have to worry about details like which network
+# port to use for communication. This sets the default ports to 5000.
+#
+Agent/Null set sport_		5000
+Agent/Null set dport_		5000
+
+Agent/CBR set sport_		5000
+Agent/CBR set dport_		5000
+
+#
+# Standard ns-2 stuff here - create the simulator object.
+#
+Simulator set MacTrace_ ON
+set ns_		[new Simulator]
+
+#
+# Create and activate trace files.
+#
+set tracefd	[open "nsclick-raw-wlan.tr" w]
+set namtrace    [open "nsclick-raw-wlan.nam" w]
+$ns_ trace-all $tracefd
+$ns_ namtrace-all-wireless $namtrace $xsize $ysize
+$ns_ use-newtrace
+
+
+#
+# Create the "god" object. This is another artifact of using
+# the mobile node type. We have to have this even though
+# we never use it.
+#
+set god_ [create-god $nodecount]
+
+#
+# Tell the simulator to create Click nodes.
+#
+Simulator set node_factory_ Node/MobileNode/ClickNode
+
+#
+# Create a network Channel for the nodes to use. One channel
+# per LAN. Create 13 channels of the 802.11 MAC layer
+for {set i 0} { $i <= 13} {incr i} {
+	set chan_($i) [new Channel/WirelessChannel]	
+}
+# And implement a channel switching function to WirelessInfo 
+# to switch from one channel to another channel
+proc SwitchChannel { i whichif whichnewchannel } {
+	global node_ chan_
+	if { $whichnewchannel > 0 } {
+#		set ns_ [Simulator instance] 
+#		set node [ $ns_ Node($i) ]
+		$node_($i) changechannel $whichif $chan_($whichnewchannel)
+		puts "Node $i changes if $whichif to channel $whichnewchannel"
+	}
+}
+
+#Also set the propagation model to be used.
+set prop_ [new $netprop]
+
+#
+# In nsclick we have to worry about assigning IP and MAC addresses
+# to out network interfaces. Here we generate a list of IP and MAC
+# addresses, one per node since we've only got one network interface
+# per node in this case. Also note that this scheme only works for
+# fewer than 255 nodes, and we aren't worrying about subnet masks.
+#
+set iptemplate "192.168.1.%d"
+set mactemplate "00:03:47:70:89:%0x"
+for {set i 0} {$i < $nodecount} {incr i} {
+    set node_ip($i) [format $iptemplate [expr $i+1]]
+    set node_mac($i) [format $mactemplate [expr $i+1]]
+}
+
+#
+# We set the routing protocol to "Empty" so that ns-2 doesn't do
+# any packet routing. All of the routing will be done by the
+# Click script.
+#
+$ns_ rtproto Empty
+
+#
+# Here is where we actually create all of the nodes.
+#
+for {set i 0} {$i < $nodecount } {incr i} {
+    set node_($i) [$ns_ node]
+
+    #
+    # After creating the node, we add one wireless network interface to
+    # it. By default, this interface will be named "eth0". If we
+    # added a second interface it would be named "eth1", a third
+    # "eth2" and so on.
+    #
+    $node_($i) add-interface $chan_(1) $prop_ $netll $netmac \
+	$netifq 1 $netphy $antenna $wtopo
+
+    #
+    # Now configure the interface eth0
+    #
+    $node_($i) setip "eth0" $node_ip($i)
+    $node_($i) setmac "eth0" $node_mac($i)
+
+    #
+    # Set some node properties
+    #
+    $gkeeper addnode $node_($i)
+    $node_($i) radius 1000
+    $node_($i) random-motion 0
+    $node_($i) topography $wtopo
+    $node_($i) nodetrace $tracefd
+
+    #
+    # The node name is used by Click to distinguish information
+    # coming from different nodes. For example, a "Print" element
+    # prepends this to the printed string so it's clear exactly
+    # which node is doing the printing.
+    #
+    [$node_($i) set classifier_] setnodename "node$i-simplelan"
+    
+    #
+    # Load the appropriate Click router script for the node.
+    # All nodes in this simulation are using the same script,
+    # but there's no reason why each node couldn't use a different
+    # script.
+    #
+    [$node_($i) entry] loadclick "nsclick-raw-wlan.click"
+}
+
+
+# 
+# Define node network traffic. There isn't a whole lot going on
+# in this simple test case, we're just going to have the first node
+# send packets to the last node, starting at 1 second, and ending at 10.
+# There are Perl scripts available to automatically generate network
+# traffic.
+#
+
+
+#
+# Start transmitting at $startxmittime, $xmitrate packets per second.
+#
+set startxmittime 1
+set xmitrate 4
+set xmitinterval 0.25
+set packetsize 64
+
+#
+# We use the "raw" packet type, which sends real packet data
+# down the pipe.
+#
+set raw_(0) [new Agent/Raw]
+$ns_ attach-agent $node_(0) $raw_(0)
+
+set lastnode [expr $nodecount-1]
+set null_(0) [new Agent/Null]
+$ns_ attach-agent $node_($lastnode) $null_(0)
+
+#
+# The CBR object is just the default ns-2 CBR object, so
+# no change in the meaning of the parameters.
+#
+set cbr_(0) [new Application/Traffic/CBR]
+$cbr_(0) set packetSize_ $packetsize
+$cbr_(0) set interval_ $xmitinterval
+$cbr_(0) set random_ 0
+$cbr_(0) set maxpkts_ [expr ($stoptime - $startxmittime)*$xmitrate]
+$cbr_(0) attach-agent $raw_(0)
+
+#
+# The Raw agent creates real UDP packets, so it has to know
+# the source and destination IP addresses and port numberes.
+#
+$raw_(0) set-srcip [$node_(0) getip eth0]
+$raw_(0) set-srcport 5000
+$raw_(0) set-destport 5000
+$raw_(0) set-destip [$node_($lastnode) getip eth0]
+
+$ns_ at $startxmittime "$cbr_(0) start"
+
+
+$node_(0) set X_ 10
+$node_(0) set Y_ 50
+$node_(0) set Z_ 0
+
+$node_(1) set X_ 50
+$node_(1) set Y_ 50
+$node_(1) set Z_ 0
+
+$node_(2) set X_ 90
+$node_(2) set Y_ 50
+$node_(2) set Z_ 0
+
+$node_(3) set X_ 50
+$node_(3) set Y_ 10
+$node_(3) set Z_ 0
+
+
+#
+# This sizes the nodes for use in nam. Currently, the trace files
+# produced by nsclick don't really work in nam.
+#
+for {set i 0} {$i < $nodecount} {incr i} {
+    $ns_ initial_node_pos $node_($i) 20
+    [$node_($i) entry] runclick
+}
+
+#
+# Stop the simulation
+#
+$ns_ at  $stoptime.000000001 "puts \"NS EXITING...\" ; $ns_ halt"
+
+#
+# Let nam know that the simulation is done.
+#
+$ns_ at  $stoptime	"$ns_ nam-end-wireless $stoptime"
+
+
+puts "Starting Simulation..."
+$ns_ run
+
+
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/ex/nsclick-simple-bridge.click ns-2.34/tcl/ex/nsclick-simple-bridge.click
--- ns-2.34-pure/tcl/ex/nsclick-simple-bridge.click	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/ex/nsclick-simple-bridge.click	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,40 @@
+//
+//  Copyright 2002, Univerity of Colorado at Boulder.                        
+//                                                                            
+//                         All Rights Reserved                                
+//                                                                            
+//  Permission to use, copy, modify, and distribute this software and its    
+//  documentation for any purpose other than its incorporation into a        
+//  commercial product is hereby granted without fee, provided that the      
+//  above copyright notice appear in all copies and that both that           
+//  copyright notice and this permission notice appear in supporting         
+//  documentation, and that the name of the University not be used in        
+//  advertising or publicity pertaining to distribution of the software      
+//  without specific, written prior permission.                              
+//                                                                            
+//  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+//  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+//  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+//  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+//  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+//  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+//  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+//  PERFORMANCE OF THIS SOFTWARE.                                            
+//
+
+// nsclick-simple-bridge.click
+//
+// This is a simple and stupid network "bridge." Packets coming
+// in off of eth0 are pumped out on eth1, and packets coming
+// in off of eth1 are pumped out on eth0.
+//
+
+FromSimDevice(eth0,4096)
+	-> Queue
+	-> ToSimDevice(eth1);
+	
+FromSimDevice(eth1,4096)
+	-> Queue
+	-> ToSimDevice(eth0);
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/ex/nsclick-simple-hybrid.nam ns-2.34/tcl/ex/nsclick-simple-hybrid.nam
--- ns-2.34-pure/tcl/ex/nsclick-simple-hybrid.nam	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/ex/nsclick-simple-hybrid.nam	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,371 @@
+n -t * -s 0  -x 10 -y 50 -Z 0 -z 10  -v circle -c black
+n -t * -s 1  -x 50 -y 50 -Z 0 -z 10  -v circle -c black
+n -t * -s 2  -x 90 -y 50 -Z 0 -z 10  -v circle -c black
+n -t * -s 3  -x 10 -y 0 -Z 0 -z 10  -v circle -c black
+n -t * -s 4  -x 50 -y 0 -Z 0 -z 10  -v circle -c black
+n -t * -s 5  -x 90 -y 0 -Z 0 -z 10  -v circle -c black
+n -t * -s 6  -x 50 -y 10 -Z 0 -z 10  -v circle -c black
+V -t * -v 1.0a5 -a 0
+W -t * -x 100 -y 100
+A -t * -n 1 -p 0 -o 0xffffffff -c 31 -a 1
+A -t * -h 1 -m 2147483647 -s 0
++ -t 1.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT 
+- -t 1.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT
+h -t 1.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT
+r -t 1.016121766 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT
+r -t 1.018301766 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT
+r -t 1.021761766 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT
+r -t 1.027061766 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT
+r -t 1.035561766 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT
+r -t 1.057281766 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT
+r -t 1.066501766 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT
++ -t 1.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT 
+- -t 1.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT
+h -t 1.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT
+r -t 1.255530989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT
+r -t 1.257510989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT
+r -t 1.261230989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT
+r -t 1.266170989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT
+r -t 1.273130989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT
+r -t 1.276750989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT
+r -t 1.279670989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT
++ -t 1.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT 
+- -t 1.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT
+h -t 1.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT
+r -t 1.505770989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT
+r -t 1.507390989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT
+r -t 1.509190989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT
+r -t 1.511290989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT
+r -t 1.520050989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT
+r -t 1.537710989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT
+r -t 1.551250989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT
++ -t 1.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT 
+- -t 1.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT
+h -t 1.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT
+r -t 1.755730989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT
+r -t 1.757350989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT
+r -t 1.760310989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT
+r -t 1.765530989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT
+r -t 1.769510989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT
+r -t 1.777590989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT
+r -t 1.790930989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT
++ -t 2.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT 
+- -t 2.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT
+h -t 2.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT
+r -t 2.005590989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT
+r -t 2.007810989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT
+r -t 2.010790989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT
+r -t 2.016050989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT
+r -t 2.026670989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT
+r -t 2.033350989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT
+r -t 2.044890989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT
++ -t 2.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT 
+- -t 2.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT
+h -t 2.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT
+r -t 2.255810989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT
+r -t 2.257610989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT
+r -t 2.260650989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT
+r -t 2.263330989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT
+r -t 2.272450989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT
+r -t 2.292070989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT
+r -t 2.307570989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT
++ -t 2.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT 
+- -t 2.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT
+h -t 2.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT
+r -t 2.505790989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT
+r -t 2.507350989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT
+r -t 2.509910989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT
+r -t 2.516170989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT
+r -t 2.524230989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT
+r -t 2.533190989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT
+r -t 2.541750989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT
++ -t 2.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT 
+- -t 2.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT
+h -t 2.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT
+r -t 2.755610989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT
+r -t 2.757470989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT
+r -t 2.760090989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT
+r -t 2.763530989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT
+r -t 2.771450989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT
+r -t 2.779790989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT
+r -t 2.791470989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT
++ -t 3.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT 
+- -t 3.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT
+h -t 3.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT
+r -t 3.005590989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT
+r -t 3.007190989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT
+r -t 3.010870989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT
+r -t 3.013790989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT
+r -t 3.024910989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT
+r -t 3.030890989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT
+r -t 3.045110989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT
++ -t 3.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT 
+- -t 3.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT
+h -t 3.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT
+r -t 3.255330989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT
+r -t 3.257450989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT
+r -t 3.260150989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT
+r -t 3.264490989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT
+r -t 3.269070989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT
+r -t 3.290510989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT
+r -t 3.310890989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT
++ -t 3.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT 
+- -t 3.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT
+h -t 3.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT
+r -t 3.505490989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT
+r -t 3.507690989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT
+r -t 3.510050989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT
+r -t 3.515570989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT
+r -t 3.524730989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT
+r -t 3.544910989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT
+r -t 3.564990989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT
++ -t 3.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT 
+- -t 3.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT
+h -t 3.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT
+r -t 3.755410989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT
+r -t 3.758150989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT
+r -t 3.761790989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT
+r -t 3.763750989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT
+r -t 3.771710989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT
+r -t 3.773530989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT
+r -t 3.785270989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT
++ -t 4.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT 
+- -t 4.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT
+h -t 4.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT
+r -t 4.005630989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT
+r -t 4.007150989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT
+r -t 4.009510989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT
+r -t 4.012030989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT
+r -t 4.014850989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT
+r -t 4.025210989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT
+r -t 4.038950989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT
++ -t 4.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT 
+- -t 4.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT
+h -t 4.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT
+r -t 4.255690989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT
+r -t 4.258350989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT
+r -t 4.260270989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT
+r -t 4.263310989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT
+r -t 4.269150989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT
+r -t 4.280110989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT
+r -t 4.293770989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT
++ -t 4.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT 
+- -t 4.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT
+h -t 4.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT
+r -t 4.505610989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT
+r -t 4.507970989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT
+r -t 4.511590989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT
+r -t 4.517610989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT
+r -t 4.525410989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT
+r -t 4.536250989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT
+r -t 4.556010989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT
++ -t 4.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT 
+- -t 4.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT
+h -t 4.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT
+r -t 4.755390989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT
+r -t 4.757630989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT
+r -t 4.760130989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT
+r -t 4.762530989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT
+r -t 4.768670989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT
+r -t 4.789210989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT
+r -t 4.808110989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT
++ -t 5.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT 
+- -t 5.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT
+h -t 5.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT
+r -t 5.005310989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT
+r -t 5.007070989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT
+r -t 5.009250989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT
+r -t 5.010830989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT
+r -t 5.020070989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT
+r -t 5.028790989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT
+r -t 5.045630989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT
++ -t 5.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT 
+- -t 5.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT
+h -t 5.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT
+r -t 5.255670989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT
+r -t 5.257990989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT
+r -t 5.261170989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT
+r -t 5.267690989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT
+r -t 5.274410989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT
+r -t 5.286030989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT
+r -t 5.290170989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT
++ -t 5.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT 
+- -t 5.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT
+h -t 5.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT
+r -t 5.505530989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT
+r -t 5.508070989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT
+r -t 5.510830989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT
+r -t 5.513830989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT
+r -t 5.522790989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT
+r -t 5.528590989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT
+r -t 5.546190989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT
++ -t 5.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT 
+- -t 5.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT
+h -t 5.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT
+r -t 5.755870989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT
+r -t 5.758330989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT
+r -t 5.759910989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT
+r -t 5.765370989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT
+r -t 5.767510989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT
+r -t 5.787530989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT
+r -t 5.800310989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT
++ -t 6.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT 
+- -t 6.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT
+h -t 6.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT
+r -t 6.005470989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT
+r -t 6.008150989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT
+r -t 6.012190989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT
+r -t 6.016850989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT
+r -t 6.025090989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT
+r -t 6.035290989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT
+r -t 6.046850989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT
++ -t 6.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT 
+- -t 6.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT
+h -t 6.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT
+r -t 6.255650989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT
+r -t 6.258110989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT
+r -t 6.260230989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT
+r -t 6.265470989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT
+r -t 6.269890989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT
+r -t 6.275050989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT
+r -t 6.278350989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT
++ -t 6.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT 
+- -t 6.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT
+h -t 6.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT
+r -t 6.505330989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT
+r -t 6.507870989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT
+r -t 6.511550989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT
+r -t 6.513550989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT
+r -t 6.517910989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT
+r -t 6.524950989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT
+r -t 6.533590989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT
++ -t 6.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT 
+- -t 6.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT
+h -t 6.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT
+r -t 6.755630989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT
+r -t 6.757290989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT
+r -t 6.759010989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT
+r -t 6.764790989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT
+r -t 6.768150989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT
+r -t 6.771410989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT
+r -t 6.792230989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT
++ -t 7.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT 
+- -t 7.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT
+h -t 7.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT
+r -t 7.005890989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT
+r -t 7.008230989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT
+r -t 7.010110989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT
+r -t 7.014230989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT
+r -t 7.021390989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT
+r -t 7.032270989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT
+r -t 7.048970989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT
++ -t 7.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT 
+- -t 7.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT
+h -t 7.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT
+r -t 7.255690989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT
+r -t 7.257750989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT
+r -t 7.261470989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT
+r -t 7.266830989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT
+r -t 7.276410989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT
+r -t 7.296610989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT
+r -t 7.301790989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT
++ -t 7.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT 
+- -t 7.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT
+h -t 7.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT
+r -t 7.505750989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT
+r -t 7.507670989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT
+r -t 7.510010989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT
+r -t 7.514930989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT
+r -t 7.518670989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT
+r -t 7.530950989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT
+r -t 7.539810989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT
++ -t 7.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT 
+- -t 7.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT
+h -t 7.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT
+r -t 7.755330989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT
+r -t 7.757210989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT
+r -t 7.760190989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT
+r -t 7.762830989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT
+r -t 7.765770989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT
+r -t 7.774430989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT
+r -t 7.781810989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT
++ -t 8.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT 
+- -t 8.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT
+h -t 8.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT
+r -t 8.005330989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT
+r -t 8.007610989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT
+r -t 8.010770989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT
+r -t 8.016410989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT
+r -t 8.025530989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT
+r -t 8.037930989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT
+r -t 8.053430989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT
++ -t 8.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT 
+- -t 8.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT
+h -t 8.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT
+r -t 8.255390989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT
+r -t 8.257290989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT
+r -t 8.259650989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT
+r -t 8.261390989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT
+r -t 8.269810989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT
+r -t 8.289310989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT
+r -t 8.310470989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT
++ -t 8.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT 
+- -t 8.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT
+h -t 8.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT
+r -t 8.505530989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT
+r -t 8.507310989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT
+r -t 8.509090989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT
+r -t 8.513370989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT
+r -t 8.521250989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT
+r -t 8.535690989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT
+r -t 8.538210989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT
++ -t 8.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT 
+- -t 8.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT
+h -t 8.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT
+r -t 8.755770989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT
+r -t 8.757370989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT
+r -t 8.760790989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT
+r -t 8.764530989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT
+r -t 8.766570989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT
+r -t 8.782250989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT
+r -t 8.801350989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT
++ -t 9.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT 
+- -t 9.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT
+h -t 9.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT
+r -t 9.005710989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT
+r -t 9.007630989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT
+r -t 9.011350989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT
+r -t 9.014170989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT
+r -t 9.020870989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT
+r -t 9.037750989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT
+r -t 9.050250989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT
++ -t 9.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT 
+- -t 9.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT
+h -t 9.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT
+r -t 9.255410989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT
+r -t 9.257390989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT
+r -t 9.259670989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT
+r -t 9.264950989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT
+r -t 9.267750989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT
+r -t 9.284430989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT
+r -t 9.305150989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT
++ -t 9.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT 
+- -t 9.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT
+h -t 9.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT
+r -t 9.505710989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT
+r -t 9.508030989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT
+r -t 9.511610989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT
+r -t 9.516250989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT
+r -t 9.526830989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT
+r -t 9.537410989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT
+r -t 9.545670989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT
++ -t 9.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT 
+- -t 9.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT
+h -t 9.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT
+r -t 9.755810989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT
+r -t 9.757530989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT
+r -t 9.761510989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT
+r -t 9.764630989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT
+r -t 9.769570989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT
+r -t 9.783270989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT
+r -t 9.795090989 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/ex/nsclick-simple-hybrid.tcl ns-2.34/tcl/ex/nsclick-simple-hybrid.tcl
--- ns-2.34-pure/tcl/ex/nsclick-simple-hybrid.tcl	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/ex/nsclick-simple-hybrid.tcl	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,397 @@
+#
+#  Copyright 2002, Univerity of Colorado at Boulder.                        
+#                                                                            
+#                         All Rights Reserved                                
+#                                                                            
+#  Permission to use, copy, modify, and distribute this software and its    
+#  documentation for any purpose other than its incorporation into a        
+#  commercial product is hereby granted without fee, provided that the      
+#  above copyright notice appear in all copies and that both that           
+#  copyright notice and this permission notice appear in supporting         
+#  documentation, and that the name of the University not be used in        
+#  advertising or publicity pertaining to distribution of the software      
+#  without specific, written prior permission.                              
+#                                                                            
+#  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+#  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+#  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+#  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+#  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+#  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+#  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+#  PERFORMANCE OF THIS SOFTWARE.                                            
+#
+# nsclick-simple-hybrid.tcl
+#
+# A sample nsclick script simulating a small hybrid wired/wireless
+#
+
+#
+# Set some general simulation parameters
+#
+
+#
+# Unity gain, omnidirectional antennas, centered 1.5m above each node.
+# These values are lifted from the ns-2 sample files.
+#
+Antenna/OmniAntenna set X_ 0
+Antenna/OmniAntenna set Y_ 0
+Antenna/OmniAntenna set Z_ 1.5
+Antenna/OmniAntenna set Gt_ 1.0
+Antenna/OmniAntenna set Gr_ 1.0
+
+#
+# Initialize the SharedMedia interface with parameters to make
+# it work like the 914MHz Lucent WaveLAN DSSS radio interface
+# These are taken directly from the ns-2 sample files.
+#
+Phy/WirelessPhy set CPThresh_ 10.0
+Phy/WirelessPhy set CSThresh_ 1.559e-11
+Phy/WirelessPhy set RXThresh_ 3.652e-10
+Phy/WirelessPhy set Rb_ 2*1e6
+Phy/WirelessPhy set Pt_ 0.2818
+Phy/WirelessPhy set freq_ 914e+6 
+Phy/WirelessPhy set L_ 1.0
+
+#
+# Disable RTS/CTS handshake for the bridge to work
+#
+Mac/802_11 set RTSThreshold_ 2500
+
+# 
+# Set the size of the playing field and the topography.
+#
+set xsize 100
+set ysize 100
+set wtopo	[new Topography]
+$wtopo load_flatgrid $xsize $ysize
+
+#
+# The network channel, physical layer, MAC, propagation model,
+# and antenna model are all standard ns-2.
+#  
+set wirelesschan Channel/WirelessChannel
+set wiredchan Channel
+
+set wirelessphy Phy/WirelessPhy
+set wiredphy Phy/WiredPhy
+
+set wirelessmac Mac/802_11
+set wiredmac Mac/802_3
+
+set netprop Propagation/TwoRayGround
+set antenna Antenna/OmniAntenna
+
+#
+# We have to use a special queue and link layer. This is so that
+# Click can have control over the network interface packet queue,
+# which is vital if we want to play with, e.g. QoS algorithms.
+#
+set netifq	Queue/ClickQueue
+set netll	LL/Ext
+LL set delay_			1ms
+
+#
+# These are pretty self-explanatory, just the number of nodes
+# and when we'll stop.
+#
+set wirednodecount 3
+set wirelessnodecount 3
+set bridgenodecount 1
+set nodecount   7
+set stoptime	10.0
+
+#
+# With nsclick, we have to worry about details like which network
+# port to use for communication. This sets the default ports to 5000.
+#
+Agent/Null set sport_		5000
+Agent/Null set dport_		5000
+
+Agent/CBR set sport_		5000
+Agent/CBR set dport_		5000
+
+#
+# Standard ns-2 stuff here - create the simulator object.
+#
+set ns_		[new Simulator]
+
+#
+# Create and activate trace files.
+#
+set tracefd	[open "nsclick-simple-hybrid.tr" w]
+set namtrace    [open "nsclick-simple-hybrid.nam" w]
+$ns_ trace-all $tracefd
+$ns_ namtrace-all-wireless $namtrace $xsize $ysize
+$ns_ use-newtrace
+
+
+#
+# Create the "god" object. This is another artifact of using
+# the mobile node type. We have to have this even though
+# we never use it.
+#
+set god_ [create-god $nodecount]
+
+#
+# Tell the simulator to create Click nodes.
+#
+Simulator set node_factory_ Node/MobileNode/ClickNode
+
+#
+# Create a network Channel for the nodes to use. One channel
+# per LAN. Also set the propagation model to be used.
+#
+set wired_chan_ [new $wiredchan]
+set wireless_chan_ [new $wirelesschan]
+set prop_ [new $netprop]
+
+#
+# In nsclick we have to worry about assigning IP and MAC addresses
+# to out network interfaces. Here we generate a list of IP and MAC
+# addresses, one per node since we've only got one network interface
+# per node in this case. Also note that this scheme only works for
+# fewer than 255 nodes, and we aren't worrying about subnet masks.
+#
+set iptemplate "192.168.1.%d"
+set mactemplate "00:03:47:70:89:%0x"
+for {set i 0} {$i < $wirednodecount} {incr i} {
+    set wired_node_ip($i) [format $iptemplate [expr $i+1]]
+    set wired_node_mac($i) [format $mactemplate [expr $i+1]]
+}
+
+set iptemplate "192.168.2.%d"
+set mactemplate "00:03:47:70:8A:%0x"
+for {set i 0} {$i < $wirelessnodecount} {incr i} {
+    set wireless_node_ip($i) [format $iptemplate [expr $i+1]]
+    set wireless_node_mac($i) [format $mactemplate [expr $i+1]]
+}
+
+
+#
+# We set the routing protocol to "Empty" so that ns-2 doesn't do
+# any packet routing. All of the routing will be done by the
+# Click script.
+#
+$ns_ rtproto Empty
+
+#
+# Here is where we actually create all of the nodes.
+# We'll create the wired, wireless, and the bridge node
+# separately.
+#
+
+#
+# Start with the wireless nodes
+#
+for {set i 0} {$i < $wirelessnodecount } {incr i} {
+    set wireless_node_($i) [$ns_ node]
+
+    #
+    # After creating the node, we add one wireless network interface to
+    # it. By default, this interface will be named "eth0". If we
+    # added a second interface it would be named "eth1", a third
+    # "eth2" and so on.
+    #
+    $wireless_node_($i) add-interface $wireless_chan_ $prop_ $netll \
+	    $wirelessmac $netifq 1 $wirelessphy $antenna $wtopo
+
+    #
+    # Now configure the interface eth0
+    #
+    $wireless_node_($i) setip "eth0" $wireless_node_ip($i)
+    $wireless_node_($i) setmac "eth0" $wireless_node_mac($i)
+
+    #
+    # Set some node properties
+    #
+    $wireless_node_($i) random-motion 0
+    $wireless_node_($i) topography $wtopo
+    $wireless_node_($i) nodetrace $tracefd
+
+    #
+    # The node name is used by Click to distinguish information
+    # coming from different nodes. For example, a "Print" element
+    # prepends this to the printed string so it's clear exactly
+    # which node is doing the printing.
+    #
+    [$wireless_node_($i) set classifier_] setnodename "wirelessnode$i-hybrid"
+    
+    #
+    # Load the appropriate Click router script for the node.
+    #
+    [$wireless_node_($i) entry] loadclick "nsclick-simple-lan.click"
+}
+
+#
+# Now create the wired nodes
+#
+for {set i 0} {$i < $wirednodecount } {incr i} {
+    set wired_node_($i) [$ns_ node]
+
+    #
+    # After creating the node, we add one wired network interface to
+    # it. By default, this interface will be named "eth0". If we
+    # added a second interface it would be named "eth1", a third
+    # "eth2" and so on.
+    #
+    $wired_node_($i) add-wired-interface $wired_chan_ $netll $wiredmac \
+	$netifq 1 $wiredphy
+
+    #
+    # Now configure the interface eth0
+    #
+    $wired_node_($i) setip "eth0" $wired_node_ip($i)
+    $wired_node_($i) setmac "eth0" $wired_node_mac($i)
+
+    #
+    # Set some node properties
+    #
+    $wired_node_($i) random-motion 0
+    $wired_node_($i) topography $wtopo
+    $wired_node_($i) nodetrace $tracefd
+
+    #
+    # The node name is used by Click to distinguish information
+    # coming from different nodes. For example, a "Print" element
+    # prepends this to the printed string so it's clear exactly
+    # which node is doing the printing.
+    #
+    [$wired_node_($i) set classifier_] setnodename "wirednode$i-hybrid"
+    
+    #
+    # Load the appropriate Click router script for the node.
+    # All nodes in this simulation are using the same script,
+    # but there's no reason why each node couldn't use a different
+    # script.
+    #
+    [$wired_node_($i) entry] loadclick "nsclick-simple-lan.click"
+}
+
+#
+# Finally make the bridge node
+#
+set bridge_node_ [$ns_ node]
+$bridge_node_ add-wired-interface $wired_chan_ $netll $wiredmac \
+	$netifq 1 $wiredphy
+$bridge_node_ add-interface $wireless_chan_ $prop_ $netll \
+	    $wirelessmac $netifq 1 $wirelessphy $antenna $wtopo
+$bridge_node_ setpromiscuous 0 1
+$bridge_node_ setpromiscuous 1 1
+
+$bridge_node_ random-motion 0
+$bridge_node_ topography $wtopo
+$bridge_node_ nodetrace $tracefd
+
+[$bridge_node_ entry] loadclick "nsclick-simple-bridge.click"
+[$bridge_node_ set classifier_] setnodename "bridgenode-hybrid"
+
+# 
+# Define node network traffic. There isn't a whole lot going on
+# in this simple test case, we're just going to have the first wireless node
+# send packets to the first wired node, starting at 1 second, and ending at 10.
+# There are Perl scripts available to automatically generate network
+# traffic.
+#
+
+
+#
+# Start transmitting at $startxmittime, $xmitrate packets per second.
+#
+set startxmittime 1
+set xmitrate 4
+set xmitinterval 0.25
+set packetsize 64
+
+#
+# We use the "raw" packet type, which sends real packet data
+# down the pipe.
+#
+set raw_(0) [new Agent/Raw]
+$ns_ attach-agent $wireless_node_(0) $raw_(0)
+
+set null_(0) [new Agent/Null]
+$ns_ attach-agent $wired_node_(0) $null_(0)
+
+#
+# The CBR object is just the default ns-2 CBR object, so
+# no change in the meaning of the parameters.
+#
+set cbr_(0) [new Application/Traffic/CBR]
+$cbr_(0) set packetSize_ $packetsize
+$cbr_(0) set interval_ $xmitinterval
+$cbr_(0) set random_ 0
+$cbr_(0) set maxpkts_ [expr ($stoptime - $startxmittime)*$xmitrate]
+$cbr_(0) attach-agent $raw_(0)
+
+#
+# The Raw agent creates real UDP packets, so it has to know
+# the source and destination IP addresses and port numberes.
+#
+$raw_(0) set-srcip [$wireless_node_(0) getip eth0]
+$raw_(0) set-srcport 5000
+$raw_(0) set-destport 5000
+$raw_(0) set-destip [$wired_node_(0) getip eth0]
+
+$ns_ at $startxmittime "$cbr_(0) start"
+
+
+$wireless_node_(0) set X_ 10
+$wireless_node_(0) set Y_ 50
+$wireless_node_(0) set Z_ 0
+
+$wireless_node_(1) set X_ 50
+$wireless_node_(1) set Y_ 50
+$wireless_node_(1) set Z_ 0
+
+$wireless_node_(2) set X_ 90
+$wireless_node_(2) set Y_ 50
+$wireless_node_(2) set Z_ 0
+
+$bridge_node_ set X_ 50
+$bridge_node_ set Y_ 10
+$bridge_node_ set Z_ 0
+
+$wired_node_(0) set X_ 10
+$wired_node_(0) set Y_ 0
+$wired_node_(0) set Z_ 0
+
+$wired_node_(1) set X_ 50
+$wired_node_(1) set Y_ 0
+$wired_node_(1) set Z_ 0
+
+$wired_node_(2) set X_ 90
+$wired_node_(2) set Y_ 0
+$wired_node_(2) set Z_ 0
+#
+# This sizes the nodes for use in nam.
+#
+for {set i 0} {$i < $wirelessnodecount} {incr i} {
+    $ns_ initial_node_pos $wireless_node_($i) 10
+    [$wireless_node_($i) entry] runclick
+}
+
+for {set i 0} {$i < $wirednodecount} {incr i} {
+    $ns_ initial_node_pos $wired_node_($i) 10
+    [$wired_node_($i) entry] runclick
+}
+
+$ns_ initial_node_pos $bridge_node_ 10
+
+#
+# Stop the simulation
+#
+$ns_ at  $stoptime.000000001 "puts \"NS EXITING...\" ; $ns_ halt"
+
+#
+# Let nam know that the simulation is done.
+#
+$ns_ at  $stoptime	"$ns_ nam-end-wireless $stoptime"
+
+
+puts "Starting Simulation..."
+$ns_ run
+
+
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/ex/nsclick-simple-hybrid.tr ns-2.34/tcl/ex/nsclick-simple-hybrid.tr
--- ns-2.34-pure/tcl/ex/nsclick-simple-hybrid.tr	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/ex/nsclick-simple-hybrid.tr	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,288 @@
+s 1.000000000 _0_ AGT  --- 0 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 1.016121766 _3_ AGT  --- 0 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.018301766 _3_ AGT  --- 0 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.021761766 _3_ AGT  --- 0 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.027061766 _3_ AGT  --- 0 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.035561766 _3_ AGT  --- 0 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.057281766 _3_ AGT  --- 0 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.066501766 _3_ AGT  --- 0 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 1.250000000 _0_ AGT  --- 3 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 1.255530989 _3_ AGT  --- 3 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.257510989 _3_ AGT  --- 3 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.261230989 _3_ AGT  --- 3 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.266170989 _3_ AGT  --- 3 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.273130989 _3_ AGT  --- 3 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.276750989 _3_ AGT  --- 3 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.279670989 _3_ AGT  --- 3 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 1.500000000 _0_ AGT  --- 4 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 1.505770989 _3_ AGT  --- 4 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.507390989 _3_ AGT  --- 4 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.509190989 _3_ AGT  --- 4 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.511290989 _3_ AGT  --- 4 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.520050989 _3_ AGT  --- 4 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.537710989 _3_ AGT  --- 4 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.551250989 _3_ AGT  --- 4 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 1.750000000 _0_ AGT  --- 5 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 1.755730989 _3_ AGT  --- 5 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.757350989 _3_ AGT  --- 5 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.760310989 _3_ AGT  --- 5 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.765530989 _3_ AGT  --- 5 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.769510989 _3_ AGT  --- 5 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.777590989 _3_ AGT  --- 5 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 1.790930989 _3_ AGT  --- 5 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 2.000000000 _0_ AGT  --- 6 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 2.005590989 _3_ AGT  --- 6 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.007810989 _3_ AGT  --- 6 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.010790989 _3_ AGT  --- 6 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.016050989 _3_ AGT  --- 6 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.026670989 _3_ AGT  --- 6 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.033350989 _3_ AGT  --- 6 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.044890989 _3_ AGT  --- 6 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 2.250000000 _0_ AGT  --- 7 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 2.255810989 _3_ AGT  --- 7 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.257610989 _3_ AGT  --- 7 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.260650989 _3_ AGT  --- 7 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.263330989 _3_ AGT  --- 7 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.272450989 _3_ AGT  --- 7 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.292070989 _3_ AGT  --- 7 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.307570989 _3_ AGT  --- 7 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 2.500000000 _0_ AGT  --- 8 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 2.505790989 _3_ AGT  --- 8 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.507350989 _3_ AGT  --- 8 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.509910989 _3_ AGT  --- 8 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.516170989 _3_ AGT  --- 8 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.524230989 _3_ AGT  --- 8 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.533190989 _3_ AGT  --- 8 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.541750989 _3_ AGT  --- 8 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 2.750000000 _0_ AGT  --- 9 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 2.755610989 _3_ AGT  --- 9 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.757470989 _3_ AGT  --- 9 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.760090989 _3_ AGT  --- 9 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.763530989 _3_ AGT  --- 9 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.771450989 _3_ AGT  --- 9 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.779790989 _3_ AGT  --- 9 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 2.791470989 _3_ AGT  --- 9 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 3.000000000 _0_ AGT  --- 10 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 3.005590989 _3_ AGT  --- 10 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.007190989 _3_ AGT  --- 10 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.010870989 _3_ AGT  --- 10 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.013790989 _3_ AGT  --- 10 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.024910989 _3_ AGT  --- 10 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.030890989 _3_ AGT  --- 10 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.045110989 _3_ AGT  --- 10 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 3.250000000 _0_ AGT  --- 11 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 3.255330989 _3_ AGT  --- 11 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.257450989 _3_ AGT  --- 11 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.260150989 _3_ AGT  --- 11 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.264490989 _3_ AGT  --- 11 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.269070989 _3_ AGT  --- 11 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.290510989 _3_ AGT  --- 11 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.310890989 _3_ AGT  --- 11 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 3.500000000 _0_ AGT  --- 12 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 3.505490989 _3_ AGT  --- 12 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.507690989 _3_ AGT  --- 12 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.510050989 _3_ AGT  --- 12 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.515570989 _3_ AGT  --- 12 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.524730989 _3_ AGT  --- 12 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.544910989 _3_ AGT  --- 12 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.564990989 _3_ AGT  --- 12 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 3.750000000 _0_ AGT  --- 13 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 3.755410989 _3_ AGT  --- 13 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.758150989 _3_ AGT  --- 13 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.761790989 _3_ AGT  --- 13 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.763750989 _3_ AGT  --- 13 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.771710989 _3_ AGT  --- 13 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.773530989 _3_ AGT  --- 13 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 3.785270989 _3_ AGT  --- 13 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 4.000000000 _0_ AGT  --- 14 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 4.005630989 _3_ AGT  --- 14 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.007150989 _3_ AGT  --- 14 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.009510989 _3_ AGT  --- 14 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.012030989 _3_ AGT  --- 14 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.014850989 _3_ AGT  --- 14 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.025210989 _3_ AGT  --- 14 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.038950989 _3_ AGT  --- 14 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 4.250000000 _0_ AGT  --- 15 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 4.255690989 _3_ AGT  --- 15 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.258350989 _3_ AGT  --- 15 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.260270989 _3_ AGT  --- 15 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.263310989 _3_ AGT  --- 15 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.269150989 _3_ AGT  --- 15 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.280110989 _3_ AGT  --- 15 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.293770989 _3_ AGT  --- 15 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 4.500000000 _0_ AGT  --- 16 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 4.505610989 _3_ AGT  --- 16 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.507970989 _3_ AGT  --- 16 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.511590989 _3_ AGT  --- 16 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.517610989 _3_ AGT  --- 16 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.525410989 _3_ AGT  --- 16 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.536250989 _3_ AGT  --- 16 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.556010989 _3_ AGT  --- 16 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 4.750000000 _0_ AGT  --- 17 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 4.755390989 _3_ AGT  --- 17 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.757630989 _3_ AGT  --- 17 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.760130989 _3_ AGT  --- 17 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.762530989 _3_ AGT  --- 17 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.768670989 _3_ AGT  --- 17 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.789210989 _3_ AGT  --- 17 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 4.808110989 _3_ AGT  --- 17 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 5.000000000 _0_ AGT  --- 18 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 5.005310989 _3_ AGT  --- 18 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.007070989 _3_ AGT  --- 18 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.009250989 _3_ AGT  --- 18 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.010830989 _3_ AGT  --- 18 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.020070989 _3_ AGT  --- 18 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.028790989 _3_ AGT  --- 18 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.045630989 _3_ AGT  --- 18 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 5.250000000 _0_ AGT  --- 19 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 5.255670989 _3_ AGT  --- 19 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.257990989 _3_ AGT  --- 19 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.261170989 _3_ AGT  --- 19 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.267690989 _3_ AGT  --- 19 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.274410989 _3_ AGT  --- 19 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.286030989 _3_ AGT  --- 19 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.290170989 _3_ AGT  --- 19 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 5.500000000 _0_ AGT  --- 20 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 5.505530989 _3_ AGT  --- 20 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.508070989 _3_ AGT  --- 20 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.510830989 _3_ AGT  --- 20 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.513830989 _3_ AGT  --- 20 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.522790989 _3_ AGT  --- 20 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.528590989 _3_ AGT  --- 20 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.546190989 _3_ AGT  --- 20 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 5.750000000 _0_ AGT  --- 21 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 5.755870989 _3_ AGT  --- 21 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.758330989 _3_ AGT  --- 21 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.759910989 _3_ AGT  --- 21 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.765370989 _3_ AGT  --- 21 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.767510989 _3_ AGT  --- 21 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.787530989 _3_ AGT  --- 21 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 5.800310989 _3_ AGT  --- 21 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 6.000000000 _0_ AGT  --- 22 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 6.005470989 _3_ AGT  --- 22 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.008150989 _3_ AGT  --- 22 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.012190989 _3_ AGT  --- 22 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.016850989 _3_ AGT  --- 22 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.025090989 _3_ AGT  --- 22 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.035290989 _3_ AGT  --- 22 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.046850989 _3_ AGT  --- 22 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 6.250000000 _0_ AGT  --- 23 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 6.255650989 _3_ AGT  --- 23 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.258110989 _3_ AGT  --- 23 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.260230989 _3_ AGT  --- 23 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.265470989 _3_ AGT  --- 23 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.269890989 _3_ AGT  --- 23 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.275050989 _3_ AGT  --- 23 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.278350989 _3_ AGT  --- 23 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 6.500000000 _0_ AGT  --- 24 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 6.505330989 _3_ AGT  --- 24 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.507870989 _3_ AGT  --- 24 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.511550989 _3_ AGT  --- 24 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.513550989 _3_ AGT  --- 24 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.517910989 _3_ AGT  --- 24 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.524950989 _3_ AGT  --- 24 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.533590989 _3_ AGT  --- 24 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 6.750000000 _0_ AGT  --- 25 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 6.755630989 _3_ AGT  --- 25 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.757290989 _3_ AGT  --- 25 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.759010989 _3_ AGT  --- 25 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.764790989 _3_ AGT  --- 25 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.768150989 _3_ AGT  --- 25 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.771410989 _3_ AGT  --- 25 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 6.792230989 _3_ AGT  --- 25 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 7.000000000 _0_ AGT  --- 26 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 7.005890989 _3_ AGT  --- 26 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.008230989 _3_ AGT  --- 26 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.010110989 _3_ AGT  --- 26 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.014230989 _3_ AGT  --- 26 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.021390989 _3_ AGT  --- 26 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.032270989 _3_ AGT  --- 26 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.048970989 _3_ AGT  --- 26 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 7.250000000 _0_ AGT  --- 27 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 7.255690989 _3_ AGT  --- 27 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.257750989 _3_ AGT  --- 27 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.261470989 _3_ AGT  --- 27 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.266830989 _3_ AGT  --- 27 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.276410989 _3_ AGT  --- 27 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.296610989 _3_ AGT  --- 27 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.301790989 _3_ AGT  --- 27 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 7.500000000 _0_ AGT  --- 28 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 7.505750989 _3_ AGT  --- 28 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.507670989 _3_ AGT  --- 28 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.510010989 _3_ AGT  --- 28 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.514930989 _3_ AGT  --- 28 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.518670989 _3_ AGT  --- 28 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.530950989 _3_ AGT  --- 28 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.539810989 _3_ AGT  --- 28 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 7.750000000 _0_ AGT  --- 29 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 7.755330989 _3_ AGT  --- 29 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.757210989 _3_ AGT  --- 29 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.760190989 _3_ AGT  --- 29 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.762830989 _3_ AGT  --- 29 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.765770989 _3_ AGT  --- 29 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.774430989 _3_ AGT  --- 29 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 7.781810989 _3_ AGT  --- 29 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 8.000000000 _0_ AGT  --- 30 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 8.005330989 _3_ AGT  --- 30 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.007610989 _3_ AGT  --- 30 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.010770989 _3_ AGT  --- 30 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.016410989 _3_ AGT  --- 30 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.025530989 _3_ AGT  --- 30 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.037930989 _3_ AGT  --- 30 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.053430989 _3_ AGT  --- 30 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 8.250000000 _0_ AGT  --- 31 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 8.255390989 _3_ AGT  --- 31 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.257290989 _3_ AGT  --- 31 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.259650989 _3_ AGT  --- 31 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.261390989 _3_ AGT  --- 31 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.269810989 _3_ AGT  --- 31 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.289310989 _3_ AGT  --- 31 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.310470989 _3_ AGT  --- 31 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 8.500000000 _0_ AGT  --- 32 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 8.505530989 _3_ AGT  --- 32 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.507310989 _3_ AGT  --- 32 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.509090989 _3_ AGT  --- 32 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.513370989 _3_ AGT  --- 32 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.521250989 _3_ AGT  --- 32 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.535690989 _3_ AGT  --- 32 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.538210989 _3_ AGT  --- 32 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 8.750000000 _0_ AGT  --- 33 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 8.755770989 _3_ AGT  --- 33 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.757370989 _3_ AGT  --- 33 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.760790989 _3_ AGT  --- 33 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.764530989 _3_ AGT  --- 33 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.766570989 _3_ AGT  --- 33 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.782250989 _3_ AGT  --- 33 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 8.801350989 _3_ AGT  --- 33 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 9.000000000 _0_ AGT  --- 34 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 9.005710989 _3_ AGT  --- 34 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.007630989 _3_ AGT  --- 34 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.011350989 _3_ AGT  --- 34 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.014170989 _3_ AGT  --- 34 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.020870989 _3_ AGT  --- 34 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.037750989 _3_ AGT  --- 34 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.050250989 _3_ AGT  --- 34 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 9.250000000 _0_ AGT  --- 35 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 9.255410989 _3_ AGT  --- 35 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.257390989 _3_ AGT  --- 35 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.259670989 _3_ AGT  --- 35 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.264950989 _3_ AGT  --- 35 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.267750989 _3_ AGT  --- 35 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.284430989 _3_ AGT  --- 35 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.305150989 _3_ AGT  --- 35 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 9.500000000 _0_ AGT  --- 36 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 9.505710989 _3_ AGT  --- 36 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.508030989 _3_ AGT  --- 36 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.511610989 _3_ AGT  --- 36 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.516250989 _3_ AGT  --- 36 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.526830989 _3_ AGT  --- 36 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.537410989 _3_ AGT  --- 36 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.545670989 _3_ AGT  --- 36 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 9.750000000 _0_ AGT  --- 37 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+r 9.755810989 _3_ AGT  --- 37 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.757530989 _3_ AGT  --- 37 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.761510989 _3_ AGT  --- 37 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.764630989 _3_ AGT  --- 37 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.769570989 _3_ AGT  --- 37 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.783270989 _3_ AGT  --- 37 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+r 9.795090989 _3_ AGT  --- 37 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/ex/nsclick-simple-lan.click ns-2.34/tcl/ex/nsclick-simple-lan.click
--- ns-2.34-pure/tcl/ex/nsclick-simple-lan.click	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/ex/nsclick-simple-lan.click	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,97 @@
+//
+//  Copyright 2002, Univerity of Colorado at Boulder.                        
+//                                                                            
+//                         All Rights Reserved                                
+//                                                                            
+//  Permission to use, copy, modify, and distribute this software and its    
+//  documentation for any purpose other than its incorporation into a        
+//  commercial product is hereby granted without fee, provided that the      
+//  above copyright notice appear in all copies and that both that           
+//  copyright notice and this permission notice appear in supporting         
+//  documentation, and that the name of the University not be used in        
+//  advertising or publicity pertaining to distribution of the software      
+//  without specific, written prior permission.                              
+//                                                                            
+//  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+//  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+//  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+//  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+//  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+//  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+//  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+//  PERFORMANCE OF THIS SOFTWARE.                                            
+//
+
+// nsclick-simple-lan.click
+//
+// This is a simple and stupid flat routing mechanism.
+// It broadcasts ARP requests if it wants to find a destination
+// address, and it responds to ARP requests made for it.
+
+elementclass DumbRouter {
+  $myaddr, $myaddr_ethernet |
+
+  class :: Classifier(12/0806 20/0001,12/0806 20/0002, -);
+  mypackets :: IPClassifier(dst host $myaddr,-);
+  myarpquerier :: ARPQuerier($myaddr,$myaddr_ethernet);
+  myarpresponder :: ARPResponder($myaddr $myaddr_ethernet);
+  ethout :: Queue -> ToSimDevice(eth0);
+
+  FromSimDevice(eth0,4096)
+	-> Print(eth0,64)
+	-> ToDump(in_eth0,PER_NODE 1)
+	-> HostEtherFilter($myaddr_ethernet)
+	-> class;
+	
+  // ARP queries from other nodes go to the ARP responder module
+  class[0] -> myarpresponder;
+
+  // ARP responses go to our query module
+  class[1] -> [1]myarpquerier;
+
+  // All other packets get checked to see if they're meant for us
+  class[2]				
+	-> Strip(14)
+	-> CheckIPHeader
+	-> MarkIPHeader
+	-> GetIPAddress(16)
+	-> mypackets; 
+
+  // Packets for us go to "tap0" which sends them to the kernel
+  mypackets[0]
+	-> IPPrint(tokernel) 
+	-> ToDump(tokernel,2000,IP,PER_NODE 1) 
+	-> ToSimDevice(tap0,IP);
+
+  // Packets for other folks or broadcast packets get discarded
+  mypackets[1]
+	-> Print(discard,64)
+	-> ToDump(discard,2000,PER_NODE 1)
+	-> Discard;
+
+  // Packets sent out by the "kernel" get pushed into the ARP query module
+  FromSimDevice(tap0,4096)
+	-> CheckIPHeader 
+	-> IPPrint(fromkernel) 
+	-> ToDump(fromkernel,2000,IP,PER_NODE 1)
+	-> GetIPAddress(16)
+	-> myarpquerier;
+
+  // Both the ARP query and response modules send data out to
+  // the simulated network device, eth0.
+  myarpquerier
+	-> Print(fromarpquery,64)
+	-> ToDump(out_arpquery,PER_NODE 1)
+	-> ethout;
+
+  myarpresponder
+	-> Print(arpresponse,64)
+	-> ToDump(out_arprespond,PER_NODE 1)
+	-> ethout;
+}
+
+
+u :: DumbRouter(eth0,eth0);
+
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/ex/nsclick-simple-lan.nam ns-2.34/tcl/ex/nsclick-simple-lan.nam
--- ns-2.34-pure/tcl/ex/nsclick-simple-lan.nam	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/ex/nsclick-simple-lan.nam	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,306 @@
+n -t * -s 0  -x 10 -y 50 -Z 0 -z 20  -v circle -c black
+n -t * -s 1  -x 50 -y 50 -Z 0 -z 20  -v circle -c black
+n -t * -s 2  -x 90 -y 50 -Z 0 -z 20  -v circle -c black
+n -t * -s 3  -x 50 -y 10 -Z 0 -z 20  -v circle -c black
+V -t * -v 1.0a5 -a 0
+W -t * -x 100 -y 100
+A -t * -n 1 -p 0 -o 0xffffffff -c 31 -a 1
+A -t * -h 1 -m 2147483647 -s 0
++ -t 1.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT 
+- -t 1.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT
+h -t 1.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT
++ -t 1.001000000 -s 0 -d 0 -p raw -e 64 -c 2 -a 0 -i 1 -k MAC 
+- -t 1.001000000 -s 0 -d 0 -p raw -e 64 -c 2 -a 0 -i 1 -k MAC
+h -t 1.001000000 -s 0 -d 0 -p raw -e 64 -c 2 -a 0 -i 1 -k MAC
+r -t 1.001055200 -s 3 -d 0 -p raw -e 28 -c 2 -a 0 -i 1 -k MAC
+r -t 1.001055200 -s 2 -d 0 -p raw -e 28 -c 2 -a 0 -i 1 -k MAC
+r -t 1.001055200 -s 1 -d 0 -p raw -e 28 -c 2 -a 0 -i 1 -k MAC
++ -t 1.003055200 -s 3 -d 0 -p raw -e 64 -c 2 -a 0 -i 2 -k MAC 
+- -t 1.003055200 -s 3 -d 0 -p raw -e 64 -c 2 -a 0 -i 2 -k MAC
+h -t 1.003055200 -s 3 -d 0 -p raw -e 64 -c 2 -a 0 -i 2 -k MAC
+r -t 1.003110400 -s 0 -d 0 -p raw -e 28 -c 2 -a 0 -i 2 -k MAC
++ -t 1.005110400 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 0 -k MAC 
+- -t 1.005110400 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 0 -k MAC
+h -t 1.005110400 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 0 -k MAC
+r -t 1.005199200 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 0 -k MAC
+r -t 1.006199200 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 0 -k AGT
++ -t 1.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT 
+- -t 1.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT
+h -t 1.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT
++ -t 1.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 3 -k MAC 
+- -t 1.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 3 -k MAC
+h -t 1.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 3 -k MAC
+r -t 1.251088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 3 -k MAC
+r -t 1.252088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 3 -k AGT
++ -t 1.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT 
+- -t 1.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT
+h -t 1.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT
++ -t 1.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 4 -k MAC 
+- -t 1.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 4 -k MAC
+h -t 1.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 4 -k MAC
+r -t 1.501088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 4 -k MAC
+r -t 1.502088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 4 -k AGT
++ -t 1.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT 
+- -t 1.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT
+h -t 1.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT
++ -t 1.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 5 -k MAC 
+- -t 1.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 5 -k MAC
+h -t 1.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 5 -k MAC
+r -t 1.751088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 5 -k MAC
+r -t 1.752088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 5 -k AGT
++ -t 2.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT 
+- -t 2.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT
+h -t 2.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT
++ -t 2.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 6 -k MAC 
+- -t 2.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 6 -k MAC
+h -t 2.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 6 -k MAC
+r -t 2.001088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 6 -k MAC
+r -t 2.002088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 6 -k AGT
++ -t 2.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT 
+- -t 2.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT
+h -t 2.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT
++ -t 2.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 7 -k MAC 
+- -t 2.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 7 -k MAC
+h -t 2.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 7 -k MAC
+r -t 2.251088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 7 -k MAC
+r -t 2.252088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 7 -k AGT
++ -t 2.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT 
+- -t 2.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT
+h -t 2.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT
++ -t 2.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 8 -k MAC 
+- -t 2.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 8 -k MAC
+h -t 2.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 8 -k MAC
+r -t 2.501088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 8 -k MAC
+r -t 2.502088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 8 -k AGT
++ -t 2.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT 
+- -t 2.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT
+h -t 2.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT
++ -t 2.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 9 -k MAC 
+- -t 2.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 9 -k MAC
+h -t 2.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 9 -k MAC
+r -t 2.751088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 9 -k MAC
+r -t 2.752088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 9 -k AGT
++ -t 3.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT 
+- -t 3.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT
+h -t 3.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT
++ -t 3.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 10 -k MAC 
+- -t 3.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 10 -k MAC
+h -t 3.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 10 -k MAC
+r -t 3.001088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 10 -k MAC
+r -t 3.002088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 10 -k AGT
++ -t 3.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT 
+- -t 3.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT
+h -t 3.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT
++ -t 3.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 11 -k MAC 
+- -t 3.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 11 -k MAC
+h -t 3.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 11 -k MAC
+r -t 3.251088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 11 -k MAC
+r -t 3.252088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 11 -k AGT
++ -t 3.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT 
+- -t 3.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT
+h -t 3.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT
++ -t 3.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 12 -k MAC 
+- -t 3.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 12 -k MAC
+h -t 3.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 12 -k MAC
+r -t 3.501088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 12 -k MAC
+r -t 3.502088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 12 -k AGT
++ -t 3.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT 
+- -t 3.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT
+h -t 3.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT
++ -t 3.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 13 -k MAC 
+- -t 3.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 13 -k MAC
+h -t 3.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 13 -k MAC
+r -t 3.751088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 13 -k MAC
+r -t 3.752088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 13 -k AGT
++ -t 4.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT 
+- -t 4.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT
+h -t 4.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT
++ -t 4.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 14 -k MAC 
+- -t 4.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 14 -k MAC
+h -t 4.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 14 -k MAC
+r -t 4.001088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 14 -k MAC
+r -t 4.002088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 14 -k AGT
++ -t 4.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT 
+- -t 4.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT
+h -t 4.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT
++ -t 4.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 15 -k MAC 
+- -t 4.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 15 -k MAC
+h -t 4.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 15 -k MAC
+r -t 4.251088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 15 -k MAC
+r -t 4.252088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 15 -k AGT
++ -t 4.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT 
+- -t 4.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT
+h -t 4.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT
++ -t 4.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 16 -k MAC 
+- -t 4.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 16 -k MAC
+h -t 4.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 16 -k MAC
+r -t 4.501088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 16 -k MAC
+r -t 4.502088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 16 -k AGT
++ -t 4.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT 
+- -t 4.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT
+h -t 4.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT
++ -t 4.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 17 -k MAC 
+- -t 4.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 17 -k MAC
+h -t 4.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 17 -k MAC
+r -t 4.751088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 17 -k MAC
+r -t 4.752088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 17 -k AGT
++ -t 5.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT 
+- -t 5.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT
+h -t 5.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT
++ -t 5.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 18 -k MAC 
+- -t 5.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 18 -k MAC
+h -t 5.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 18 -k MAC
+r -t 5.001088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 18 -k MAC
+r -t 5.002088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 18 -k AGT
++ -t 5.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT 
+- -t 5.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT
+h -t 5.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT
++ -t 5.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 19 -k MAC 
+- -t 5.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 19 -k MAC
+h -t 5.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 19 -k MAC
+r -t 5.251088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 19 -k MAC
+r -t 5.252088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 19 -k AGT
++ -t 5.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT 
+- -t 5.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT
+h -t 5.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT
++ -t 5.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 20 -k MAC 
+- -t 5.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 20 -k MAC
+h -t 5.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 20 -k MAC
+r -t 5.501088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 20 -k MAC
+r -t 5.502088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 20 -k AGT
++ -t 5.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT 
+- -t 5.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT
+h -t 5.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT
++ -t 5.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 21 -k MAC 
+- -t 5.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 21 -k MAC
+h -t 5.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 21 -k MAC
+r -t 5.751088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 21 -k MAC
+r -t 5.752088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 21 -k AGT
++ -t 6.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT 
+- -t 6.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT
+h -t 6.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT
++ -t 6.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 22 -k MAC 
+- -t 6.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 22 -k MAC
+h -t 6.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 22 -k MAC
+r -t 6.001088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 22 -k MAC
+r -t 6.002088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 22 -k AGT
++ -t 6.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT 
+- -t 6.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT
+h -t 6.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT
++ -t 6.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 23 -k MAC 
+- -t 6.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 23 -k MAC
+h -t 6.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 23 -k MAC
+r -t 6.251088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 23 -k MAC
+r -t 6.252088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 23 -k AGT
++ -t 6.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT 
+- -t 6.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT
+h -t 6.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT
++ -t 6.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 24 -k MAC 
+- -t 6.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 24 -k MAC
+h -t 6.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 24 -k MAC
+r -t 6.501088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 24 -k MAC
+r -t 6.502088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 24 -k AGT
++ -t 6.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT 
+- -t 6.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT
+h -t 6.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT
++ -t 6.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 25 -k MAC 
+- -t 6.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 25 -k MAC
+h -t 6.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 25 -k MAC
+r -t 6.751088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 25 -k MAC
+r -t 6.752088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 25 -k AGT
++ -t 7.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT 
+- -t 7.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT
+h -t 7.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT
++ -t 7.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 26 -k MAC 
+- -t 7.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 26 -k MAC
+h -t 7.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 26 -k MAC
+r -t 7.001088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 26 -k MAC
+r -t 7.002088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 26 -k AGT
++ -t 7.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT 
+- -t 7.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT
+h -t 7.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT
++ -t 7.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 27 -k MAC 
+- -t 7.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 27 -k MAC
+h -t 7.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 27 -k MAC
+r -t 7.251088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 27 -k MAC
+r -t 7.252088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 27 -k AGT
++ -t 7.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT 
+- -t 7.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT
+h -t 7.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT
++ -t 7.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 28 -k MAC 
+- -t 7.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 28 -k MAC
+h -t 7.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 28 -k MAC
+r -t 7.501088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 28 -k MAC
+r -t 7.502088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 28 -k AGT
++ -t 7.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT 
+- -t 7.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT
+h -t 7.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT
++ -t 7.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 29 -k MAC 
+- -t 7.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 29 -k MAC
+h -t 7.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 29 -k MAC
+r -t 7.751088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 29 -k MAC
+r -t 7.752088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 29 -k AGT
++ -t 8.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT 
+- -t 8.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT
+h -t 8.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT
++ -t 8.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 30 -k MAC 
+- -t 8.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 30 -k MAC
+h -t 8.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 30 -k MAC
+r -t 8.001088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 30 -k MAC
+r -t 8.002088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 30 -k AGT
++ -t 8.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT 
+- -t 8.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT
+h -t 8.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT
++ -t 8.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 31 -k MAC 
+- -t 8.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 31 -k MAC
+h -t 8.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 31 -k MAC
+r -t 8.251088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 31 -k MAC
+r -t 8.252088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 31 -k AGT
++ -t 8.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT 
+- -t 8.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT
+h -t 8.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT
++ -t 8.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 32 -k MAC 
+- -t 8.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 32 -k MAC
+h -t 8.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 32 -k MAC
+r -t 8.501088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 32 -k MAC
+r -t 8.502088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 32 -k AGT
++ -t 8.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT 
+- -t 8.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT
+h -t 8.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT
++ -t 8.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 33 -k MAC 
+- -t 8.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 33 -k MAC
+h -t 8.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 33 -k MAC
+r -t 8.751088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 33 -k MAC
+r -t 8.752088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 33 -k AGT
++ -t 9.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT 
+- -t 9.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT
+h -t 9.000000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT
++ -t 9.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 34 -k MAC 
+- -t 9.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 34 -k MAC
+h -t 9.001000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 34 -k MAC
+r -t 9.001088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 34 -k MAC
+r -t 9.002088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 34 -k AGT
++ -t 9.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT 
+- -t 9.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT
+h -t 9.250000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT
++ -t 9.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 35 -k MAC 
+- -t 9.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 35 -k MAC
+h -t 9.251000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 35 -k MAC
+r -t 9.251088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 35 -k MAC
+r -t 9.252088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 35 -k AGT
++ -t 9.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT 
+- -t 9.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT
+h -t 9.500000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT
++ -t 9.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 36 -k MAC 
+- -t 9.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 36 -k MAC
+h -t 9.501000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 36 -k MAC
+r -t 9.501088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 36 -k MAC
+r -t 9.502088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 36 -k AGT
++ -t 9.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT 
+- -t 9.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT
+h -t 9.750000000 -s 0 -d -1 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT
++ -t 9.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 37 -k MAC 
+- -t 9.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 37 -k MAC
+h -t 9.751000000 -s 0 -d 3 -p raw -e 106 -c 2 -a 0 -i 37 -k MAC
+r -t 9.751088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 37 -k MAC
+r -t 9.752088800 -s 3 -d 3 -p raw -e 92 -c 2 -a 0 -i 37 -k AGT
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/ex/nsclick-simple-lan.tcl ns-2.34/tcl/ex/nsclick-simple-lan.tcl
--- ns-2.34-pure/tcl/ex/nsclick-simple-lan.tcl	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/ex/nsclick-simple-lan.tcl	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,271 @@
+#
+#  Copyright 2002, Univerity of Colorado at Boulder.                        
+#                                                                            
+#                         All Rights Reserved                                
+#                                                                            
+#  Permission to use, copy, modify, and distribute this software and its    
+#  documentation for any purpose other than its incorporation into a        
+#  commercial product is hereby granted without fee, provided that the      
+#  above copyright notice appear in all copies and that both that           
+#  copyright notice and this permission notice appear in supporting         
+#  documentation, and that the name of the University not be used in        
+#  advertising or publicity pertaining to distribution of the software      
+#  without specific, written prior permission.                              
+#                                                                            
+#  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+#  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+#  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+#  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+#  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+#  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+#  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+#  PERFORMANCE OF THIS SOFTWARE.                                            
+#
+# nsclick-simple-lan.tcl
+#
+# A sample nsclick script simulating a small LAN
+#
+
+#
+# Set some general simulation parameters
+#
+
+# 
+# Even though this is a wired simulation with non-moving nodes, nsclick
+# uses the mobile node type. This means we have to set the size of the
+# playing field and the topography even though it won't matter.
+#
+set xsize 100
+set ysize 100
+set wtopo	[new Topography]
+$wtopo load_flatgrid $xsize $ysize
+
+#
+# The network channel, physical layer, and MAC are all standard ns-2.
+#  
+set netchan	Channel
+set netphy	Phy/WiredPhy
+set netmac	Mac/802_3
+
+#
+# We have to use a special queue and link layer. This is so that
+# Click can have control over the network interface packet queue,
+# which is vital if we want to play with, e.g. QoS algorithms.
+#
+set netifq	Queue/ClickQueue
+set netll	LL/Ext
+LL set delay_			1ms
+
+#
+# These are pretty self-explanatory, just the number of nodes
+# and when we'll stop.
+#
+set nodecount   4
+set stoptime	10.0
+
+#
+# With nsclick, we have to worry about details like which network
+# port to use for communication. This sets the default ports to 5000.
+#
+Agent/Null set sport_		5000
+Agent/Null set dport_		5001
+
+Agent/CBR set sport_		5002
+Agent/CBR set dport_		5003
+
+#
+# Standard ns-2 stuff here - create the simulator object.
+#
+Simulator set MacTrace_ ON
+set ns_		[new Simulator]
+
+#
+# Create and activate trace files.
+#
+set tracefd	[open "nsclick-simple-lan.tr" w]
+set namtrace    [open "nsclick-simple-lan.nam" w]
+$ns_ trace-all $tracefd
+$ns_ namtrace-all-wireless $namtrace $xsize $ysize
+$ns_ use-newtrace
+
+
+#
+# Create the "god" object. This is another artifact of using
+# the mobile node type. We have to have this even though
+# we never use it.
+#
+set god_ [create-god $nodecount]
+
+#
+# Tell the simulator to create Click nodes.
+#
+Simulator set node_factory_ Node/MobileNode/ClickNode
+
+#
+# Create a network Channel for the nodes to use. One channel
+# per LAN.
+#
+set chan_1_ [new $netchan]
+
+#
+# In nsclick we have to worry about assigning IP and MAC addresses
+# to out network interfaces. Here we generate a list of IP and MAC
+# addresses, one per node since we've only got one network interface
+# per node in this case. Also note that this scheme only works for
+# fewer than 255 nodes, and we aren't worrying about subnet masks.
+#
+set iptemplate "192.168.1.%d"
+set mactemplate "00:03:47:70:89:%0x"
+for {set i 0} {$i < $nodecount} {incr i} {
+    set node_ip($i) [format $iptemplate [expr $i+1]]
+    set node_mac($i) [format $mactemplate [expr $i+1]]
+}
+
+#
+# We set the routing protocol to "Empty" so that ns-2 doesn't do
+# any packet routing. All of the routing will be done by the
+# Click script.
+#
+$ns_ rtproto Empty
+
+#
+# Here is where we actually create all of the nodes.
+#
+for {set i 0} {$i < $nodecount } {incr i} {
+    set node_($i) [$ns_ node]
+
+    #
+    # After creating the node, we add one wired network interface to
+    # it. By default, this interface will be named "eth0". If we
+    # added a second interface it would be named "eth1", a third
+    # "eth2" and so on.
+    #
+    $node_($i) add-wired-interface $chan_1_ $netll $netmac \
+	$netifq 1 $netphy
+
+    #
+    # Now configure the interface eth0
+    #
+    $node_($i) setip "eth0" $node_ip($i)
+    $node_($i) setmac "eth0" $node_mac($i)
+
+    #
+    # Set some node properties
+    #
+    $node_($i) random-motion 0
+    $node_($i) topography $wtopo
+    $node_($i) nodetrace $tracefd
+
+    #
+    # The node name is used by Click to distinguish information
+    # coming from different nodes. For example, a "Print" element
+    # prepends this to the printed string so it's clear exactly
+    # which node is doing the printing.
+    #
+    [$node_($i) set classifier_] setnodename "node$i-simplelan"
+    
+    #
+    # Load the appropriate Click router script for the node.
+    # All nodes in this simulation are using the same script,
+    # but there's no reason why each node couldn't use a different
+    # script.
+    #
+    [$node_($i) entry] loadclick "nsclick-simple-lan.click"
+}
+
+
+# 
+# Define node network traffic. There isn't a whole lot going on
+# in this simple test case, we're just going to have the first node
+# send packets to the last node, starting at 1 second, and ending at 10.
+# There are Perl scripts available to automatically generate network
+# traffic.
+#
+
+
+#
+# Start transmitting at $startxmittime, $xmitrate packets per second.
+#
+set startxmittime 1
+set xmitrate 4
+set xmitinterval 0.25
+set packetsize 64
+
+#
+# We use the "raw" packet type, which sends real packet data
+# down the pipe.
+#
+set raw_(0) [new Agent/Raw]
+$ns_ attach-agent $node_(0) $raw_(0)
+
+set lastnode [expr $nodecount-1]
+set null_(0) [new Agent/Null]
+$ns_ attach-agent $node_($lastnode) $null_(0)
+
+#
+# The CBR object is just the default ns-2 CBR object, so
+# no change in the meaning of the parameters.
+#
+set cbr_(0) [new Application/Traffic/CBR]
+$cbr_(0) set packetSize_ $packetsize
+$cbr_(0) set interval_ $xmitinterval
+$cbr_(0) set random_ 0
+$cbr_(0) set maxpkts_ [expr ($stoptime - $startxmittime)*$xmitrate]
+$cbr_(0) attach-agent $raw_(0)
+
+#
+# The Raw agent creates real UDP packets, so it has to know
+# the source and destination IP addresses and port numberes.
+#
+$raw_(0) set-srcip [$node_(0) getip eth0]
+$raw_(0) set-srcport 5000
+$raw_(0) set-destport 5001
+$raw_(0) set-destip [$node_($lastnode) getip eth0]
+
+$ns_ at $startxmittime "$cbr_(0) start"
+
+#
+# Set node positions. For wired networks, these are only used
+# when looking at nam traces.
+#
+$node_(0) set X_ 10
+$node_(0) set Y_ 50
+$node_(0) set Z_ 0
+
+$node_(1) set X_ 50
+$node_(1) set Y_ 50
+$node_(1) set Z_ 0
+
+$node_(2) set X_ 90
+$node_(2) set Y_ 50
+$node_(2) set Z_ 0
+
+$node_(3) set X_ 50
+$node_(3) set Y_ 10
+$node_(3) set Z_ 0
+
+#
+# This sizes the nodes for use in nam.
+#
+for {set i 0} {$i < $nodecount} {incr i} {
+    $ns_ initial_node_pos $node_($i) 20
+    [$node_($i) entry] runclick
+}
+
+#
+# Stop the simulation
+#
+$ns_ at  $stoptime.000000001 "puts \"NS EXITING...\" ; $ns_ halt"
+
+#
+# Let nam know that the simulation is done.
+#
+$ns_ at  $stoptime	"$ns_ nam-end-wireless $stoptime"
+
+
+puts "Starting Simulation..."
+$ns_ run
+
+
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/ex/nsclick-simple-lan.tr ns-2.34/tcl/ex/nsclick-simple-lan.tr
--- ns-2.34-pure/tcl/ex/nsclick-simple-lan.tr	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/ex/nsclick-simple-lan.tr	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,150 @@
+s 1.000000000 _0_ AGT  --- 0 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 1.001000000 _0_ MAC  --- 1 raw 64 [0 0 ffff0008 0] ------- [0:0 0:0 0 0] raw 
+r 1.001055200 _3_ MAC  --- 1 raw 28 [0 0 ffff0008 0] ------- [0:0 0:0 0 0] raw 
+r 1.001055200 _2_ MAC  --- 1 raw 28 [0 0 ffff0008 0] ------- [0:0 0:0 0 0] raw 
+r 1.001055200 _1_ MAC  --- 1 raw 28 [0 0 ffff0008 0] ------- [0:0 0:0 0 0] raw 
+s 1.003055200 _3_ MAC  --- 2 raw 64 [0 3000000 8 0] ------- [0:0 0:0 0 0] raw 
+r 1.003110400 _0_ MAC  --- 2 raw 28 [0 3000000 8 0] ------- [0:0 0:0 0 0] raw 
+s 1.005110400 _0_ MAC  --- 0 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 1.005199200 _3_ MAC  --- 0 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 1.006199200 _3_ AGT  --- 0 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 1.250000000 _0_ AGT  --- 3 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 1.251000000 _0_ MAC  --- 3 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 1.251088800 _3_ MAC  --- 3 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 1.252088800 _3_ AGT  --- 3 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 1.500000000 _0_ AGT  --- 4 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 1.501000000 _0_ MAC  --- 4 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 1.501088800 _3_ MAC  --- 4 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 1.502088800 _3_ AGT  --- 4 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 1.750000000 _0_ AGT  --- 5 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 1.751000000 _0_ MAC  --- 5 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 1.751088800 _3_ MAC  --- 5 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 1.752088800 _3_ AGT  --- 5 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 2.000000000 _0_ AGT  --- 6 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 2.001000000 _0_ MAC  --- 6 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 2.001088800 _3_ MAC  --- 6 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 2.002088800 _3_ AGT  --- 6 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 2.250000000 _0_ AGT  --- 7 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 2.251000000 _0_ MAC  --- 7 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 2.251088800 _3_ MAC  --- 7 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 2.252088800 _3_ AGT  --- 7 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 2.500000000 _0_ AGT  --- 8 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 2.501000000 _0_ MAC  --- 8 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 2.501088800 _3_ MAC  --- 8 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 2.502088800 _3_ AGT  --- 8 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 2.750000000 _0_ AGT  --- 9 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 2.751000000 _0_ MAC  --- 9 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 2.751088800 _3_ MAC  --- 9 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 2.752088800 _3_ AGT  --- 9 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 3.000000000 _0_ AGT  --- 10 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 3.001000000 _0_ MAC  --- 10 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 3.001088800 _3_ MAC  --- 10 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 3.002088800 _3_ AGT  --- 10 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 3.250000000 _0_ AGT  --- 11 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 3.251000000 _0_ MAC  --- 11 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 3.251088800 _3_ MAC  --- 11 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 3.252088800 _3_ AGT  --- 11 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 3.500000000 _0_ AGT  --- 12 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 3.501000000 _0_ MAC  --- 12 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 3.501088800 _3_ MAC  --- 12 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 3.502088800 _3_ AGT  --- 12 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 3.750000000 _0_ AGT  --- 13 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 3.751000000 _0_ MAC  --- 13 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 3.751088800 _3_ MAC  --- 13 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 3.752088800 _3_ AGT  --- 13 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 4.000000000 _0_ AGT  --- 14 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 4.001000000 _0_ MAC  --- 14 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 4.001088800 _3_ MAC  --- 14 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 4.002088800 _3_ AGT  --- 14 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 4.250000000 _0_ AGT  --- 15 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 4.251000000 _0_ MAC  --- 15 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 4.251088800 _3_ MAC  --- 15 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 4.252088800 _3_ AGT  --- 15 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 4.500000000 _0_ AGT  --- 16 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 4.501000000 _0_ MAC  --- 16 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 4.501088800 _3_ MAC  --- 16 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 4.502088800 _3_ AGT  --- 16 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 4.750000000 _0_ AGT  --- 17 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 4.751000000 _0_ MAC  --- 17 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 4.751088800 _3_ MAC  --- 17 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 4.752088800 _3_ AGT  --- 17 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 5.000000000 _0_ AGT  --- 18 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 5.001000000 _0_ MAC  --- 18 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 5.001088800 _3_ MAC  --- 18 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 5.002088800 _3_ AGT  --- 18 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 5.250000000 _0_ AGT  --- 19 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 5.251000000 _0_ MAC  --- 19 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 5.251088800 _3_ MAC  --- 19 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 5.252088800 _3_ AGT  --- 19 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 5.500000000 _0_ AGT  --- 20 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 5.501000000 _0_ MAC  --- 20 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 5.501088800 _3_ MAC  --- 20 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 5.502088800 _3_ AGT  --- 20 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 5.750000000 _0_ AGT  --- 21 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 5.751000000 _0_ MAC  --- 21 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 5.751088800 _3_ MAC  --- 21 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 5.752088800 _3_ AGT  --- 21 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 6.000000000 _0_ AGT  --- 22 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 6.001000000 _0_ MAC  --- 22 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 6.001088800 _3_ MAC  --- 22 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 6.002088800 _3_ AGT  --- 22 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 6.250000000 _0_ AGT  --- 23 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 6.251000000 _0_ MAC  --- 23 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 6.251088800 _3_ MAC  --- 23 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 6.252088800 _3_ AGT  --- 23 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 6.500000000 _0_ AGT  --- 24 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 6.501000000 _0_ MAC  --- 24 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 6.501088800 _3_ MAC  --- 24 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 6.502088800 _3_ AGT  --- 24 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 6.750000000 _0_ AGT  --- 25 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 6.751000000 _0_ MAC  --- 25 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 6.751088800 _3_ MAC  --- 25 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 6.752088800 _3_ AGT  --- 25 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 7.000000000 _0_ AGT  --- 26 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 7.001000000 _0_ MAC  --- 26 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 7.001088800 _3_ MAC  --- 26 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 7.002088800 _3_ AGT  --- 26 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 7.250000000 _0_ AGT  --- 27 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 7.251000000 _0_ MAC  --- 27 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 7.251088800 _3_ MAC  --- 27 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 7.252088800 _3_ AGT  --- 27 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 7.500000000 _0_ AGT  --- 28 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 7.501000000 _0_ MAC  --- 28 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 7.501088800 _3_ MAC  --- 28 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 7.502088800 _3_ AGT  --- 28 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 7.750000000 _0_ AGT  --- 29 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 7.751000000 _0_ MAC  --- 29 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 7.751088800 _3_ MAC  --- 29 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 7.752088800 _3_ AGT  --- 29 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 8.000000000 _0_ AGT  --- 30 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 8.001000000 _0_ MAC  --- 30 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 8.001088800 _3_ MAC  --- 30 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 8.002088800 _3_ AGT  --- 30 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 8.250000000 _0_ AGT  --- 31 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 8.251000000 _0_ MAC  --- 31 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 8.251088800 _3_ MAC  --- 31 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 8.252088800 _3_ AGT  --- 31 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 8.500000000 _0_ AGT  --- 32 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 8.501000000 _0_ MAC  --- 32 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 8.501088800 _3_ MAC  --- 32 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 8.502088800 _3_ AGT  --- 32 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 8.750000000 _0_ AGT  --- 33 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 8.751000000 _0_ MAC  --- 33 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 8.751088800 _3_ MAC  --- 33 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 8.752088800 _3_ AGT  --- 33 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 9.000000000 _0_ AGT  --- 34 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 9.001000000 _0_ MAC  --- 34 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 9.001088800 _3_ MAC  --- 34 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 9.002088800 _3_ AGT  --- 34 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 9.250000000 _0_ AGT  --- 35 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 9.251000000 _0_ MAC  --- 35 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 9.251088800 _3_ MAC  --- 35 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 9.252088800 _3_ AGT  --- 35 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 9.500000000 _0_ AGT  --- 36 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 9.501000000 _0_ MAC  --- 36 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 9.501088800 _3_ MAC  --- 36 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 9.502088800 _3_ AGT  --- 36 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
+s 9.750000000 _0_ AGT  --- 37 raw 92 [0 0 0 0] ------- [0:0 -1:-1 32 0] raw 
+s 9.751000000 _0_ MAC  --- 37 raw 106 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 9.751088800 _3_ MAC  --- 37 raw 92 [0 0 8 0] ------- [0:0 0:0 0 3] raw 
+r 9.752088800 _3_ AGT  --- 37 raw 92 [0 0 ffff0000 0] ------- [0:0 0:0 0 3] raw 
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/ex/nsclick-simple-wlan.tcl ns-2.34/tcl/ex/nsclick-simple-wlan.tcl
--- ns-2.34-pure/tcl/ex/nsclick-simple-wlan.tcl	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/ex/nsclick-simple-wlan.tcl	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,295 @@
+#
+#  Copyright 2002, Univerity of Colorado at Boulder.                        
+#                                                                            
+#                         All Rights Reserved                                
+#                                                                            
+#  Permission to use, copy, modify, and distribute this software and its    
+#  documentation for any purpose other than its incorporation into a        
+#  commercial product is hereby granted without fee, provided that the      
+#  above copyright notice appear in all copies and that both that           
+#  copyright notice and this permission notice appear in supporting         
+#  documentation, and that the name of the University not be used in        
+#  advertising or publicity pertaining to distribution of the software      
+#  without specific, written prior permission.                              
+#                                                                            
+#  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+#  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+#  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+#  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+#  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+#  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+#  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+#  PERFORMANCE OF THIS SOFTWARE.                                            
+#
+# nsclick-simple-lan.tcl
+#
+# A sample nsclick script simulating a small LAN
+#
+
+#
+# Set some general simulation parameters
+#
+
+#
+# Unity gain, omnidirectional antennas, centered 1.5m above each node.
+# These values are lifted from the ns-2 sample files.
+#
+Antenna/OmniAntenna set X_ 0
+Antenna/OmniAntenna set Y_ 0
+Antenna/OmniAntenna set Z_ 1.5
+Antenna/OmniAntenna set Gt_ 1.0
+Antenna/OmniAntenna set Gr_ 1.0
+
+#
+# Initialize the SharedMedia interface with parameters to make
+# it work like the 914MHz Lucent WaveLAN DSSS radio interface
+# These are taken directly from the ns-2 sample files.
+#
+Phy/WirelessPhy set CPThresh_ 10.0
+Phy/WirelessPhy set CSThresh_ 1.559e-11
+Phy/WirelessPhy set RXThresh_ 3.652e-10
+Phy/WirelessPhy set Rb_ 2*1e6
+Phy/WirelessPhy set Pt_ 0.2818
+Phy/WirelessPhy set freq_ 914e+6 
+Phy/WirelessPhy set L_ 1.0
+
+# 
+# Set the size of the playing field and the topography.
+#
+set xsize 100
+set ysize 100
+set wtopo	[new Topography]
+$wtopo load_flatgrid $xsize $ysize
+
+#
+# The network channel, physical layer, MAC, propagation model,
+# and antenna model are all standard ns-2.
+#  
+set netchan	Channel/WirelessChannel
+set netphy	Phy/WirelessPhy
+set netmac	Mac/802_11
+set netprop     Propagation/TwoRayGround
+set antenna     Antenna/OmniAntenna
+
+#
+# We have to use a special queue and link layer. This is so that
+# Click can have control over the network interface packet queue,
+# which is vital if we want to play with, e.g. QoS algorithms.
+#
+set netifq	Queue/ClickQueue
+set netll	LL/Ext
+LL set delay_			1ms
+
+#
+# These are pretty self-explanatory, just the number of nodes
+# and when we'll stop.
+#
+set nodecount   4
+set stoptime	10.0
+
+#
+# With nsclick, we have to worry about details like which network
+# port to use for communication. This sets the default ports to 5000.
+#
+Agent/Null set sport_		5000
+Agent/Null set dport_		5000
+
+Agent/CBR set sport_		5000
+Agent/CBR set dport_		5000
+
+#
+# Standard ns-2 stuff here - create the simulator object.
+#
+Simulator set MacTrace_ ON
+set ns_		[new Simulator]
+
+#
+# Create and activate trace files.
+#
+set tracefd	[open "nsclick-simple-wlan.tr" w]
+set namtrace    [open "nsclick-simple-wlan.nam" w]
+$ns_ trace-all $tracefd
+$ns_ namtrace-all-wireless $namtrace $xsize $ysize
+$ns_ use-newtrace
+
+
+#
+# Create the "god" object. This is another artifact of using
+# the mobile node type. We have to have this even though
+# we never use it.
+#
+set god_ [create-god $nodecount]
+
+#
+# Tell the simulator to create Click nodes.
+#
+Simulator set node_factory_ Node/MobileNode/ClickNode
+
+#
+# Create a network Channel for the nodes to use. One channel
+# per LAN. Also set the propagation model to be used.
+#
+set chan_1_ [new $netchan]
+set prop_ [new $netprop]
+
+#
+# In nsclick we have to worry about assigning IP and MAC addresses
+# to out network interfaces. Here we generate a list of IP and MAC
+# addresses, one per node since we've only got one network interface
+# per node in this case. Also note that this scheme only works for
+# fewer than 255 nodes, and we aren't worrying about subnet masks.
+#
+set iptemplate "192.168.1.%d"
+set mactemplate "00:03:47:70:89:%0x"
+for {set i 0} {$i < $nodecount} {incr i} {
+    set node_ip($i) [format $iptemplate [expr $i+1]]
+    set node_mac($i) [format $mactemplate [expr $i+1]]
+}
+
+#
+# We set the routing protocol to "Empty" so that ns-2 doesn't do
+# any packet routing. All of the routing will be done by the
+# Click script.
+#
+$ns_ rtproto Empty
+
+#
+# Here is where we actually create all of the nodes.
+#
+for {set i 0} {$i < $nodecount } {incr i} {
+    set node_($i) [$ns_ node]
+
+    #
+    # After creating the node, we add one wireless network interface to
+    # it. By default, this interface will be named "eth0". If we
+    # added a second interface it would be named "eth1", a third
+    # "eth2" and so on.
+    #
+    $node_($i) add-interface $chan_1_ $prop_ $netll $netmac \
+	$netifq 1 $netphy $antenna $wtopo
+
+    #
+    # Now configure the interface eth0
+    #
+    $node_($i) setip "eth0" $node_ip($i)
+    $node_($i) setmac "eth0" $node_mac($i)
+
+    #
+    # Set some node properties
+    #
+    $node_($i) random-motion 0
+    $node_($i) topography $wtopo
+    $node_($i) nodetrace $tracefd
+
+    #
+    # The node name is used by Click to distinguish information
+    # coming from different nodes. For example, a "Print" element
+    # prepends this to the printed string so it's clear exactly
+    # which node is doing the printing.
+    #
+    [$node_($i) set classifier_] setnodename "node$i-simplelan"
+    
+    #
+    # Load the appropriate Click router script for the node.
+    # All nodes in this simulation are using the same script,
+    # but there's no reason why each node couldn't use a different
+    # script.
+    #
+    [$node_($i) entry] loadclick "nsclick-simple-lan.click"
+}
+
+
+# 
+# Define node network traffic. There isn't a whole lot going on
+# in this simple test case, we're just going to have the first node
+# send packets to the last node, starting at 1 second, and ending at 10.
+# There are Perl scripts available to automatically generate network
+# traffic.
+#
+
+
+#
+# Start transmitting at $startxmittime, $xmitrate packets per second.
+#
+set startxmittime 1
+set xmitrate 4
+set xmitinterval 0.25
+set packetsize 64
+
+#
+# We use the "raw" packet type, which sends real packet data
+# down the pipe.
+#
+set raw_(0) [new Agent/Raw]
+$ns_ attach-agent $node_(0) $raw_(0)
+
+set lastnode [expr $nodecount-1]
+set null_(0) [new Agent/Null]
+$ns_ attach-agent $node_($lastnode) $null_(0)
+
+#
+# The CBR object is just the default ns-2 CBR object, so
+# no change in the meaning of the parameters.
+#
+set cbr_(0) [new Application/Traffic/CBR]
+$cbr_(0) set packetSize_ $packetsize
+$cbr_(0) set interval_ $xmitinterval
+$cbr_(0) set random_ 0
+$cbr_(0) set maxpkts_ [expr ($stoptime - $startxmittime)*$xmitrate]
+$cbr_(0) attach-agent $raw_(0)
+
+#
+# The Raw agent creates real UDP packets, so it has to know
+# the source and destination IP addresses and port numberes.
+#
+$raw_(0) set-srcip [$node_(0) getip eth0]
+$raw_(0) set-srcport 5000
+$raw_(0) set-destport 5000
+$raw_(0) set-destip [$node_($lastnode) getip eth0]
+
+$ns_ at $startxmittime "$cbr_(0) start"
+
+
+$node_(0) set X_ 10
+$node_(0) set Y_ 50
+$node_(0) set Z_ 0
+
+$node_(1) set X_ 50
+$node_(1) set Y_ 50
+$node_(1) set Z_ 0
+
+$node_(2) set X_ 90
+$node_(2) set Y_ 50
+$node_(2) set Z_ 0
+
+$node_(3) set X_ 50
+$node_(3) set Y_ 10
+$node_(3) set Z_ 0
+
+
+#
+# This sizes the nodes for use in nam. Currently, the trace files
+# produced by nsclick don't really work in nam.
+#
+for {set i 0} {$i < $nodecount} {incr i} {
+    $ns_ initial_node_pos $node_($i) 20
+    [$node_($i) entry] runclick
+}
+
+#
+# Stop the simulation
+#
+$ns_ at  $stoptime.000000001 "puts \"NS EXITING...\" ; $ns_ halt"
+
+#
+# Let nam know that the simulation is done.
+#
+$ns_ at  $stoptime	"$ns_ nam-end-wireless $stoptime"
+
+
+puts "Starting Simulation..."
+$ns_ run
+
+
+
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/lib/ns-clicknode.tcl ns-2.34/tcl/lib/ns-clicknode.tcl
--- ns-2.34-pure/tcl/lib/ns-clicknode.tcl	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/lib/ns-clicknode.tcl	2010-02-28 09:31:39.000000000 -0800
@@ -0,0 +1,352 @@
+#
+#  Copyright 2002, Univerity of Colorado at Boulder.                        
+#                                                                            
+#                         All Rights Reserved                                
+#                                                                            
+#  Permission to use, copy, modify, and distribute this software and its    
+#  documentation for any purpose other than its incorporation into a        
+#  commercial product is hereby granted without fee, provided that the      
+#  above copyright notice appear in all copies and that both that           
+#  copyright notice and this permission notice appear in supporting         
+#  documentation, and that the name of the University not be used in        
+#  advertising or publicity pertaining to distribution of the software      
+#  without specific, written prior permission.                              
+#                                                                            
+#  UNIVERSITY OF COLORADO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS      
+#  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND        
+#  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL THE UNIVERSITY    
+#  OF COLORADO BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL         
+#  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA      
+#  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER       
+#  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR         
+#  PERFORMANCE OF THIS SOFTWARE.                                            
+#
+#
+
+Class ClickNode -superclass Node/MobileNode
+
+Node/MobileNode/ClickNode instproc init args {
+    $self instvar nifs_ netif_ mac_ ifq_ ll_ dmux_
+    set ns [Simulator instance]
+    eval $self next $args
+    set nifs_ 0
+    $self register-module [new RtModule/Click]
+
+    #
+    # This Trace Target is used to log changes in direction
+    # and velocity for the mobile node.
+    #
+    set tracefd [$ns get-ns-traceall]
+    if {$tracefd != "" } {
+	$self nodetrace $tracefd
+	#$self agenttrace $tracefd
+    }
+
+    set namtracefd [$ns get-nam-traceall]
+    if {$namtracefd != "" } {
+	$self namattach $namtracefd
+    }
+
+}
+
+Node/MobileNode/ClickNode instproc getip { ifname } {
+    [$self entry] getip $ifname
+}
+
+Node/MobileNode/ClickNode instproc getmac { ifname } {
+    [$self entry] getmac $ifname
+}
+
+Node/MobileNode/ClickNode instproc setip { ifname ipaddr } {
+    [$self entry] setip $ifname $ipaddr
+}
+
+Node/MobileNode/ClickNode instproc setmac { ifname macaddr } {
+    [$self entry] setmac $ifname $macaddr
+}
+
+Node/MobileNode/ClickNode instproc add-route { dst target } {
+    #puts "ClickNode does routing via Click - not ns."
+}
+
+Node/MobileNode/ClickNode instproc delete-route args {
+    #puts "ClickNode does routing via Click - not ns."
+}
+
+Node/MobileNode/ClickNode instproc route-notify { module } {
+    #puts "ClickNode does routing via Click - not ns."
+}
+
+#
+# The following setups up link layer, mac layer, network interface
+# and physical layer structures for the click node. Stolen from
+# the MobileNode code, and then modified a bit, e.g. the ARP
+# stuff got removed.
+#
+Node/MobileNode/ClickNode instproc add-interface { channel pmodel lltype mactype \
+					    qtype qlen iftype anttype topo} {
+
+    $self instvar nifs_ netif_ mac_ ifq_ ll_
+    set ns [Simulator instance]
+    set t $nifs_
+    incr nifs_
+
+    set netif_($t)	[new $iftype]		;# interface
+    set mac_($t)	[new $mactype]		;# mac layer
+    set ifq_($t)	[new $qtype]		;# interface queue
+    set ll_($t)	[new $lltype]		;# link layer
+    set ant_($t)    [new $anttype]
+
+    set namfp [$ns get-nam-traceall]
+
+    #
+    # Local Variables
+    #
+    set nullAgent_ [$ns set nullAgent_]
+    set netif $netif_($t)
+    set mac $mac_($t)
+    set ifq $ifq_($t)
+    set ll $ll_($t)
+
+    #
+    # Link Layer
+    #
+    $ll mac $mac
+    $ll down-target $ifq
+    $ll up-target [$self entry]
+    # Stuff the link layer into the next available classifier slot, and
+    # use that slot number as the network id
+    $ll setid [[$self entry] installNext $ll]
+    # Set the associated MAC layer address
+    $ll set macDA_ [$mac id]
+
+    #
+    # Interface Queue
+    #
+    $ifq target $mac
+    $ifq set limit_ $qlen
+    set drpT [cmu-trace Drop "IFQ" $self]
+    $ifq drop-target $drpT
+    if { $namfp != "" } {
+	$drpT namattach $namfp
+    }
+    if {$qtype == "Queue/ClickQueue"} {
+	$ifq setclickclassifier [$self entry]
+	$ll ifq $ifq
+    }
+
+    #
+    # Mac Layer
+    #
+    $mac netif $netif
+    $mac up-target $ll
+    $mac down-target $netif
+    set god_ [God instance]
+    if {$mactype == "Mac/802_11"} {
+	# XXX this is a hack to handle multiple interfaces per node.
+	$mac nodes [expr 4*[$god_ num_nodes]]
+    }
+    #
+    # Network Interface
+    #
+    $netif channel $channel
+    $netif up-target $mac
+    $netif propagation $pmodel	;# Propagation Model
+    $netif node $self		;# Bind node <---> interface
+    $netif antenna $ant_($t)
+    #
+    # Physical Channel
+    #
+    $channel addif $netif
+
+        # List-based improvement
+	# For nodes talking to multiple channels this should
+	# be called multiple times for each channel
+	$channel add-node $self		
+
+	# let topo keep handle of channel
+	$topo channel $channel	
+
+    
+    # ============================================================
+    
+    if { [Simulator set MacTrace_] == "ON" } {
+	#
+	# Trace RTS/CTS/ACK Packets
+	#
+	set rcvT [cmu-trace Recv "MAC" $self]
+	$mac log-target $rcvT
+	if { $namfp != "" } {
+	    $rcvT namattach $namfp
+	}
+	#
+	# Trace Sent Packets
+	#
+	set sndT [cmu-trace Send "MAC" $self]
+	$sndT target [$mac down-target]
+	$mac down-target $sndT
+	if { $namfp != "" } {
+	    $sndT namattach $namfp
+	}
+	#
+	# Trace Received Packets
+	#
+	set rcvT [cmu-trace Recv "MAC" $self]
+	$rcvT target [$mac up-target]
+	$mac up-target $rcvT
+	if { $namfp != "" } {
+	    $rcvT namattach $namfp
+	}
+	#
+	# Trace Dropped Packets
+	#
+	set drpT [cmu-trace Drop "MAC" $self]
+	$mac drop-target $drpT
+	if { $namfp != "" } {
+	    $drpT namattach $namfp
+	}
+    } else {
+	$mac log-target [$ns set nullAgent_]
+	$mac drop-target [$ns set nullAgent_]
+    }
+    
+    # ============================================================
+    
+    $self addif $netif
+}
+
+
+#
+# The following setups up link layer, mac layer, network interface
+# and physical layer structures for the click node. Stolen from
+# the MobileNode code, and then modified a bit, e.g. the ARP
+# stuff got removed.
+#
+Node/MobileNode/ClickNode instproc add-wired-interface { channel lltype mactype qtype qlen iftype} {
+
+    $self instvar nifs_ netif_ mac_ ifq_ ll_
+    set ns [Simulator instance]
+    set t $nifs_
+    incr nifs_
+
+    set netif_($t)	[new $iftype]		;# interface
+    set mac_($t)	[new $mactype]		;# mac layer
+    set ifq_($t)	[new $qtype]		;# interface queue
+    set ll_($t)	[new $lltype]		;# link layer
+
+
+    set namfp [$ns get-nam-traceall]
+
+    #
+    # Local Variables
+    #
+    set nullAgent_ [$ns set nullAgent_]
+    set netif $netif_($t)
+    set mac $mac_($t)
+    set ifq $ifq_($t)
+    set ll $ll_($t)
+
+    #
+    # Link Layer
+    #
+    $ll mac $mac
+    $ll down-target $ifq
+     $ll up-target [$self entry]
+    # Stuff the link layer into the next available classifier slot, and
+    # use that slot number as the network id
+    $ll setid [[$self entry] installNext $ll]
+    # Set the associated MAC layer address
+    $ll set macDA_ [$mac id]
+
+    #
+    # Interface Queue
+    #
+    $ifq target $mac
+    $ifq set limit_ $qlen
+    set drpT [cmu-trace Drop "IFQ" $self]
+    $ifq drop-target $drpT
+    if { $namfp != "" } {
+	$drpT namattach $namfp
+    }
+    if {$qtype == "Queue/ClickQueue"} {
+	$ifq setclickclassifier [$self entry]
+	$ll ifq $ifq
+    }
+
+    #
+    # Mac Layer
+    #
+    $mac netif $netif
+    $mac up-target $ll
+    $mac down-target $netif
+    set god_ [God instance]
+    if {$mactype == "Mac/802_11"} {
+	$mac nodes [$god_ num_nodes]
+    }
+    #
+    # Network Interface
+    #
+    $netif channel $channel
+    $netif up-target $mac
+    $netif node $self		;# Bind node <---> interface
+    #
+    # Physical Channel
+    #
+    $channel addif $netif
+    
+    # ============================================================
+    
+    if { [Simulator set MacTrace_] == "ON" } {
+	#
+	# Trace RTS/CTS/ACK Packets
+	#
+	set rcvT [cmu-trace Recv "MAC" $self]
+	$mac log-target $rcvT
+	if { $namfp != "" } {
+	    $rcvT namattach $namfp
+	}
+	#
+	# Trace Sent Packets
+	#
+	set sndT [cmu-trace Send "MAC" $self]
+	$sndT target [$mac down-target]
+	$mac down-target $sndT
+	if { $namfp != "" } {
+	    $sndT namattach $namfp
+	}
+	#
+	# Trace Received Packets
+	#
+	set rcvT [cmu-trace Recv "MAC" $self]
+	$rcvT target [$mac up-target]
+	$mac up-target $rcvT
+	if { $namfp != "" } {
+	    $rcvT namattach $namfp
+	}
+	#
+	# Trace Dropped Packets
+	#
+	set drpT [cmu-trace Drop "MAC" $self]
+	$mac drop-target $drpT
+	if { $namfp != "" } {
+	    $drpT namattach $namfp
+	}
+    } else {
+	$mac log-target [$ns set nullAgent_]
+	$mac drop-target [$ns set nullAgent_]
+    }
+    
+    # ============================================================
+    
+    $self addif $netif
+}
+
+Node/MobileNode/ClickNode instproc setpromiscuous { whichif ispromisc } {
+    $self instvar ll_
+    set thell $ll_($whichif)
+    $thell setpromiscuous $ispromisc
+}
+
+Node/MobileNode/ClickNode instproc dump-namconfig {} {
+# Do nothing
+}
\ No newline at end of file
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/lib/ns-default.tcl ns-2.34/tcl/lib/ns-default.tcl
--- ns-2.34-pure/tcl/lib/ns-default.tcl	2009-06-14 10:35:41.000000000 -0700
+++ ns-2.34/tcl/lib/ns-default.tcl	2010-02-28 09:31:39.000000000 -0800
@@ -761,6 +761,19 @@
 Phy/WirelessPhy set Pt_ 0.28183815
 Phy/WirelessPhy set freq_ 914e+6
 Phy/WirelessPhy set L_ 1.0  
+# Madwifi multirate support
+# Number of rates
+# Set 0 to disable multirate
+Phy/WirelessPhy set RateCount_ 0
+
+# Placeholder SwitchChannel function
+# This allows the WirelessInfo element in the Click router
+# to trigger a channel change.
+# Override this in your simulation script to effectively 
+# change the channel of wireless interface.
+proc SwitchChannel { i whichif whichnewchannel } {
+
+}
 
 Phy/WirelessPhyExt set CSThresh_ 6.30957e-12           ;# -82 dBm
 Phy/WirelessPhyExt set noise_floor_ 7.96159e-14        ;# -101 dBm
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/lib/ns-default.tcl.orig ns-2.34/tcl/lib/ns-default.tcl.orig
--- ns-2.34-pure/tcl/lib/ns-default.tcl.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/lib/ns-default.tcl.orig	2009-06-14 10:35:41.000000000 -0700
@@ -0,0 +1,1465 @@
+# -*-	Mode:tcl; tcl-indent-level:8; tab-width:8; indent-tabs-mode:t -*-
+#
+# Time-stamp: <2000-09-13 13:48:04 haoboy>
+#
+# Copyright (c) 1996-1997 Regents of the University of California.
+# All rights reserved.
+# 
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. All advertising materials mentioning features or use of this software
+#    must display the following acknowledgement:
+# 	This product includes software developed by the MASH Research
+# 	Group at the University of California Berkeley.
+# 4. Neither the name of the University nor of the Research Group may be
+#    used to endorse or promote products derived from this software without
+#    specific prior written permission.
+# 
+
+# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/lib/ns-default.tcl,v 1.383 2009/01/02 21:50:24 tom_henderson Exp $
+
+# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+#
+#
+# Set up all the default paramters.  Each default parameter
+# is stored in the OTcl class template and copied from the
+# class into the instance when the object is created
+# (this happens in the Tcl/tcl-object.tcl helper library)
+#
+
+########################################################
+
+# Debojyoti added this
+Simulator set useasim_ 1
+Asim set debug_ false
+
+set MAXSEQ 1073741824
+# Increased Floating Point Precision
+set tcl_precision 17
+
+Connector set debug_ false
+TTLChecker set debug_ false
+
+Trace set src_ -1
+Trace set dst_ -1
+Trace set callback_ 0
+Trace set show_tcphdr_ 0
+Trace set show_sctphdr_ 0
+Trace set debug_ false
+
+
+CMUTrace set debug_ false
+CMUTrace set show_sctphdr_ 0
+CMUTrace set radius_scaling_factor_ 1.0
+CMUTrace set duration_scaling_factor_ 3.0e4
+
+Scheduler/RealTime set maxslop_ 0.010; # max allowed slop b4 error (sec)
+
+Scheduler/Calendar set adjust_new_width_interval_ 10;	# the interval (in unit of resize times) we recalculate bin width. 0 means disable dynamic adjustment
+Scheduler/Calendar set min_bin_width_ 1e-18;		# the lower bound for the bin_width
+
+#
+# Queues and associated
+#
+Integrator set lastx_ 0.0
+Integrator set lasty_ 0.0
+Integrator set sum_ 0.0
+
+# 10->50 to be like ns-1
+Queue set limit_ 50
+Queue set blocked_ false
+Queue set unblock_on_resume_ true
+
+Queue set interleave_ false
+Queue set acksfirst_ false
+Queue set ackfromfront_ false
+Queue set debug_ false
+
+Queue/SFQ set maxqueue_ 40
+Queue/SFQ set buckets_ 16
+
+Queue/FQ set secsPerByte_ 0
+# change DropTail to RED for RED on individual queues
+FQLink set queueManagement_ DropTail
+
+Queue/DropTail set drop_front_ false
+Queue/DropTail set summarystats_ false
+Queue/DropTail set queue_in_bytes_ false
+Queue/DropTail set mean_pktsize_ 500
+
+Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1
+
+# special cmu implemented priority queue used by DSR
+CMUPriQueue set qlen_logthresh_ 10
+CMUPriQueue set fw_logthresh_ 25
+CMUPriQueue set debug_ false
+
+#notel's diffserv module
+Queue/dsRED set numQueues_ 4
+Queue/dsRED set ecn_ 0
+
+# XXX Temporary fix XXX
+# support only xcp flows; set to 1 when supporting both tcp and xcp flows; temporary fix for allocating link BW between xcp and tcp queues until dynamic queue weights come into effect. This fix should then go away
+Queue/XCP set tcp_xcp_on_ 0  ;
+
+Queue/RED set bytes_ true ;		# default changed on 10/11/2004.
+Queue/RED set queue_in_bytes_ true ;	# default changed on 10/11/2004.
+# Queue/RED set thresh_ 5
+Queue/RED set thresh_ 0
+# Queue/RED/thresh_ was changed on 12/29/01, for automatic configuration.
+# Queue/RED set maxthresh_ 15
+Queue/RED set maxthresh_ 0
+# Queue/RED/maxthresh_ was changed on 12/29/01, for automatic configuration.
+Queue/RED set thresh_queue_ [Queue set limit_]
+# Note from Sally: I don't see that thresh_queue_ is used for anything.
+Queue/RED set maxthresh_queue_ [Queue set limit_]
+# Note from Sally: I don't see that maxthresh_queue_ is used for anything.
+Queue/RED set mean_pktsize_ 500
+Queue/RED set idle_pktsize_ 100
+# Queue/RED set q_weight_ 0.002
+Queue/RED set q_weight_ -1
+# Queue/RED/q_weight_ was changed on 12/29/01, for automatic configuration.
+Queue/RED set wait_ true
+Queue/RED set linterm_ 10
+Queue/RED set mark_p_ 0.1
+Queue/RED set use_mark_p_ true
+# Queue/RED/use_mark_p_ was added on 11/23/05.
+# Queue/RED/use_mark_p_ was changed to true on 12/22/05.
+Queue/RED set setbit_ false
+Queue/RED set gentle_ true
+### Queue/RED/gentle_ was changed from false to true on Apr 23, 2001.
+Queue/RED set drop_tail_ true
+Queue/RED set drop_front_ false
+Queue/RED set drop_rand_ false
+Queue/RED set doubleq_ false
+Queue/RED set ns1_compat_ false
+Queue/RED set dqthresh_ 50
+Queue/RED set ave_ 0.0
+Queue/RED set prob1_ 0.0
+Queue/RED set curq_ 0
+Queue/RED set cur_max_p_ 0
+Queue/RED set summarystats_ false
+### Adaptive RED.
+Queue/RED set alpha_ 0.01
+Queue/RED set beta_ 0.9 
+Queue/RED set adaptive_ 0
+Queue/RED set interval_ 0.5
+Queue/RED set targetdelay_ 0.005
+Queue/RED set top_ 0.5
+Queue/RED set bottom_ 0
+### Queue/RED/bottom_ was changed from 0.01 to 0 on June 23, 2004,
+###   for automatic configuration.
+Queue/RED set cautious_ 0
+Queue/RED set feng_adaptive_ 0
+
+Queue/RED/RIO set bytes_ false
+Queue/RED/RIO set queue_in_bytes_ false
+Queue/RED/RIO set thresh_ 5
+Queue/RED/RIO set maxthresh_ 15
+Queue/RED/RIO set in_thresh_ 15
+Queue/RED/RIO set in_maxthresh_ 30
+Queue/RED/RIO set out_thresh_ 5
+Queue/RED/RIO set out_maxthresh_ 15
+Queue/RED/RIO set mean_pktsize_ 500
+Queue/RED/RIO set q_weight_ 0.002
+Queue/RED/RIO set wait_ true
+Queue/RED/RIO set linterm_ 10
+Queue/RED/RIO set in_linterm_ 50
+Queue/RED/RIO set out_linterm_ 5
+Queue/RED/RIO set setbit_ false
+Queue/RED/RIO set gentle_ false
+Queue/RED/RIO set in_gentle_ false
+Queue/RED/RIO set out_gentle_ false
+Queue/RED/RIO set drop_tail_ true
+Queue/RED/RIO set drop_front_ false
+Queue/RED/RIO set drop_rand_ false
+Queue/RED/RIO set doubleq_ false
+Queue/RED/RIO set ns1_compat_ false
+Queue/RED/RIO set dqthresh_ 50
+Queue/RED/RIO set ave_ 0.0
+Queue/RED/RIO set in_ave_ 0.0
+Queue/RED/RIO set out_ave_ 0.0
+Queue/RED/RIO set prob1_ 0.0
+Queue/RED/RIO set in_prob1_ 0.0
+Queue/RED/RIO set out_prob1_ 0.0
+Queue/RED/RIO set curq_ 0
+Queue/RED/RIO set priority_method_ 0
+
+#for RedPDQueue - ratul
+Queue/RED/PD set auto_ false
+Queue/RED/PD set global_target_ false
+Queue/RED/PD set noMonitored_ 0
+Queue/RED/PD set targetBW_ 0
+Queue/RED/PD set unresponsive_penalty_ 1
+Queue/RED/PD set P_testFRp_ -1
+Queue/RED/PD set noidle_ false
+
+Queue/PI set bytes_ false
+Queue/PI set queue_in_bytes_ false
+Queue/PI set a_ 0.00001822
+Queue/PI set b_ 0.00001816
+Queue/PI set w_ 170
+Queue/PI set qref_ 50
+Queue/PI set mean_pktsize_ 500
+Queue/PI set setbit_ false
+Queue/PI set prob_ 0
+Queue/PI set curq_ 0
+
+# Queue/Vq set queue_in_bytes_ false
+Queue/Vq set queue_in_bytes_ true
+# Default for queue_in_bytes_ changed to true on 4/28/2002.
+Queue/Vq set markpkts_ false 
+Queue/Vq set ecnlim_ 0.8
+Queue/Vq set buflim_ 1.0 
+# Queue/Vq set gamma_ 0.895
+Queue/Vq set gamma_ 0.98
+# Default for gamma_ changed to 0.98 on 4/28/2002.
+Queue/Vq set mean_pktsize_ 1000
+Queue/Vq set curq_ 0
+Queue/Vq set drop_front_ 0
+Queue/Vq set markfront_ 0
+
+Queue/REM set gamma_ 0.001
+Queue/REM set phi_ 1.001
+Queue/REM set inw_ 1
+Queue/REM set mean_pktsize_ 1000
+Queue/REM set pupdtime_ 0.002
+Queue/REM set pbo_ 20.0
+Queue/REM set prob_ 0.0
+Queue/REM set curq_ 0.0
+Queue/REM set pmark_ 0.0
+Queue/REM set markpkts_ false
+Queue/REM set qib_ false
+
+Queue/GK set ecnlim_ 0.95
+Queue/GK set mean_pktsize_ 1000
+Queue/GK set curq_ 0
+Queue/GK set drop_front_ 0
+
+Queue/DRR set buckets_ 10
+Queue/DRR set blimit_ 25000
+Queue/DRR set quantum_ 250
+Queue/DRR set mask_ 0
+
+# Integrated SRR (1/20/2002, xuanc)
+Queue/SRR set maxqueuenumber_ 16
+Queue/SRR set mtu_ 1000
+Queue/SRR set granularity_ 1000
+Queue/SRR set blimit_ 25000
+
+Queue/CBQ set algorithm_ 0 ;# used by compat only, not bound
+Queue/CBQ set maxpkt_ 1024
+CBQClass set priority_ 0
+CBQClass set level_ 1
+CBQClass set extradelay_ 0.0
+CBQClass set def_qtype_ DropTail
+CBQClass set okborrow_ true
+CBQClass set automaxidle_gain_ 0.9375
+CBQClass set debug_ false
+
+SnoopQueue/In set debug_ false
+SnoopQueue/Out set debug_ false
+SnoopQueue/Drop set debug_ false
+SnoopQueue/EDrop set debug_ false
+SnoopQueue/Tagger set debug_ false
+
+PacketQueue/Semantic set acksfirst_ false
+PacketQueue/Semantic set filteracks_ false
+PacketQueue/Semantic set replace_head_ false
+PacketQueue/Semantic set priority_drop_ false
+PacketQueue/Semantic set random_drop_ false
+PacketQueue/Semantic set reconsAcks_ false
+PacketQueue/Semantic set random_ecn_ false
+
+QueueMonitor set size_ 0
+QueueMonitor set pkts_ 0
+QueueMonitor set parrivals_ 0
+QueueMonitor set barrivals_ 0
+QueueMonitor set pdepartures_ 0
+QueueMonitor set bdepartures_ 0
+QueueMonitor set pdrops_ 0
+QueueMonitor set pmarks_ 0
+QueueMonitor set bdrops_ 0
+
+QueueMonitor set qs_pkts_ 0
+QueueMonitor set qs_bytes_ 0
+QueueMonitor set qs_drops_ 0
+
+QueueMonitor set first_pkt_ 0
+QueueMonitor set last_pkt_ 0
+
+#added for keeping RTT stats
+QueueMonitor set keepRTTstats_ 0
+QueueMonitor set maxRTT_ 5
+QueueMonitor set binsPerSec_ 100
+
+#added for keeping Seqno stats
+QueueMonitor set keepSeqnoStats_ 0
+QueueMonitor set maxSeqno_ 1000
+QueueMonitor set SeqnoBinSize_ 10
+
+#added for online rate monitoring - ratul
+QueueMonitor set k_ 0.1
+QueueMonitor set prevTime_ 0
+QueueMonitor set startTime_ 0
+QueueMonitor set estRate_ 0
+QueueMonitor set estimate_rate_ 0
+
+QueueMonitor/ED set epdrops_ 0
+QueueMonitor/ED set ebdrops_ 0
+
+#mon stuff added for RedPD and Pushback - ratul
+QueueMonitor/ED set mon_epdrops_ 0                     
+QueueMonitor/ED set mon_ebdrops_ 0
+
+QueueMonitor/ED/Flowmon set enable_in_ true
+QueueMonitor/ED/Flowmon set enable_out_ true
+QueueMonitor/ED/Flowmon set enable_drop_ true
+QueueMonitor/ED/Flowmon set enable_edrop_ true
+QueueMonitor/ED/Flowmon set enable_mon_edrop_ true
+
+QueueMonitor/ED/Flow set src_ -1
+QueueMonitor/ED/Flow set dst_ -1
+QueueMonitor/ED/Flow set flowid_ -1
+
+QueueMonitor/ED/Flow/TB set target_rate_ 128000 
+QueueMonitor/ED/Flow/TB set bucket_depth_ 10000
+QueueMonitor/ED/Flow/TB set tbucket_ 10000
+QueueMonitor/ED/Flow/TSW set target_rate_ 0
+QueueMonitor/ED/Flow/TSW set win_len_ 10
+QueueMonitor/ED/Flow/TSW set wait_ true
+
+#RedPDFlow  - ratul
+QueueMonitor/ED/Flow/RedPD set targetBW_ 0
+QueueMonitor/ED/Flow/RedPD set currentBW_ 0
+QueueMonitor/ED/Flow/RedPD set monitored_ 0
+QueueMonitor/ED/Flow/RedPD set unresponsive_ 0
+QueueMonitor/ED/Flow/RedPD set monitorStartTime_ 0
+QueueMonitor/ED/Flow/RedPD set unresponsiveStartTime_ 0
+QueueMonitor/ED/Flow/RedPD set lastDropTime_ 0 
+QueueMonitor/ED/Flow/RedPD set auto_ 0 
+
+DelayLink set bandwidth_ 1.5Mb
+DelayLink set delay_ 100ms
+DelayLink set debug_ false
+DelayLink set avoidReordering_ false ;	# Added 3/27/2003.
+					# Set to true to avoid reordering when
+					#   changing link bandwidth or delay.
+DynamicLink set status_ 1
+DynamicLink set debug_ false
+
+Filter set debug_ false
+Filter/Field set offset_ 0
+Filter/Field set match_  -1
+
+
+
+# these are assigned when created
+Classifier set offset_ 0
+Classifier set shift_ 0
+Classifier set mask_ 0xffffffff
+Classifier set debug_ false
+
+Classifier/Hash set default_ -1; # none
+Classifier/Replicator set ignore_ 0
+
+# MPLS Classifier
+Classifier/Addr/MPLS set ttl_   32
+Classifier/Addr/MPLS set trace_mpls_ 0
+Classifier/Addr/MPLS set label_ -1
+Classifier/Addr/MPLS set enable_reroute_    0
+Classifier/Addr/MPLS set reroute_option_ 0
+Classifier/Addr/MPLS set control_driven_ 0
+Classifier/Addr/MPLS set data_driven_ 0
+
+#
+# FEC models
+#
+
+FECModel set debug_ false
+
+#
+# Error models
+#
+
+ErrorModule set debug_ false
+
+ErrorModel set enable_ 1
+ErrorModel set markecn_ false
+ErrorModel set delay_pkt_ false
+ErrorModel set delay_ 0
+ErrorModel set rate_ 0
+ErrorModel set bandwidth_ 2Mb
+ErrorModel set debug_ false
+
+ErrorModel/Trace set good_ 123456789
+ErrorModel/Trace set loss_ 0
+ErrorModel/Periodic set period_ 1.0
+ErrorModel/Periodic set offset_ 0.0
+ErrorModel/Periodic set burstlen_ 0.0
+ErrorModel/Periodic set default_drop_ 0 ;	# set to 1 for default-drop,
+						# to drop all but last pkt
+						# in period_
+ErrorModel/MultiState set curperiod_ 0.0
+ErrorModel/MultiState set sttype_ pkt
+ErrorModel/MultiState set texpired_ 0
+
+SelectErrorModel set enable_ 1
+SelectErrorModel set markecn_ false
+SelectErrorModel set rate_ 0
+SelectErrorModel set bandwidth_ 2Mb
+SelectErrorModel set pkt_type_ 2
+SelectErrorModel set drop_cycle_ 10
+SelectErrorModel set drop_offset_ 1
+SelectErrorModel set debug_ false
+SelectErrorModel set delay_pkt_ false
+SelectErrorModel set delay_ 0
+SRMErrorModel set enable_ 1
+SRMErrorModel set markecn_ false
+SRMErrorModel set rate_ 0
+SRMErrorModel set bandwidth_ 2Mb
+SRMErrorModel set pkt_type_ 2
+SRMErrorModel set drop_cycle_ 10
+SRMErrorModel set drop_offset_ 1
+SRMErrorModel set debug_ false
+SRMErrorModel set delay_pkt_ false
+SRMErrorModel set delay_ 0
+#MrouteErrorModel set enable_ 1
+#MrouteErrorModel set rate_ 0
+#MrouteErrorModel set bandwidth_ 2Mb
+#MrouteErrorModel set pkt_type_ 2
+#MrouteErrorModel set drop_cycle_ 10
+#MrouteErrorModel set drop_offset_ 1
+#MrouteErrorModel set good_ 99999999
+#MrouteErrorModel set loss_ 0
+
+rtModel set startTime_ 0.5
+rtModel set finishTime_ "-"
+rtModel/Exponential set upInterval_   10.0
+rtModel/Exponential set downInterval_  1.0
+rtModel/Deterministic set upInterval_   2.0
+rtModel/Deterministic set downInterval_ 1.0
+
+#
+# Application
+#
+
+Application/Traffic/CBR_PP set rate_ 448Kb ;# corresponds to interval of 3.75ms
+Application/Traffic/CBR_PP set packetSize_ 210
+Application/Traffic/CBR_PP set random_ 0
+Application/Traffic/CBR_PP set maxpkts_ 268435456; # 0x10000000
+Application/Traffic/CBR_PP set PBM_ 2
+
+Application/Traffic/Exponential set burst_time_ .5
+Application/Traffic/Exponential set idle_time_ .5
+Application/Traffic/Exponential set rate_ 64Kb
+Application/Traffic/Exponential set packetSize_ 210
+
+Application/Traffic/Pareto set burst_time_ 500ms
+Application/Traffic/Pareto set idle_time_ 500ms
+Application/Traffic/Pareto set rate_ 64Kb
+Application/Traffic/Pareto set packetSize_ 210
+Application/Traffic/Pareto set shape_ 1.5
+
+Application/Traffic/RealAudio set burst_time_ 0.05ms
+Application/Traffic/RealAudio set idle_time_ 1800ms
+Application/Traffic/RealAudio set rate_ 2Kb
+Application/Traffic/RealAudio set packetSize_ 240
+Application/Traffic/RealAudio set minCDF_ 0
+Application/Traffic/RealAudio set maxCDF_ 1
+Application/Traffic/RealAudio set interpolation_ 0
+Application/Traffic/RealAudio set maxEntry_ 32
+
+Application/Traffic/CBR set rate_ 448Kb	;# corresponds to interval of 3.75ms
+Application/Traffic/CBR set packetSize_ 210
+Application/Traffic/CBR set random_ 0
+Application/Traffic/CBR set maxpkts_ 268435456; # 0x10000000
+
+Application/Telnet set interval_ 1.0
+
+# Default config based on data for slammer worm
+Application/Worm set ScanRate 4000
+Application/Worm set ScanPort 1434
+Application/Worm set ScanPacketSize 404
+Application/Worm/An set TimeStep 1
+
+Application/SctpApp1 set interval_ 1.0
+Application/SctpApp1 set numStreams_ 1
+Application/SctpApp1 set numUnreliable_ 0
+Application/SctpApp1 set reliability_ 0
+
+RandomVariable/Uniform set min_ 0.0
+RandomVariable/Uniform set max_ 1.0
+RandomVariable/Exponential set avg_ 1.0
+RandomVariable/Erlang set lambda_ 1.0
+RandomVariable/Erlang set k_ 1.0
+RandomVariable/Gamma set alpha_ 1.0
+RandomVariable/Gamma set beta_ 1.0
+RandomVariable/Pareto set avg_ 1.0
+RandomVariable/Pareto set shape_ 1.5
+RandomVariable/ParetoII set avg_ 10.0
+RandomVariable/ParetoII set shape_ 1.2
+RandomVariable/Constant set val_ 1.0
+RandomVariable/HyperExponential set avg_ 1.0
+RandomVariable/HyperExponential set cov_ 4.0
+RandomVariable/Empirical set minCDF_ 0
+RandomVariable/Empirical set maxCDF_ 1
+RandomVariable/Empirical set interpolation_ 0
+RandomVariable/Empirical set maxEntry_ 32
+RandomVariable/Normal set avg_ 0.0
+RandomVariable/Normal set std_ 1.0
+RandomVariable/LogNormal set avg_ 1.0
+RandomVariable/LogNormal set std_ 1.0
+RandomVariable/Weibull set scale_ 1.0
+RandomVariable/Weibull set shape_ 1.0
+
+ADC/MS set debug_ false
+ADC/HB set debug_ false
+ADC/Param set debug_ false
+ADC/ACTP set debug_ false
+ADC/ACTO set debug_ false
+
+Est/Null set debug_ false
+Est/TimeWindow set debug_ false
+Est/ExpAvg set debug_ false
+Est/PointSample set debug_ false
+
+MeasureMod set debug_ false
+SALink set debug_ false
+
+#
+# Node
+#
+
+Node set multiPath_ 0
+Node set rtagent_port_ 255
+
+# setting port for diffusion application agent
+Node set DIFFUSION_APP_PORT 254
+
+Node/MobileNode set X_				0
+Node/MobileNode set Y_				0
+Node/MobileNode set Z_				0
+Node/MobileNode set speed_				0
+Node/MobileNode set position_update_interval_	0
+Node/MobileNode set bandwidth_			0	;# not used
+Node/MobileNode set delay_				0	;# not used
+Node/MobileNode set REGAGENT_PORT 0
+Node/MobileNode set DECAP_PORT 1
+
+
+# Default settings for Hierarchical topology
+#
+# Bits are allocated for different fields like port, nodeid, mcast, 
+# hierarchical-levels. 
+# All Mask and Shift values are stored in Class AddrParams.
+AddrParams set ALL_BITS_SET 0xffffffff
+AddrParams PortShift 0
+AddrParams PortMask [AddrParams set ALL_BITS_SET]
+AddrParams set domain_num_ 1
+AddrParams set def_clusters 4
+AddrParams set def_nodes 5
+
+####  Default and Maximum Address space - leaving the MSB as signed bit
+AllocAddrBits set DEFADDRSIZE_ 32
+AllocAddrBits set MAXADDRSIZE_ 32                ;# leaving the signed bit
+
+Simulator set node_factory_ Node
+Simulator set nsv1flag 0
+Simulator set mobile_ip_ 0			 ;# flag for mobileIP
+
+#this was commented out - ratul
+#Simulator set EnableHierRt_ 0   ;# is hierarchical routing on?  (to turn it on, call set-hieraddress)
+
+Simulator set routingAgent_ ""
+Simulator set addressType_   ""
+Simulator set MovementTrace_ OFF
+
+# change wrt Mike's code
+Simulator set EotTrace_ OFF
+
+
+# This flag should be initially empty. It will be set to either ON or OFF
+# by Simulator::create-wireless-node{}. 
+Simulator set IMEPFlag_ ""
+Simulator set WirelessNewTrace_ 0
+Simulator set propInstCreated_ 0
+
+# Enable packet reference count
+SessionSim set rc_ 0
+
+# Defaults for multicast addresses
+Simulator set McastBaseAddr_ 0x80000000
+Simulator set McastAddr_ 0x80000000
+
+# Default values used for wireless simulations
+Simulator set AgentTrace_ ON
+Simulator set RouterTrace_ OFF
+Simulator set MacTrace_   OFF
+Simulator set PhyTrace_   OFF
+
+# use tagged traces or positional traces?
+Simulator set TaggedTrace_ OFF
+
+# this can be set to use custom Routing Agents implemented within dynamic libraries
+Simulator set rtAgentFunction_ ""
+
+SessionHelper set rc_ 0                      ;# just to eliminate warnings
+SessionHelper set debug_ false
+
+NetworkInterface set debug_ false
+
+# SRM Agent defaults are in ../tcl/mcast/srm.tcl and ../mcast/srm-adaptive.tcl
+
+# IntServ Object specific defaults are in ../tcl/lib/ns-intserv.tcl
+
+# defaults for tbf
+TBF set rate_ 64k
+TBF set bucket_ 1024
+TBF set qlen_ 0
+
+#
+# mobile Ip
+#
+MIPEncapsulator set addr_ 0
+MIPEncapsulator set port_ 0
+MIPEncapsulator set shift_ 0
+MIPEncapsulator set mask_ [AddrParams set ALL_BITS_SET]
+MIPEncapsulator set ttl_ 32
+MIPEncapsulator set debug_ false
+
+# GAF
+ 
+GAFPartner set addr_ 0
+GAFPartner set port_ 254
+GAFPartner set shift_ 0
+GAFPartner set mask_ [AddrParams set ALL_BITS_SET]
+GAFPartner set debug_ false                  
+ 
+# HTTP-related defaults are in ../tcl/webcache/http-agent.tcl
+
+#
+# Wireless simulation support 
+#
+
+Mac set debug_ false
+ARPTable set debug_ false
+ARPTable set avoidReordering_ false ; #not used
+God set debug_ false
+
+Mac/Tdma set slot_packet_len_	1500
+Mac/Tdma set max_node_num_	64
+
+LL set mindelay_                50us
+LL set delay_                   25us
+LL set bandwidth_               0       ;# not used
+LL set debug_ false
+LL set avoidReordering_ false ;	#not used 
+
+Snoop set debug_ false
+
+
+
+#change wrt Mike's code
+ # 802.11 MIB parameters
+ #
+
+ Mac/802_11 set CWMin_         31
+ Mac/802_11 set CWMax_         1023
+ Mac/802_11 set SlotTime_      0.000020        ;# 20us
+ Mac/802_11 set SIFS_          0.000010        ;# 10us
+ Mac/802_11 set PreambleLength_        144             ;# 144 bit
+ Mac/802_11 set PLCPHeaderLength_      48              ;# 48 bits
+ Mac/802_11 set PLCPDataRate_  1.0e6           ;# 1Mbps
+ Mac/802_11 set RTSThreshold_  0               ;# bytes
+ Mac/802_11 set ShortRetryLimit_       7               ;# retransmittions
+ Mac/802_11 set LongRetryLimit_        4               ;# retransmissions
+
+Mac/802_11 set bugFix_timer_ true;         # fix for when RTS/CTS not used
+# details at http://www.dei.unipd.it/wdyn/?IDsezione=2435
+
+ Mac/802_11 set BeaconInterval_	       0.1		;# 100ms	
+ Mac/802_11 set ScanType_	PASSIVE
+ Mac/802_11 set ProbeDelay_	0.0001		;# 0.1 ms
+ Mac/802_11 set MaxChannelTime_ 0.011		;# 11 ms
+ Mac/802_11 set MinChannelTime_ 0.005		; # 5 ms
+ Mac/802_11 set ChannelTime_ 0.12		;# 120 ms
+
+
+
+Mac/802_11Ext set HeaderDuration_   0.000020  ;# (SERVICE) 16bits last of PLCP header are not included
+Mac/802_11Ext set SymbolDuration_   0.000004  ;# (SERVICE) 16bits last of PLCP header are not included
+Mac/802_11Ext set BasicModulationScheme_ 0    ;# BPSK and coding rate 1/2 is the basic modulation scheme for header and ctrl packets
+Mac/802_11Ext set use_802_11a_flag_	true
+
+Mac/802_11Ext set CWMin_            15
+Mac/802_11Ext set CWMax_            1023
+Mac/802_11Ext set SlotTime_         0.000009
+Mac/802_11Ext set SIFS_             0.000016
+
+Mac/802_11Ext set RTSThreshold_     3000
+Mac/802_11Ext set ShortRetryLimit_  7
+Mac/802_11Ext set LongRetryLimit_   4
+
+Mac/802_11Ext set MAC_DBG           0
+
+
+# 
+# Support for Abstract LAN
+#
+
+Classifier/Replicator set direction_ false
+Mac set abstract_ false
+
+#
+# Support for MAC Level trace
+#
+Mac/802_3 set trace_ false
+
+# Turning on/off sleep-wakeup cycles for SMAC
+Mac/SMAC set syncFlag_ 1
+                                                                                                                
+# Nodes synchronize their schedules in SMAC
+Mac/SMAC set selfConfigFlag_ 1
+
+# Default duty cycle in SMAC
+Mac/SMAC set dutyCycle_ 10                                                                                                                
+#
+# Unity gain, omni-directional antennas
+# Set up the antennas to be centered in the node and 1.5 meters above it
+Antenna/OmniAntenna set X_ 0
+Antenna/OmniAntenna set Y_ 0
+Antenna/OmniAntenna set Z_ 1.5 
+Antenna/OmniAntenna set Gt_ 1.0
+Antenna/OmniAntenna set Gr_ 1.0
+
+Phy set debug_ false
+
+# Initialize the SharedMedia interface with parameters to make
+# it work like the 914MHz Lucent WaveLAN DSSS radio interface
+Phy/WirelessPhy set CPThresh_ 10.0
+Phy/WirelessPhy set CSThresh_ 1.559e-11
+Phy/WirelessPhy set RXThresh_ 3.652e-10
+Phy/WirelessPhy set bandwidth_ 2e6
+Phy/WirelessPhy set Pt_ 0.28183815
+Phy/WirelessPhy set freq_ 914e+6
+Phy/WirelessPhy set L_ 1.0  
+
+Phy/WirelessPhyExt set CSThresh_ 6.30957e-12           ;# -82 dBm
+Phy/WirelessPhyExt set noise_floor_ 7.96159e-14        ;# -101 dBm
+Phy/WirelessPhyExt set PowerMonitorThresh_ 2.653e-14   ;# -105.7 dBm (noise_floor_ / 3)
+Phy/WirelessPhyExt set Pt_  0.1
+Phy/WirelessPhyExt set freq_ 5.18e+9                   ;# 5.18 GHz
+Phy/WirelessPhyExt set HeaderDuration_   0.000020      ;# 20 us
+Phy/WirelessPhyExt set BasicModulationScheme_ 0        ;# BPSK
+Phy/WirelessPhyExt set L_ 1.0                          ;# default
+Phy/WirelessPhyExt set PreambleCaptureSwitch_ 1
+Phy/WirelessPhyExt set DataCaptureSwitch_ 0
+Phy/WirelessPhyExt set SINR_PreambleCapture_ 3.1623;   ;# 5 dB
+Phy/WirelessPhyExt set SINR_DataCapture_ 10.0;         ;# 10 dB
+Phy/WirelessPhyExt set trace_dist_ 1e6                 ;# trace until distance of 1 Mio. km ("infinty")
+Phy/WirelessPhyExt set PHY_DBG_ 0
+Phy/WirelessPhyExt set CPThresh_ 0 ;# not used by WirelessPhyExt, but available to be compabile with WirelessPhy
+Phy/WirelessPhyExt set RXThresh_ 0 ;# not used by WirelessPhyExt, but available to be compabile with WirelessPhy
+
+Phy/WiredPhy set bandwidth_ 10e6
+
+# Shadowing propagation model
+Propagation/Shadowing set pathlossExp_ 2.0
+Propagation/Shadowing set std_db_ 4.0
+Propagation/Shadowing set dist0_ 1.0
+Propagation/Shadowing set seed_ 0
+
+Propagation/Nakagami set gamma0_ 1.9
+Propagation/Nakagami set gamma1_ 3.8
+Propagation/Nakagami set gamma2_ 3.8
+
+Propagation/Nakagami set d0_gamma_ 200
+Propagation/Nakagami set d1_gamma_ 500
+
+Propagation/Nakagami set use_nakagami_dist_ false
+
+Propagation/Nakagami set m0_  1.5
+Propagation/Nakagami set m1_  0.75
+Propagation/Nakagami set m2_  0.75
+
+Propagation/Nakagami set d0_m_ 80
+Propagation/Nakagami set d1_m_ 200
+
+# Turning on/off sleep-wakeup cycles for SMAC
+Mac/SMAC set syncFlag_ 0
+
+
+
+# variables of the link state module is moved to ns-rtProtoLS.tcl
+
+#
+# Agents
+#
+Agent set fid_ 0
+Agent set prio_ 0
+Agent set agent_addr_ -1
+Agent set agent_port_ -1
+Agent set dst_addr_ -1
+Agent set dst_port_ -1
+Agent set flags_ 0
+Agent set ttl_ 32 ; # arbitrary choice here
+Agent set debug_ false
+Agent set class_ 0
+
+##Agent set seqno_ 0 now is gone
+##Agent set class_ 0 now is gone
+
+Agent/Ping set packetSize_ 64
+
+Agent/UDP set packetSize_ 1000
+Agent/UDP instproc done {} { }
+Agent/UDP instproc process_data {from data} { }
+
+Agent/SCTP set debugMask_ 0             ;# all debugging off by default
+Agent/SCTP set debugFileIndex_ -1       ;# default outputs to stderr
+Agent/SCTP set associationMaxRetrans_ 10;# 10 attempts
+Agent/SCTP set pathMaxRetrans_ 5        ;# 5 attempts (per destination)
+Agent/SCTP set changePrimaryThresh_ -1  ;# infinite (ie, never change primary
+Agent/SCTP set maxInitRetransmits_ 8    ;# 8 attempts
+Agent/SCTP set heartbeatInterval_ 30    ;# 30 secs
+Agent/SCTP set mtu_ 1500                ;# MTU of ethernet (most common)
+Agent/SCTP set initialRwnd_ 65536       ;# default inital receiver window
+Agent/SCTP set initialSsthresh_ 65536   ;# default inital ssthresh value
+Agent/SCTP set initialCwnd_ 2           ;# default cwnd = 2 * MTU
+Agent/SCTP set initialRto_ 3.0          ;# default initial RTO = 3 secs       
+Agent/SCTP set minRto_ 1.0              ;# default min RTO = 1 sec            
+Agent/SCTP set maxRto_ 60.0             ;# default max RTO = 60 secs          
+Agent/SCTP set fastRtxTrigger_ 4        ;# 4 missing reports trigger fast rtx
+Agent/SCTP set numOutStreams_ 1         ;# single stream default
+Agent/SCTP set numUnrelStreams_ 0       ;# by default all streams are reliable
+Agent/SCTP set reliability_ 0           ;# by default unrel streams have 0 rtx's
+Agent/SCTP set unordered_ 0             ;# by default all chunks are ordered
+Agent/SCTP set ipHeaderSize_ 20         ;# default is IPv4
+Agent/SCTP set dataChunkSize_ 1468      ;# restricted to 4 byte boundaries
+Agent/SCTP set useDelayedSacks_ 1       ;# rfc2960 says SHOULD use delayed sacks
+Agent/SCTP set sackDelay_ 0.200         ;# rfc2960 recommends 200 ms
+Agent/SCTP set useMaxBurst_ 1           ;# sctp implementors guide adds this var
+Agent/SCTP set rtxToAlt_ 1              ;# by default rtxs go to alternate dest
+Agent/SCTP set dormantAction_ 0		;# 0 = change dest, 1 = use primary, 2 = use last dest before dormant;
+                                                                             
+## These variables are for simulating reactive routing overheads (for         
+## MANETs, etc). This feature is turned off is delay is 0. The cache lifetime 
+## by default is just slightly larger than the default min RTO to avoid a "cache                                                                             
+## miss" after a single timeout event.
+Agent/SCTP set routeCalcDelay_ 0        ;# time to calculate a route          
+Agent/SCTP set routeCacheLifetime_ 1.2  ;# how long a route remains cached  
+
+Agent/SCTP set trace_all_ 0             ;# trace all vars ?
+
+## These variables are set because they have to be bound to be traceable.
+## This default does not matter to us at all.
+Agent/SCTP set cwnd_ 0                 ; 
+Agent/SCTP set rwnd_ 0                 ; 
+Agent/SCTP set rto_ 0                  ;
+Agent/SCTP set errorCount_ 0           ;
+Agent/SCTP set frCount_ 0              ;                                      
+Agent/SCTP set timeoutCount_ 0         ;                                      
+Agent/SCTP set rcdCount_ 0             ;# total count of route calc delays    
+
+Agent/SCTP/MultipleFastRtx set mfrCount_ 0                                    
+Agent/SCTP/MfrTimestamp set mfrCount_ 0    
+
+## CMT variables
+Agent/SCTP/CMT set useCmtReordering_ 1  ;# Turn ON CMT Reordering algo
+Agent/SCTP/CMT set useCmtCwnd_ 1        ;# Turn ON CMT cwnd growth algo
+Agent/SCTP/CMT set useCmtDelAck_ 1      ;# Turn ON CMT delayed ack algo
+Agent/SCTP/CMT set eCmtRtxPolicy_ 4     ;# Default policy = RTX_CWND
+## CMT-PF variables
+Agent/SCTP/CMT set useCmtPF_ 0          ;# CMT-PF turned off
+Agent/SCTP/CMT set cmtPFCwnd_ 2	        ;# Cwnd in MTUs after HB-ACK (1 or 2)
+## CMT-PF trace variables
+Agent/SCTP/CMT set countPFToActiveNewData_ 0 ;# count of PF->Active changes
+                                              # for new data transfer
+Agent/SCTP/CMT set countPFToActiveRtxms_ 0;   # count of PF->Active changes
+                                              # for retransmissions
+
+Agent/TCP set seqno_ 0
+Agent/TCP set t_seqno_ 0
+Agent/TCP set maxburst_ 0
+Agent/TCP set aggressive_maxburst_ 1 ;  # Added 2003/6/2.
+					# No change to default behavior.
+Agent/TCP set maxcwnd_ 0
+Agent/TCP set numdupacks_ 3
+Agent/TCP set numdupacksFrac_ -1 ;	# Added 2002/10/18.
+					# Set to -1  for this to have
+					#   no effect even for large windows.
+					# Default changed to -1 on 2006/09/27.
+                                        # Set to 100 to have numdupacks_
+                                        #   up to 1/100-th of cwnd.
+Agent/TCP set exitFastRetrans_ true ;	# Added 2003/7/28.
+					# For clean exits of Fast Retransmit.
+					# False for old buggy behavior.
+Agent/TCP set window_ 20
+Agent/TCP set windowInit_ 2 ;		# default changed on 2001/5/26.
+Agent/TCP set windowInitOption_ 1
+Agent/TCP set syn_ true ;		# default changed on 2001/5/17.
+Agent/TCP set max_connects_ -1 ;	# Variable added on 2007/9/25.
+					# Set to -1 for a no-op, 2007/9/28.
+Agent/TCP set windowOption_ 1
+Agent/TCP set windowConstant_ 4
+Agent/TCP set windowThresh_ 0.002
+Agent/TCP set decrease_num_ 0.5
+Agent/TCP set increase_num_ 1.0
+Agent/TCP set k_parameter_ 0.0 ;	# for binomial congestion control
+Agent/TCP set l_parameter_ 1.0 ;  	# for binomial congestion control
+Agent/TCP set overhead_ 0
+Agent/TCP set ecn_ 0
+Agent/TCP set old_ecn_ 0
+Agent/TCP set bugfix_ss_ 1 ;		# Variable added on 2006/06/13
+Agent/TCP set packetSize_ 1000
+Agent/TCP set tcpip_base_hdr_size_ 40
+Agent/TCP set ts_option_size_ 10; 	# in bytes
+Agent/TCP set bugFix_ true
+Agent/TCP set bugFix_ack_ false ;       # Variable added on 2003/08/13
+					# To allow multiple Fast Retransmits
+Agent/TCP set bugFix_ts_ false ;	# Variable added on 2003/08/13
+					# To allow multiple Fast Retransmits
+Agent/TCP set lessCareful_ false ;	# for the Less Careful variant of
+					# bugFix_, just for illustration.
+Agent/TCP set timestamps_ false
+Agent/TCP set ts_resetRTO_ false ;	# Added 2003/07/24.
+					# Set to true to un-back-off RTO
+					#   after any valid RTT measurement.
+Agent/TCP set slow_start_restart_ true
+Agent/TCP set restart_bugfix_ true
+Agent/TCP set tcpTick_ 0.01 ;		# default changed on 2002/03/07
+					# to reflect a changing reality.
+Agent/TCP set maxrto_ 60 ; 		# default changed on 2007/03/28
+					#  to reflect RFC2988.
+Agent/TCP set minrto_ 0.2 ;		# Default changed to 200ms on 
+					#  2004/10/14, to match values
+					#  used by many implementations.
+Agent/TCP set srtt_init_ 0
+Agent/TCP set rttvar_init_ 12
+Agent/TCP set rtxcur_init_ 3.0 ;	# Default changed on 2006/01/21		
+Agent/TCP set T_SRTT_BITS 3
+Agent/TCP set T_RTTVAR_BITS 2
+Agent/TCP set rttvar_exp_ 2
+Agent/TCP set updated_rttvar_ true ;	# Variable added on 2006/1/21
+Agent/TCP set timerfix_ true ; 		# Variable added on 2001/05/11
+ 					# Set to "false" to give the old 
+					#  behavior. 
+Agent/TCP set rfc2988_ true ;		# Default set to "true" on 2002/03/07.
+					# Set rfc2988_ "true" to give RFC2988-
+					#  compliant behavior for timers.
+Agent/TCP instproc done {} { }
+Agent/TCP set noFastRetrans_ false
+Agent/TCP set partial_ack_ false ;	# Variable added on 2002/12/28.
+					# Set to "true" to ensure sending
+					#  a packet on a partial ACK.
+Agent/TCP set dupacks_ 0
+Agent/TCP set ack_ 0
+Agent/TCP set cwnd_ 0
+Agent/TCP set awnd_ 0
+Agent/TCP set ssthresh_ 0
+Agent/TCP set rtt_ 0
+Agent/TCP set srtt_ 0
+Agent/TCP set rttvar_ 0
+Agent/TCP set backoff_ 0
+Agent/TCP set maxseq_ 0
+Agent/TCP set singledup_ 1 ;		# default changed on 2001/11/28.
+Agent/TCP set LimTransmitFix_ false ;	# added on 2003/03/31.
+Agent/TCP set precisionReduce_ true ;	# default changed on 2006/1/24.
+Agent/TCP set oldCode_ false
+Agent/TCP set useHeaders_ true ;	# default changed on 2001/11/28. 
+
+# These are all used for high-speed TCP.
+Agent/TCP set low_window_ 38 ;		# default changed on 2002/8/12.		
+Agent/TCP set high_window_ 83000
+Agent/TCP set high_p_ 0.0000001
+Agent/TCP set high_decrease_ 0.1
+Agent/TCP set max_ssthresh_ 0
+Agent/TCP set cwnd_range_ 0 ;		# cwnd_frac_ deleted on 6/6/04,
+					# replaced by cwnd_range_
+# For Quick-Start:
+Agent/TCP set rate_request_ 0
+Agent/TCP set qs_enabled_ false
+Agent/TCP set tcp_qs_recovery_ true ;	# Added on 2004/09/21, by Pasi.
+Agent/TCP set qs_request_mode_ 1
+Agent/TCP set qs_rtt_ 50
+Agent/TCP set print_request_ false
+Agent/TCP set qs_thresh_ 4
+
+# These are all variables for tracing information.
+Agent/TCP set ndatapack_ 0
+Agent/TCP set ndatabytes_ 0
+Agent/TCP set nackpack_ 0
+Agent/TCP set nrexmit_ 0
+Agent/TCP set nrexmitpack_ 0
+Agent/TCP set nrexmitbytes_ 0
+Agent/TCP set necnresponses_ 0
+Agent/TCP set ncwndcuts_ 0 
+Agent/TCP set ncwndcuts1_ 0
+
+Agent/TCP set trace_all_oneline_ false
+
+Agent/TCP set QOption_ 0 
+Agent/TCP set EnblRTTCtr_ 0
+Agent/TCP set control_increase_ 0
+
+Agent/TCP set SetCWRonRetransmit_ true ; # added on 2005/06/19.
+				 	 # default changed on 2008/06/05. 
+
+# XXX Generate nam trace or plain old text trace for variables. 
+# When it's true, generate nam trace.
+Agent/TCP set nam_tracevar_ false
+
+Agent/TCP/Fack set ss-div4_ false
+Agent/TCP/Fack set rampdown_ false
+
+Agent/TCP/Reno/XCP set timestamps_ true
+Agent/TCP/FullTcp/Newreno/XCP set timestamps_ true
+
+Agent/TCP set eln_ 0
+Agent/TCP set eln_rxmit_thresh_ 1
+# Agent/TCP set delay_growth_ false
+Agent/TCP set delay_growth_ true ;	# default changed on 2001/5/17.
+
+Agent/TCP set CoarseTimer_      0
+
+Agent/TCP set frto_enabled_	0 ;	# Added on 2004/10/26 for F-RTO
+Agent/TCP set sfrto_enabled_	0 ;	# Added on 2004/10/26 for F-RTO
+Agent/TCP set spurious_response_ 1 ;	# Added on 2004/10/26 for F-RTO
+
+Agent/TCPSink set sport_        0
+Agent/TCPSink set dport_        0         
+
+#XXX other kinds of sinks -> should reparent
+Agent/TCPSink set packetSize_ 40
+Agent/TCPSink set maxSackBlocks_ 3
+Agent/TCPSink set ts_echo_bugfix_ true ;	# default changed, 2003/8/13
+Agent/TCPSink set ts_echo_rfc1323_ false ;	# default added, 2003/8/13
+Agent/TCPSink set generateDSacks_ false
+Agent/TCPSink set qs_enabled_ false
+Agent/TCPSink set RFC2581_immediate_ack_ true
+Agent/TCPSink set bytes_ 0
+Agent/TCPSink set ecn_syn_ false ;	# Added 2005/11/21 for SYN/ACK pkts.
+
+Agent/TCPSink/DelAck set interval_ 100ms
+catch {
+	Agent/TCPSink/Asym set interval_ 100ms
+	Agent/TCPSink/Asym set maxdelack_ 5
+}
+Agent/TCPSink/Sack1/DelAck set interval_ 100ms
+
+ # setting newreno_changes_ to 1 implements some changes to reno 
+ # proposed by Janey Hoe (other than fixing reno's
+ # unnecessary retransmit timeouts)
+Agent/TCP/Newreno set newreno_changes_ 0
+ # setting newreno_changes1_ to 1 allows the retransmit timer to expire for
+ # a window with many packet drops
+ # Default changed to 1 on 5/5/03, to reflect RFC 2582.
+Agent/TCP/Newreno set newreno_changes1_ 1
+Agent/TCP/Newreno set partial_window_deflation_ 1 ; # Default changed to 1
+						    # on 5/5/03, to reflect
+						    # RFC 2582.
+Agent/TCP/Newreno set exit_recovery_fix_ 0
+
+Agent/TCP/Vegas set v_alpha_ 1
+Agent/TCP/Vegas set v_beta_ 3
+Agent/TCP/Vegas set v_gamma_ 1
+Agent/TCP/Vegas set v_rtt_ 0
+
+Agent/TCP/Vegas/RBP set rbp_scale_ 0.75
+# rbp_rate_algorithm_'s are defined in tcp-rbp.cc.
+# 1=RBP_VEGAS_RATE_ALGORITHM (default),
+# 2=RBP_CWND_ALGORITHM
+Agent/TCP/Vegas/RBP set rbp_rate_algorithm_ 1
+Agent/TCP/Vegas/RBP set rbp_segs_actually_paced_ 0
+Agent/TCP/Vegas/RBP set rbp_inter_pace_delay_ 0
+
+Agent/TCP/Reno/RBP set rbp_scale_ 0.75
+Agent/TCP/Reno/RBP set rbp_segs_actually_paced_ 0
+Agent/TCP/Reno/RBP set rbp_inter_pace_delay_ 0
+# Reno/RBP supports only RBP_CWND_ALGORITHM 
+# Agent/TCP/Reno/RBP set rbp_rate_algorithm_ 2
+
+Agent/TCP/Asym set g_ 0.125
+Agent/TCP/Reno/Asym set g_ 0.125
+Agent/TCP/Newreno/Asym set g_ 0.125
+
+# RFC793eduTcp -- 19990820, fcela@acm.org
+Agent/TCP/RFC793edu set add793expbackoff_  true 
+Agent/TCP/RFC793edu set add793jacobsonrtt_ false
+Agent/TCP/RFC793edu set add793fastrtx_     false
+Agent/TCP/RFC793edu set add793slowstart_   false
+Agent/TCP/RFC793edu set add793additiveinc_ false
+Agent/TCP/RFC793edu set add793karnrtt_     true 
+Agent/TCP/RFC793edu set rto_               60
+Agent/TCP/RFC793edu set syn_               true
+Agent/TCP/RFC793edu set add793exponinc_    false
+
+Agent/TCP/FullTcp instproc done_data {} { }
+
+# Dynamic state:
+Agent/TFRC set rate_ 0 
+Agent/TFRC set ndatapack_ 0 ;	# Number of packets sent
+Agent/TFRC set ndatabytes_ 0 ;	# Number of bytes sent
+Agent/TFRC set true_loss_rate_ 0.0 ; # For statistics only.
+# RTT:
+Agent/TFRC set srtt_init_ 0 ;	# Variables for tracking RTT	
+Agent/TFRC set rttvar_init_ 12  
+Agent/TFRC set rtxcur_init_ 6.0	
+Agent/TFRC set rttvar_exp_ 2	
+Agent/TFRC set T_SRTT_BITS 3	
+Agent/TFRC set T_RTTVAR_BITS 2	
+# VoIP mode:
+Agent/TFRC set voip_ 0 ;        # Added on 10/23/2004      
+				# 1 for voip mode.
+Agent/TFRC set voip_max_pkt_rate_ 100 ;  # Max rate in pps, for voip mode.
+Agent/TFRC set fsize_ 1460 ;	# Default size for large TCP packets. 
+				# Used for VoIP mode.
+Agent/TFRC set headersize_ 32 ; # Size for packet headers.
+# End of VoIP mode.
+# Variants in the TFRC algorithms:
+# Agent/TFRC set standard_ 0 ;	# Added on 4/19/2007
+				# Set to 1 for RFC 3448 algorithms.
+				# Set to 2 for RFC 4342 algorithms.
+				# Set to 3 for RFC 3448bis algorithms.
+Agent/TFRC set rate_init_option_ 2 ;	# Added on 10/20/2004
+				# Set to 1 for backward compatibility. 
+				# Set to 2 for RFC 3390 initial rates
+				# Default changed on 10/21/2004.
+Agent/TFRC set slow_increase_ 1 ;	# Added on 10/20//2004
+				# Set to 1 for gradual rate changes.  
+				# This also gives backward compatibility.
+# Agent/TFRC set ss_changes_ 1 ;	# Deleted on 3/14//2006. 
+Agent/TFRC set maxHeavyRounds_ 0; # Number of rounds for sending rate allowed
+				  #  to be greater than twice receiving rate.
+				  # Default changed on 3/27/2007, to conform
+				  # to RFC3448 and CCID 3.
+Agent/TFRC set conservative_ 0 ;  # Set to true for a conservative 
+				  # response to heavy congestion.
+Agent/TFRC set scmult_ 1.5 ;	# self clocking parameter for conservative_
+Agent/TFRC set oldCode_ false ; # Set to 1 to use old code for datalimited
+				#   applications.
+				# Parameter added on 12/18/02.
+# End of Variands.
+# Parameters:
+Agent/TFRC set packetSize_ 1000 
+Agent/TFRC set df_ 0.95 ;	# decay factor for accurate RTT estimate
+Agent/TFRC set tcp_tick_ 0.1 ;	
+Agent/TFRC set InitRate_ 300 ;	# Initial send rate	
+Agent/TFRC set overhead_ 0 ;	# If > 0, dither outgoing packets
+Agent/TFRC set ssmult_ 2 ; 	# Rate of increase during slow-start:
+Agent/TFRC set bval_ 1 ;	# Value of B for TCP formula
+Agent/TFRC set ca_ 1 ; 	 	# Enable Sqrt(RTT) congestion avoidance
+Agent/TFRC set printStatus_ 0 
+Agent/TFRC set ecn_ 0 ;		# Set to 1 for ECN-capable connection.
+Agent/TFRC set minrto_ 0.0 ;	# Minimum RTO, for use in TCP equation.
+				# The default is not to use minrto_.
+Agent/TFRC set SndrType_ 0 ;    # Set to 1 to use data-producing applications
+                                #   such as FTP.
+Agent/TFRC set maxqueue_ MAXSEQ ;  # queue from application.
+Agent/TFRC set rate_init_ 2 ;		# Added on 10/20/2004
+				# Set to 1 for backward compatibility. 
+				# Default changed on 10/21/2004.
+Agent/TFRC set useHeaders_ true ;	# Added on 2005/06/24. 
+Agent/TFRC set idleFix_ true ;	# Added on 2006/03/12.
+
+Agent/TFRCSink set packetSize_ 40
+Agent/TFRCSink set InitHistorySize_ 100000
+Agent/TFRCSink set NumFeedback_ 1 
+Agent/TFRCSink set AdjustHistoryAfterSS_ 1
+Agent/TFRCSink set NumSamples_ -1
+Agent/TFRCSink set discount_ 1;	# History Discounting
+Agent/TFRCSink set minDiscountRatio_ 0.5; # Minimum for history discounting.
+Agent/TFRCSink set printLoss_ 0
+Agent/TFRCSink set smooth_ 1 ;	# smoother Average Loss Interval
+Agent/TFRCSink set ShortIntervals_ 0 ; #  For calculating loss event rates 
+                        	# for short loss intervals differently
+Agent/TFRCSink set ShortRtts_ 2 ; # Max num of RTTs in a short interval.
+Agent/TFRCSink set minlc_ 4
+Agent/TFRCSink set algo_ 1 ;  	# 1: algo from sigcomm paper 2: ewma 
+				# 3: fixed window
+Agent/TFRCSink set maxint_ 1000 ;     # max loss interval history 
+Agent/TFRCSink set history_ 0.75 ;    # loss history for EWMA
+Agent/TFRCSink set PreciseLoss_ 1 ;   # 1 for more precise loss events
+				      # Introduced on 12/11/02, default 1.
+				      # No change in performance.
+Agent/TFRCSink set numPkts_ 1;	# Num non-sequential packets before loss
+				# Introduced on 12/12/02, with default 1.
+				# Default changed to 3 on 12/16/02.
+				# Default changed to 1 on 10/28/03 due
+				#    to a major bug.
+Agent/TFRCSink set bytes_ 0 ;	# For counting bytes received.
+
+if [TclObject is-class Agent/TCP/FullTcp] {
+	Agent/TCP/FullTcp set segsperack_ 1; # ACK frequency
+	Agent/TCP/FullTcp set spa_thresh_ 0; # below do 1 seg per ack [0:disable]
+	Agent/TCP/FullTcp set segsize_ 536; # segment size
+	Agent/TCP/FullTcp set tcprexmtthresh_ 3; # num dupacks to enter recov
+	Agent/TCP/FullTcp set iss_ 0; # Initial send seq#
+	Agent/TCP/FullTcp set nodelay_ false; # Nagle disable?
+	Agent/TCP/FullTcp set data_on_syn_ false; # allow data on 1st SYN?
+	Agent/TCP/FullTcp set dupseg_fix_ true ; # no rexmt w/dup segs from peer
+	Agent/TCP/FullTcp set dupack_reset_ false; # exit recov on ack < highest
+	Agent/TCP/FullTcp set interval_ 0.1 ; # delayed ACK interval 100ms 
+	Agent/TCP/FullTcp set close_on_empty_ false; # close conn if sent all
+	Agent/TCP/FullTcp set signal_on_empty_ false; # signal if sent all
+	Agent/TCP/FullTcp set ts_option_size_ 10; # in bytes
+	Agent/TCP/FullTcp set reno_fastrecov_ true; # fast recov true by default
+	Agent/TCP/FullTcp set pipectrl_ false; # use "pipe" ctrl
+	Agent/TCP/FullTcp set open_cwnd_on_pack_ true; # ^ win on partial acks?
+	Agent/TCP/FullTcp set halfclose_ false; # do simplex closes (shutdown)?
+	Agent/TCP/FullTcp set nopredict_ false; # disable header prediction code?
+        Agent/TCP/FullTcp set ecn_syn_ false; # Make SYN/ACK packet ECN-Capable?
+        Agent/TCP/FullTcp set ecn_syn_wait_ 0; # Wait after marked SYN/ACK? 
+        Agent/TCP/FullTcp set debug_ false;  # Added Sept. 16, 2007.
+
+	Agent/TCP/FullTcp/Newreno set recov_maxburst_ 2; # max burst dur recov
+
+	Agent/TCP/FullTcp/Sack set sack_block_size_ 8; # bytes in a SACK block
+	Agent/TCP/FullTcp/Sack set sack_option_size_ 2; # bytes in opt hdr
+	Agent/TCP/FullTcp/Sack set max_sack_blocks_ 3; # max # of sack blks
+	Agent/TCP/FullTcp/Sack set clear_on_timeout_ true; # clear sq at sender on timeout?
+	Agent/TCP/FullTcp/Sack set sack_rtx_cthresh_ 1; # dup cnt to trigger rtx
+	Agent/TCP/FullTcp/Sack set sack_rtx_bthresh_ 1; # dup bcnt to trigger rtx
+	Agent/TCP/FullTcp/Sack set sack_rtx_threshmode_ 1; # 1 = cnt only
+
+	Agent/TCP/FullTcp/Tahoe instproc init {} {
+		$self next
+		$self instvar reno_fastrecov_
+		set reno_fastrecov_ false
+	}
+
+	Agent/TCP/FullTcp/Sack instproc init {} {
+		$self next
+		$self instvar reno_fastrecov_ open_cwnd_on_pack_
+		set reno_fastrecov_ false
+		set open_cwnd_on_pack_ false
+	}
+
+	Agent/TCP/FullTcp/Newreno instproc init {} {
+		$self next
+		$self instvar open_cwnd_on_pack_
+		set open_cwnd_on_pack_ false
+	}
+
+}
+
+if [TclObject is-class Agent/TCP/BayFullTcp] {
+	Agent/TCP/BayFullTcp set segsperack_ 1; # ACK frequency
+	Agent/TCP/BayFullTcp set segsize_ 536; # segment size
+	Agent/TCP/BayFullTcp set tcprexmtthresh_ 3; # num dupacks to enter recov
+	Agent/TCP/BayFullTcp set iss_ 0; # Initial send seq#
+	Agent/TCP/BayFullTcp set nodelay_ false; # Nagle disable?
+	Agent/TCP/BayFullTcp set data_on_syn_ false; # allow data on 1st SYN?
+	Agent/TCP/BayFullTcp set dupseg_fix_ true ; # no rexmt w/dup segs from peer
+	Agent/TCP/BayFullTcp set dupack_reset_ false; # exit recov on ack < highest
+	Agent/TCP/BayFullTcp set interval_ 0.1 ; # delayed ACK interval 100ms 
+	Agent/TCP/BayFullTcp set close_on_empty_ false; # close conn if sent all
+	Agent/TCP/BayFullTcp set ts_option_size_ 10; # in bytes
+	Agent/TCP/BayFullTcp set reno_fastrecov_ true; # fast recov true by default
+	Agent/TCP/BayFullTcp set pipectrl_ false; # use "pipe" ctrl
+	Agent/TCP/BayFullTcp set open_cwnd_on_pack_ true; # ^ win on partial acks?
+	Agent/TCP/BayFullTcp set halfclose_ false; # do simplex closes (shutdown)?
+	Agent/TCP/BayFullTcp/Newreno set recov_maxburst_ 2; # max burst dur recov
+
+	Agent/TCP/BayFullTcp/Sack set sack_block_size_ 8; # bytes in a SACK block
+	Agent/TCP/BayFullTcp/Sack set sack_option_size_ 2; # bytes in opt hdr
+	Agent/TCP/BayFullTcp/Sack set max_sack_blocks_ 3; # max # of sack blks
+}
+
+# Default values used by wireless simulations
+Agent/Null set sport_           0
+Agent/Null set dport_           0
+
+Agent/CBR set sport_            0
+Agent/CBR set dport_            0
+
+# Http invalidation agent
+Agent/HttpInval set inval_hdr_size_ 40
+
+Agent/RTP set seqno_ 0
+Agent/RTP set interval_ 3.75ms
+Agent/RTP set random_ 0
+Agent/RTP set packetSize_ 210
+Agent/RTP set maxpkts_ 0x10000000
+Agent/RTP instproc done {} { }
+
+Agent/RTCP set seqno_ 0
+
+Agent/Message set packetSize_ 180
+
+Agent/MessagePassing set packetSize_ 1500
+
+Agent/LossMonitor set nlost_ 0
+Agent/LossMonitor set npkts_ 0
+Agent/LossMonitor set bytes_ 0
+Agent/LossMonitor set lastPktTime_ 0
+Agent/LossMonitor set expected_ 0
+
+# RAP
+Agent/RAP set packetSize_ 512
+Agent/RAP set seqno_ 0
+Agent/RAP set sessionLossCount_ 0
+Agent/RAP set ipg_ 2.0
+Agent/RAP set alpha_ 1.0
+Agent/RAP set beta_ 0.5
+Agent/RAP set srtt_ 2.0
+Agent/RAP set variance_ 0.0
+Agent/RAP set delta_ 0.5
+Agent/RAP set mu_ 1.2
+Agent/RAP set phi_ 4.0
+Agent/RAP set timeout_ 2.0
+Agent/RAP set overhead_ 0
+Agent/RAP set useFineGrain_ 0
+Agent/RAP set kfrtt_ 0.9
+Agent/RAP set kxrtt_ 0.01
+Agent/RAP set debugEnable_ 0
+Agent/RAP set rap_base_hdr_size_ 44
+Agent/RAP set dpthresh_ 50
+Agent/RAP instproc done {} { }
+
+# Routing protocol agents
+Agent/Mcast/Control set packetSize_ 80
+
+# Dynamic routing defaults
+Agent/rtProto set preference_ 200		;# global default preference
+Agent/rtProto/Direct set preference_ 100
+Agent/rtProto/DV set preference_	120
+Agent/rtProto/DV set INFINITY		 [Agent set ttl_]
+Agent/rtProto/DV set advertInterval	  2
+
+Agent/Encapsulator set status_ 1
+Agent/Encapsulator set overhead_ 20
+
+Agent/DSRAgent set sport_ 255
+Agent/DSRAgent set dport_ 255
+
+Agent/MIPBS set adSize_ 48
+Agent/MIPBS set shift_ 0
+Agent/MIPBS set mask_ [AddrParams set ALL_BITS_SET]
+Agent/MIPBS set ad_lifetime_ 2
+ 
+Agent/MIPMH set home_agent_ 0
+Agent/MIPMH set rreqSize_ 52
+Agent/MIPMH set reg_rtx_ 0.5
+Agent/MIPMH set shift_ 0
+Agent/MIPMH set mask_ [AddrParams set ALL_BITS_SET]
+Agent/MIPMH set reg_lifetime_ 2
+ 
+# Intitialization for directed diffusion : Chalermek
+Agent/Diff_Sink set packetSize_ 512
+Agent/Diff_Sink set interval_   0.5
+Agent/Diff_Sink set random_     1
+Agent/Diff_Sink set maxpkts_    10000
+Agent/Diff_Sink set data_type_  0
+
+# PLM contributed by Arnaud Legout at EURECOM
+Agent/LossMonitor/PLM set flag_PP_ 0
+Agent/LossMonitor/PLM set packet_time_PP_ 0
+Agent/LossMonitor/PLM set fid_PP_ 0
+Agent/LossMonitor/PLM set seqno_ 0
+
+# MPLS Label Distribution Protocol agent
+Agent/LDP set trace_ldp_ 0
+
+# Default to NOT nix-vector routing
+Simulator set nix-routing 0
+#Node/NixNode set id_ 0
+
+#Routing Module variable setting
+RtModule set classifier_ ""
+RtModule/Base set classifier_ ""
+#RtModule/Hier set classifier_ [new Classifier/Hier]
+#RtModule/Manual set classifier_ [new Classifier/Hash/Dest 2]
+#RtModule/VC set classifier_ [new Classifier/Virtual]
+
+#
+# LMS initializations
+#
+LMSErrorModel set rate_		0.0	;# just to eliminate warnings
+LMSErrorModel set errPkt_	0
+LMSErrorModel set errByte_	0
+LMSErrorModel set errTime_	0.0
+LMSErrorModel set onlink_	0
+LMSErrorModel set enable_	0
+LMSErrorModel set ndrops_	0
+LMSErrorModel set bandwidth_	2Mb
+LMSErrorModel set markecn_	false
+LMSErrorModel set debug_	false
+LMSErrorModel set delay_pkt_ false
+LMSErrorModel set delay_ 0
+
+set lmsPacketSize 1024
+set lsize [Application/Traffic/CBR set packetSize_]
+
+RtModule/LMS set node_	""
+
+Agent/LMS set lms_enabled_	1
+Agent/LMS set packetSize_	$lmsPacketSize
+
+Agent/LMS/Sender set interval_ 4.0ms
+Agent/LMS/Sender set packetSize_ $lsize
+Agent/LMS/Sender set lmsPacketSize_ $lmsPacketSize
+Agent/LMS/Sender set random_ 0
+Agent/LMS/Sender set maxpkts_ 0x10000000
+Agent/LMS/Sender set odat_ 0
+Agent/LMS/Sender instproc done {} { }
+
+Agent/LMS/Receiver set lmsPacketSize_ $lmsPacketSize
+Agent/LMS/Receiver set bytes_ 0
+Agent/LMS/Receiver set nlost_ 0
+Agent/LMS/Receiver set npkts_ 0
+Agent/LMS/Receiver set expected_ 0
+Agent/LMS/Receiver set lastPktTime_ 0.0
+Agent/LMS/Receiver instproc done {} { }
+Agent/LMS/Receiver set packetSize_ $lsize
+
+# Following defaults defined for TCP Quick Start
+# http://www.icir.org/floyd/quickstart.html
+Agent/QSAgent set qs_enabled_ 1
+Agent/QSAgent set old_classifier_ 0
+Agent/QSAgent set state_delay_ 0.2 ;	# Changed from 0.25 to 0.2, 2/25/05.
+Agent/QSAgent set alloc_rate_ 0.85 ; 	# Changed from 0.6 to 0.85, 2/25/05.
+Agent/QSAgent set threshold_ 0.85 ; 	# Changed from 0.4 to 0.85, 2/25/05.
+Agent/QSAgent set max_rate_ 256
+Agent/QSAgent set mss_ [Agent/TCP set packetSize_]
+Agent/QSAgent set rate_function_ 2
+Agent/QSAgent set algorithm_ 3	; 	# Changed from 2 to 3, 2/25/05.
+
+Queue set util_weight_ 0.8
+Queue set util_check_intv_ 0.2 ;	# Changed from 1 to 0.2, 2/25/05.
+Queue set util_records_ 5 ; 		# Changed from 0 to 5, 2/25/05.
+
+# Quick Start definitions end here
+
+Delayer set debug_ false
+
+Agent/TCP/Linux set rtxcur_init_ 3
+Agent/TCP/Linux set maxrto_ 120
+Agent/TCP/Linux set minrto_ 0.2
+Agent/TCP/Linux set ts_resetRTO_ true
+Agent/TCP/Linux set next_pkts_in_flight_ 0
+Agent/TCP/Linux set delay_growth_ false
+
+Agent/PBC set payloadSize 200
+Agent/PBC set periodicBroadcastInterval 1
+Agent/PBC set periodicBroadcastVariance 0.1
+Agent/PBC set modulationScheme 0
+
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/lib/ns-lib.tcl ns-2.34/tcl/lib/ns-lib.tcl
--- ns-2.34-pure/tcl/lib/ns-lib.tcl	2009-06-14 10:35:41.000000000 -0700
+++ ns-2.34/tcl/lib/ns-lib.tcl	2010-02-28 09:31:39.000000000 -0800
@@ -208,6 +208,8 @@
 source ns-default.tcl
 source ../emulate/ns-emulate.tcl
 
+source ns-clicknode.tcl
+
 #pushback
 source ns-pushback.tcl
 
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/lib/ns-mobilenode.tcl ns-2.34/tcl/lib/ns-mobilenode.tcl
--- ns-2.34-pure/tcl/lib/ns-mobilenode.tcl	2009-06-14 10:35:41.000000000 -0700
+++ ns-2.34/tcl/lib/ns-mobilenode.tcl	2010-02-28 09:31:39.000000000 -0800
@@ -706,6 +706,7 @@
 
 
 
+
 Node/MobileNode instproc mobility-trace { ttype atype } {
 	set ns [Simulator instance]
         set tracefd [$ns get-ns-traceall]
@@ -834,6 +835,21 @@
 }
 # </zheng: add>
 
+# change interface channel
+Node/MobileNode instproc changechannel { whichif newchan } {
+	$self instvar netif_
+	[$netif_($whichif) getchannel] delif $netif_($whichif)
+	$netif_($whichif) channel $newchan
+	$newchan addif $netif_($whichif)
+}
+
+# aim a steerable antenna
+Node/MobileNode instproc aimantenna { whichif newdir } {
+	$self instvar netif_
+	set theant [$netif_($whichif) getantenna]
+	$theant set Dir_ $newdir
+}
+
 Class SRNodeNew -superclass Node/MobileNode
 
 SRNodeNew instproc init args {
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/lib/ns-mobilenode.tcl.orig ns-2.34/tcl/lib/ns-mobilenode.tcl.orig
--- ns-2.34-pure/tcl/lib/ns-mobilenode.tcl.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/tcl/lib/ns-mobilenode.tcl.orig	2009-06-14 10:35:41.000000000 -0700
@@ -0,0 +1,930 @@
+# -*-	Mode:tcl; tcl-indent-level:8; tab-width:8; indent-tabs-mode:t -*-
+#
+# Copyright (c) 1998-2000 Regents of the University of California.
+# All rights reserved.
+# 
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. All advertising materials mentioning features or use of this software
+#    must display the following acknowledgement:
+# 	This product includes software developed by the MASH Research
+# 	Group at the University of California Berkeley.
+# 4. Neither the name of the University nor of the Research Group may be
+#    used to endorse or promote products derived from this software without
+#    specific prior written permission.
+# 
+# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+# $Header: /cvsroot/nsnam/ns-2/tcl/lib/ns-mobilenode.tcl,v 1.60 2009/01/15 06:23:49 tom_henderson Exp $
+#
+# Ported from CMU-Monarch project's mobility extensions -Padma, 10/98.
+#
+
+# IT IS NOT ENCOURAGED TO SUBCLASSS MOBILENODE CLASS DEFINED IN THIS FILE
+
+#======================================================================
+# The ARPTable class
+#======================================================================
+ARPTable instproc init args {
+	eval $self next $args		;# parent class constructor
+}
+
+ARPTable set bandwidth_         0
+ARPTable set delay_             5us
+
+#======================================================================
+# The Node/MobileNodeNode class
+#======================================================================
+
+Node/MobileNode instproc init args {
+#  	# I don't care about address classifier; it's not my business
+#  	# All I do is to setup port classifier so we can do broadcast, 
+#  	# and to set up interface stuff.
+#  	$self attach-node $node
+#  	$node port-notify $self
+
+	eval $self next $args
+
+	$self instvar nifs_ arptable_ X_ Y_ Z_ nodetype_
+	set X_ 0.0
+	set Y_ 0.0
+	set Z_ 0.0
+        set arptable_ ""                ;# no ARP table yet
+	set nifs_	0		;# number of network interfaces
+	# Mobile IP node processing
+        $self makemip-New$nodetype_
+}
+
+#----------------------------------------------------------------------
+
+# XXX Following are the last remnant of nodetype_. Need to be completely 
+# removed, however, we need a better mechanism to distinguish vanilla 
+# mobile node from MIP base station, and MIP mobile host.
+
+Node/MobileNode instproc makemip-NewMobile {} {
+}
+
+Node/MobileNode instproc makemip-NewBase {} {
+}
+
+Node/MobileNode instproc makemip-New {} {
+}
+
+Node/MobileNode instproc makemip-NewMIPBS {} {
+	$self instvar regagent_ encap_ decap_ agents_ id_
+
+	set dmux [new Classifier/Port/Reserve]
+	$dmux set mask_ 0x7fffffff
+	$dmux set shift_ 0
+	$self install-demux $dmux
+   
+	set regagent_ [new Agent/MIPBS $self]
+	$self attach $regagent_ [Node/MobileNode set REGAGENT_PORT]
+	$self attach-encap 
+	$self attach-decap
+}
+
+Node/MobileNode instproc attach-encap {} {
+	$self instvar encap_ 
+	
+	set encap_ [new MIPEncapsulator]
+
+	$encap_ set mask_ [AddrParams NodeMask 1]
+	$encap_ set shift_ [AddrParams NodeShift 1]
+	#set mask 0x7fffffff
+	#set shift 0
+	set nodeaddr [AddrParams addr2id [$self node-addr]]
+	$encap_ set addr_ [expr ( ~([AddrParams NodeMask 1] << \
+			[AddrParams NodeShift 1]) & $nodeaddr )]
+	$encap_ set port_ 1
+	$encap_ target [$self entry]
+	$encap_ set node_ $self
+}
+
+Node/MobileNode instproc attach-decap {} {
+	$self instvar decap_ dmux_ agents_
+	set decap_ [new Classifier/Addr/MIPDecapsulator]
+	lappend agents_ $decap_
+	$decap_ set mask_ [AddrParams NodeMask 1]
+	$decap_ set shift_ [AddrParams NodeShift 1]
+	$dmux_ install [Node/MobileNode set DECAP_PORT] $decap_
+}
+
+Node/MobileNode instproc makemip-NewMIPMH {} {
+	$self instvar regagent_
+ 
+	set dmux [new Classifier/Port/Reserve]
+	$dmux set mask_ 0x7fffffff
+	$dmux set shift_ 0
+	$self install-demux $dmux
+
+	set regagent_ [new Agent/MIPMH $self]
+	$self attach $regagent_ [Node/MobileNode set REGAGENT_PORT]
+	$regagent_ set mask_ [AddrParams NodeMask 1]
+	$regagent_ set shift_ [AddrParams NodeShift 1]
+ 	$regagent_ set dst_addr_ [expr (~0) << [AddrParams NodeShift 1]]
+	$regagent_ set dst_port_ 0
+	$regagent_ node $self
+}
+
+#----------------------------------------------------------------------
+
+Node/MobileNode instproc reset {} {
+	$self instvar arptable_ nifs_ netif_ mac_ ifq_ ll_ imep_
+        for {set i 0} {$i < $nifs_} {incr i} {
+		$netif_($i) reset
+		$mac_($i) reset
+		$ll_($i) reset
+		$ifq_($i) reset
+		if { [info exists opt(imep)] && $opt(imep) == "ON" } { 
+			$imep_($i) reset 
+		}
+	}
+	if { $arptable_ != "" } {
+		$arptable_ reset 
+	}
+}
+
+#
+# Attach an agent to a node.  Pick a port and
+# bind the agent to the port number.
+# if portnumber is 255, default target is set to the routing agent
+#
+Node/MobileNode instproc add-target { agent port } {
+	$self instvar dmux_ imep_ toraDebug_ 
+
+	set ns [Simulator instance]
+	set newapi [$ns imep-support]
+
+	$agent set sport_ $port
+
+	# special processing for TORA/IMEP node
+	set toraonly [string first "TORA" [$agent info class]] 
+	if {$toraonly != -1 } {
+		$agent if-queue [$self set ifq_(0)]  ;# ifq between LL and MAC
+		#
+		# XXX: The routing protocol and the IMEP agents needs handles
+		# to each other.
+		#
+		$agent imep-agent [$self set imep_(0)]
+		[$self set imep_(0)] rtagent $agent
+	}
+	
+	# Special processing for AOMDV
+	set aomdvonly [string first "AOMDV" [$agent info class]] 
+	if {$aomdvonly != -1 } {
+		$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
+	}
+	
+	# Special processing for AODV
+	set aodvonly [string first "AODV" [$agent info class]] 
+	if {$aodvonly != -1 } {
+		$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
+	}
+	
+	#<zheng: add>
+	# Special processing for ZBR
+	#set zbronly [string first "ZBR" [$agent info class]] 
+	#if {$zbronly != -1 } {
+	#	$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
+	#}
+	#</zheng: add>
+
+	if { $port == [Node set rtagent_port_] } {			
+		# Ad hoc routing agent setup needs special handling
+		$self add-target-rtagent $agent $port
+		return
+	}
+
+	# Attaching a normal agent
+	set namfp [$ns get-nam-traceall]
+	if { [Simulator set AgentTrace_] == "ON" } {
+		#
+		# Send Target
+		#
+		if {$newapi != ""} {
+			set sndT [$self mobility-trace Send "AGT"]
+		} else {
+			set sndT [cmu-trace Send AGT $self]
+		}
+		if { $namfp != "" } {
+			$sndT namattach $namfp
+		}
+		$sndT target [$self entry]
+		$agent target $sndT
+		#
+		# Recv Target
+		#
+		if {$newapi != ""} {
+			set rcvT [$self mobility-trace Recv "AGT"]
+		} else {
+			set rcvT [cmu-trace Recv AGT $self]
+		}
+		if { $namfp != "" } {
+			$rcvT namattach $namfp
+		}
+		$rcvT target $agent
+		$dmux_ install $port $rcvT
+	} else {
+		#
+		# Send Target
+		#
+		$agent target [$self entry]
+		#
+		# Recv Target
+		#
+		$dmux_ install $port $agent
+	}
+}
+
+Node/MobileNode instproc add-target-rtagent { agent port } {
+	$self instvar imep_ toraDebug_ 
+
+	set ns [Simulator instance]
+	set newapi [$ns imep-support]
+	set namfp [$ns get-nam-traceall]
+
+	set dmux_ [$self demux]
+	set classifier_ [$self entry]
+
+	# let the routing agent know about the port dmux
+	$agent port-dmux $dmux_
+
+	if { [Simulator set RouterTrace_] == "ON" } {
+		#
+		# Send Target
+		#
+		if {$newapi != ""} {
+			set sndT [$self mobility-trace Send "RTR"]
+		} else {
+			set sndT [cmu-trace Send "RTR" $self]
+		}
+		if { $namfp != "" } {
+			$sndT namattach $namfp
+		}
+		if { $newapi == "ON" } {
+			$agent target $imep_(0)
+			$imep_(0) sendtarget $sndT
+			# second tracer to see the actual
+			# types of tora packets before imep packs them
+			if { [info exists toraDebug_] && $toraDebug_ == "ON"} {
+				set sndT2 [$self mobility-trace Send "TRP"]
+				$sndT2 target $imep_(0)
+				$agent target $sndT2
+			}
+		} else {  ;#  no IMEP
+			$agent target $sndT
+		}
+		$sndT target [$self set ll_(0)]
+		#
+		# Recv Target
+		#
+		if {$newapi != ""} {
+			set rcvT [$self mobility-trace Recv "RTR"]
+		} else {
+			set rcvT [cmu-trace Recv "RTR" $self]
+		}
+		if { $namfp != "" } {
+			$rcvT namattach $namfp
+		}
+		if {$newapi == "ON" } {
+			[$self set ll_(0)] up-target $imep_(0)
+			$classifier_ defaulttarget $agent
+			# need a second tracer to see the actual
+			# types of tora packets after imep unpacks them
+			# no need to support any hier node
+			if {[info exists toraDebug_] && $toraDebug_ == "ON" } {
+				set rcvT2 [$self mobility-trace Recv "TRP"]
+				$rcvT2 target $agent
+				$classifier_ defaulttarget $rcvT2
+			}
+		} else {
+			$rcvT target $agent
+			$classifier_ defaulttarget $rcvT
+			$dmux_ install $port $rcvT
+		}
+	} else {
+		#
+		# Send Target
+		#
+		# if tora is used
+		if { $newapi == "ON" } {
+			$agent target $imep_(0)
+			# second tracer to see the actual
+			# types of tora packets before imep packs them
+			if { [info exists toraDebug_] && $toraDebug_ == "ON"} {
+				set sndT2 [$self mobility-trace Send "TRP"]
+				$sndT2 target $imep_(0)
+				$agent target $sndT2
+			}
+			$imep_(0) sendtarget [$self set ll_(0)]
+			
+		} else {  ;#  no IMEP
+			$agent target [$self set ll_(0)]
+		}    
+		#
+		# Recv Target
+		#
+		if {$newapi == "ON" } {
+			[$self set ll_(0)] up-target $imep_(0)
+			$classifier_ defaulttarget $agent
+			# need a second tracer to see the actual
+			# types of tora packets after imep unpacks them
+			# no need to support any hier node
+			if {[info exists toraDebug_] && $toraDebug_ == "ON" } {
+				set rcvT2 [$self mobility-trace Recv "TRP"]
+				$rcvT2 target $agent
+				[$self set classifier_] defaulttarget $rcvT2
+			}
+		} else {
+			$classifier_ defaulttarget $agent
+			$dmux_ install $port $agent
+		}
+	}
+}
+
+#
+# The following setups up link layer, mac layer, network interface
+# and physical layer structures for the mobile node.
+#
+Node/MobileNode instproc add-interface { channel pmodel lltype mactype qtype qlen iftype anttype topo inerrproc outerrproc fecproc } {
+	$self instvar arptable_ nifs_ netif_ mac_ ifq_ ll_ imep_ inerr_ outerr_ fec_
+	
+	set ns [Simulator instance]
+	set imepflag [$ns imep-support]
+	set t $nifs_
+	incr nifs_
+
+	set netif_($t)	[new $iftype]		;# interface
+	set mac_($t)	[new $mactype]		;# mac layer
+	set ifq_($t)	[new $qtype]		;# interface queue
+	set ll_($t)	[new $lltype]		;# link layer
+        set ant_($t)    [new $anttype]
+
+	$ns mac-type $mactype
+	set inerr_($t) ""
+	if {$inerrproc != ""} {
+		set inerr_($t) [$inerrproc]
+	}
+	set outerr_($t) ""
+	if {$outerrproc != ""} {
+		set outerr_($t) [$outerrproc]
+	}
+	set fec_($t) ""
+	if {$fecproc != ""} {
+		set fec_($t) [$fecproc]
+	}
+
+	set namfp [$ns get-nam-traceall]
+        if {$imepflag == "ON" } {              
+		# IMEP layer
+		set imep_($t) [new Agent/IMEP [$self id]]
+		set imep $imep_($t)
+		set drpT [$self mobility-trace Drop "RTR"]
+		if { $namfp != "" } {
+			$drpT namattach $namfp
+		}
+		$imep drop-target $drpT
+		$ns at 0.[$self id] "$imep_($t) start"   ;# start beacon timer
+        }
+	#
+	# Local Variables
+	#
+	set nullAgent_ [$ns set nullAgent_]
+	set netif $netif_($t)
+	set mac $mac_($t)
+	set ifq $ifq_($t)
+	set ll $ll_($t)
+
+	set inerr $inerr_($t)
+	set outerr $outerr_($t)
+	set fec $fec_($t)
+
+	#
+	# Initialize ARP table only once.
+	#
+	if { $arptable_ == "" } {
+		set arptable_ [new ARPTable $self $mac]
+		# FOR backward compatibility sake, hack only
+		if {$imepflag != ""} {
+			set drpT [$self mobility-trace Drop "IFQ"]
+		} else {
+			set drpT [cmu-trace Drop "IFQ" $self]
+		}
+		$arptable_ drop-target $drpT
+		if { $namfp != "" } {
+			$drpT namattach $namfp
+		}
+        }
+	#
+	# Link Layer
+	#
+	$ll arptable $arptable_
+	$ll mac $mac
+	$ll down-target $ifq
+
+	if {$imepflag == "ON" } {
+		$imep recvtarget [$self entry]
+		$imep sendtarget $ll
+		$ll up-target $imep
+        } else {
+		$ll up-target [$self entry]
+	}
+
+	#
+	# Interface Queue
+	#
+	$ifq target $mac
+	$ifq set limit_ $qlen
+	if {$imepflag != ""} {
+		set drpT [$self mobility-trace Drop "IFQ"]
+	} else {
+		set drpT [cmu-trace Drop "IFQ" $self]
+        }
+	$ifq drop-target $drpT
+	if { $namfp != "" } {
+		$drpT namattach $namfp
+	}
+	if {[$ifq info class] == "Queue/XCP"} {		
+		$mac set bandwidth_ [$ll set bandwidth_]
+		$mac set delay_ [$ll set delay_]
+		$ifq set-link-capacity [$mac set bandwidth_]
+		$ifq queue-limit $qlen
+		$ifq link $ll
+		$ifq reset
+		
+	}
+
+	#
+	# Mac Layer
+	#
+	
+	$mac netif $netif
+	$mac up-target $ll
+
+	if {$outerr == "" && $fec == ""} {
+		$mac down-target $netif
+	} elseif {$outerr != "" && $fec == ""} {
+		$mac down-target $outerr
+		$outerr target $netif
+	} elseif {$outerr == "" && $fec != ""} {
+		$mac down-target $fec
+		$fec down-target $netif
+	} else {
+		$mac down-target $fec
+		$fec down-target $outerr
+		$err target $netif
+	}
+
+	set god_ [God instance]
+    if {$mactype == "Mac/802_11Ext"} {
+		$mac nodes [$god_ num_nodes]
+	}
+    if {$mactype == "Mac/802_11"} {
+		$mac nodes [$god_ num_nodes]
+	}
+	#
+	# Network Interface
+	#
+	#if {$fec == ""} {
+        #		$netif up-target $mac
+	#} else {
+        #		$netif up-target $fec
+	#	$fec up-target $mac
+	#}
+
+	$netif channel $channel
+	if {$inerr == "" && $fec == ""} {
+		$netif up-target $mac
+	} elseif {$inerr != "" && $fec == ""} {
+		$netif up-target $inerr
+		$inerr target $mac
+	} elseif {$err == "" && $fec != ""} {
+		$netif up-target $fec
+		$fec up-target $mac
+	} else {
+		$netif up-target $inerr
+		$inerr target $fec
+		$fec up-target $mac
+	}
+
+	$netif propagation $pmodel	;# Propagation Model
+	$netif node $self		;# Bind node <---> interface
+	$netif antenna $ant_($t)
+	#
+	# Physical Channel
+	#
+	$channel addif $netif
+	
+        # List-based improvement
+	# For nodes talking to multiple channels this should
+	# be called multiple times for each channel
+	$channel add-node $self		
+
+	# let topo keep handle of channel
+	$topo channel $channel
+	# ============================================================
+
+	if { [Simulator set PhyTrace_] == "ON" } {
+		#
+		# Trace Dropped Packets
+		#
+		if {$imepflag != ""} {
+			set drpPhyT [$self mobility-trace Drop "PHY"]
+		} else {
+			set drpPhyT [cmu-trace Drop "PHY" $self]
+		}
+		$netif drop-target $drpPhyT
+		if { $namfp != "" } {
+			$drpPhyT namattach $namfp
+		}
+
+		#
+		# Trace Sent Packets
+		#
+        if {$imepflag != ""} {
+            set sndPhyT [$self mobility-trace Send "PHY"]
+        } else {
+            set sndPhyT [cmu-trace Send "PHY" $self]
+        }
+        $sndPhyT target $channel
+        $netif down-target $sndPhyT
+        if { $namfp != "" } {
+            $sndPhyT namattach $namfp
+        }
+        
+	} else {
+		$netif drop-target [$ns set nullAgent_]
+	}
+
+	if { [Simulator set MacTrace_] == "ON" } {
+		#
+		# Trace RTS/CTS/ACK Packets
+		#
+		if {$imepflag != ""} {
+			set rcvT [$self mobility-trace Recv "MAC"]
+		} else {
+			set rcvT [cmu-trace Recv "MAC" $self]
+		}
+		$mac log-target $rcvT
+		if { $namfp != "" } {
+			$rcvT namattach $namfp
+		}
+		#
+		# Trace Sent Packets
+		#
+		if {$imepflag != ""} {
+			set sndT [$self mobility-trace Send "MAC"]
+		} else {
+			set sndT [cmu-trace Send "MAC" $self]
+		}
+		$sndT target [$mac down-target]
+		$mac down-target $sndT
+		if { $namfp != "" } {
+			$sndT namattach $namfp
+		}
+		#
+		# Trace Received Packets
+		#
+		if {$imepflag != ""} {
+			set rcvT [$self mobility-trace Recv "MAC"]
+		} else {
+			set rcvT [cmu-trace Recv "MAC" $self]
+		}
+		$rcvT target [$mac up-target]
+		$mac up-target $rcvT
+		if { $namfp != "" } {
+			$rcvT namattach $namfp
+		}
+		#
+		# Trace Dropped Packets
+		#
+		if {$imepflag != ""} {
+			set drpT [$self mobility-trace Drop "MAC"]
+		} else {
+			set drpT [cmu-trace Drop "MAC" $self]
+		}
+		$mac drop-target $drpT
+		if { $namfp != "" } {
+			$drpT namattach $namfp
+		}
+	} else {
+		$mac log-target [$ns set nullAgent_]
+		$mac drop-target [$ns set nullAgent_]
+	}
+
+# change wrt Mike's code
+       if { [Simulator set EotTrace_] == "ON" } {
+               #
+               # Also trace end of transmission time for packets
+               #
+
+               if {$imepflag != ""} {
+                       set eotT [$self mobility-trace EOT "MAC"]
+               } else {
+                       set eoT [cmu-trace EOT "MAC" $self]
+               }
+               $mac eot-target $eotT
+       }
+
+
+
+	# ============================================================
+
+	$self addif $netif
+}
+
+# set transmission power
+Node/MobileNode instproc setPt { val } {
+	$self instvar netif_
+	$netif_(0) setTxPower $val
+}
+
+# set receiving power
+Node/MobileNode instproc setPr { val } {
+	$self instvar netif_
+	$netif_(0) setRxPower $val
+}
+
+# set idle power -- Chalermek
+Node/MobileNode instproc setPidle { val } {
+	$self instvar netif_
+	$netif_(0) setIdlePower $val
+}
+#
+Node/MobileNode instproc setPsleep { val } {
+	$self instvar netif_
+	$netif_(0) setSleepPower $val
+}
+#
+Node/MobileNode instproc setTSleep { val } {
+	$self instvar netif_
+	$netif_(0) setSleepTime $val
+}
+#
+Node/MobileNode instproc setPtransition { val } {
+	$self instvar netif_
+	$netif_(0) setTransitionPower $val
+}
+
+Node/MobileNode instproc setTtransition { val } {
+	$self instvar netif_
+	$netif_(0) setTransitionTime $val
+}
+#
+# change wrt Mike's code
+ Node/MobileNode instproc getMac {param0} {
+       $self instvar mac_
+       return $mac_($param0)
+ }
+
+ Node/MobileNode instproc CFP { beacon_period cfp_duration } {
+       if {$mactype == "Mac/802_11"} {
+               $self instvar mac_
+               set ns_ [Simulator instance]
+               set beacon_period [$ns_ delay_parse $beacon_period]
+               set cfp_duration [$ns_ delay_parse $cfp_duration]
+               $mac_(0) cfp $beacon_period $cfp_duration
+       }
+ }
+
+
+
+Node/MobileNode instproc mobility-trace { ttype atype } {
+	set ns [Simulator instance]
+        set tracefd [$ns get-ns-traceall]
+        if { $tracefd == "" } {
+	        puts "Warning: You have not defined you tracefile yet!"
+	        puts "Please use trace-all command to define it."
+		return ""
+	}
+	set T [new CMUTrace/$ttype $atype]
+	$T newtrace [Simulator set WirelessNewTrace_]
+	$T tagged [Simulator set TaggedTrace_]
+	$T target [$ns nullagent]
+	$T attach $tracefd
+        $T set src_ [$self id]
+        $T node $self
+	return $T
+}
+
+Node/MobileNode instproc nodetrace { tracefd } {
+	#
+	# This Trace Target is used to log changes in direction
+	# and velocity for the mobile node.
+	#
+	set T [new Trace/Generic]
+	$T target [[Simulator instance] set nullAgent_]
+	$T attach $tracefd
+	$T set src_ [$self id]
+	$self log-target $T    
+}
+
+Node/MobileNode instproc agenttrace {tracefd} {
+	set ns [Simulator instance]
+	set ragent [$self set ragent_]
+	#
+	# Drop Target (always on regardless of other tracing)
+	#
+	set drpT [$self mobility-trace Drop "RTR"]
+	set namfp [$ns get-nam-traceall]
+	if { $namfp != ""} {
+		$drpT namattach $namfp
+	}
+	$ragent drop-target $drpT
+	#
+	# Log Target
+	#
+	set T [new Trace/Generic]
+	$T target [$ns set nullAgent_]
+	$T attach $tracefd
+	$T set src_ [$self id]
+	$ragent tracetarget $T
+	#
+	# XXX: let the IMEP agent use the same log target.
+	#
+	set imepflag [$ns imep-support]
+	if {$imepflag == "ON"} {
+		[$self set imep_(0)] log-target $T
+	}
+}
+
+Node/MobileNode instproc mip-call {ragent} {
+	$self instvar regagent_
+	if [info exists regagent_] {
+		$regagent_ ragent $ragent
+	}
+}
+
+Node/MobileNode instproc attach-gafpartner {} {
+
+        $self instvar gafpartner_ address_ ll_ 
+
+        set gafpartner_ [new GAFPartner]
+
+	$gafpartner_ set mask_ [AddrParams NodeMask 1]
+	$gafpartner_ set shift_ [AddrParams NodeShift 1]
+	set nodeaddr [AddrParams addr2id [$self node-addr]]
+	
+	#$gafpartner_ set addr_ [expr ( ~([AddrParams NodeMask 1] << \
+	#		[AddrParams NodeShift 1]) & $nodeaddr )]
+
+	
+	$gafpartner_ set addr_ $nodeaddr
+	$gafpartner_ set port_ 254
+
+	#puts [$gafpartner_ set addr_]
+
+        $gafpartner_ target [$self entry]
+	$ll_(0) up-target $gafpartner_
+}
+
+Node/MobileNode instproc unset-gafpartner {} {
+	$self instvar gafpartner_
+	
+	$gafpartner_ set-gafagent 0
+
+}
+
+# <zheng: add>
+Node/MobileNode instproc sscs args {
+	$self instvar mac_
+	eval $mac_(0) sscs $args
+}
+
+Node/MobileNode instproc NodeClr {arg1} {
+	$self instvar mac_
+	$mac_(0) NodeClr $arg1
+}
+
+Node/MobileNode instproc NodeLabel args {
+	$self instvar mac_
+	eval $mac_(0) NodeLabel $args
+}
+
+Node/MobileNode instproc node-down {} {
+	$self instvar mac_
+	$mac_(0) node-down
+}
+
+Node/MobileNode instproc node-up {} {
+	$self instvar mac_
+	$mac_(0) node-up
+}
+
+Node/MobileNode instproc RNType args {
+	$self instvar ragent_
+	eval $ragent_ RNType $args
+}
+# </zheng: add>
+
+Class SRNodeNew -superclass Node/MobileNode
+
+SRNodeNew instproc init args {
+	$self instvar dsr_agent_ dmux_ entry_point_ address_
+
+        set ns [Simulator instance]
+
+	eval $self next $args	;# parent class constructor
+
+	if {$dmux_ == "" } {
+		# Use the default mash and shift
+		set dmux_ [new Classifier/Port]
+	}
+	set dsr_agent_ [new Agent/DSRAgent]
+
+	# setup address (supports hier-address) for dsragent
+	$dsr_agent_ addr $address_
+	$dsr_agent_ node $self
+	if [Simulator set mobile_ip_] {
+		$dsr_agent_ port-dmux [$self set dmux_]
+	}
+	# set up IP address
+	$self addr $address_
+	
+	if { [Simulator set RouterTrace_] == "ON" } {
+		# Recv Target
+		set rcvT [$self mobility-trace Recv "RTR"]
+		set namfp [$ns get-nam-traceall]
+		if {  $namfp != "" } {
+			$rcvT namattach $namfp
+		}
+		$rcvT target $dsr_agent_
+		set entry_point_ $rcvT	
+	} else {
+		# Recv Target
+		set entry_point_ $dsr_agent_
+	}
+
+	$self set ragent_ $dsr_agent_
+	$dsr_agent_ target $dmux_
+
+	# packets to the DSR port should be dropped, since we've
+	# already handled them in the DSRAgent at the entry.
+	set nullAgent_ [$ns set nullAgent_]
+	$dmux_ install [Node set rtagent_port_] $nullAgent_
+
+	# SRNodes don't use the IP addr classifier.  The DSRAgent should
+	# be the entry point
+	$self instvar classifier_
+	set classifier_ "srnode made illegal use of classifier_"
+
+	return $self
+}
+
+SRNodeNew instproc start-dsr {} {
+	$self instvar dsr_agent_
+	$dsr_agent_ startdsr
+}
+
+SRNodeNew instproc entry {} {
+        $self instvar entry_point_
+        return $entry_point_
+}
+
+SRNodeNew instproc add-interface args {
+	eval $self next $args
+
+	$self instvar dsr_agent_ ll_ mac_ ifq_
+
+	set ns [Simulator instance]
+	$dsr_agent_ mac-addr [$mac_(0) id]
+
+	if { [Simulator set RouterTrace_] == "ON" } {
+		# Send Target
+		set sndT [$self mobility-trace Send "RTR"]
+		set namfp [$ns get-nam-traceall]
+		if {$namfp != "" } {
+			$sndT namattach $namfp
+		}
+		$sndT target $ll_(0)
+		$dsr_agent_ add-ll $sndT $ifq_(0)
+	} else {
+		# Send Target
+		$dsr_agent_ add-ll $ll_(0) $ifq_(0)
+	}
+	# setup promiscuous tap into mac layer
+	$dsr_agent_ install-tap $mac_(0)
+}
+
+SRNodeNew instproc reset args {
+	$self instvar dsr_agent_
+	eval $self next $args
+	$dsr_agent_ reset
+}
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/lib/ns-packet.tcl ns-2.34/tcl/lib/ns-packet.tcl
--- ns-2.34-pure/tcl/lib/ns-packet.tcl	2009-06-14 10:35:41.000000000 -0700
+++ ns-2.34/tcl/lib/ns-packet.tcl	2010-02-28 09:31:39.000000000 -0800
@@ -115,6 +115,7 @@
 	Common 
 	Flags
 	IP 	# IP
+	Raw	# nsclick: raw packet type
 # Routing Protocols:
 	NV 	# NixVector classifier for stateless routing 
 	rtProtoDV 	# distance vector routing protocol
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/lib/ns-rtmodule.tcl ns-2.34/tcl/lib/ns-rtmodule.tcl
--- ns-2.34-pure/tcl/lib/ns-rtmodule.tcl	2009-06-14 10:35:41.000000000 -0700
+++ ns-2.34/tcl/lib/ns-rtmodule.tcl	2010-02-28 09:31:39.000000000 -0800
@@ -340,6 +340,43 @@
 RtModule/VC instproc add-route { dst target } {
 }
 
+
+#
+# Click routing module. Intended to subvert the normal routing process
+# and defer to Click.
+#
+RtModule/Click instproc init {} {
+        $self next
+}
+
+RtModule/Click instproc register { node } {
+        $self next $node
+        $self make-classifier
+}
+
+RtModule/Click instproc make-classifier {} {
+        $self instvar classifier_
+        set classifier_ [new Classifier/Ext/Click]
+        [$self node] install-entry $self $classifier_
+        $classifier_ setnodename [format "node%d" [[$self node] set id_]]
+        $classifier_ setnodeaddr [[$self node] set address_]
+        [$self node] set dmux_ [new Classifier/Port]
+
+        # Always stick the kernel tap interface into slot 0
+        $classifier_ install 0 [[$self node] set dmux_]
+}
+
+RtModule/Click instproc attach { agent port } {
+        # Send target
+        $agent target [[$self node] entry]
+        # Recv target
+        [[$self node] demux] install $port $agent
+}
+
+RtModule/Click instproc detach { agent nullagent } {
+        # Empty method
+}
+
 Classifier/Virtual instproc find dst {
 	$self instvar node_
 	if {[$node_ id] == $dst} {
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tcl/rtglib/route-proto.tcl ns-2.34/tcl/rtglib/route-proto.tcl
--- ns-2.34-pure/tcl/rtglib/route-proto.tcl	2009-06-14 10:35:40.000000000 -0700
+++ ns-2.34/tcl/rtglib/route-proto.tcl	2010-02-28 09:31:39.000000000 -0800
@@ -739,6 +739,15 @@
 Agent/rtProto/Manual proc init-all args {
     # The user will do all routing.
 }
+#
+# Empty. Does NOTHING - even less than the Manual routing.
+#
+Class Agent/rtProto/Empty -superclass Agent/rtProto
+
+Agent/rtProto/Empty proc init-all args {
+    # Do nothing
+}
+
 
 ### Local Variables:
 ### mode: tcl
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/tools/random.cc ns-2.34/tools/random.cc
--- ns-2.34-pure/tools/random.cc	2009-06-14 10:35:44.000000000 -0700
+++ ns-2.34/tools/random.cc	2010-02-28 09:31:39.000000000 -0800
@@ -34,7 +34,7 @@
  * "@(#) $Header: /cvsroot/nsnam/ns-2/tools/random.cc,v 1.21 2006/12/17 15:12:37 mweigle Exp $ (LBL)";
  */
 
-#ifndef WIN32
+#if !defined(WIN32) && !defined(ALLOW_RANDOM)
 
 #include <sys/time.h>
 #include "config.h"
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/trace/cmu-trace.cc ns-2.34/trace/cmu-trace.cc
--- ns-2.34-pure/trace/cmu-trace.cc	2009-06-14 10:35:07.000000000 -0700
+++ ns-2.34/trace/cmu-trace.cc	2010-02-28 09:31:39.000000000 -0800
@@ -55,6 +55,7 @@
 #include <aomdv/aomdv_packet.h>
 #include <cmu-trace.h>
 #include <mobilenode.h>
+#include <rawpacket.h>
 #include <simulator.h>
 //<zheng: add for 802.15.4>
 #include "wpan/p802_15_4pkt.h"
@@ -1061,6 +1062,20 @@
 	}
 }
 
+// XXX Fix this
+void
+CMUTrace::format_raw(Packet *p, int offset)
+{
+        //struct hdr_cmn *ch = HDR_CMN(p);
+        //struct hdr_tcp *th = HDR_TCP(p);
+        
+        if( newtrace_ ) {
+                sprintf(pt_->buffer() + offset,"raw ");
+        } else {
+                sprintf(pt_->buffer() + offset,"raw ");
+        }
+}
+
 void
 CMUTrace::nam_format(Packet *p, int offset)
 {
@@ -1305,6 +1320,12 @@
 	hdr_cmn *ch = HDR_CMN(p);
 	int offset = 0;
 
+	int israw = (PT_RAW == ch->ptype());
+ 	hdr_raw* rhdr = hdr_raw::access(p);	
+	if (israw) {
+	    ch->ptype() = (packet_t) rhdr->ns_type;
+	}
+
 	/*
 	 * Log the MAC Header
 	 */
@@ -1313,6 +1334,8 @@
 	if (pt_->namchannel()) 
 		nam_format(p, offset);
 	offset = strlen(pt_->buffer());
+
+
 	switch(ch->ptype()) {
 	case PT_MAC:
 	case PT_SMAC:
@@ -1324,6 +1347,9 @@
 		format_ip(p, offset);
 		offset = strlen(pt_->buffer());
 		switch(ch->ptype()) {
+		case PT_RAW:
+			format_raw(p, offset);
+			break;
 		case PT_AODV:
 			format_aodv(p, offset);
 			break;
@@ -1374,6 +1400,9 @@
 			break;		//zheng: add
 		}
 	}
+	if (israw) {
+	    ch->ptype() = PT_RAW;
+	}
 }
 
 int
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/trace/cmu-trace.cc.orig ns-2.34/trace/cmu-trace.cc.orig
--- ns-2.34-pure/trace/cmu-trace.cc.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/trace/cmu-trace.cc.orig	2009-06-14 10:35:07.000000000 -0700
@@ -0,0 +1,1510 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Ported from CMU/Monarch's code, appropriate copyright applies.
+ * nov'98 -Padma.
+ *
+ * $Header: /cvsroot/nsnam/ns-2/trace/cmu-trace.cc,v 1.94 2009/01/15 06:23:49 tom_henderson Exp $
+ */
+
+#include <packet.h>
+#include <ip.h>
+#include <tcp.h>
+#include <sctp.h>
+#include <rtp.h>
+#include <arp.h>
+#include <dsr/hdr_sr.h>	// DSR
+#include <mac.h>
+#include <mac-802_11.h>
+#include <smac.h>
+#include <address.h>
+#include <tora/tora_packet.h> //TORA
+#include <imep/imep_spec.h>         // IMEP
+#include <aodv/aodv_packet.h> //AODV
+// AOMDV patch
+#include <aomdv/aomdv_packet.h>
+#include <cmu-trace.h>
+#include <mobilenode.h>
+#include <simulator.h>
+//<zheng: add for 802.15.4>
+#include "wpan/p802_15_4pkt.h"
+#include "wpan/p802_15_4trace.h"
+#include "wpan/p802_15_4nam.h"
+//</zheng: add for 802.15.4>
+
+#include "diffusion/diff_header.h" // DIFFUSION -- Chalermek
+
+
+PacketTracer::PacketTracer() : next_(0)
+{
+}
+void PacketTracer::setNext(PacketTracer *next)
+{
+	next_ = next;
+}
+
+PacketTracer::~PacketTracer()
+{
+}
+
+PacketTracer *PacketTracer::getNext()
+{
+	return next_;
+}
+
+int PacketTracer::format_unknow(Packet *p, int offset, BaseTrace *pt, int newtrace)
+{
+	return (format(p, offset, pt, newtrace) || (next_ && next_->format_unknow(p, offset, pt, newtrace)));
+}
+
+PacketTracer *CMUTrace::pktTrc_ = 0;
+
+void CMUTrace::addPacketTracer(PacketTracer *pt)
+{
+	if(!pt)
+		return;
+	pt->setNext(pktTrc_);
+	pktTrc_ = pt;
+}
+
+
+//#define LOG_POSITION
+
+//extern char* pt_names[];
+
+static class CMUTraceClass : public TclClass {
+public:
+	CMUTraceClass() : TclClass("CMUTrace") { }
+	TclObject* create(int, const char*const* argv) {
+		return (new CMUTrace(argv[4], *argv[5]));
+	}
+} cmutrace_class;
+
+
+//<zheng: ns 2.27 removed the following part, but we need it to control the broadcast radius>
+double CMUTrace::bradius = 0.0;
+double CMUTrace::radius_scaling_factor_ = 0.0;
+double CMUTrace::duration_scaling_factor_ = 0.0;
+//</zheng>
+
+CMUTrace::CMUTrace(const char *s, char t) : Trace(t)
+{
+	bzero(tracename, sizeof(tracename));
+	strncpy(tracename, s, MAX_ID_LEN);
+
+        if(strcmp(tracename, "RTR") == 0) {
+                tracetype = TR_ROUTER;
+        }
+	else if(strcmp(tracename, "TRP") == 0) {
+                tracetype = TR_ROUTER;
+        }
+        else if(strcmp(tracename, "PHY") == 0) {
+                tracetype = TR_PHY;
+        }
+        else if(strcmp(tracename, "MAC") == 0) {
+                tracetype = TR_MAC;
+        }
+        else if(strcmp(tracename, "IFQ") == 0) {
+                tracetype = TR_IFQ;
+        }
+        else if(strcmp(tracename, "AGT") == 0) {
+                tracetype = TR_AGENT;
+        }
+        else {
+                fprintf(stderr, "CMU Trace Initialized with invalid type\n");
+                exit(1);
+        }
+// change wrt Mike's code
+//	assert(type_ == DROP || type_ == SEND || type_ == RECV);
+	assert(type_ == DROP || type_ == SEND || type_ == RECV
+               || ((type_ == EOT) && (tracetype == TR_MAC)));
+
+
+
+	newtrace_ = 0;
+	for (int i=0 ; i < MAX_NODE ; i++) 
+		nodeColor[i] = 3 ;
+        node_ = 0;
+}
+
+void
+CMUTrace::format_mac_common(Packet *p, const char *why, int offset)
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_ip *ih = HDR_IP(p);
+	struct hdr_mac802_11 *mh;
+	struct hdr_smac *sh;
+	char mactype[SMALL_LEN];
+
+	strcpy(mactype, Simulator::instance().macType());
+	if (strcmp (mactype, "Mac/SMAC") == 0)
+		sh = HDR_SMAC(p);
+	else
+		mh = HDR_MAC802_11(p);
+	
+	double x = 0.0, y = 0.0, z = 0.0;
+       
+	char op = (char) type_;
+	Node* thisnode = Node::get_node_by_address(src_);
+	double energy = -1;
+	if (thisnode) {
+	    if (thisnode->energy_model()) {
+		    energy = thisnode->energy_model()->energy();
+	    }
+	}
+
+	// hack the IP address to convert pkt format to hostid format
+	// for now until port ids are removed from IP address. -Padma.
+
+	int src = Address::instance().get_nodeaddr(ih->saddr());
+
+	if(tracetype == TR_ROUTER && type_ == SEND) {
+		if(src_ != src)
+			op = FWRD;
+	}
+
+	// use tagged format if appropriate
+	if (pt_->tagged()) {
+		int next_hop = -1 ;
+		Node* nextnode = Node::get_node_by_address(ch->next_hop_);
+        	if (nextnode) next_hop = nextnode->nodeid(); 
+
+		node_->getLoc(&x, &y, &z);
+
+		if (op == DROP) op = 'd';
+		if (op == SEND) op = '+';
+		if (op == FWRD) op = 'h';
+
+		sprintf(pt_->buffer() + offset,
+			"%c "TIME_FORMAT" -s %d -d %d -p %s -k %3s -i %d "
+			"-N:loc {%.2f %.2f %.2f} -N:en %f ",
+			
+			op,				// event type
+			Scheduler::instance().clock(),	// time
+			src_,				// this node
+			next_hop,			// next hop
+			packet_info.name(ch->ptype()),	// packet type
+			tracename,			// trace level
+			ch->uid(),			// event id
+			x, y, z,			// location
+			energy);				// energy
+
+		offset = strlen(pt_->buffer());
+		if (strcmp (mactype, "Mac/SMAC") == 0) {
+			format_smac(p, offset);
+		} else {
+			format_mac(p, offset);
+		}
+		return;
+	}
+
+
+	// Use new ns trace format to replace the old cmu trace format)
+	if (newtrace_) {
+	    
+	    node_->getLoc(&x, &y, &z);
+	    // consistence
+	    if ( op == DROP ) { op = 'd';}
+
+	        // basic trace infomation + basic exenstion
+
+	    sprintf(pt_->buffer() + offset,
+		   "%c -t %.9f -Hs %d -Hd %d -Ni %d -Nx %.2f -Ny %.2f -Nz %.2f -Ne %f -Nl %3s -Nw %s ",
+		    op,                       // event type
+		    Scheduler::instance().clock(),  // time
+		    src_,                           // this node
+                    ch->next_hop_,                  // next hop
+		    src_,                           // this node
+		    x,                              // x coordinate
+		    y,                              // y coordinate
+		    z,                              // z coordinate
+		    energy,                         // energy, -1 = not existing
+		    tracename,                      // trace level
+                    why);                            // reason
+
+	    // mac layer extension
+
+	    offset = strlen(pt_->buffer());
+	    if (strcmp(mactype, "Mac/SMAC") == 0) {
+		    format_smac(p, offset);
+	    } else {
+		    format_mac(p, offset);
+	    }
+	    return;
+	}
+
+
+#ifdef LOG_POSITION
+        x = 0.0, y = 0.0, z = 0.0;
+        node_->getLoc(&x, &y, &z);
+#endif
+	sprintf(pt_->buffer() + offset,
+#ifdef LOG_POSITION
+		"%c %.9f %d (%6.2f %6.2f) %3s %4s %d %s %d ",
+#else
+		"%c %.9f _%d_ %3s %4s %d %s %d",
+#endif
+		op,
+		Scheduler::instance().clock(),
+                src_,                           // this node
+#ifdef LOG_POSITION
+                x,
+                y,
+#endif
+		tracename,
+		why,
+		
+                ch->uid(),                      // identifier for this event
+		
+		((ch->ptype() == PT_MAC) ? (
+		  (mh->dh_fc.fc_type == MAC_Type_Control) ? (
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_RTS) ? "RTS"  :
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_CTS) ? "CTS"  :
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_ACK) ? "ACK":
+		  //<zheng: add for 802.15.4>
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Beacon) ? "BCN"  :		//Beacon
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_AssoReq) ? "CM1"  :	//CMD: Association request
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_AssoRsp) ? "CM2"  :	//CMD: Association response
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_DAssNtf) ? "CM3"  :	//CMD: Disassociation notification
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_DataReq) ? "CM4"  :	//CMD: Data request
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_PIDCNtf) ? "CM5"  :	//CMD: PAN ID conflict notification
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_OrphNtf) ? "CM6"  :	//CMD: Orphan notification
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_BconReq) ? "CM7"  :	//CMD: Beacon request
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_CoorRea) ? "CM8"  :	//CMD: Coordinator realignment
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_GTSReq) ? "CM9"  :	//CMD: GTS request
+	          "UNKN") :
+		   (mh->dh_fc.fc_type == MAC_Type_Management) ? (
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_80211_Beacon) ? "BCN"  :
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_AssocReq) ? "ACRQ"  :
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_AssocRep) ? "ACRP"  : 
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_Auth) ? "AUTH"  :
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_ProbeReq) ? "PRRQ"  :
+		  (mh->dh_fc.fc_subtype == MAC_Subtype_ProbeRep) ? "PRRP"  :
+		  "UNKN") :
+		  "UNKN") :
+		 (ch->ptype() == PT_SMAC) ? (
+		  (sh->type == RTS_PKT) ? "RTS" :
+		  (sh->type == CTS_PKT) ? "CTS" :
+		  (sh->type == ACK_PKT) ? "ACK" :
+		  (sh->type == SYNC_PKT) ? "SYNC" :
+		  "UNKN") : 
+		 packet_info.name(ch->ptype())),
+		ch->size());
+	
+	offset = strlen(pt_->buffer());
+
+	if(tracetype == TR_PHY) {
+		format_phy(p, offset);
+		offset = strlen(pt_->buffer());
+		return;
+	}
+
+	if (strncmp (mactype, "Mac/SMAC", 8) == 0) {
+		format_smac(p, offset);
+	} else {
+		format_mac(p, offset);
+        }
+	
+	offset = strlen(pt_->buffer());
+
+	if (thisnode) {
+		if (thisnode->energy_model()) {
+			// log detailed energy consumption
+			// total energy and breakdown in idle, sleep, transmit and receive modes
+			sprintf(pt_->buffer() + offset,
+				"[energy %f ei %.3f es %.3f et %.3f er %.3f] ",
+				thisnode->energy_model()->energy(),
+				thisnode->energy_model()->ei(),
+				thisnode->energy_model()->es(),				
+				thisnode->energy_model()->et(),
+				thisnode->energy_model()->er());				
+		}
+        }
+}
+
+void
+CMUTrace::format_phy(Packet *p, int offset)
+{
+	sprintf(pt_->buffer() + offset, " ");
+}
+
+
+void
+CMUTrace::format_mac(Packet *p, int offset)
+{
+	struct hdr_mac802_11 *mh = HDR_MAC802_11(p);
+	struct hdr_cmn *ch = HDR_CMN(p);
+	// This function assumes in some places that mh->dh_body points
+	// to an ethertype, which may not be true and causes some portability
+	// problems, so we zero the printing of this field in some cases
+	bool print_ether_type = true;
+	if ( (ch->ptype() == PT_MAC) && 
+	     ( (mh->dh_fc.fc_type == MAC_Type_Control) ||
+	       (mh->dh_fc.fc_type == MAC_Type_Management))) {
+		print_ether_type = false;
+	} 
+	
+	if (pt_->tagged()) {
+		sprintf(pt_->buffer() + offset,
+			"-M:dur %x -M:s %x -M:d %x -M:t %x ",
+			mh->dh_duration,		// MAC: duration
+			
+			// change wrt Mike's code
+			//ETHER_ADDR(mh->dh_da),		// MAC: source
+			//ETHER_ADDR(mh->dh_sa),		// MAC: destination
+			ETHER_ADDR(mh->dh_ra),          // MAC: source
+                       ETHER_ADDR(mh->dh_ta),          // MAC: destination
+
+
+			print_ether_type ? GET_ETHER_TYPE(mh->dh_body) : 0);	// MAC: type
+	} else if (newtrace_) {
+		sprintf(pt_->buffer() + offset, 
+			"-Ma %x -Md %x -Ms %x -Mt %x ",
+			mh->dh_duration,
+			
+			// change wrt Mike's code
+			//ETHER_ADDR(mh->dh_da),
+			//ETHER_ADDR(mh->dh_sa),
+
+	   		ETHER_ADDR(mh->dh_ra),
+	                   ETHER_ADDR(mh->dh_ta),
+
+			print_ether_type ? GET_ETHER_TYPE(mh->dh_body) : 0);
+	} else {
+		sprintf(pt_->buffer() + offset,
+			" [%x %x %x %x] ",
+			//*((u_int16_t*) &mh->dh_fc),
+			mh->dh_duration,
+			
+			// change wrt Mike's code
+			//ETHER_ADDR(mh->dh_da),
+			//ETHER_ADDR(mh->dh_sa),
+			ETHER_ADDR(mh->dh_ra),
+                        ETHER_ADDR(mh->dh_ta),
+			print_ether_type ? GET_ETHER_TYPE(mh->dh_body) : 0);
+	}
+}
+
+void
+CMUTrace::format_smac(Packet *p, int offset)
+{
+	struct hdr_smac *sh = HDR_SMAC(p);
+	sprintf(pt_->buffer() + offset,
+		" [%.2f %d %d] ",
+		sh->duration,
+		sh->dstAddr,
+		sh->srcAddr);
+}
+	
+
+void
+CMUTrace::format_ip(Packet *p, int offset)
+{
+        struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_ip *ih = HDR_IP(p);
+	
+	// hack the IP address to convert pkt format to hostid format
+	// for now until port ids are removed from IP address. -Padma.
+	int src = Address::instance().get_nodeaddr(ih->saddr());
+	int dst = Address::instance().get_nodeaddr(ih->daddr());
+
+	if (pt_->tagged()) {
+		sprintf(pt_->buffer() + offset,
+			"-IP:s %d -IP:sp %d -IP:d %d -IP:dp %d -p %s -e %d "
+			"-c %d -i %d -IP:ttl %d ",
+			src,                           // packet src
+			ih->sport(),                   // src port
+			dst,                           // packet dest
+			ih->dport(),                   // dst port
+			packet_info.name(ch->ptype()), // packet type
+			ch->size(),                    // packet size
+			ih->flowid(),                  // flow id
+			ch->uid(),                     // unique id
+			ih->ttl_                       // ttl
+			);
+	} else if (newtrace_) {
+	    sprintf(pt_->buffer() + offset,
+		    "-Is %d.%d -Id %d.%d -It %s -Il %d -If %d -Ii %d -Iv %d ",
+		    src,                           // packet src
+		    ih->sport(),                   // src port
+		    dst,                           // packet dest
+		    ih->dport(),                   // dst port
+		    packet_info.name(ch->ptype()),  // packet type
+		    ch->size(),                     // packet size
+		    ih->flowid(),                   // flow id
+		    ch->uid(),                      // unique id
+		    ih->ttl_);                      // ttl
+	} else {
+	    sprintf(pt_->buffer() + offset, "------- [%d:%d %d:%d %d %d] ",
+		src, ih->sport(),
+		dst, ih->dport(),
+		ih->ttl_, (ch->next_hop_ < 0) ? 0 : ch->next_hop_);
+	}
+}
+
+// Note:  HDLC format (format_hdlc()) has moved to satellite tracing
+
+void
+CMUTrace::format_arp(Packet *p, int offset)
+{
+	struct hdr_arp *ah = HDR_ARP(p);
+
+	if (pt_->tagged()) {
+	    sprintf(pt_->buffer() + offset,
+		    "-arp:op %s -arp:ms %d -arp:s %d -arp:md %d -arp:d %d ",
+		    ah->arp_op == ARPOP_REQUEST ?  "REQUEST" : "REPLY",
+		    ah->arp_sha,
+		    ah->arp_spa,
+		    ah->arp_tha,
+		    ah->arp_tpa);
+	} else if (newtrace_) {
+	    sprintf(pt_->buffer() + offset,
+		    "-P arp -Po %s -Pms %d -Ps %d -Pmd %d -Pd %d ",
+		    ah->arp_op == ARPOP_REQUEST ?  "REQUEST" : "REPLY",
+		    ah->arp_sha,
+		    ah->arp_spa,
+		    ah->arp_tha,
+		    ah->arp_tpa);
+	} else {
+
+	    sprintf(pt_->buffer() + offset,
+		"------- [%s %d/%d %d/%d]",
+		ah->arp_op == ARPOP_REQUEST ?  "REQUEST" : "REPLY",
+		ah->arp_sha,
+		ah->arp_spa,
+		ah->arp_tha,
+		ah->arp_tpa);
+	}
+}
+
+void
+CMUTrace::format_dsr(Packet *p, int offset)
+{
+	hdr_sr *srh = hdr_sr::access(p);
+
+	if (pt_->tagged()) {
+	    sprintf(pt_->buffer() + offset,
+		    "-dsr:h %d -dsr:q %d -dsr:s %d -dsr:p %d -dsr:n %d "
+		    "-dsr:l %d -dsr:e {%d %d} -dsr:w %d -dsr:m %d -dsr:c %d "
+		    "-dsr:b {%d %d} ",
+		    srh->num_addrs(),
+		    srh->route_request(),
+		    srh->rtreq_seq(),
+		    srh->route_reply(),
+		    srh->rtreq_seq(),
+		    srh->route_reply_len(),
+		    srh->reply_addrs()[0].addr,
+		    srh->reply_addrs()[srh->route_reply_len()-1].addr,
+		    srh->route_error(),
+		    srh->num_route_errors(),
+		    srh->down_links()[srh->num_route_errors() - 1].tell_addr,
+		    srh->down_links()[srh->num_route_errors() - 1].from_addr,
+		    srh->down_links()[srh->num_route_errors() - 1].to_addr);
+	    return;
+	} else if (newtrace_) {
+	    sprintf(pt_->buffer() + offset, 
+		"-P dsr -Ph %d -Pq %d -Ps %d -Pp %d -Pn %d -Pl %d -Pe %d->%d -Pw %d -Pm %d -Pc %d -Pb %d->%d ",
+		    srh->num_addrs(),                   // how many nodes travered
+
+		srh->route_request(),
+		srh->rtreq_seq(),
+
+		srh->route_reply(),
+		srh->rtreq_seq(),
+		srh->route_reply_len(),
+		// the dest of the src route
+		srh->reply_addrs()[0].addr,
+		srh->reply_addrs()[srh->route_reply_len()-1].addr,
+
+		srh->route_error(),
+		srh->num_route_errors(),
+		srh->down_links()[srh->num_route_errors() - 1].tell_addr,
+		srh->down_links()[srh->num_route_errors() - 1].from_addr,
+		srh->down_links()[srh->num_route_errors() - 1].to_addr);
+
+	   return;
+	}
+	sprintf(pt_->buffer() + offset, 
+		"%d [%d %d] [%d %d %d %d->%d] [%d %d %d %d->%d]",
+		srh->num_addrs(),
+
+		srh->route_request(),
+		srh->rtreq_seq(),
+
+		srh->route_reply(),
+		srh->rtreq_seq(),
+		srh->route_reply_len(),
+		// the dest of the src route
+		srh->reply_addrs()[0].addr,
+		srh->reply_addrs()[srh->route_reply_len()-1].addr,
+
+		srh->route_error(),
+		srh->num_route_errors(),
+		srh->down_links()[srh->num_route_errors() - 1].tell_addr,
+		srh->down_links()[srh->num_route_errors() - 1].from_addr,
+		srh->down_links()[srh->num_route_errors() - 1].to_addr);
+}
+
+void
+CMUTrace::format_msg(Packet *, int)
+{
+}
+
+void
+CMUTrace::format_tcp(Packet *p, int offset)
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_tcp *th = HDR_TCP(p);
+	
+	if (pt_->tagged()) {
+	    sprintf(pt_->buffer() + offset,
+		    "-tcp:s %d -tcp:a %d -tcp:f %d -tcp:o %d ",
+		    th->seqno_,
+		    th->ackno_,
+		    ch->num_forwards(),
+		    ch->opt_num_forwards());
+	} else if (newtrace_) {
+	    sprintf(pt_->buffer() + offset,
+		"-Pn tcp -Ps %d -Pa %d -Pf %d -Po %d ",
+		th->seqno_,
+		th->ackno_,
+		ch->num_forwards(),
+		ch->opt_num_forwards());
+
+	} else {
+	    sprintf(pt_->buffer() + offset,
+		"[%d %d] %d %d",
+		th->seqno_,
+		th->ackno_,
+		ch->num_forwards(),
+		ch->opt_num_forwards());
+	}
+}
+
+/* Armando L. Caro Jr. <acaro@@cis,udel,edu> 6/5/2002
+ * (with help from Florina Almenrez <florina@@it,uc3m,es>)
+ */
+void
+CMUTrace::format_sctp(Packet* p,int offset)
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_sctp *sh = HDR_SCTP(p);
+	//struct hdr_ip *ih = HDR_IP(p);
+	char cChunkType;
+  
+	for(u_int i = 0; i < sh->NumChunks(); i++) {
+		switch(sh->SctpTrace()[i].eType) {
+		case SCTP_CHUNK_INIT:
+		case SCTP_CHUNK_INIT_ACK:
+		case SCTP_CHUNK_COOKIE_ECHO:
+		case SCTP_CHUNK_COOKIE_ACK:
+			cChunkType = 'I';       // connection initialization
+			break;
+      
+		case SCTP_CHUNK_DATA:
+			cChunkType = 'D';
+			break;
+      
+		case SCTP_CHUNK_SACK:
+			cChunkType = 'S';
+			break;
+      
+		case SCTP_CHUNK_FORWARD_TSN:
+			cChunkType = 'R';
+			break;
+
+		case SCTP_CHUNK_HB:
+			cChunkType = 'H';
+			break;
+			
+		case SCTP_CHUNK_HB_ACK:
+			cChunkType = 'B';
+			break;
+		default:
+			// quiet compiler
+			cChunkType = ' ';
+			assert (false);
+			break;
+		}
+    
+		if( newtrace_ ) {
+			sprintf(pt_->buffer() + offset,
+				"-Pn sctp -Pnc %d -Pct %c "
+				"-Ptsn %d -Psid %d -Pssn %d "
+				"-Pf %d -Po %d ",
+				sh->NumChunks(),
+				cChunkType,
+				sh->SctpTrace()[i].uiTsn,
+				sh->SctpTrace()[i].usStreamId,
+				sh->SctpTrace()[i].usStreamSeqNum,
+				ch->num_forwards(),
+				ch->opt_num_forwards());
+		}
+		else {
+			sprintf(pt_->buffer() + offset,
+				"[%d %c %d %d %d] %d %d",
+				sh->NumChunks(),
+				cChunkType,
+				sh->SctpTrace()[i].uiTsn,
+				sh->SctpTrace()[i].usStreamId,
+				sh->SctpTrace()[i].usStreamSeqNum,
+				ch->num_forwards(),
+				ch->opt_num_forwards());
+		}
+	}
+}
+
+void
+CMUTrace::format_rtp(Packet *p, int offset)
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_rtp *rh = HDR_RTP(p);
+	struct hdr_ip *ih = HDR_IP(p);
+        Node* thisnode = Node::get_node_by_address(src_);
+
+	//hacking, needs to change later, 
+        int dst = Address::instance().get_nodeaddr(ih->daddr());
+	
+	if (dst == src_){
+		// I just received a cbr data packet
+		if (thisnode->energy_model() && 
+		    thisnode->energy_model()->powersavingflag()) {
+			thisnode->energy_model()->set_node_state(EnergyModel::INROUTE);
+		}
+        }
+
+	if (pt_->tagged()) {
+		sprintf(pt_->buffer() + offset,
+			"-cbr:s %d -cbr:f %d -cbr:o %d ",
+			rh->seqno_,
+			ch->num_forwards(),
+			ch->opt_num_forwards());
+	} else if (newtrace_) {
+		sprintf(pt_->buffer() + offset,
+			"-Pn cbr -Pi %d -Pf %d -Po %d ",
+			rh->seqno_,
+			ch->num_forwards(),
+			ch->opt_num_forwards());
+	} else {
+		sprintf(pt_->buffer() + offset,
+			"[%d] %d %d",
+			rh->seqno_,
+			ch->num_forwards(),
+			ch->opt_num_forwards());
+	}
+}
+
+void
+CMUTrace::format_imep(Packet *p, int offset)
+{
+        struct hdr_imep *im = HDR_IMEP(p);
+
+#define U_INT16_T(x)    *((u_int16_t*) &(x))
+
+	if (pt_->tagged()) {
+	    sprintf(pt_->buffer() + offset,
+		    "-imep:a %c -imep:h %c -imep:o %c -imep:l %04x ",
+		    (im->imep_block_flags & BLOCK_FLAG_ACK) ? 'A' : '-',
+                    (im->imep_block_flags & BLOCK_FLAG_HELLO) ? 'H' : '-',
+                    (im->imep_block_flags & BLOCK_FLAG_OBJECT) ? 'O' : '-',
+                    U_INT16_T(im->imep_length));
+	} else if (newtrace_) {
+	    sprintf(pt_->buffer() + offset,
+                "-P imep -Pa %c -Ph %c -Po %c -Pl 0x%04x ] ",
+                (im->imep_block_flags & BLOCK_FLAG_ACK) ? 'A' : '-',
+                (im->imep_block_flags & BLOCK_FLAG_HELLO) ? 'H' : '-',
+                (im->imep_block_flags & BLOCK_FLAG_OBJECT) ? 'O' : '-',
+                U_INT16_T(im->imep_length));
+	} else {
+            sprintf(pt_->buffer() + offset,
+                "[%c %c %c 0x%04x] ",
+                (im->imep_block_flags & BLOCK_FLAG_ACK) ? 'A' : '-',
+                (im->imep_block_flags & BLOCK_FLAG_HELLO) ? 'H' : '-',
+                (im->imep_block_flags & BLOCK_FLAG_OBJECT) ? 'O' : '-',
+                U_INT16_T(im->imep_length));
+	}
+#undef U_INT16_T
+}
+
+
+void
+CMUTrace::format_tora(Packet *p, int offset)
+{
+        struct hdr_tora *th = HDR_TORA(p);
+        struct hdr_tora_qry *qh = HDR_TORA_QRY(p);
+        struct hdr_tora_upd *uh = HDR_TORA_UPD(p);
+        struct hdr_tora_clr *ch = HDR_TORA_CLR(p);
+
+        switch(th->th_type) {
+
+        case TORATYPE_QRY:
+
+		if (pt_->tagged()) {
+		    sprintf(pt_->buffer() + offset,
+			    "-tora:t %x -tora:d %d -tora:c QUERY",
+			    qh->tq_type, qh->tq_dst);
+		} else if (newtrace_) {
+		    sprintf(pt_->buffer() + offset,
+			"-P tora -Pt 0x%x -Pd %d -Pc QUERY ",
+                        qh->tq_type, qh->tq_dst);
+			
+                } else {
+
+                    sprintf(pt_->buffer() + offset, "[0x%x %d] (QUERY)",
+                        qh->tq_type, qh->tq_dst);
+		}
+                break;
+
+        case TORATYPE_UPD:
+
+		if (pt_->tagged()) {
+		    sprintf(pt_->buffer() + offset,
+			    "-tora:t %x -tora:d %d -tora:a %f -tora:o %d "
+			    "-tora:r %d -tora:e %d -tora:i %d -tora:c UPDATE",
+			    uh->tu_type,
+                            uh->tu_dst,
+                            uh->tu_tau,
+                            uh->tu_oid,
+                            uh->tu_r,
+                            uh->tu_delta,
+                            uh->tu_id);
+		} else if (newtrace_) {
+		    sprintf(pt_->buffer() + offset,
+                        "-P tora -Pt 0x%x -Pd %d (%f %d %d %d %d) -Pc UPDATE ",
+                        uh->tu_type,
+                        uh->tu_dst,
+                        uh->tu_tau,
+                        uh->tu_oid,
+                        uh->tu_r,
+                        uh->tu_delta,
+                        uh->tu_id);
+		} else {
+                    sprintf(pt_->buffer() + offset,
+                        "-Pt 0x%x -Pd %d -Pa %f -Po %d -Pr %d -Pe %d -Pi %d -Pc UPDATE ",
+                        uh->tu_type,
+                        uh->tu_dst,
+                        uh->tu_tau,
+                        uh->tu_oid,
+                        uh->tu_r,
+                        uh->tu_delta,
+                        uh->tu_id);
+		}
+                break;
+
+        case TORATYPE_CLR:
+		if (pt_->tagged()) {
+		    sprintf(pt_->buffer() + offset,
+			    "-tora:t %x -tora:d %d -tora:a %f -tora:o %d "
+			    "-tora:c CLEAR ",
+			    ch->tc_type,
+                            ch->tc_dst,
+                            ch->tc_tau,
+                            ch->tc_oid);
+		} else if (newtrace_) {
+		    sprintf(pt_->buffer() + offset, 
+			"-P tora -Pt 0x%x -Pd %d -Pa %f -Po %d -Pc CLEAR ",
+                        ch->tc_type,
+                        ch->tc_dst,
+                        ch->tc_tau,
+                        ch->tc_oid);
+		} else {
+                    sprintf(pt_->buffer() + offset, "[0x%x %d %f %d] (CLEAR)",
+                        ch->tc_type,
+                        ch->tc_dst,
+                        ch->tc_tau,
+                        ch->tc_oid);
+		}
+                break;
+        }
+}
+
+void
+CMUTrace::format_aodv(Packet *p, int offset)
+{
+        struct hdr_aodv *ah = HDR_AODV(p);
+        struct hdr_aodv_request *rq = HDR_AODV_REQUEST(p);
+        struct hdr_aodv_reply *rp = HDR_AODV_REPLY(p);
+
+
+        switch(ah->ah_type) {
+        case AODVTYPE_RREQ:
+
+		if (pt_->tagged()) {
+		    sprintf(pt_->buffer() + offset,
+			    "-aodv:t %x -aodv:h %d -aodv:b %d -aodv:d %d "
+			    "-aodv:ds %d -aodv:s %d -aodv:ss %d "
+			    "-aodv:c REQUEST ",
+			    rq->rq_type,
+                            rq->rq_hop_count,
+                            rq->rq_bcast_id,
+                            rq->rq_dst,
+                            rq->rq_dst_seqno,
+                            rq->rq_src,
+                            rq->rq_src_seqno);
+		} else if (newtrace_) {
+
+		    sprintf(pt_->buffer() + offset,
+			"-P aodv -Pt 0x%x -Ph %d -Pb %d -Pd %d -Pds %d -Ps %d -Pss %d -Pc REQUEST ",
+			rq->rq_type,
+                        rq->rq_hop_count,
+                        rq->rq_bcast_id,
+                        rq->rq_dst,
+                        rq->rq_dst_seqno,
+                        rq->rq_src,
+                        rq->rq_src_seqno);
+
+
+		} else {
+
+		    sprintf(pt_->buffer() + offset,
+			"[0x%x %d %d [%d %d] [%d %d]] (REQUEST)",
+			rq->rq_type,
+                        rq->rq_hop_count,
+                        rq->rq_bcast_id,
+                        rq->rq_dst,
+                        rq->rq_dst_seqno,
+                        rq->rq_src,
+                        rq->rq_src_seqno);
+		}
+                break;
+
+        case AODVTYPE_RREP:
+        case AODVTYPE_HELLO:
+	case AODVTYPE_RERR:
+		
+		if (pt_->tagged()) {
+		    sprintf(pt_->buffer() + offset,
+			    "-aodv:t %x -aodv:h %d -aodv:d %d -adov:ds %d "
+			    "-aodv:l %f -aodv:c %s ",
+			    rp->rp_type,
+			    rp->rp_hop_count,
+			    rp->rp_dst,
+			    rp->rp_dst_seqno,
+			    rp->rp_lifetime,
+			    rp->rp_type == AODVTYPE_RREP ? "REPLY" :
+			    (rp->rp_type == AODVTYPE_RERR ? "ERROR" :
+			     "HELLO"));
+		} else if (newtrace_) {
+			
+			sprintf(pt_->buffer() + offset,
+			    "-P aodv -Pt 0x%x -Ph %d -Pd %d -Pds %d -Pl %f -Pc %s ",
+				rp->rp_type,
+				rp->rp_hop_count,
+				rp->rp_dst,
+				rp->rp_dst_seqno,
+				rp->rp_lifetime,
+				rp->rp_type == AODVTYPE_RREP ? "REPLY" :
+				(rp->rp_type == AODVTYPE_RERR ? "ERROR" :
+				 "HELLO"));
+	        } else {
+			
+			sprintf(pt_->buffer() + offset,
+				"[0x%x %d [%d %d] %f] (%s)",
+				rp->rp_type,
+				rp->rp_hop_count,
+				rp->rp_dst,
+				rp->rp_dst_seqno,
+				rp->rp_lifetime,
+				rp->rp_type == AODVTYPE_RREP ? "REPLY" :
+				(rp->rp_type == AODVTYPE_RERR ? "ERROR" :
+				 "HELLO"));
+		}
+                break;
+		
+        default:
+#ifdef WIN32
+                fprintf(stderr,
+		        "CMUTrace::format_aodv: invalid AODV packet type\n");
+#else
+		fprintf(stderr,
+		        "%s: invalid AODV packet type\n", __FUNCTION__);
+#endif
+                abort();
+        }
+}
+
+// AOMDV patch
+void
+CMUTrace::format_aomdv(Packet *p, int offset)
+{
+	struct hdr_aomdv *ah = HDR_AOMDV(p);
+	struct hdr_aomdv_request *rq = HDR_AOMDV_REQUEST(p);
+	struct hdr_aomdv_reply *rp = HDR_AOMDV_REPLY(p);
+	
+	
+	switch(ah->ah_type) {
+		case AOMDVTYPE_RREQ:
+			
+			if (pt_->tagged()) {
+				sprintf(pt_->buffer() + offset,
+						  "-aomdv:t %x -aomdv:h %d -aomdv:b %d -aomdv:d %d "
+						  "-aomdv:ds %d -aomdv:s %d -aomdv:ss %d "
+						  "-aomdv:c REQUEST ",
+						  rq->rq_type,
+						  rq->rq_hop_count,
+						  rq->rq_bcast_id,
+						  rq->rq_dst,
+						  rq->rq_dst_seqno,
+						  rq->rq_src,
+						  rq->rq_src_seqno);
+			} else if (newtrace_) {
+				
+				sprintf(pt_->buffer() + offset,
+						  "-P aomdv -Pt 0x%x -Ph %d -Pb %d -Pd %d -Pds %d -Ps %d -Pss %d -Pc REQUEST ",
+						  rq->rq_type,
+						  rq->rq_hop_count,
+						  rq->rq_bcast_id,
+						  rq->rq_dst,
+						  rq->rq_dst_seqno,
+						  rq->rq_src,
+						  rq->rq_src_seqno);
+				
+				
+			} else {
+				
+				sprintf(pt_->buffer() + offset,
+						  "[0x%x %d %d [%d %d] [%d %d]] (REQUEST)",
+						  rq->rq_type,
+						  rq->rq_hop_count,
+						  rq->rq_bcast_id,
+						  rq->rq_dst,
+						  rq->rq_dst_seqno,
+						  rq->rq_src,
+						  rq->rq_src_seqno);
+			}
+			break;
+			
+		case AOMDVTYPE_RREP:
+		case AOMDVTYPE_HELLO:
+		case AOMDVTYPE_RERR:
+			
+			if (pt_->tagged()) {
+				sprintf(pt_->buffer() + offset,
+						  "-aomdv:t %x -aomdv:h %d -aomdv:d %d -admov:ds %d "
+						  "-aomdv:l %f -aomdv:c %s ",
+						  rp->rp_type,
+						  rp->rp_hop_count,
+						  rp->rp_dst,
+						  rp->rp_dst_seqno,
+						  rp->rp_lifetime,
+						  rp->rp_type == AOMDVTYPE_RREP ? "REPLY" :
+						  (rp->rp_type == AOMDVTYPE_RERR ? "ERROR" :
+							"HELLO"));
+			} else if (newtrace_) {
+				
+				sprintf(pt_->buffer() + offset,
+						  "-P aomdv -Pt 0x%x -Ph %d -Pd %d -Pds %d -Pl %f -Pc %s ",
+						  rp->rp_type,
+						  rp->rp_hop_count,
+						  rp->rp_dst,
+						  rp->rp_dst_seqno,
+						  rp->rp_lifetime,
+						  rp->rp_type == AOMDVTYPE_RREP ? "REPLY" :
+						  (rp->rp_type == AOMDVTYPE_RERR ? "ERROR" :
+							"HELLO"));
+	        } else {
+				  sprintf(pt_->buffer() + offset,
+							 "[0x%x %d [%d %d] %f] (%s) [%d %d]",
+							 rp->rp_type,
+							 rp->rp_hop_count,
+							 rp->rp_dst,
+							 rp->rp_dst_seqno,
+							 rp->rp_lifetime,
+							 rp->rp_type == AODVTYPE_RREP ? "REPLY" :
+							 (rp->rp_type == AODVTYPE_RERR ? "ERROR" :
+							  "HELLO"),
+							 rp->rp_bcast_id,
+							 rp->rp_first_hop
+							 );
+			  }
+			break;
+			
+		default:
+#ifdef WIN32
+			fprintf(stderr,
+					  "CMUTrace::format_aomdv: invalid AODV packet type\n");
+#else
+			fprintf(stderr,
+					  "%s: invalid AOMDV packet type\n", __FUNCTION__);
+#endif
+			abort();
+	}
+}
+
+void
+CMUTrace::nam_format(Packet *p, int offset)
+{
+	Node* srcnode = 0 ;
+	Node* dstnode = 0 ;
+	Node* nextnode = 0 ;
+        struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_ip *ih = HDR_IP(p);
+	char op = (char) type_;
+	char colors[32];
+	int next_hop = -1 ;
+
+// change wrt Mike's code
+	assert(type_ != EOT);
+
+
+
+	//<zheng: add for 802.15.4>
+
+	//Actually we only need to handle MAC layer for nam (but should display dropping for other layers)
+	//if (strcmp(tracename,"MAC") != 0)
+	//if ((op != 'D')&&(op != 'd'))
+	//	return;
+
+	struct hdr_mac802_11 *mh = HDR_MAC802_11(p);
+	char ptype[11];
+	strcpy(ptype,
+	((ch->ptype() == PT_MAC) ? (
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_RTS) ? "RTS"  :
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_CTS) ? "CTS"  :
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_ACK) ? "ACK"  :
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Beacon) ? "BCN"  :		//Beacon
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_AssocReq) ? "ACRQ"  :
+          (mh->dh_fc.fc_subtype == MAC_Subtype_AssocRep) ? "ACRP"  :
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_AssoReq) ? "CM1"  :	//CMD: Association request
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_AssoRsp) ? "CM2"  :	//CMD: Association response
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_DAssNtf) ? "CM3"  :	//CMD: Disassociation notification
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_DataReq) ? "CM4"  :	//CMD: Data request
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_PIDCNtf) ? "CM5"  :	//CMD: PAN ID conflict notification
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_OrphNtf) ? "CM6"  :	//CMD: Orphan notification
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_BconReq) ? "CM7"  :	//CMD: Beacon request
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_CoorRea) ? "CM8"  :	//CMD: Coordinator realignment
+	  (mh->dh_fc.fc_subtype == MAC_Subtype_Command_GTSReq) ? "CM9"  :	//CMD: GTS request
+	  "UNKN"
+	  ) : packet_info.name(ch->ptype())));
+	//</zheng: add for 802.15.4>
+        int dst = Address::instance().get_nodeaddr(ih->daddr());
+
+	nextnode = Node::get_node_by_address(ch->next_hop_);
+        if (nextnode) next_hop = nextnode->nodeid(); 
+
+	srcnode = Node::get_node_by_address(src_);
+	dstnode = Node::get_node_by_address(ch->next_hop_);
+
+	double distance = 0;
+
+        if ((srcnode) && (dstnode)) {
+	   MobileNode* tmnode = (MobileNode*)srcnode;
+	   MobileNode* rmnode = (MobileNode*)dstnode;
+
+	   distance = tmnode->propdelay(rmnode) * 300000000 ;
+	}
+
+	double energy = -1;
+	double initenergy = -1;
+
+	//default value for changing node color with respect to energy depletion
+	double l1 = 0.5; 
+	double l2 = 0.2;
+	
+	if (srcnode) {
+	    if (srcnode->energy_model()) {
+		    energy = srcnode->energy_model()->energy();
+		    initenergy = srcnode->energy_model()->initialenergy();
+		    l1 = srcnode->energy_model()->level1();
+		    l2 = srcnode->energy_model()->level2();
+	    }
+	}
+
+        int energyLevel = 0 ;
+        double energyLeft = (double)(energy/initenergy) ;
+
+        if ((energyLeft <= 1 ) && (energyLeft >= l1 )) energyLevel = 3;	
+        if ((energyLeft >= l2 ) && (energyLeft < l1 )) energyLevel = 2;	
+        if ((energyLeft > 0 ) && (energyLeft < l2 )) energyLevel = 1;	
+
+	if (energyLevel == 0) 
+		strcpy(colors,"-c black -o red");
+        else if (energyLevel == 1) 
+		strcpy(colors,"-c red -o yellow");
+        else if (energyLevel == 2) 
+		strcpy(colors,"-c yellow -o green");
+        else if (energyLevel == 3) 
+		strcpy(colors,"-c green -o black");
+
+	// A simple hack for scadds demo (fernandez's visit) -- Chalermek
+	int pkt_color = 0;
+	if (ch->ptype()==PT_DIFF) {
+		hdr_cdiff *dfh= HDR_CDIFF(p);
+		if (dfh->mess_type != DATA) {
+			pkt_color = 1;
+		}
+	}
+
+	//<zheng: add for 802.15.4>
+	if (Nam802_15_4::Nam_Status)
+	{
+		ATTRIBUTELINK *attr;
+		int t_src,t_dst;
+		if (ch->ptype() == PT_MAC)
+		{
+			t_src = p802_15_4macSA(p);
+			t_dst = p802_15_4macDA(p);;
+		}
+		else
+		{
+			t_src = HDR_IP(p)->saddr();
+			t_dst = HDR_IP(p)->daddr();
+		}
+		attr = findAttrLink(HDR_CMN(p)->ptype(),t_src,t_dst);
+		if (attr == NULL)
+			attr = findAttrLink(HDR_CMN(p)->ptype());
+		if (attr != NULL)
+			HDR_LRWPAN(p)->attribute = attr->attribute;
+		else
+			HDR_LRWPAN(p)->attribute = 0;
+		if (HDR_LRWPAN(p)->attribute >= 32)
+			pkt_color = HDR_LRWPAN(p)->attribute;
+	}
+	//</zheng: add for 802.15.4>
+
+	// convert to nam format 
+	if (op == 's') op = 'h' ;
+	if (op == 'D') op = 'd' ;
+	if (op == 'h') {
+		sprintf(pt_->nbuffer(),
+			"+ -t %.9f -s %d -d %d -p %s -e %d -c 2 -a %d -i %d -k %3s ",
+			Scheduler::instance().clock(),
+			src_,                           // this node
+			next_hop,
+			ptype,			//<zheng: modify for 802.15.4>packet_info.name(ch->ptype()),
+			ch->size(),
+			pkt_color,   
+			ch->uid(),
+			tracename);
+
+		offset = strlen(pt_->nbuffer());
+		pt_->namdump();
+		sprintf(pt_->nbuffer() ,
+			"- -t %.9f -s %d -d %d -p %s -e %d -c 2 -a %d -i %d -k %3s",
+			Scheduler::instance().clock(),
+			src_,                           // this node
+			next_hop,
+			ptype,			//<zheng: modify for 802.15.4>packet_info.name(ch->ptype()),
+			ch->size(),
+			pkt_color,
+			ch->uid(),
+			tracename);
+		
+		offset = strlen(pt_->nbuffer());
+		pt_->namdump();
+	}
+
+        // if nodes are too far from each other
+	// nam won't dump SEND event 'cuz it's
+	// gonna be dropped later anyway
+	// this value 250 is pre-calculated by using 
+	// two-ray ground refelction model with fixed
+	// transmission power 3.652e-10
+//	if ((type_ == SEND)  && (distance > 250 )) return ;
+
+	if(tracetype == TR_ROUTER && type_ == RECV && dst != -1 ) return ;
+	if(type_ == RECV && dst == -1 )dst = src_ ; //broadcasting event
+
+        if (energy != -1) { //energy model being turned on
+	   if (src_ >= MAX_NODE) {
+		   fprintf (stderr, "node id must be < %d\n",
+			    MAX_NODE);
+	       exit(0);
+	   }
+	   if (nodeColor[src_] != energyLevel ) { //only dump it when node  
+	       sprintf(pt_->nbuffer() ,                    //color change
+	          "n -t %.9f -s %d -S COLOR %s",
+	           Scheduler::instance().clock(),
+	           src_,                           // this node
+	           colors);
+               offset = strlen(pt_->nbuffer());
+               pt_->namdump();
+	       nodeColor[src_] = energyLevel ;
+	    }   
+        }
+
+	sprintf(pt_->nbuffer() ,
+		"%c -t %.9f -s %d -d %d -p %s -e %d -c 2 -a %d -i %d -k %3s",
+		op,
+		Scheduler::instance().clock(),
+		src_,                           // this node
+		next_hop,
+		ptype,			//<zheng: modify for 802.15.4>packet_info.name(ch->ptype()),
+		ch->size(),
+		pkt_color,
+		ch->uid(),
+		tracename);
+
+//<zheng: ns 2.27 removed the following part, but we need it to control the broadcast radius>
+if (Nam802_15_4::Nam_Status)
+{
+	if ((strcmp(tracename, "AGT") != 0) || ((u_int32_t)(ih->daddr()) == IP_BROADCAST))		//<zheng: add: next_hop info not available at agent level>
+											//(doesn't really matter -- seems agent level has no effect on nam)
+	if (next_hop == -1 && op == 'h') {
+		// print extra fields for broadcast packets
+
+		// bradius is calculated assuming 2-ray ground reflectlon
+		// model using default settings of Phy/WirelessPhy and
+		// Antenna/OmniAntenna
+		if (bradius == 0.0) calculate_broadcast_parameters();
+
+		double radius = bradius*radius_scaling_factor_; 
+
+		// duration is calculated based on the radius and
+		// the speed of light (299792458 m/s)
+		double duration = (bradius/299792458.0)*duration_scaling_factor_;
+		//<zheng: add -- the duration in 802.15.4 could be very small and rounded to 0.0>
+		if (Nam802_15_4::Nam_Status)
+		if (duration < 0.000000001)
+			duration = 0.000000001;
+		//</zheng: add>
+		sprintf(pt_->nbuffer() + strlen(pt_->nbuffer()),
+			" -R %.2f -D %.2f",
+			radius,
+			duration);
+	}
+}
+//</zheng>
+
+	offset = strlen(pt_->nbuffer());
+	pt_->namdump();
+}
+
+void CMUTrace::format(Packet* p, const char *why)
+{
+	hdr_cmn *ch = HDR_CMN(p);
+	int offset = 0;
+
+	/*
+	 * Log the MAC Header
+	 */
+	format_mac_common(p, why, offset);
+
+	if (pt_->namchannel()) 
+		nam_format(p, offset);
+	offset = strlen(pt_->buffer());
+	switch(ch->ptype()) {
+	case PT_MAC:
+	case PT_SMAC:
+		break;
+	case PT_ARP:
+		format_arp(p, offset);
+		break;
+	default:
+		format_ip(p, offset);
+		offset = strlen(pt_->buffer());
+		switch(ch->ptype()) {
+		case PT_AODV:
+			format_aodv(p, offset);
+			break;
+		// AOMDV patch
+		case PT_AOMDV:
+			format_aomdv(p, offset);
+			break;
+		case PT_TORA:
+                        format_tora(p, offset);
+                        break;
+                case PT_IMEP:
+                        format_imep(p, offset);
+                        break;
+		case PT_DSR:
+			format_dsr(p, offset);
+			break;
+		case PT_MESSAGE:
+		case PT_UDP:
+			format_msg(p, offset);
+			break;
+		case PT_TCP:
+		case PT_ACK:
+			format_tcp(p, offset);
+			break;
+		case PT_SCTP:
+			/* Armando L. Caro Jr. <acaro@@cis,udel,edu> 6/5/2002
+			 */
+			format_sctp(p, offset);
+			break;
+		case PT_CBR:
+			format_rtp(p, offset);
+			break;
+	        case PT_DIFF:
+			break;
+		case PT_GAF:
+		case PT_PING:
+			break;
+		default:
+
+			if(pktTrc_ && pktTrc_->format_unknow(p, offset, pt_, newtrace_))
+				break;
+
+		/*<zheng: del -- there are many more new packet types added, like PT_EXP (poisson traffic belongs to this type)>
+			fprintf(stderr, "%s - invalid packet type (%s).\n",
+				__PRETTY_FUNCTION__, packet_info.name(ch->ptype()));
+			exit(1);
+		</zheng: del>*/
+			break;		//zheng: add
+		}
+	}
+}
+
+int
+CMUTrace::command(int argc, const char*const* argv)
+{
+	
+        if(argc == 3) {
+                if(strcmp(argv[1], "node") == 0) {
+                        node_ = (MobileNode*) TclObject::lookup(argv[2]);
+                        if(node_ == 0)
+                                return TCL_ERROR;
+                        return TCL_OK;
+                }
+		if (strcmp(argv[1], "newtrace") == 0) {
+			newtrace_ = atoi(argv[2]);
+		        return TCL_OK;
+		}
+        }
+	return Trace::command(argc, argv);
+}
+
+/*ARGSUSED*/
+void
+CMUTrace::recv(Packet *p, Handler *h)
+{
+	if (!node_energy()) {
+		Packet::free(p);
+		return;
+	}
+        assert(initialized());
+        /*
+         * Agent Trace "stamp" the packet with the optimal route on
+         * sending.
+         */
+        if (tracetype == TR_AGENT && type_ == SEND) {
+                God::instance()->stampPacket(p);
+        }
+#if 0
+        /*
+         * When the originator of a packet drops the packet, it may or may
+         * not have been stamped by GOD.  Stamp it before logging the
+         * information.
+         */
+        if(src_ == src && type_ == DROP) {
+                God::instance()->stampPacket(p);
+        }
+#endif
+	format(p, "---");
+	pt_->dump();
+	//namdump();
+	if(target_ == 0)
+		Packet::free(p);
+	else
+		send(p, h);
+}
+
+void
+CMUTrace::recv(Packet *p, const char* why)
+{
+        assert(initialized() && type_ == DROP);
+	if (!node_energy()) {
+		Packet::free(p);
+		return;
+	}
+#if 0
+        /*
+         * When the originator of a packet drops the packet, it may or may
+         * not have been stamped by GOD.  Stamp it before logging the
+         * information.
+         */
+        if(src_ == ih->saddr()) {
+                God::instance()->stampPacket(p);
+        }
+#endif
+	format(p, why);
+	pt_->dump();
+	//namdump();
+	Packet::free(p);
+}
+
+int CMUTrace::node_energy()
+{
+	Node* thisnode = Node::get_node_by_address(src_);
+	double energy = 1;
+	if (thisnode) {
+		if (thisnode->energy_model()) {
+			energy = thisnode->energy_model()->energy();
+		}
+	} 
+	if (energy > 0) return 1;
+	return 0;
+}
+
+//<zheng: ns 2.27 removed the following part, but we need it to control the broadcast radius>
+void CMUTrace::calculate_broadcast_parameters() {
+	// Calculate the maximum distance at which a packet can be received
+	// based on the two-ray reflection model using the current default
+	// values for Phy/WirelessPhy and Antenna/OmniAntenna.
+
+	double P_t, P_r, G_t, G_r, h, L;
+	Tcl& tcl = Tcl::instance();
+
+	tcl.evalc("Phy/WirelessPhy set Pt_");
+	P_t = atof(tcl.result());
+	tcl.evalc("Phy/WirelessPhy set RXThresh_");
+	P_r = atof(tcl.result());
+	tcl.evalc("Phy/WirelessPhy set L_");
+	L = atof(tcl.result());
+	tcl.evalc("Antenna/OmniAntenna set Gt_");
+	G_t = atof(tcl.result());
+	tcl.evalc("Antenna/OmniAntenna set Gr_");
+	G_r = atof(tcl.result());
+	tcl.evalc("Antenna/OmniAntenna set Z_");
+	h = atof(tcl.result());
+	bradius = pow(P_t*G_r*G_t*pow(h,4.0)/(P_r*L), 0.25);
+	//<zheng: add for 802.15.4>
+	//the above calculation is not accurate for short distance
+	double PI,freq,lambda,crossover_dist;
+	PI = 3.14159265359;
+	tcl.evalc("Phy/WirelessPhy set freq_");
+	freq = atof(tcl.result());
+	lambda = 3.0e8/freq;
+	crossover_dist = (4 * PI * h * h) / lambda;
+	if (bradius < crossover_dist)	//need re-calculation
+		bradius = pow(P_t * G_r * G_t * pow(lambda, 2.0)/(P_r * L), 0.5)/(4 * PI);
+	//</zheng: add for 802.15.4>
+
+	// Also get the scaling factors
+	tcl.evalc("CMUTrace set radius_scaling_factor_");
+	radius_scaling_factor_ = atof(tcl.result());
+	tcl.evalc("CMUTrace set duration_scaling_factor_");
+	duration_scaling_factor_ = atof(tcl.result());
+}
+//</zheng>
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/trace/cmu-trace.h ns-2.34/trace/cmu-trace.h
--- ns-2.34-pure/trace/cmu-trace.h	2009-06-14 10:35:07.000000000 -0700
+++ ns-2.34/trace/cmu-trace.h	2010-02-28 09:31:39.000000000 -0800
@@ -159,6 +159,7 @@
 	void	format_tora(Packet *p, int offset);
         void    format_imep(Packet *p, int offset);
         void    format_aodv(Packet *p, int offset);
+	void    format_raw(Packet *p, int offset);
 	void    format_aomdv(Packet *p, int offset);
 
 	// This holds all the tracers added at run-time
diff -ruN --exclude='*.o' --exclude='autom4*' ns-2.34-pure/trace/cmu-trace.h.orig ns-2.34/trace/cmu-trace.h.orig
--- ns-2.34-pure/trace/cmu-trace.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ ns-2.34/trace/cmu-trace.h.orig	2009-06-14 10:35:07.000000000 -0700
@@ -0,0 +1,169 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*-
+ *
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $Header: /cvsroot/nsnam/ns-2/trace/cmu-trace.h,v 1.28 2009/01/15 06:23:49 tom_henderson Exp $
+ */
+
+/* Ported from CMU/Monarch's code, nov'98 -Padma.*/
+
+#ifndef __cmu_trace__
+#define __cmu_trace__
+
+#include "trace.h"
+#include "god.h"
+
+#ifndef __PRETTY_FUNCTION__
+#define __PRETTY_FUNCTION__ ("")
+#endif /* !__PRETTY_FUNCTION__ */
+
+/* ======================================================================
+   Global Defines
+   ====================================================================== */
+#define	DROP            'D'
+#define	RECV            'r'
+#define	SEND    	's'
+#define	FWRD    	'f'
+
+// change wrt Mike's code
+#define EOT             'x'
+
+
+
+#define TR_ROUTER	0x01
+#define TR_MAC		0x02
+#define TR_IFQ		0x04
+#define TR_AGENT	0x08
+
+#define TR_PHY		0x10
+
+#define DROP_END_OF_SIMULATION		"END"
+#define	DROP_MAC_COLLISION		"COL"
+#define DROP_MAC_DUPLICATE		"DUP"
+#define DROP_MAC_PACKET_ERROR		"ERR"
+#define DROP_MAC_RETRY_COUNT_EXCEEDED	"RET"
+#define DROP_MAC_INVALID_STATE		"STA"
+#define DROP_MAC_BUSY			"BSY"
+#define DROP_MAC_INVALID_DST            "DST"
+#define DROP_MAC_SLEEP                  "SLP"   // smac sleep state
+
+#define DROP_RTR_NO_ROUTE		"NRTE"  // no route
+#define DROP_RTR_ROUTE_LOOP		"LOOP"  // routing loop
+#define DROP_RTR_TTL                    "TTL"   // ttl reached zero
+#define DROP_RTR_QFULL                  "IFQ"   // queue full
+#define DROP_RTR_QTIMEOUT               "TOUT"  // packet expired
+#define DROP_RTR_MAC_CALLBACK           "CBK"   // MAC callback
+#define DROP_RTR_SALVAGE	        "SAL"
+
+#define DROP_IFQ_QFULL                  "IFQ"   // no buffer space in IFQ
+#define DROP_IFQ_ARP_FULL               "ARP"   // dropped by ARP
+#define DROP_IFQ_FILTER                 "FIL"
+
+#define DROP_OUTSIDE_SUBNET             "OUT"   // dropped by base stations if received rtg updates from nodes outside its domain.
+
+#define MAX_ID_LEN	3
+#define MAX_NODE	4096
+
+/**
+ * This class allows a dynamic library to define the tracing format
+ * for newly defined packet types 
+ * 
+ */
+class PacketTracer
+{
+	public:
+		PacketTracer();
+        	virtual ~PacketTracer();
+		void setNext(PacketTracer *next);
+		PacketTracer *getNext();
+		int format_unknow(Packet *p, int offset, BaseTrace *pt_, int newtrace);
+	protected:
+		virtual int format(Packet *p, int offset, BaseTrace *pt_, int newtrace) = 0;	//return 0 if the packet is unknown
+		PacketTracer *next_;
+};
+
+
+class CMUTrace : public Trace {
+public:
+	CMUTrace(const char *s, char t);
+	void	recv(Packet *p, Handler *h);
+	void	recv(Packet *p, const char* why);
+
+	static void addPacketTracer(PacketTracer *pt);
+
+
+private:
+	char	tracename[MAX_ID_LEN + 1];
+	int	nodeColor[MAX_NODE];
+        int     tracetype;
+        MobileNode *node_;
+	int     newtrace_;
+
+	//<zheng: ns 2.27 removed the following part, but we need it to control the broadcast radius>
+        static double  bradius;
+        static double  radius_scaling_factor_;
+        static double  duration_scaling_factor_;
+        static void calculate_broadcast_parameters();
+	//</zheng>
+
+        int initialized() { return node_ && 1; }
+	int node_energy();
+	int	command(int argc, const char*const* argv);
+	void	format(Packet *p, const char *why);
+
+        void    nam_format(Packet *p, int offset);
+
+	void	format_phy(Packet *p, int offset);
+	
+	void	format_mac_common(Packet *p, const char *why, int offset);
+	void    format_mac(Packet *p, int offset);
+	void    format_smac(Packet *p, int offset);
+	void	format_ip(Packet *p, int offset);
+
+	void	format_arp(Packet *p, int offset);
+	void    format_hdlc(Packet *p, int offset);
+	void	format_dsr(Packet *p, int offset);
+	void	format_msg(Packet *p, int offset);
+	void	format_tcp(Packet *p, int offset);
+	void    format_sctp(Packet *p, int offset);
+	void	format_rtp(Packet *p, int offset);
+	void	format_tora(Packet *p, int offset);
+        void    format_imep(Packet *p, int offset);
+        void    format_aodv(Packet *p, int offset);
+	void    format_aomdv(Packet *p, int offset);
+
+	// This holds all the tracers added at run-time
+	static PacketTracer *pktTrc_;
+
+};
+
+#endif /* __cmu_trace__ */
