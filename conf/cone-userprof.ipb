// Kernel configuration for cone as a router between
// 18.26.4 (eth0) and 18.26.7 (eth1).
// Proxy ARPs for 18.26.7 on eth0.

// Don't forget ifconfig eth1 up.

// eth0, 00:00:C0:AE:67:EF, 18.26.4.24
// eth1, 00:00:C0:4F:71:EF, 18.26.7.1

// 0. ARP queries
// 1. ARP replies
// 2. IP
// 3. Other
// We need separate classifiers for each interface because
// we only want proxy ARP on eth0.
c0 :: Classifier(12/0806 20/0001,
                12/0806 20/0002,
                12/0800,
                -);
c1 :: Classifier(12/0806 20/0001,
                12/0806 20/0002,
                12/0800,
                -);


Idle -> Paint(1) -> [0]c0;
InfiniteSource(\<00 00 c0 ae 67 ef 00 00 00 00 00 00 08 00
45 00 00 28  00 00 00 00  40 11 77 c3  01 00 00 01  
02 00 00 02  13 69 13 69  00 14 d6 41  55 44 50 20  
70 61 63 6b  65 74 21 0a  04 00 00 00  01 00 00 00  
01 00 00 00  00 00 00 00  00 80 04 08  00 80 04 08  
53 53 00 00  53 53 00 00  05 00 00 00  00 10 00 00  
01 00 00 00  54 53 00 00  54 e3 04 08  54 e3 04 08  
d8 01 00 00>, 600000, 5) -> Paint(2) -> [0]c1;
out0 :: Queue(200) -> Discard;
out1 :: Queue(200) -> Discard;
tol :: Discard;

// An ARP querier for each interface.
arpq0 :: EtherEncap(0x0800, 00:00:c0:ae:67:ef, 00:00:c0:4f:71:ef); //ARPQuerier(18.26.4.24, 00:00:C0:AE:67:EF);
arpq1 :: EtherEncap(0x0800, 00:00:c0:4f:71:ef, 00:00:c0:4f:71:ef); //ARPQuerier(18.26.7.1, 00:00:C0:4F:71:EF);

// Deliver ARP responses to ARP queriers as well as Linux.
t :: Tee(3);
c0[1] -> t;
c1[1] -> t;
t[0] -> tol;
t[1] -> [0]arpq0; //[1]
t[2] -> [0]arpq1; //[1]

// Connect ARP outputs to the interface queues.
arpq0 -> out0;
arpq1 -> out1;

// Proxy ARP on eth0 for 18.26.7, as well as cone's IP address.
ar0 :: { input -> ARPResponder(18.26.4.24 00:00:C0:AE:67:EF,
                    18.26.7.0/24 00:00:C0:AE:67:EF) -> output };
c0[0] -> ar0 -> out0;

// Ordinary ARP on eth1.
ar1 :: ARPResponder(18.26.7.1 00:00:C0:4F:71:EF);
c1[0] -> ar1 -> out1;

// IP routing table. Outputs:
// 0: packets for this machine.
// 1: packets for 18.26.4.
// 2: packets for 18.26.7.
// 3: default route to LCS router.
rt :: LookupIPRoute(18.26.4.24 0,
                 18.26.4.255 0,
                 18.26.4.0 0,
                 18.26.7.1 0,
                 18.26.7.255 0,
                 18.26.7.0 0,
                 18.26.4.0/24 1,
                 18.26.7.0/24 2,
                 0.0.0.0/0 18.26.4.1 1);

// Hand incoming IP packets to the routing table.
// CheckIPHeader checks all the lengths and length fields
// for sanity.
ip ::   Strip(14)
     -> CheckIPHeader
     -> GetIPAddress(16)
     -> [0]rt;
c0[2] -> ip;
c1[2] -> ip;

// IP packets for this machine.
// ToLinux expects ethernet packets, so cook up a fake header.
rt[0] -> EtherEncap(0x0800, 1:1:1:1:1:1, 2:2:2:2:2:2) -> tol;

// These are the main output paths; we've committed to a
// particular output device.
// Check paint to see if a redirect is required.
// Process record route and timestamp IP options.
// Fill in missing ip_src fields.
// Discard packets that arrived over link-level broadcast or multicast.
// Decrement and check the TTL after deciding to forward.
// Fragment.
// Send outgoing packets through ARP to the interfaces.
rt[1] -> DropBroadcasts
      -> cp1 :: CheckPaint(1)
      -> gio1 :: IPGWOptions(18.26.4.24)
      -> FixIPSrc(18.26.4.24)
      -> dt1 :: DecIPTTL
      -> SetIPDSCP(9)
      -> cccc :: CheckIPHeader
      -> fr1 :: IPFragmenter(300)
      -> [0]arpq0;
rt[2] -> DropBroadcasts
      -> cp2 :: CheckPaint(2)
      -> gio2 :: IPGWOptions(18.26.7.1)
      -> FixIPSrc(18.26.7.1)
      -> dt2 :: DecIPTTL
      -> fr2 :: IPFragmenter(300)
      -> [0]arpq1;

// cccc[1] -> Print(fucker!) -> Discard;

// DecIPTTL[1] emits packets with expired TTLs.
// Reply with ICMPs. Rate-limit them?
dt1[1] -> ICMPError(18.26.4.24, 11, 0) -> [0]rt;
dt2[1] -> ICMPError(18.26.4.24, 11, 0) -> [0]rt;

// Send back ICMP UNREACH/NEEDFRAG messages on big packets with DF set.
// This makes path mtu discovery work.
fr1[1] -> ICMPError(18.26.7.1, 3, 4) -> [0]rt;
fr2[1] -> ICMPError(18.26.7.1, 3, 4) -> [0]rt;

// Send back ICMP Parameter Problem messages for badly formed
// IP options. Should set the code to point to the
// bad byte, but that's too hard.
gio1[1] -> ICMPError(18.26.4.24, 12, 1) -> [0]rt;
gio2[1] -> ICMPError(18.26.4.24, 12, 1) -> [0]rt;

// Send back an ICMP redirect if required.
cp1[1] -> ICMPError(18.26.4.24, 5, 1) -> [0]rt;
cp2[1] -> ICMPError(18.26.7.1, 5, 1) -> [0]rt;

// Unknown ethernet type numbers.
c0[3] -> Print(c3) -> Discard;
c1[3] -> Print(c3) -> Discard;
