// This configuration was generated by make-adapt-ron.pl
// 6/30/101  15:3:17
//
// make-adapt-ron.pl 18.239.0.139 00:40:05:A2:AC:77 18.239.2.103 18.239.0.1 18.26.4.60 18.26.4.104 
//
// This IP:	18.239.0.139
// This HW:	00:40:05:A2:AC:77
// Exit IP:	18.239.2.103
// GW IP:  	18.239.0.1
// Neighbor0:	18.26.4.60
// Neighbor1:	18.26.4.104

require(ron);

elementclass ICMPClassifier {
	input -> c :: IPClassifier(tcp or udp, icmp type echo or icmp type echo_reply, icmp, -);
	c[0] -> [0]output;
	c[1] -> [1]output;
	c[2] -> [2]output;
	c[3] -> [3]output;
	}

from0 :: FromDevice(eth0);
to0 :: ToDevice(eth0);
mainclassifier :: Classifier (
	12/0800 26/121a043c 23/04, 	// IP encap from neighbor 1(18.26.4.60)
	12/0800 26/121a0468 23/04, 	// IP encap from neighbor 2(18.26.4.104)
	12/0800 30/12ef0267 !26/12ef0267, 		// IP to my exit point (18.239.2.103)
	12/0800 !30/12ef008b !26/12ef0267 !19/ff,	// IP not to me, not broadcast (forward path entracepoint)
	12/0806 20/0002,		// ARP Replies
	12/0806 20/0001			// ARP Queries
	);

routingtable :: LookupIPRouteRON(3);

// ----- Rewriters -----
iprw :: IPRewriter(
	pattern 18.239.2.103 4000-4099 - - 0 1,
	pattern 18.239.2.103 4100-4199 - - 2 3,
	pattern 18.239.2.103 4200-4299 - - 4 5,
	drop);

icmprw :: ICMPRewriter(iprw);

icmppingrw :: ICMPPingRewriter(18.239.2.103, -);

setgw :: SetIPAddress(18.239.0.1);

arpq :: ARPQuerier(18.239.0.139, 00:40:05:A2:AC:77);
arpr :: ARPResponder(18.239.2.103 00:40:05:A2:AC:77);

dirPathC :: ICMPClassifier;
revPathC :: ICMPClassifier;
c1 :: ICMPClassifier;
c2 :: ICMPClassifier;

elementclass directionclassifier {
	input
	-> t :: Tee(2)[0] -> pt0 :: PaintTee(0);
	t[1] -> pt1 :: PaintTee(1);
	pt0[0] -> Discard;
	pt0[1] -> [0]output;
	pt1[0] -> Discard;
	pt1[1] -> [1]output;
	}

// -----------------------------------------------------------
from0 -> mainclassifier;

dc2 :: directionclassifier;
dc3 :: directionclassifier;

mainclassifier[3]
	-> Strip(14)
	-> CheckIPHeader
	-> DropBroadcasts
	-> Print(InClassPort2)
	-> IPPrint(InClassPort2)
	-> GetIPAddress(16)
	-> routingtable;

mainclassifier[0]
	-> Strip(14)
	-> CheckIPHeader
	-> Print(InClassPort0)
	-> IPDecapPaint
	-> CheckIPHeader
	-> IPPrint(EncapsulatedPac)
	-> dc2[0] // FORWARD path
	-> IPReassembler
	-> c1;

mainclassifier[1]
	-> Strip(14)
	-> CheckIPHeader
	-> Print(InClassPort0)
	-> IPDecapPaint
	-> CheckIPHeader
	-> IPPrint(EncapsulatedPac)
	-> dc3[0] // FORWARD path
	-> IPReassembler
	-> c2;

mainclassifier[2]
	-> Strip(14)
	-> CheckIPHeader
	-> fragforA::IPFragmenter(1470)
	-> Print(InClassPort1)
	-> IPReassembler
	-> IPReassembler
	-> CheckIPHeader
	-> IPPrint(InClassPort1)
	-> revPathC;

mainclassifier[4]
//	-> Print(SawARPReply, 64)
	-> [1]arpq;

mainclassifier[5]
//	-> Print(SawARPQuery, 64)
	-> arpr;

routingtable[0] -> setgw; // REPLY pkts

routingtable[1]
	-> Print(ROUTE1(direct))
	-> IPReassembler
	-> dirPathC;

routingtable[2]
	-> Print(ROUTE2(forw2_))
	-> fragforB0::IPFragmenter(1470)
	-> SetIPAddress(18.26.4.60)
	-> IPEncapPaint(0, 4, 18.239.0.139) // FORWARD pkts get painted 0 
	-> setgw;

routingtable[3]
	-> Print(ROUTE2(forw3_))
	-> fragforB1::IPFragmenter(1470)
	-> SetIPAddress(18.26.4.104)
	-> IPEncapPaint(0, 4, 18.239.0.139) // FORWARD pkts get painted 0 
	-> setgw;

// Direct pkts
dirPathC[0] -> IPPrint(IP) -> [0]iprw;	// TCP, UDP
dirPathC[1] -> icmppingrw;	// ICMP Pings
dirPathC[2] -> icmprw;	// ICMP errors
dirPathC[3] -> Discard;

// Forward pkts received through tunnel
c1[0] -> [1]iprw;	// TCP, UDP
c1[1] -> icmppingrw;	// ICMP Pings
c1[2] -> icmprw;	// ICMP errors
c1[3] -> Discard;

// Forward pkts received through tunnel
c2[0] -> [2]iprw;	// TCP, UDP
c2[1] -> icmppingrw;	// ICMP Pings
c2[2] -> icmprw;	// ICMP errors
c2[3] -> Discard;

// Reverse pkts received at Exit Point
revPathC[0] -> [3]iprw;	// TCP, UDP
revPathC[1] -> icmppingrw;	// ICMP Pings
revPathC[2] -> icmprw;	// ICMP errors
revPathC[3] -> Discard;

// REVERSE pkts received through tunnel
dc2[1]
	->IPReassembler
	->CheckIPHeader
	->GetIPAddress(16)
	->IPPrint(RCVTunnelREVERSE)
	-> [2]routingtable
dc3[1]
	->IPReassembler
	->CheckIPHeader
	->GetIPAddress(16)
	->IPPrint(RCVTunnelREVERSE)
	-> [3]routingtable

// Direct rewrite pattern
iprw[0] -> Queue(50) -> DelayShaper(1) -> Unqueue -> IPPrint(IPRewritten0) -> setgw;
iprw[1] -> IPPrint(IPRewritten1) -> GetIPAddress(16) -> [1]routingtable;

iprw[2] -> setgw;
iprw[3] -> fragrev0::IPFragmenter(1470)
	-> SetIPAddress(18.26.4.60)
	-> IPEncapPaint(1, 4, 18.239.0.139) // Tunnel (REV)
	-> setgw;

iprw[4] -> setgw;
iprw[5] -> fragrev1::IPFragmenter(1470)
	-> SetIPAddress(18.26.4.104)
	-> IPEncapPaint(1, 4, 18.239.0.139) // Tunnel (REV)
	-> setgw;

icmprw -> setgw;
icmppingrw[0] -> IPPrint(IPPingRewritten1) -> setgw;
icmppingrw[1] -> IPPrint(IPPingRewritten2) -> setgw; // this is only for direct pings
setgw -> [0]arpq;
//setlaptop -> [0]arpq;

icmperror :: ICMPError(18.239.2.103, 3, 4) -> SetIPAddress(18.239.0.1) -> arpq;
fragforA[1] -> icmperror;
fragforB0[1] -> icmperror;
fragrev0[1] -> icmperror;
fragforB1[1] -> icmperror;
fragrev1[1] -> icmperror;
arpq -> q :: Queue(100) -> Print(OutEth0,56) -> to0;
arpr -> Print(ARPResponseSent) -> q;

