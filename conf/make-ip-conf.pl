#!/usr/local/bin/perl -w

# make-ip-conf.pl -- make a Click IP router configuration
# Robert Morris
#
# Copyright (c) 1999-2000 Massachusetts Institute of Technology.
#
# This software is being provided by the copyright holders under the GNU
# General Public License, either version 2 or, at your discretion, any later
# version. For more information, see the `COPYRIGHT' file in the source
# distribution.

# Make a Click IP router configuration.
# The output is only useful with the Linux kernel module.
# This script generates a configuration using PollDevices. You can change
# it to use FromDevices; see the comment above the $ifs array, below.


# IP router setup for  blackisle -> plebic -> darkstar

# Change this array to suit your router.
# One line per network interface, containing:
#  The interface name;
#  Whether the interface can use polling (1 = polling, 0 = no polling);
#  The router's IP address on that interface;
#  The netmask on that interface; and
#  The router's Ethernet address on that interface.

my $ifs = [ [ "eth0", 1, "18.26.4.92", "255.255.255.0", "00:00:C0:3B:71:EF" ],
            [ "eth1", 1, "1.0.0.1", "255.0.0.0", "00:00:C0:CA:68:EF" ],
#           [ "eth2", 1, "2.0.0.1", "255.0.0.0", "00:00:C0:8A:67:EF" ],
           ];

if ($#ARGV >= 0) {
  $ifs = [];
  for ($i = 0; $i < $ARGV[0]; $i++) {
    push @$ifs, [ "eth" . $i, 1, "1.0.0.2", "255.0.0.0", "00:00:c0:8a:67:ef" ];
  }
}


my $nifs = $#$ifs + 1;

print "// Generated by make-ip-conf.pl\n";
my $i;
for($i = 0; $i < $nifs; $i++){
    printf("// %s %s %s\n",
           $ifs->[$i]->[0],
           $ifs->[$i]->[2],
           $ifs->[$i]->[4]);
}
print "\n";

print "tol :: ToLinux;\n";
printf("t :: Tee(%d);\n", $nifs + 1);
print "t[$nifs] -> tol;\n";
print "\n";

for($i = 0; $i < $nifs; $i++){
    my $eth = $ifs->[$i]->[0];
    my $ip = $ifs->[$i]->[2];
    my $ena = $ifs->[$i]->[4];
    my $paint = $i + 1;
    my $fromdevice = ($ifs->[$i]->[1] ? "PollDevice" : "FromDevice");
    print <<EOF
c$i :: Classifier(12/0806 20/0001,
                  12/0806 20/0002,
                  12/0800,
                  -);
$fromdevice($eth) -> PullToPush -> [0]c$i;
out$i :: Queue(200) -> ToDevice($eth);
arpq$i :: ARPQuerier($ip, $ena);
c$i [1] -> t;
t[$i] -> [1]arpq$i;
arpq$i -> out$i;
ar$i :: ARPResponder($ip 255.255.255.255 $ena);
c$i [0] -> ar$i -> out$i;

EOF
}

my $ipharg = "";
for($i = 0; $i < $nifs; $i++){
    my $ii = ip2i($ifs->[$i]->[2]);
    my $mask = ip2i($ifs->[$i]->[3]);
    $ipharg .= i2ip(($ii & $mask) | ~$mask) . " ";
}

print "rt :: LookupIPRoute(\n";
for($i = 0; $i < $nifs; $i++){
    my $ii = ip2i($ifs->[$i]->[2]);
    my $mask = ip2i($ifs->[$i]->[3]);
    printf(" %s 255.255.255.255 0.0.0.0 0,\n", $ifs->[$i]->[2]);
    printf(" %s 255.255.255.255 0.0.0.0 0,\n",
           i2ip(($ii & $mask) | ~$mask));
    printf(" %s 255.255.255.255 0.0.0.0 0,\n",
           i2ip($ii & $mask));
}
for($i = 0; $i < $nifs; $i++){
    my $ii = ip2i($ifs->[$i]->[2]);
    my $mask = ip2i($ifs->[$i]->[3]);
    printf(" %s %s 0.0.0.0 %d,\n",
           i2ip($ii & $mask),
           i2ip($mask),
           $i + 1);
}
print " 255.255.255.255 255.255.255.255 0.0.0.0 0,\n";
print " 0.0.0.0 255.255.255.255 0.0.0.0 0,\n";
print " 0.0.0.0 0.0.0.0 18.26.4.1 1);\n"; # XXX

print <<EOF;

rt[0] -> EtherEncap(0x0800, 1:1:1:1:1:1, 2:2:2:2:2:2) -> tol;
ip ::  Strip(14)
    -> CheckIPHeader($ipharg)
    -> GetIPAddress(16)
    -> [0]rt;
EOF

for($i = 0; $i < $nifs; $i++){
  my $paint = $i + 1;
  print "c$i [2] -> Paint($paint) -> ip;\n";
}
print "\n";

for($i = 0; $i < $nifs; $i++){
    my $i1 = $i + 1;
    my $ipa = $ifs->[$i]->[2];
    print <<EOF;
rt[$i1] -> DropBroadcasts
        -> cp$i :: CheckPaint($i1)
        -> gio$i :: IPGWOptions($ipa)
        -> FixIPSrc($ipa)
        -> dt$i :: DecIPTTL
        -> fr$i :: IPFragmenter(1500)
        -> [0]arpq$i;
dt$i [1] -> ICMPError($ipa, 11, 0) -> [0]rt;
fr$i [1] -> ICMPError($ipa, 3, 4) -> [0]rt;
gio$i [1] -> ICMPError($ipa, 12, 1) -> [0]rt;
cp$i [1] -> ICMPError($ipa, 5, 1) -> [0]rt;
c$i [3] -> Print(xx$i) -> Discard;
EOF
}

sub ip2i {
    my($ip) = @_;
    my @a = split(/\./, $ip);
    my $i = ($a[0] << 24) + ($a[1] << 16) + ($a[2] << 8) + $a[3];
    return($i);
}
sub i2ip {
    my($i) = @_;
    my $a = ($i >> 24) & 0xff;
    my $b = ($i >> 16) & 0xff;
    my $c = ($i >> 8) & 0xff;
    my $d = $i & 0xff;
    return sprintf("%d.%d.%d.%d", $a, $b, $c, $d);
}

