#!/usr/bin/perl -w
use Symbol 'qualify_to_ref';

## utilities

sub index2 ($$;$) {
    my($result) = (defined($_[2]) ? index($_[0], $_[1], $_[2]) : index($_[0], $_[1]));
    $result = length $_[0] if $result < 0;
    $result;
}

sub shquote ($) {
    my($t) = @_;
    $t =~ s/\'/\'\"\'\"\'/g;
    "'$t'";
}


## read file

package Testicle;

my %_special_filenames = ('stdin' => 1, 'stdout' => 1, 'stderr' => 1);

sub lineno ($$) {
    my($tt, $lineno) = @_;
    my($fn) = $tt->{'filename'};
    $fn = 'line ' if !defined($fn);
    $fn .= ':' if $fn !~ /[ :]$/;
    "$fn$lineno";
}

sub file_err ($$) {
    my($tt, $text) = @_;
    $text .= "\n" if $text !~ /\n$/s;
    print STDERR $tt->lineno($.), ': ', $text;
    $tt->{'err'}++;
}

sub _shell_split (\@\@$$;$) {
    my($arr, $lineno_arr, $text, $lineno, $rewrite_sub) = @_;
    $rewrite_sub = sub { $_[0] } if !defined($rewrite_sub);
    my($qf, $qb, $out) = (0, 0, '');
    my($sq, $dq, $bq, $nl) = (-2, -2, -2, -2);
    my($first, $pos) = (0, 0);
    $lineno -= ($text =~ tr/\n//);
    
    while ($pos < length $text) {
	$sq = ::index2($text, "\'", $pos) if $sq < $pos;
	$dq = ::index2($text, "\"", $pos) if $dq < $pos;
	$bq = ::index2($text, "\`", $pos) if $bq < $pos;
	$nl = ::index2($text, "\n", $pos) if $nl < $pos;
	
	if ($qf == 1) {
	    $qf = 0 if $sq < length $text;
	    $out .= substr($text, $pos, $sq + 1 - $pos);
	    $pos = $sq + 1;
	    next;
	} elsif ($qf == 2) {
	    $qf = 0 if $dq < length $text;
	    $out .= $rewrite_sub->(substr($text, $pos, $dq - $pos), 2) . '"';
	    $pos = $dq + 1;
	    next;
	}

	# find minimum
	my($min, $min1) = (($sq < $dq ? $sq : $dq), ($bq < $nl ? $bq : $nl));
	$min = $min1 if $min1 < $min;
	$out .= $rewrite_sub->(substr($text, $pos, $min - $pos), 0) . substr($text, $min, 1);
	
	if ($sq == $min) {
	    $qf = 1;
	    $pos = $sq + 1;
	} elsif ($dq == $min) {
	    $qf = 2;
	    $pos = $dq + 1;
	} elsif ($bq == $min) {
	    $qb = !$qb;
	    $pos = $bq + 1;
	} elsif (!$qb && ($nl == $pos || substr($text, $nl - 1, 1) ne "\\")) {
	    push @$arr, $out;
	    push @$lineno_arr, $lineno;
	    $out = '';
	    $lineno += (substr($text, $first, $nl - $first + 1) =~ tr/\n//);
	    $first = $pos = $nl + 1;
	} else {
	    $pos = $nl + 1;
	}
    }

    if ($first < length $text) {
	push @$arr, $out;
	push @$lineno_arr, $lineno;
    }
    
    if ($qf == 1) {
	"unmatched single quote";
    } elsif ($qf == 2) {
	"unmatched double quote";
    } elsif ($qb) {
	"unmatched backquote";
    } else {
	"";
    }
}

sub _read_text ($) {
    my($fh) = @_;
    my($r, $t) = ('');
    while (defined($t = <$fh>)) {
	last if $t =~ /^%/;
	$t =~ s/^\|//;
	$r .= $t;
    }
    ($r, $t);
}

sub _read_text_into ($$$) {
    my($fh, $tt, $section) = @_;
    my($r, $t) = _read_text($fh);
    $tt->{$section} = '' if !defined($tt->{$section});
    $tt->{$section} .= $r;
    $t;
}

sub _read_script_section ($$$) {
    my($fh, $tt, $args) = @_;
    $tt->file_err("arguments to `%script' ignored") if $args ne '';
    $tt->file_err("multiple `%script' sections defined") if $tt->{'script'};
    my($r, $t) = _read_text($fh);
    my($what) = _shell_split(@{$tt->{'script'}}, @{$tt->{'script_lineno'}}, $r, $.);
    $tt->file_err("$what in `%script'") if $what ne '';
    $t;
}

sub _read_file_section ($$$$) {
    my($fh, $tt, $args, $secname) = @_;
    $args =~ s/\s+$//;
    my($fn, $length, $crap) = split(/\s+/, $args);

    # assert that we understand $secname
    die if $secname ne 'file' && $secname ne 'expect' && $secname ne 'expectv' && $secname ne 'ignore';
    
    if (!defined $fn) {
	$tt->file_err("filename missing in `$secname' section");
	return _skip_section($fh, $tt);
    } elsif ($fn !~ /^\@\w+\@$/ && $fn ne 'stdin' && $fn ne 'stdout' && $fn ne 'stderr' && $fn ne 'all') {
	$tt->file_err("odd filename `$fn' might not work");
	$tt->file_err("(You probably want to add \@ signs at either end.)") if $fn !~ /^\@.*\@$/;
    } elsif (($fn eq 'stdin' && $secname ne 'file')
	     || (($fn eq 'stdout' || $fn eq 'stderr') && $secname eq 'file')
	     || ($fn eq 'all' && $secname ne 'ignore')) {
	$tt->file_err("`$fn' not meaningful for `%$secname'");
    }

    my($hashkey) = substr($secname, 0, 1) . ":" . $fn;
    if (exists $tt->{$hashkey}) {
	$tt->file_err("file `$fn' already defined");
    } else {
	push @{$tt->{$secname}}, $fn;
    }

    $tt->file_err("ignoring extra arguments to `%$secname'") if defined($crap);

    my($t);
    if (defined($length) && $length =~ /^\d+$/) {
	read $fh, $tt->{$hashkey}, $length;
	$tt->file_err("file too short") if length($tt->{$hashkey}) != $length;
	$t = <$fh>;
    } else {
	$tt->file_err("bad length argument ignored") if defined($length);
	($tt->{$hashkey}, $t) = _read_text($fh);
    }
    
    $t;
}

sub _skip_section ($$) {
    my($fh, $tt) = @_;
    my($t);
    while (defined($t = <$fh>)) {
	last if $t =~ /^%/;
    }
    $t;
}

sub read (*;$) {
    my($fh, $fn) = @_;
    $fh = ::qualify_to_ref($fh, caller);
    
    my($tt) = bless { 'filename' => $fn, 'err' => 0 }, Testicle;
    
    my($t, $read_command) = (undef, 0);
    $t = <$fh>;
    while (defined($t)) {
	if ($t =~ /^%\s*(\w+)\s*(.*?)\s*$/) {
	    my($command, $args) = (lc($1), $2);
	    if ($command eq 'script') {
		$t = _read_script_section($fh, $tt, $args);
	    } elsif ($command eq 'info') {
		$tt->file_err("arguments to `%info' ignored") if $args ne '';
		$t = _read_text_into($fh, $tt, 'info');
	    } elsif ($command eq 'stdin' || $command eq 'input') {
		$t = _read_file_section($fh, $tt, "stdin $args", 'file');
	    } elsif ($command eq 'file') {
		$args = 'stdin' if $args eq '';
		$t = _read_file_section($fh, $tt, $args, 'file');
	    } elsif ($command eq 'stdout' || $command eq 'output') {
		$t = _read_file_section($fh, $tt, "stdout $args", 'expect');
	    } elsif ($command eq 'stderr') {
		$t = _read_file_section($fh, $tt, "stderr $args", 'expect');
	    } elsif ($command eq 'expect') {
		$args = 'stdout' if $args eq '';
		$t = _read_file_section($fh, $tt, $args, 'expect');
	    } elsif ($command eq 'expectv' || $command eq 'expect_verbatim'
		     || $command eq 'verbatim') {
		$args = 'stdout' if $args eq '';
		$t = _read_file_section($fh, $tt, $args, 'expectv');
	    } elsif ($command eq 'ignore') {
		$args = 'all' if $args eq '';
		$t = _read_file_section($fh, $tt, $args, 'ignore');
	    } else {
		$tt->file_err("unrecognized command `$command'");
		$t = _skip_section($fh, $tt);
	    }
	    $read_command = 1;
	} else {
	    if ($t =~ /^%/) {
		$tt->file_err("bad `%' command");
	    } elsif ($t !~ /^[\#!]/ && $t =~ /\S/) {
		$tt->file_err("warning: garbage ignored") if $read_command;
		$read_command = 0;
	    }
	    $t = <$fh>;
	}
    }

    $tt;
}


sub save_files ($&) {
    my($tt, $filename_subr) = @_;
    foreach my $fn (@{$tt->{'file'}}) {
	my($actual) = $filename_subr->($fn);
	next if !defined($actual);
	open OUT, ">$actual" || die "$actual: $!\n";
	print OUT $tt->{"f:$fn"};
	close OUT;
    }
}

sub script_text ($&) {
    my($tt, $filename_subr) = @_;

    # develop file-replacing subroutine
    my($subbody) = '';
    foreach my $fn (@{$tt->{'file'}}, @{$tt->{'expect'}}, @{$tt->{'expectv'}}, @{$tt->{'ignore'}}) {
	next if $_special_filenames{$fn};
	my($inner) = quotemeta($filename_subr->($fn));
	next if !defined($inner);
	$fn = quotemeta($fn);
	$subbody .= "\$t =~ s/(^|[^\\\\])$fn/\$1$inner/g;\n";
    }
    my($code) = eval("sub { my(\$t) = \@_; $subbody\$t; }");

    my($t) = <<EOD;
testicle_failed () {
  exit 1
}
EOD
    
    foreach my $i (0..$#{$tt->{'script'}}) {
	my($ln, $text) = ($tt->{'script_lineno'}[$i], $tt->{'script'}[$i]);
	$t .= "echo testicle_lineno:" . ::shquote($tt->lineno($ln)) . " >&2\n";
	my(@c, @d);
	_shell_split(@c, @d, $text, 0, $code);
	die if @c != 1;
	chomp $c[0];
	next if $c[0] =~ /^\s*$/s;
	$t .= $c[0] . " || testicle_failed \$?\n";
    }
    
    $t;
}


package main;

my $dir = "testicle$$";

sub script_fn_to_fn ($) {
    my($fn) = @_;
    return "$dir/$fn" if $fn eq 'stdin' || $fn eq 'stdout' || $fn eq 'stderr';
    $fn = $1 if $fn =~ /^\@(.+)\@$/s;
    "$dir/f_$fn";
}

sub run_test (;$) {
    my($fn) = @_;
    my($tt);
    if (!defined($fn) || $fn eq '-') {
	$tt = Testicle::read(STDIN, "<stdin>");
    } else {
	if (!open(IN, $fn)) {
	    print STDERR "$fn: $!\n";
	    return -1;
	}
	$tt = Testicle::read(IN, $fn);
	close IN;
    }
    
    $tt->save_files(\&script_fn_to_fn);

    open(SCR, ">$dir/script") || die "$dir/script: $!\n";
    print SCR $tt->script_text(\&script_fn_to_fn);
    close SCR;

    
    0;
}

$SIG{'INT'} = $SIG{'QUIT'} = $SIG{'TERM'} = $SIG{'__DIE__'} = sub {
    system("/bin/rm -rf $dir");
    exit(1);
};


if (-d $dir) {
    print STDERR "warning: $dir directory exists; removing it\n";
    system("/bin/rm -rf $dir");
    -d $dir && die "cannot remove $dir directory: $!\n";
}
mkdir $dir || die "cannot create $dir directory: $!\n";

run_test('/tmp/x');

system("/bin/rm -rf $dir") if 0;
