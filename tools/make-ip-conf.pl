#!/usr/local/bin/perl -w

# make-ip-conf.pl
# Make a Click IP router configuration.

# Change this array to suit your router.
# One line per network interface, containing:
#  The interface name,
#  The router's IP address on that interface,
#  The netmask on that interface, and
#  The router's Ethernet address on that interface.
my $ifs = [ [ "eth0", "18.26.4.89", "255.255.255.0", "00:90:27:14:E3:59" ],
            [ "eth1", "2.0.0.1", "255.0.0.0", "00:00:C0:B4:68:EF" ],
            [ "eth2", "1.0.0.2", "255.0.0.0", "00:00:C0:8A:67:EF" ]
           ];

my $nifs = $#$ifs + 1;

print "# Generated by make-ip-conf.pl\n";
my $i;
for($i = 0; $i < $nifs; $i++){
    printf("# %s %s %s\n",
           $ifs->[$i]->[0],
           $ifs->[$i]->[1],
           $ifs->[$i]->[3]);
}
print "\n";

print "tol :: ToLinux;\n";
printf("t :: Tee(%d);\n", $nifs + 1);
print "t[$nifs] -> tol;\n";
print "\n";

for($i = 0; $i < $nifs; $i++){
    my $eth = $ifs->[$i]->[0];
    my $ip = $ifs->[$i]->[1];
    my $ena = $ifs->[$i]->[3];
    my $paint = $i + 1;
    print <<EOF
c$i :: Classifier(12/0806 20/0001,
                  12/0806 20/0002,
                  12/0800,
                  -);
FromDevice($eth) -> [0]c$i;
out$i :: Queue(200) -> ToDevice($eth);
arpq$i :: ARPQuerier($ip, $ena);
c$i [1] -> t;
t[$i] -> [1]arpq$i;
arpq$i -> out$i;
ar$i :: ARPResponder($ip 255.255.255.255 $ena);
c$i [0] -> ar$i -> out$i;

EOF
}

my $ipharg = "";
for($i = 0; $i < $nifs; $i++){
    my $ii = ip2i($ifs->[$i]->[1]);
    my $mask = ip2i($ifs->[$i]->[2]);
    $ipharg .= i2ip(($ii & $mask) | ~$mask) . ", ";
}
$ipharg =~ s/, $//;

print "rt :: LookupIPRoute(\n";
for($i = 0; $i < $nifs; $i++){
    my $ii = ip2i($ifs->[$i]->[1]);
    my $mask = ip2i($ifs->[$i]->[2]);
    printf(" %s 255.255.255.255 0.0.0.0 0,\n", $ifs->[$i]->[1]);
    printf(" %s 255.255.255.255 0.0.0.0 0,\n",
           i2ip(($ii & $mask) | ~$mask));
    printf(" %s 255.255.255.255 0.0.0.0 0,\n",
           i2ip($ii & $mask));
}
for($i = 0; $i < $nifs; $i++){
    my $ii = ip2i($ifs->[$i]->[1]);
    my $mask = ip2i($ifs->[$i]->[2]);
    printf(" %s %s 0.0.0.0 %d,\n",
           i2ip($ii & $mask),
           i2ip($mask),
           $i + 1);
}
print " 255.255.255.255 255.255.255.255 0.0.0.0 0,\n";
print " 0.0.0.0 255.255.255.255 0.0.0.0 0,\n";
print " 0.0.0.0 0.0.0.0 18.26.4.1 1);\n"; # XXX

print <<EOF;

rt[0] -> EtherEncap(0x0800, 1:1:1:1:1:1, 2:2:2:2:2:2) -> tol;
ip ::  Strip(14)
    -> CheckIPHeader($ipharg)
    -> GetIPAddress(16)
    -> [0]rt;
EOF

for($i = 0; $i < $nifs; $i++){
  my $paint = $i + 1;
  print "c$i [2] -> Paint($paint) -> ip;\n";
}
print "\n";

for($i = 0; $i < $nifs; $i++){
    my $i1 = $i + 1;
    my $ipa = $ifs->[$i]->[1];
    print <<EOF;
rt[$i1] -> DropBroadcasts
        -> cp$i :: CheckPaint($i1)
        -> gio$i :: IPGWOptions($ipa)
        -> FixIPSrc($ipa)
        -> dt$i :: DecIPTTL
        -> fr$i :: IPFragmenter(1500)
        -> [0]arpq$i;
dt$i [1] -> ICMPError($ipa, 11, 0) -> [0]rt;
fr$i [1] -> ICMPError($ipa, 3, 4) -> [0]rt;
gio$i [1] -> ICMPError($ipa, 12, 1) -> [0]rt;
cp$i [1] -> ICMPError($ipa, 5, 1) -> [0]rt;
c$i [3] -> Print(xx$i) -> Discard;
EOF
}

sub ip2i {
    my($ip) = @_;
    my @a = split(/\./, $ip);
    my $i = ($a[0] << 24) + ($a[1] << 16) + ($a[2] << 8) + $a[3];
    return($i);
}
sub i2ip {
    my($i) = @_;
    my $a = ($i >> 24) & 0xff;
    my $b = ($i >> 16) & 0xff;
    my $c = ($i >> 8) & 0xff;
    my $d = $i & 0xff;
    return sprintf("%d.%d.%d.%d", $a, $b, $c, $d);
}

